commit 4aff10785ee96a35eb4777c08b81722a59cecf68
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 5 18:46:38 2024 -0500

    üßë‚Äçüíª Use "enum class"

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 16b43f62f0..1b8ebeea69 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1423,21 +1423,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
-  marlin_state = MF_KILLED;
+  marlin_state = MarlinState::MF_KILLED;
   thermalManager.disable_all_heaters();
   #if HAS_BEEPER
     for (uint8_t i = 20; i--;) {
       hal.watchdog_refresh();
       buzzer.click(25);
       delay(80);
       hal.watchdog_refresh();
     }
     buzzer.on();
   #endif
@@ -2070,21 +2070,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::task() {
-  if (marlin_state == MF_INITIALIZING) return hal.watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
+  if (marlin_state == MarlinState::MF_INITIALIZING) return hal.watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
 
   static bool no_reentry = false;  // Prevent recursion
   if (no_reentry) return;
   REMEMBER(mh, no_reentry, true);
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!

commit 75eee04972ad51f48e517f2c2b065343eb42ef13
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon May 20 16:10:15 2024 +1200

    ü©π Return 0 for bad index in Temperature::getHeaterPower (#27037)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 95d2da38f1..16b43f62f0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1296,22 +1296,24 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     #if HAS_COOLER
       case H_COOLER: return temp_cooler.soft_pwm_amount;
     #endif
-    default:
-      return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
+    #if HAS_HOTEND
+      case 0 ... HOTENDS - 1: return temp_hotend[heater_id].soft_pwm_amount;
+    #endif
+    default: return 0;
   }
 }
 
 #if HAS_AUTO_FAN
 
   #define _EFANOVERLAP(I,N) ((I != N) && _FANOVERLAP(I,E##N))
 
   #if EXTRUDER_AUTO_FAN_SPEED != 255
     #define INIT_E_AUTO_FAN_PIN(P) do{ if (PWM_PIN(P)) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else

commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    ü©π Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1fa7eaae0d..95d2da38f1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -799,21 +799,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
               SERIAL_ECHOLNPGM(STR_KU, Ku, STR_TU, Tu);
               if (ischamber || isbed)
                 SERIAL_ECHOLNPGM(" No overshoot");
               else
                 SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
               SERIAL_ECHOLNPGM(STR_KP, tune_pid.p, STR_KI, tune_pid.i, STR_KD, tune_pid.d);
             }
           }
           SHV((bias + d) >> 1);
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PID_CYCLE), cycles, ncycles));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT_F(MSG_PID_CYCLE), cycles, ncycles));
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
@@ -2012,21 +2012,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
       const auto deg = degCooler();
       if (deg > COOLER_MAXTEMP) MAXTEMP_ERROR(H_COOLER, deg);
     }
     #endif
 
     #if WATCH_COOLER
       // Make sure temperature is decreasing
       if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
         const auto deg = degCooler();
         if (deg > watch_cooler.target)            // Failed to decrease enough?
-          _TEMP_ERROR(H_COOLER, GET_EN_TEXT_F(MSG_ERR_COOLING_FAILED), MSG_ERR_COOLING_FAILED, deg);
+          _TEMP_ERROR(H_COOLER, GET_TEXT_F(MSG_ERR_COOLING_FAILED), MSG_ERR_COOLING_FAILED, deg);
         else
           start_watching_cooler();                // Start again if the target is still far off
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
     if (cooler.enabled) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
       if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
@@ -4427,21 +4427,21 @@ void Temperature::isr() {
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e, const bool isM104/*=false*/) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf(0,
         #if HAS_MULTI_HOTEND
           F("E%c " S_FMT), '1' + e
         #else
           F("E1 " S_FMT)
         #endif
-        , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
+        , heating ? GET_TEXT_F(MSG_HEATING) : GET_TEXT_F(MSG_COOLING)
       );
 
       if (isM104) {
         static uint8_t wait_e; wait_e = e;
         ui.set_status_reset_fn([]{
           const celsius_t c = degTargetHotend(wait_e);
           return c < 30 || degHotendNear(wait_e, c);
         });
       }
     }

commit cecc7458440b17340184f9508d0c9da0747ecc72
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Apr 24 18:51:08 2024 -0400

    üö∏ Fix duplicate temperature report (#26952)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 87afa2cbdd..1fa7eaae0d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -4412,20 +4412,21 @@ void Temperature::isr() {
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() s.append(F(" @"), e, ':', getHeaterPower((heater_id_t)e));
     #endif
     s.echo();
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
     void Temperature::AutoReportTemp::report() {
+      if (wait_for_heatup) return;
       print_heater_states(active_extruder OPTARG(HAS_TEMP_REDUNDANT, ENABLED(AUTO_REPORT_REDUNDANT)));
       SERIAL_EOL();
     }
   #endif
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e, const bool isM104/*=false*/) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf(0,
         #if HAS_MULTI_HOTEND

commit a1ecea60fdbf4f930f1aff236900b642883dfc6a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Apr 24 12:35:11 2024 +1200

    ‚úèÔ∏è MPCTEMP_START => MPC_STARTED (#27002)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a1fe14c75d..87afa2cbdd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1188,21 +1188,21 @@ volatile bool Temperature::raw_temps_ready = false;
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
     // Determine ambient temperature.
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
-    TERN_(EXTENSIBLE_UI, ExtUI::onMPCTuning(ExtUI::mpcresult_t::MPCTEMP_START));
+    TERN_(EXTENSIBLE_UI, ExtUI::onMPCTuning(ExtUI::mpcresult_t::MPC_STARTED));
     TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT), LCD_MESSAGE(MSG_COOLING));
 
     if (tuner.measure_ambient_temp() != MPC_autotuner::MeasurementState::SUCCESS) return;
     hotend.modeled_ambient_temp = tuner.get_ambient_temp();
 
     #if HAS_FAN
       set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 53b9f37fb2..a1fe14c75d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -45,22 +45,20 @@
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "../feature/controllerfan.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_LCD_PROUI)
-  #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
@@ -716,27 +714,25 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_STARTED));
-    TERN_(PROUI_PID_TUNE, dwinPidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
+    TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ischamber ? ExtUI::pidresult_t::PID_CHAMBER_STARTED : isbed ? ExtUI::pidresult_t::PID_BED_STARTED : ExtUI::pidresult_t::PID_STARTED));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, hotend_max_target(heater_id))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
-      TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-      TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
+      TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::pidresult_t::PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
@@ -815,22 +811,21 @@ volatile bool Temperature::raw_temps_ready = false;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
-        TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-        TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
+        TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::pidresult_t::PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
@@ -853,22 +848,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         #endif
       } // every 2 seconds
 
       // Timeout after PID_AUTOTUNE_MAX_CYCLE_MINS minutes since the last undershoot/overshoot cycle
       #ifndef PID_AUTOTUNE_MAX_CYCLE_MINS
         #define PID_AUTOTUNE_MAX_CYCLE_MINS 20L
       #endif
       if ((ms - _MIN(t1, t2)) > MIN_TO_MS(PID_AUTOTUNE_MAX_CYCLE_MINS)) {
         TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
-        TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TUNING_TIMEOUT));
-        TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
+        TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::pidresult_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if ANY(PIDTEMPBED, PIDTEMPCHAMBER)
@@ -912,22 +906,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
         goto EXIT_M303;
       }
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     EXIT_M303:
       TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPIDTuningDone(oldcolor));
-      TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_DONE));
-      TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
+      TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::pidresult_t::PID_DONE));
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
   #if ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
     #define SINGLEFAN 1
@@ -1130,21 +1123,21 @@ volatile bool Temperature::raw_temps_ready = false;
         #endif
         else if (ELAPSED(curr_time_ms, test_end_ms)) break;
 
         last_temp = current_temp;
         next_test_ms += test_interval_ms;
       }
 
       // Ensure we don't drift too far from the window between the last sampled temp and the target temperature
       if (!WITHIN(current_temp, get_sample_3_temp() - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
-        TERN_(DWIN_LCD_PROUI, dwinMPCTuning(MPC_TEMP_ERROR));
+        TERN_(EXTENSIBLE_UI, ExtUI::onMPCTuning(ExtUI::mpcresult_t::MPC_TEMP_ERROR));
         wait_for_heatup = false;
         return FAILED;
       }
     }
     wait_for_heatup = false;
 
     power_fan0 = total_energy_fan0 / MS_TO_SEC_PRECISE(test_duration);
     TERN_(HAS_FAN, power_fan255 = (total_energy_fan255 * 1000) / test_duration);
 
     #if ENABLED(DEBUG_MPC_AUTOTUNE)
@@ -1168,21 +1161,21 @@ volatile bool Temperature::raw_temps_ready = false;
     if (temp_ready) current_temp = degHotend(e);
 
     if (ELAPSED(curr_time_ms, next_report_ms)) {
       next_report_ms += report_interval_ms;
       print_heater_states(e);
       SERIAL_EOL();
     }
 
     if (!wait_for_heatup) {
       SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
-      TERN_(DWIN_LCD_PROUI, dwinMPCTuning(MPC_INTERRUPTED));
+      TERN_(EXTENSIBLE_UI, ExtUI::onMPCTuning(ExtUI::mpcresult_t::MPC_INTERRUPTED));
       return MeasurementState::CANCELLED;
     }
 
     return MeasurementState::SUCCESS;
   }
 
   void Temperature::MPC_autotune(const uint8_t e, MPCTuningType tuning_type=AUTO) {
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
 
     MPC_autotuner tuner(e);
@@ -1195,26 +1188,22 @@ volatile bool Temperature::raw_temps_ready = false;
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
     // Determine ambient temperature.
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
-    #if ENABLED(DWIN_LCD_PROUI)
-      dwinMPCTuning(MPCTEMP_START);
-      LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT);
-    #else
-      LCD_MESSAGE(MSG_COOLING);
-    #endif
+    TERN_(EXTENSIBLE_UI, ExtUI::onMPCTuning(ExtUI::mpcresult_t::MPCTEMP_START));
+    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT), LCD_MESSAGE(MSG_COOLING));
 
     if (tuner.measure_ambient_temp() != MPC_autotuner::MeasurementState::SUCCESS) return;
     hotend.modeled_ambient_temp = tuner.get_ambient_temp();
 
     #if HAS_FAN
       set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     // Heat to 200 degrees
@@ -1286,21 +1275,21 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_ECHOLNPGM("block_responsiveness ", p_float_t(block_responsiveness, 4));
       #endif
 
       // Update analytic tuning values based on the above
       mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
       mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
 
     }
 
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
-    TERN_(DWIN_LCD_PROUI, dwinMPCTuning(AUTOTUNE_DONE));
+    TERN_(EXTENSIBLE_UI, ExtUI::onMPCTuning(ExtUI::mpcresult_t::MPC_DONE));
 
     SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
     SERIAL_ECHOLNPGM("MPC_SENSOR_RESPONSIVENESS ", p_float_t(mpc.sensor_responsiveness, 4));
     SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF ", p_float_t(mpc.ambient_xfer_coeff_fan0, 4));
     TERN_(HAS_FAN, SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF_FAN255 ", p_float_t(ambient_xfer_coeff_fan255, 4)));
   }
 
 #endif // MPC_AUTOTUNE
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
@@ -1525,29 +1514,31 @@ void Temperature::_temp_error(
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
 void Temperature::maxtemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg)) {
-  #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
-    dwinPopupTemperature(1);
+  #if HAS_HOTEND || HAS_HEATED_BED
+    TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(1));
+    TERN_(EXTENSIBLE_UI, ExtUI::onMaxTempError(heater_id));
   #endif
   _TEMP_ERROR(heater_id, F(STR_T_MAXTEMP), MSG_ERR_MAXTEMP, deg);
 }
 
 void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg)) {
-  #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
-    dwinPopupTemperature(0);
+  #if HAS_HOTEND || HAS_HEATED_BED
+    TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
+    TERN_(EXTENSIBLE_UI, ExtUI::onMinTempError(heater_id));
   #endif
   _TEMP_ERROR(heater_id, F(STR_T_MINTEMP), MSG_ERR_MINTEMP, deg);
 }
 
 #if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
 
 #if HAS_PID_HEATING
 
@@ -1758,21 +1749,22 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_hotend_preheating(e))
         && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           auto temp = degHotend(e);
           if (watch_hotend[e].check(temp))          // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
-            TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
+            TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
+            TERN_(EXTENSIBLE_UI, ExtUI::onHeatingError(e));
             _TEMP_ERROR(e, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, temp);
           }
         }
       #endif
 
     } // HOTEND_LOOP
   }
 
 #endif // HAS_HOTEND
 
@@ -1788,21 +1780,22 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
     #endif
 
     #if WATCH_BED
     {
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         const auto deg = degBed();
         if (watch_bed.check(deg))               // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
-          TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
+          TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
+          TERN_(EXTENSIBLE_UI, ExtUI::onHeatingError(H_BED));
           _TEMP_ERROR(H_BED, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, deg);
         }
       }
     }
     #endif // WATCH_BED
 
     #if ALL(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
@@ -3240,27 +3233,29 @@ void Temperature::init() {
         if (rdiff <= hysteresis_degc) {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
-        TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
+        TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
+        TERN_(EXTENSIBLE_UI, ExtUI::onHeatingError(heater_id));
         _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_ERR_THERMAL_RUNAWAY, current);
         break;
 
       #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
         case TRMalfunction:
-          TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
+          TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
+          TERN_(EXTENSIBLE_UI, ExtUI::onHeatingError(heater_id));
           _TEMP_ERROR(heater_id, F(STR_T_THERMAL_MALFUNCTION), MSG_ERR_TEMP_MALFUNCTION, current);
           break;
       #endif
     }
   }
 
   #pragma GCC diagnostic pop
 
 #endif // HAS_THERMAL_PROTECTION
 

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    ü©π Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9b071ecc36..53b9f37fb2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -716,26 +716,26 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
+    TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_STARTED));
     TERN_(PROUI_PID_TUNE, dwinPidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, hotend_max_target(heater_id))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
-      TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
+      TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
@@ -815,21 +815,21 @@ volatile bool Temperature::raw_temps_ready = false;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
-        TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
+        TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
@@ -854,21 +854,21 @@ volatile bool Temperature::raw_temps_ready = false;
         #endif
       } // every 2 seconds
 
       // Timeout after PID_AUTOTUNE_MAX_CYCLE_MINS minutes since the last undershoot/overshoot cycle
       #ifndef PID_AUTOTUNE_MAX_CYCLE_MINS
         #define PID_AUTOTUNE_MAX_CYCLE_MINS 20L
       #endif
       if ((ms - _MIN(t1, t2)) > MIN_TO_MS(PID_AUTOTUNE_MAX_CYCLE_MINS)) {
         TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
         TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TUNING_TIMEOUT));
-        TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
+        TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if ANY(PIDTEMPBED, PIDTEMPCHAMBER)
@@ -911,22 +911,22 @@ volatile bool Temperature::raw_temps_ready = false;
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         goto EXIT_M303;
       }
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     EXIT_M303:
-      TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
-      TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
+      TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPIDTuningDone(oldcolor));
+      TERN_(EXTENSIBLE_UI, ExtUI::onPIDTuning(ExtUI::result_t::PID_DONE));
       TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
   #if ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)

commit 669814d0d408a622f020a55971ba04030e4fa4bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 23:40:54 2024 -0600

    ‚ú® MARLIN_SMALL_BUILD option (#26775)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5ac26794a4..9b071ecc36 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2264,20 +2264,22 @@ void Temperature::task() {
         { true, BOARD_SH_C_COEFF, 0, BOARD_PULLUP_RESISTOR_OHMS, BOARD_RESISTANCE_25C_OHMS, 0, 0, BOARD_BETA, 0 },
       #endif
       #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
         { true, REDUNDANT_SH_C_COEFF, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::M305_report(const uint8_t t_index, const bool forReplay/*=true*/) {
+    TERN_(MARLIN_SMALL_BUILD, return);
+
     gcode.report_heading_etc(forReplay, F(STR_USER_THERMISTORS));
     SERIAL_ECHOPGM("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHO(
       F(" R"), p_float_t(t.series_res, 1), FPSTR(SP_T_STR), p_float_t(t.res_25, 1),
       FPSTR(SP_B_STR), p_float_t(t.beta, 1), FPSTR(SP_C_STR), p_float_t(t.sh_c_coeff, 9),
       F(" ; ")
     );

commit 1dee4d92c61b14458cd394d1f609f0dc80282092
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 4 12:09:08 2024 -0600

    üîß TOUCH_IDLE_SLEEP_MINS => DISPLAY_SLEEP_MINUTES
    
    Follow up to #26517

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4ff62d0172..5ac26794a4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -847,25 +847,25 @@ volatile bool Temperature::raw_temps_ready = false;
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _TEMP_ERROR(heater_id, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, current_temp);
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
               _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_ERR_THERMAL_RUNAWAY, current_temp);
           }
         #endif
       } // every 2 seconds
 
-      // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
-      #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
-        #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
+      // Timeout after PID_AUTOTUNE_MAX_CYCLE_MINS minutes since the last undershoot/overshoot cycle
+      #ifndef PID_AUTOTUNE_MAX_CYCLE_MINS
+        #define PID_AUTOTUNE_MAX_CYCLE_MINS 20L
       #endif
-      if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
+      if ((ms - _MIN(t1, t2)) > MIN_TO_MS(PID_AUTOTUNE_MAX_CYCLE_MINS)) {
         TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
         TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);

commit 604d3e8fadc1fd3603409f0d22d8a49de6f46cc2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 22 16:38:08 2024 -0600

    üé® Move EXIT_M303

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ad1daae762..4ff62d0172 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -903,38 +903,31 @@ volatile bool Temperature::raw_temps_ready = false;
         #if ENABLED(PIDTEMPCHAMBER)
           auto _set_chamber_pid = [](const raw_pid_t &in_pid) {
             temp_chamber.pid.set(in_pid);
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
-        TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
-
-        TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-        TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
-
         goto EXIT_M303;
       }
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
-    TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
-
-    TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-    TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
-
     EXIT_M303:
+      TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
+      TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
+      TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
   #if ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
     #define SINGLEFAN 1

commit cb291e8d00a6c1ee0a778625e0170b6b7430a004
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 22:41:00 2024 -0600

    ü©π Fix some temp constraints

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c4920c2100..ad1daae762 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -294,27 +294,27 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   constexpr celsius_t Temperature::hotend_maxtemp[HOTENDS];
 
   #if ENABLED(MPCTEMP)
     bool MPC::e_paused; // = false
     int32_t MPC::e_position; // = 0
   #endif
 
   // Sanity-check max readable temperatures
   #define CHECK_MAXTEMP_(N,M,S) static_assert( \
-    S >= 998 || M <= _MAX(TT_NAME(S)[0].celsius, TT_NAME(S)[COUNT(TT_NAME(S)) - 1].celsius) - HOTEND_OVERSHOOT, \
+    S >= 998 || M <= _MAX(TT_NAME(S)[0].celsius, TT_NAME(S)[COUNT(TT_NAME(S)) - 1].celsius) - (HOTEND_OVERSHOOT), \
     "HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") is too high for thermistor_" STRINGIFY(S) ".h with HOTEND_OVERSHOOT=" STRINGIFY(HOTEND_OVERSHOOT) ".");
   #define CHECK_MAXTEMP(N) TERN(TEMP_SENSOR_##N##_IS_THERMISTOR, CHECK_MAXTEMP_, CODE_0)(N, HEATER_##N##_MAXTEMP, TEMP_SENSOR_##N)
   REPEAT(HOTENDS, CHECK_MAXTEMP)
 
   #if HAS_PREHEAT
-    #define CHECK_PREHEAT__(N,P,T,M) static_assert(T <= M - HOTEND_OVERSHOOT, "PREHEAT_" STRINGIFY(P) "_TEMP_HOTEND (" STRINGIFY(T) ") must be less than HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") - " STRINGIFY(HOTEND_OVERSHOOT) ".");
+    #define CHECK_PREHEAT__(N,P,T,M) static_assert(T <= (M) - (HOTEND_OVERSHOOT), "PREHEAT_" STRINGIFY(P) "_TEMP_HOTEND (" STRINGIFY(T) ") must be less than HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") - " STRINGIFY(HOTEND_OVERSHOOT) ".");
     #define CHECK_PREHEAT_(N,P) CHECK_PREHEAT__(N, P, PREHEAT_##P##_TEMP_HOTEND, HEATER_##N##_MAXTEMP)
     #define CHECK_PREHEAT(P) REPEAT2(HOTENDS, CHECK_PREHEAT_, P)
     #if PREHEAT_COUNT >= 1
       CHECK_PREHEAT(1)
     #endif
     #if PREHEAT_COUNT >= 2
       CHECK_PREHEAT(2)
     #endif
     #if PREHEAT_COUNT >= 3
       CHECK_PREHEAT(3)
@@ -1687,21 +1687,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
         hotend.modeled_ambient_temp += delta_to_apply > 0.f ? _MAX(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : _MIN(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
 
       float power = 0.0;
       if (hotend.target != 0 && !is_idling) {
         // Plan power level to get to target temperature in 2 seconds
         power = (hotend.target - hotend.modeled_block_temp) * mpc.block_heat_capacity / 2.0f;
         power -= (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff;
       }
 
       float pid_output = power * 254.0f / mpc.heater_power + 1.0f;        // Ensure correct quantization into a range of 0 to 127
-      pid_output = constrain(pid_output, 0, MPC_MAX);
+      LIMIT(pid_output, 0, MPC_MAX);
 
       /* <-- add a slash to enable
         static uint32_t nexttime = millis() + 1000;
         if (ELAPSED(millis(), nexttime)) {
           nexttime += 1000;
           SERIAL_ECHOLNPGM("block temp ", hotend.modeled_block_temp,
                            ", celsius ", hotend.celsius,
                            ", blocktempdelta ", blocktempdelta,
                            ", delta_to_apply ", delta_to_apply,
                            ", ambient ", hotend.modeled_ambient_temp,

commit 25caae1e8c238422cb8ee00637d463ae837c5273
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Jan 10 15:55:20 2024 +1300

    ü©π Fix PID / MPC tune background tasks (#26652)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5173db02a1..c4920c2100 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -621,20 +621,50 @@ volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused_for_probing;
 #endif
 
 /**
  * public:
  * Class and Instance Methods
  */
 
+#if ANY(HAS_PID_HEATING, MPC_AUTOTUNE)
+
+  /**
+   * Run the minimal required activities during a tuning loop.
+   * TODO: Allow tuning routines to call idle() for more complete keepalive.
+   */
+  bool Temperature::tuning_idle(const millis_t &ms) {
+
+    // Run HAL idle tasks
+    hal.idletask();
+
+    const bool temp_ready = updateTemperaturesIfReady();
+
+    #if HAS_FAN_LOGIC
+      if (temp_ready) manage_extruder_fans(ms);
+    #else
+      UNUSED(ms);
+    #endif
+
+    // Run Controller Fan check (normally handled by manage_inactivity)
+    TERN_(USE_CONTROLLER_FAN, controllerFan.update());
+
+    // Run UI update
+    ui.update();
+
+    return temp_ready;
+  }
+
+#endif
+
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
@@ -720,33 +750,35 @@ volatile bool Temperature::raw_temps_ready = false;
     TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
 
     LCD_MESSAGE(MSG_HEATING);
 
     // PID Tuning loop
     wait_for_heatup = true;
     while (wait_for_heatup) { // Can be interrupted with M108
 
       const millis_t ms = millis();
 
-      if (updateTemperaturesIfReady()) { // temp sample ready
+      // Run minimal necessary machine tasks
+      const bool temp_ready = tuning_idle(ms);
+
+      // If a new sample has arrived process things
+      if (temp_ready) {
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
 
-        TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
-
         if (heating && current_temp > target && ELAPSED(ms, t2 + 5000UL)) {
           heating = false;
           SHV((bias - d) >> 1);
           t1 = ms;
           t_high = t1 - t2;
           maxT = target;
         }
 
         if (!heating && current_temp < target && ELAPSED(ms, t1 + 5000UL)) {
           heating = true;
@@ -878,26 +910,20 @@ volatile bool Temperature::raw_temps_ready = false;
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
 
         goto EXIT_M303;
       }
-
-      // Run HAL idle tasks
-      hal.idletask();
-
-      // Run UI update
-      ui.update();
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
 
@@ -1135,34 +1161,32 @@ volatile bool Temperature::raw_temps_ready = false;
       TERN_(HAS_FAN, SERIAL_ECHOLNPGM("power_fan255 ", power_fan255));
     #endif
 
     return SUCCESS;
   }
 
   Temperature::MPC_autotuner::MeasurementState Temperature::MPC_autotuner::housekeeping() {
     constexpr millis_t report_interval_ms = 1000UL;
     curr_time_ms = millis();
 
-    if (updateTemperaturesIfReady()) { // temp sample ready
-      current_temp = degHotend(e);
-      TERN_(HAS_FAN_LOGIC, manage_extruder_fans(curr_time_ms));
-    }
+    // Run minimal necessary machine tasks
+    const bool temp_ready = tuning_idle(curr_time_ms);
+
+    // Set MPC temp if a new sample is ready
+    if (temp_ready) current_temp = degHotend(e);
 
     if (ELAPSED(curr_time_ms, next_report_ms)) {
       next_report_ms += report_interval_ms;
       print_heater_states(e);
       SERIAL_EOL();
     }
 
-    hal.idletask();
-    ui.update();
-
     if (!wait_for_heatup) {
       SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
       TERN_(DWIN_LCD_PROUI, dwinMPCTuning(MPC_INTERRUPTED));
       return MeasurementState::CANCELLED;
     }
 
     return MeasurementState::SUCCESS;
   }
 
   void Temperature::MPC_autotune(const uint8_t e, MPCTuningType tuning_type=AUTO) {

commit 12d7995a18d3ce59c871e11c4940bbaeb9c352fc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 18:45:17 2024 -0600

    üé® Minor temp / UI refactor

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e65297b04a..5173db02a1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -483,70 +483,66 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if WATCH_HOTENDS
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
   Temperature::heater_idle_t Temperature::heater_idle[NR_HEATER_IDLE]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
-  raw_adc_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP,
-            Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
+  temp_raw_range_t Temperature::temp_sensor_range_bed = { TEMP_SENSOR_BED_RAW_LO_TEMP, TEMP_SENSOR_BED_RAW_HI_TEMP };
   #if WATCH_BED
     bed_watch_t Temperature::watch_bed; // = { 0 }
   #endif
   #if DISABLED(PIDTEMPBED)
     millis_t Temperature::next_bed_check_ms;
   #endif
 #endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     millis_t next_cool_check_ms = 0;
     celsius_float_t old_temp = 9999;
-    raw_adc_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
-              Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
+    temp_raw_range_t Temperature::temp_sensor_range_chamber = { TEMP_SENSOR_CHAMBER_RAW_LO_TEMP, TEMP_SENSOR_CHAMBER_RAW_HI_TEMP };
     #if WATCH_CHAMBER
       chamber_watch_t Temperature::watch_chamber; // = { 0 }
     #endif
     #if DISABLED(PIDTEMPCHAMBER)
       millis_t Temperature::next_chamber_check_ms;
     #endif
   #endif
 #endif
 
 #if HAS_TEMP_COOLER
   cooler_info_t Temperature::temp_cooler; // = { 0 }
   #if HAS_COOLER
     bool flag_cooler_state;
     //bool flag_cooler_excess = false;
     celsius_float_t previous_temp = 9999;
-    raw_adc_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,
-              Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
+    temp_raw_range_t Temperature::temp_sensor_range_cooler = { TEMP_SENSOR_COOLER_RAW_LO_TEMP, TEMP_SENSOR_COOLER_RAW_HI_TEMP };
     #if WATCH_COOLER
       cooler_watch_t Temperature::watch_cooler; // = { 0 }
     #endif
     millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
   #endif
 #endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if HAS_TEMP_BOARD
   board_info_t Temperature::temp_board; // = { 0 }
   #if ENABLED(THERMAL_PROTECTION_BOARD)
-    raw_adc_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
-              Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
+    temp_raw_range_t Temperature::temp_sensor_range_board = { TEMP_SENSOR_BOARD_RAW_LO_TEMP, TEMP_SENSOR_BOARD_RAW_HI_TEMP };
   #endif
 #endif
 
 #if HAS_TEMP_SOC
   soc_info_t Temperature::temp_soc; // = { 0 }
   raw_adc_t Temperature::maxtemp_raw_SOC = TEMP_SENSOR_SOC_RAW_HI_TEMP;
 #endif
 
 #if ALL(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
   bool Temperature::allow_cold_extrude_override = false;
@@ -693,39 +689,39 @@ volatile bool Temperature::raw_temps_ready = false;
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(PROUI_PID_TUNE, dwinPidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
 
-    if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
+    if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, hotend_max_target(heater_id))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
-      LEDColor color = ONHEATINGSTART();
+      const LEDColor oldcolor = ONHEATINGSTART();
     #endif
 
     TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
 
     LCD_MESSAGE(MSG_HEATING);
 
     // PID Tuning loop
     wait_for_heatup = true;
     while (wait_for_heatup) { // Can be interrupted with M108
 
@@ -875,39 +871,39 @@ volatile bool Temperature::raw_temps_ready = false;
         #if ENABLED(PIDTEMPCHAMBER)
           auto _set_chamber_pid = [](const raw_pid_t &in_pid) {
             temp_chamber.pid.set(in_pid);
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
-        TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
+        TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
-      TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
+      ui.update();
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
-    TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
+    TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(oldcolor));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
 
     EXIT_M303:
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
@@ -1136,36 +1132,36 @@ volatile bool Temperature::raw_temps_ready = false;
       SERIAL_ECHOLNPGM("MPC_autotuner::measure_transfer() Completed");
       SERIAL_ECHOLNPGM("=====");
       SERIAL_ECHOLNPGM("power_fan0 ", power_fan0);
       TERN_(HAS_FAN, SERIAL_ECHOLNPGM("power_fan255 ", power_fan255));
     #endif
 
     return SUCCESS;
   }
 
   Temperature::MPC_autotuner::MeasurementState Temperature::MPC_autotuner::housekeeping() {
-    const millis_t report_interval_ms = 1000UL;
+    constexpr millis_t report_interval_ms = 1000UL;
     curr_time_ms = millis();
 
     if (updateTemperaturesIfReady()) { // temp sample ready
       current_temp = degHotend(e);
       TERN_(HAS_FAN_LOGIC, manage_extruder_fans(curr_time_ms));
     }
 
     if (ELAPSED(curr_time_ms, next_report_ms)) {
       next_report_ms += report_interval_ms;
       print_heater_states(e);
       SERIAL_EOL();
     }
 
     hal.idletask();
-    TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
+    ui.update();
 
     if (!wait_for_heatup) {
       SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
       TERN_(DWIN_LCD_PROUI, dwinMPCTuning(MPC_INTERRUPTED));
       return MeasurementState::CANCELLED;
     }
 
     return MeasurementState::SUCCESS;
   }
 
@@ -1827,26 +1823,32 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
         if (is_bed_preheating()) {
           temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
         }
         else {
           #if ENABLED(PIDTEMPBED)
             temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
           #else
             // Check if temperature is within the correct band
             if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
               #if ENABLED(BED_LIMIT_SWITCHING)
+
+                // Range-limited "bang-bang" bed heating
                 if (temp_bed.is_above_target(BED_HYSTERESIS))
                   temp_bed.soft_pwm_amount = 0;
                 else if (temp_bed.is_below_target(BED_HYSTERESIS))
                   temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
+
               #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
+
+                // Simple (noisy) "bang-bang" bed heating
                 temp_bed.soft_pwm_amount = temp_bed.is_below_target() ? MAX_BED_POWER >> 1 : 0;
+
               #endif
             }
             else {
               temp_bed.soft_pwm_amount = 0;
               WRITE_HEATER_BED(LOW);
             }
           #endif
         }
       }
 
@@ -2625,45 +2627,22 @@ void Temperature::updateTemperaturesFromRawValues() {
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.getraw()));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.getraw()));
   TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.getraw()));
   TERN_(HAS_TEMP_SOC,       temp_soc.celsius       = analog_to_celsius_soc(temp_soc.getraw()));
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.getraw()));
 
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
   #if HAS_HOTEND
-    static constexpr int8_t temp_dir[HOTENDS] = {
-      #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
-        0
-      #else
-        TEMPDIR(0)
-      #endif
-      #if HAS_MULTI_HOTEND
-        #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
-          , 0
-        #else
-          , TEMPDIR(1)
-        #endif
-      #endif
-      #if HOTENDS > 2
-        #if TEMP_SENSOR_IS_ANY_MAX_TC(2)
-          , 0
-        #else
-          , TEMPDIR(2)
-        #endif
-      #endif
-      #if HOTENDS > 3
-        #define _TEMPDIR(N) , TEMPDIR(N)
-        REPEAT_S(3, HOTENDS, _TEMPDIR)
-      #endif
-    };
+    #define _TEMPDIR(N) TEMP_SENSOR_IS_ANY_MAX_TC(N) ? 0 : TEMPDIR(N),
+    static constexpr int8_t temp_dir[HOTENDS] = { REPEAT(HOTENDS, _TEMPDIR) };
 
     HOTEND_LOOP() {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
         MAXTEMP_ERROR(e, temp_hotend[e].celsius);
 
       /**
       // DEBUG PREHEATING TIME
       SERIAL_ECHOLNPGM("\nExtruder = ", e, " Preheat On/Off = ", is_preheating(e));
@@ -2676,45 +2655,51 @@ void Temperature::updateTemperaturesFromRawValues() {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
           MINTEMP_ERROR(e, temp_hotend[e].celsius);
       }
       else {
         TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
       }
     }
 
   #endif // HAS_HOTEND
 
-  #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
-    if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) MAXTEMP_ERROR(H_BED, temp_bed.celsius);
-    if (temp_bed.target > 0 && !is_bed_preheating() && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) MINTEMP_ERROR(H_BED, temp_bed.celsius);
+    if (TP_CMP(BED, temp_bed.getraw(), temp_sensor_range_bed.raw_max))
+      MAXTEMP_ERROR(H_BED, temp_bed.celsius);
+    if (temp_bed.target > 0 && !is_bed_preheating() && TP_CMP(BED, temp_sensor_range_bed.raw_min, temp_bed.getraw()))
+      MINTEMP_ERROR(H_BED, temp_bed.celsius);
   #endif
 
   #if ALL(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
-    if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) MAXTEMP_ERROR(H_CHAMBER, temp_chamber.celsius);
-    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) MINTEMP_ERROR(H_CHAMBER, temp_chamber.celsius);
+    if (TP_CMP(CHAMBER, temp_chamber.getraw(), temp_sensor_range_chamber.raw_max))
+      MAXTEMP_ERROR(H_CHAMBER, temp_chamber.celsius);
+    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, temp_sensor_range_chamber.raw_min, temp_chamber.getraw()))
+      MINTEMP_ERROR(H_CHAMBER, temp_chamber.celsius);
   #endif
 
   #if ALL(HAS_COOLER, THERMAL_PROTECTION_COOLER)
-    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) MAXTEMP_ERROR(H_COOLER, temp_cooler.celsius);
-    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) MINTEMP_ERROR(H_COOLER, temp_cooler.celsius);
+    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), temp_sensor_range_cooler.raw_max))
+      MAXTEMP_ERROR(H_COOLER, temp_cooler.celsius);
+    if (TP_CMP(COOLER, temp_sensor_range_cooler.raw_min, temp_cooler.getraw()))
+      MINTEMP_ERROR(H_COOLER, temp_cooler.celsius);
   #endif
 
   #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
-    if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) MAXTEMP_ERROR(H_BOARD, temp_board.celsius);
-    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) MINTEMP_ERROR(H_BOARD, temp_board.celsius);
+    if (TP_CMP(BOARD, temp_board.getraw(), temp_sensor_range_board.raw_max))
+      MAXTEMP_ERROR(H_BOARD, temp_board.celsius);
+    if (TP_CMP(BOARD, temp_sensor_range_board.raw_min, temp_board.getraw()))
+      MINTEMP_ERROR(H_BOARD, temp_board.celsius);
   #endif
 
   #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
     if (TP_CMP(SOC, temp_soc.getraw(), maxtemp_raw_SOC)) MAXTEMP_ERROR(H_SOC, temp_soc.celsius);
   #endif
-  #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to task()
  *
  *  - Init (and disable) SPI thermocouples like MAX6675 and MAX31865
  *  - Disable RUMBA JTAG to accommodate a thermocouple extension
@@ -2726,21 +2711,20 @@ void Temperature::updateTemperaturesFromRawValues() {
  *  - Set thermistor pins to analog inputs according to the HAL
  *  - Start the Temperature ISR timer
  *  - Init the AUTO FAN pins as PWM or OUTPUT
  *  - Wait 250ms for temperatures to settle
  *  - Init temp_range[], used for catching min/maxtemp
  */
 void Temperature::init() {
 
   TERN_(PROBING_HEATERS_OFF, paused_for_probing = false);
 
-
   // Init (and disable) SPI thermocouples
   #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && PIN_EXISTS(TEMP_0_CS)
     OUT_WRITE(TEMP_0_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && PIN_EXISTS(TEMP_1_CS)
     OUT_WRITE(TEMP_1_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_ANY_MAX_TC(2) && PIN_EXISTS(TEMP_2_CS)
     OUT_WRITE(TEMP_2_CS_PIN, HIGH);
   #endif
@@ -3044,37 +3028,45 @@ void Temperature::init() {
     #if _MINMAX_TEST(7, MIN)
       _TEMP_MIN_E(7);
     #endif
     #if _MINMAX_TEST(7, MAX)
       _TEMP_MAX_E(7);
     #endif
   #endif // HAS_HOTEND
 
   // TODO: combine these into the macros above
   #if HAS_HEATED_BED
-    while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
-    while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
+    while (analog_to_celsius_bed(temp_sensor_range_bed.raw_min) < BED_MINTEMP)
+      temp_sensor_range_bed.raw_min += TEMPDIR(BED) * (OVERSAMPLENR);
+    while (analog_to_celsius_bed(temp_sensor_range_bed.raw_max) > BED_MAXTEMP)
+      temp_sensor_range_bed.raw_max -= TEMPDIR(BED) * (OVERSAMPLENR);
   #endif
 
   #if HAS_HEATED_CHAMBER
-    while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
-    while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
+    while (analog_to_celsius_chamber(temp_sensor_range_chamber.raw_min) < CHAMBER_MINTEMP)
+      temp_sensor_range_chamber.raw_min += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
+    while (analog_to_celsius_chamber(temp_sensor_range_chamber.raw_max) > CHAMBER_MAXTEMP)
+      temp_sensor_range_chamber.raw_max -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
-    while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
-    while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
+    while (analog_to_celsius_cooler(temp_sensor_range_cooler.raw_min) > COOLER_MINTEMP)
+      temp_sensor_range_cooler.raw_min += TEMPDIR(COOLER) * (OVERSAMPLENR);
+    while (analog_to_celsius_cooler(temp_sensor_range_cooler.raw_max) < COOLER_MAXTEMP)
+      temp_sensor_range_cooler.raw_max -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
 
   #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
-    while (analog_to_celsius_board(mintemp_raw_BOARD) < BOARD_MINTEMP) mintemp_raw_BOARD += TEMPDIR(BOARD) * (OVERSAMPLENR);
-    while (analog_to_celsius_board(maxtemp_raw_BOARD) > BOARD_MAXTEMP) maxtemp_raw_BOARD -= TEMPDIR(BOARD) * (OVERSAMPLENR);
+    while (analog_to_celsius_board(temp_sensor_range_board.raw_min) < BOARD_MINTEMP)
+      temp_sensor_range_board.raw_min += TEMPDIR(BOARD) * (OVERSAMPLENR);
+    while (analog_to_celsius_board(temp_sensor_range_board.raw_max) > BOARD_MAXTEMP)
+      temp_sensor_range_board.raw_max -= TEMPDIR(BOARD) * (OVERSAMPLENR);
   #endif
 
   #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
     while (analog_to_celsius_soc(maxtemp_raw_SOC) > SOC_MAXTEMP) maxtemp_raw_SOC -= OVERSAMPLENR;
   #endif
 
   #if HAS_TEMP_REDUNDANT
     temp_redundant.target = &(
       #if REDUNDANT_TEMP_MATCH(TARGET, COOLER) && HAS_TEMP_COOLER
         temp_cooler

commit 52693f72afca243ace00a7a57365301f5f8c42c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 4 13:01:45 2024 -0600

    üé® Clean up some checks & includes

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3f55dde598..e65297b04a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -175,24 +175,20 @@
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
 
-#if ENABLED(SINGLENOZZLE)
-  #include "tool_change.h"
-#endif
-
 #if HAS_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if ANY(TEMP_SENSOR_0_IS_THERMISTOR, TEMP_SENSOR_1_IS_THERMISTOR, TEMP_SENSOR_2_IS_THERMISTOR, TEMP_SENSOR_3_IS_THERMISTOR, \
         TEMP_SENSOR_4_IS_THERMISTOR, TEMP_SENSOR_5_IS_THERMISTOR, TEMP_SENSOR_6_IS_THERMISTOR, TEMP_SENSOR_7_IS_THERMISTOR )

commit 54b7da18cbbbed49fee93f0f39b7093c527c25ea
Author: Taylor Talkington <taylor.talkington@gmail.com>
Date:   Wed Jan 3 21:45:50 2024 -0500

    ü©π Fix Bed PID Autotune output (#26606)
    
    Followup to #25928

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5b4dcc83bc..3f55dde598 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -842,23 +842,23 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if ANY(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
-          say_default_(); SERIAL_ECHO(estring, F("Kp "), tune_pid.p);
-          say_default_(); SERIAL_ECHO(estring, F("Ki "), tune_pid.i);
-          say_default_(); SERIAL_ECHO(estring, F("Kd "), tune_pid.d);
+          say_default_(); SERIAL_ECHOLN(estring, F("Kp "), tune_pid.p);
+          say_default_(); SERIAL_ECHOLN(estring, F("Ki "), tune_pid.i);
+          say_default_(); SERIAL_ECHOLN(estring, F("Kd "), tune_pid.d);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
           say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
           say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #endif
 
         auto _set_hotend_pid = [](const uint8_t tool, const raw_pid_t &in_pid) {
           #if ENABLED(PIDTEMP)
             #if ENABLED(PID_PARAMS_PER_HOTEND)
               thermalManager.temp_hotend[tool].pid.set(in_pid);

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    üßë‚Äçüíª AS_CHAR => C (#26569)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d3aa37c6ab..5b4dcc83bc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1480,21 +1480,21 @@ void Temperature::_temp_error(
     #endif
 
     switch (real_heater_id) {
       OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
       OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
       OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
       OPTCODE(HAS_TEMP_SOC,     case H_SOC:     SERIAL_ECHOPGM(STR_SOC);            break)
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
-        if (real_heater_id >= 0) SERIAL_ECHO(AS_CHAR('E'), real_heater_id);
+        if (real_heater_id >= 0) SERIAL_ECHO(C('E'), real_heater_id);
     }
     #if ENABLED(ERR_INCLUDE_TEMP)
       SERIAL_ECHOLNPGM(STR_DETECTED_TEMP_B, deg, STR_DETECTED_TEMP_E);
     #else
       SERIAL_EOL();
     #endif
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   hal.watchdog_refresh();

commit d9a388bab86381843691af939dd023c6d534cf50
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 24 21:31:54 2023 -0600

    ü©π Fix some serial chars

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index afde7d3b34..d3aa37c6ab 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1480,21 +1480,21 @@ void Temperature::_temp_error(
     #endif
 
     switch (real_heater_id) {
       OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
       OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
       OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
       OPTCODE(HAS_TEMP_SOC,     case H_SOC:     SERIAL_ECHOPGM(STR_SOC);            break)
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
-        if (real_heater_id >= 0) SERIAL_ECHO('E', real_heater_id);
+        if (real_heater_id >= 0) SERIAL_ECHO(AS_CHAR('E'), real_heater_id);
     }
     #if ENABLED(ERR_INCLUDE_TEMP)
       SERIAL_ECHOLNPGM(STR_DETECTED_TEMP_B, deg, STR_DETECTED_TEMP_E);
     #else
       SERIAL_EOL();
     #endif
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   hal.watchdog_refresh();

commit c18294d83cc891c47d5abe56a4842adbe6fbb1aa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 21 15:30:03 2023 -0600

    üîß Optional FAN_INVERTING

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fc9e08fe7c..afde7d3b34 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -363,23 +363,23 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed = FAN_OFF_PWM;
 #endif
 
 #if ALL(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
   uint8_t Temperature::soft_pwm_controller_speed = FAN_OFF_PWM;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef BOARD_OPENDRAIN_MOSFETS
-  #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
+  #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, ENABLED(FAN_INVERTING) ? LOW : HIGH)
 #else
-  #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
+  #define _INIT_SOFT_FAN(P) OUT_WRITE(P, ENABLED(FAN_INVERTING) ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
   #define SET_FAST_PWM_FREQ(P) hal.set_pwm_frequency(pin_t(P), FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
@@ -3812,21 +3812,21 @@ void Temperature::isr() {
   #endif
 
   #if HAS_COOLER
     static SoftPWM soft_pwm_cooler;
   #endif
 
   #if ALL(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
     static SoftPWM soft_pwm_controller;
   #endif
 
-  #define WRITE_FAN(n, v) WRITE(FAN##n##_PIN, (v) ^ FAN_INVERTING)
+  #define WRITE_FAN(n, v) WRITE(FAN##n##_PIN, (v) ^ ENABLED(FAN_INVERTING))
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
     #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, HAS_COOLER, FAN_SOFT_PWM)
       constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \
         const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
         WRITE_HEATER_##N(on);                               \
       }while(0)
     #endif

commit 0a86a5f39c560f324e65b539b5be8da1ed91c60a
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Sun Nov 26 02:55:51 2023 +0100

    ‚ú® MAX Thermocouples for Heated Bed (#26441)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2f8761ec39..fc9e08fe7c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -67,21 +67,20 @@
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "../libs/nozzle.h"
 #endif
 
 #if LASER_SAFETY_TIMEOUT_MS > 0
   #include "../feature/spindle_laser.h"
 #endif
 
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
-#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (TEMP_SENSOR_IS_MAX_TC(n) || (TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
 #if HAS_MAX6675 && USE_LIB_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
 
 // LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library.
 // If LIB_MAX31855 is not on the build_flags then raw SPI reads will be used.
@@ -114,20 +113,23 @@
 //
 #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && TEMP_SENSOR_0_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
   #define TEMP_SENSOR_0_USES_SW_SPI 1
 #endif
 #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && TEMP_SENSOR_1_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
   #define TEMP_SENSOR_1_USES_SW_SPI 1
 #endif
 #if TEMP_SENSOR_IS_ANY_MAX_TC(2) && TEMP_SENSOR_2_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
   #define TEMP_SENSOR_2_USES_SW_SPI 1
 #endif
+#if TEMP_SENSOR_IS_ANY_MAX_TC(BED) && TEMP_SENSOR_0_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
+  #define TEMP_SENSOR_BED_USES_SW_SPI 1
+#endif
 
 #if (TEMP_SENSOR_0_USES_SW_SPI || TEMP_SENSOR_1_USES_SW_SPI || TEMP_SENSOR_2_USES_SW_SPI) && !HAS_MAXTC_LIBRARIES
   #include "../libs/private_spi.h"
   #define HAS_MAXTC_SW_SPI 1
 
   // Define pins for SPI-based sensors
   #if TEMP_SENSOR_0_USES_SW_SPI
     #define SW_SPI_SCK_PIN    TEMP_0_SCK_PIN
     #define SW_SPI_MISO_PIN   TEMP_0_MISO_PIN
     #if PIN_EXISTS(TEMP_0_MOSI)
@@ -252,34 +254,39 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
     #if TEMP_SENSOR_IS_MAX(2, 31855)
       MAXTC_INIT(2, 31855);
     #endif
   #endif
 
   // MAX31865 always uses a library, unlike '55 & 6675
   #if HAS_MAX31865
     #define _MAX31865_0_SW TEMP_SENSOR_0_USES_SW_SPI
     #define _MAX31865_1_SW TEMP_SENSOR_1_USES_SW_SPI
     #define _MAX31865_2_SW TEMP_SENSOR_2_USES_SW_SPI
+    #define _MAX31865_BED_SW TEMP_SENSOR_BED_USES_SW_SPI
 
     #if TEMP_SENSOR_IS_MAX(0, 31865)
       MAXTC_INIT(0, 31865);
     #endif
     #if TEMP_SENSOR_IS_MAX(1, 31865)
       MAXTC_INIT(1, 31865);
     #endif
     #if TEMP_SENSOR_IS_MAX(2, 31865)
       MAXTC_INIT(2, 31865);
     #endif
+    #if TEMP_SENSOR_IS_MAX(BED, 31865)
+      MAXTC_INIT(BED, 31865);
+    #endif
 
     #undef _MAX31865_0_SW
     #undef _MAX31865_1_SW
     #undef _MAX31865_2_SW
+    #undef _MAX31865_BED_SW
   #endif
 
   #undef MAXTC_INIT
 
 #endif
 
 /**
  * public:
  */
 
@@ -2082,47 +2089,52 @@ void Temperature::task() {
       }
     #endif
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_IS_MAX_TC(0)
     {
       const auto deg = degHotend(0);
-      if (deg > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) MAXTEMP_ERROR(H_E0, deg);
-      if (deg < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) MINTEMP_ERROR(H_E0, deg);
+      if (deg > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.00f)) MAXTEMP_ERROR(H_E0, deg);
+      if (deg < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + 0.01f)) MINTEMP_ERROR(H_E0, deg);
     }
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(1)
     {
       const auto deg = degHotend(1);
-      if (deg > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) MAXTEMP_ERROR(H_E1, deg);
-      if (deg < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) MINTEMP_ERROR(H_E1, deg);
+      if (deg > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.00f)) MAXTEMP_ERROR(H_E1, deg);
+      if (deg < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + 0.01f)) MINTEMP_ERROR(H_E1, deg);
     }
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(2)
     {
       const auto deg = degHotend(2);
-      if (deg > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.0)) MAXTEMP_ERROR(H_E2, deg);
-      if (deg < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + .01)) MINTEMP_ERROR(H_E2, deg);
+      if (deg > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.00f)) MAXTEMP_ERROR(H_E2, deg);
+      if (deg < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + 0.01f)) MINTEMP_ERROR(H_E2, deg);
     }
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
     {
       const auto deg = degRedundant();
-      if (deg > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) MAXTEMP_ERROR(H_REDUNDANT, deg);
-      if (deg < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) MINTEMP_ERROR(H_REDUNDANT, deg);
+      if (deg > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.00f) MAXTEMP_ERROR(H_REDUNDANT, deg);
+      if (deg < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + 0.01f) MINTEMP_ERROR(H_REDUNDANT, deg);
+    }
+    #endif
+    #if TEMP_SENSOR_IS_MAX_TC(BED)
+    {
+      const auto deg = degBed();
+      if (deg > _MIN(BED_MAXTEMP, TEMP_SENSOR_BED_MAX_TC_TMAX - 1.00f)) MAXTEMP_ERROR(H_BED, deg);
+      if (deg < _MAX(BED_MINTEMP, TEMP_SENSOR_BED_MAX_TC_TMIN + 0.01f)) MINTEMP_ERROR(H_BED, deg);
     }
     #endif
-  #else
-    #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
   #endif
 
   const millis_t ms = millis();
 
   // Handle Hotend Temp Errors, Heating Watch, etc.
   TERN_(HAS_HOTEND, manage_hotends(ms));
 
   #if HAS_TEMP_REDUNDANT
   {
     const auto deg = degRedundant();
@@ -2322,59 +2334,59 @@ void Temperature::task() {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif TEMP_SENSOR_IS_MAX_TC(0)
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
               max31865_0.temperature(raw),
               max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
             );
           #else
-            return (int16_t)raw * 0.25;
+            return (int16_t)raw * 0.25f;
           #endif
         #elif TEMP_SENSOR_0_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_0_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
         #if TEMP_SENSOR_1_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
         #elif TEMP_SENSOR_IS_MAX_TC(1)
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
               max31865_1.temperature(raw),
               max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1)
             );
           #else
-            return (int16_t)raw * 0.25;
+            return (int16_t)raw * 0.25f;
           #endif
         #elif TEMP_SENSOR_1_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_1_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
         #if TEMP_SENSOR_2_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
         #elif TEMP_SENSOR_IS_MAX_TC(2)
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
               max31865_2.temperature(raw),
               max31865_2.temperature(MAX31865_SENSOR_OHMS_2, MAX31865_CALIBRATION_OHMS_2)
             );
           #else
-            return (int16_t)raw * 0.25;
+            return (int16_t)raw * 0.25f;
           #endif
         #elif TEMP_SENSOR_2_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_2_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 3:
         #if TEMP_SENSOR_3_IS_CUSTOM
@@ -2437,20 +2449,29 @@ void Temperature::task() {
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // For bed temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_bed(const raw_adc_t raw) {
     #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
+    #elif TEMP_SENSOR_IS_MAX_TC(BED)
+      #if TEMP_SENSOR_BED_IS_MAX31865
+        return TERN(LIB_INTERNAL_MAX31865,
+          max31865_BED.temperature(raw),
+          max31865_BED.temperature(MAX31865_SENSOR_OHMS_BED, MAX31865_CALIBRATION_OHMS_BED)
+        );
+      #else
+        return (int16_t)raw * 0.25f;
+      #endif
     #elif TEMP_SENSOR_BED_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
     #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
@@ -2542,25 +2563,25 @@ void Temperature::task() {
     );
   }
 #endif
 
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_redundant(const raw_adc_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E0)
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(raw), (int16_t)raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(raw), (int16_t)raw * 0.25f);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E1)
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(raw), (int16_t)raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(raw), (int16_t)raw * 0.25f);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E2)
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_2.temperature(raw), (int16_t)raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_2.temperature(raw), (int16_t)raw * 0.25f);
     #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
@@ -2588,20 +2609,23 @@ void Temperature::updateTemperaturesFromRawValues() {
   #endif
   #if TEMP_SENSOR_IS_MAX_TC(1)
     temp_hotend[1].setraw(READ_MAX_TC(1));
   #endif
   #if TEMP_SENSOR_IS_MAX_TC(2)
     temp_hotend[2].setraw(READ_MAX_TC(2));
   #endif
   #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
     temp_redundant.setraw(READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE)));
   #endif
+  #if TEMP_SENSOR_IS_MAX_TC(BED)
+    temp_bed.setraw(read_max_tc_bed());
+  #endif
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].getraw(), e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.getraw()));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.getraw()));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.getraw()));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.getraw()));
   TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.getraw()));
@@ -2756,20 +2780,31 @@ void Temperature::init() {
       max6675_2.begin();
     #elif TEMP_SENSOR_IS_MAX(2, 31855) && HAS_MAX31855_LIBRARY
       max31855_2.begin();
     #elif TEMP_SENSOR_IS_MAX(2, 31865)
       max31865_2.begin(
         MAX31865_WIRES(MAX31865_SENSOR_WIRES_2) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
         OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_2, MAX31865_CALIBRATION_OHMS_2, MAX31865_WIRE_OHMS_2)
       );
     #endif
 
+    #if TEMP_SENSOR_IS_MAX(BED, 6675) && HAS_MAX6675_LIBRARY
+      max6675_BED.begin();
+    #elif TEMP_SENSOR_IS_MAX(BED, 31855) && HAS_MAX31855_LIBRARY
+      max31855_BED.begin();
+    #elif TEMP_SENSOR_IS_MAX(BED, 31865)
+      max31865_BED.begin(
+        MAX31865_WIRES(MAX31865_SENSOR_WIRES_BED) // MAX31865_BEDWIRE, MAX31865_3WIRE, MAX31865_4WIRE
+        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_BED, MAX31865_CALIBRATION_OHMS_BED, MAX31865_WIRE_OHMS_BED)
+      );
+    #endif
+
     #undef MAX31865_WIRES
     #undef _MAX31865_WIRES
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
@@ -3314,20 +3349,22 @@ void Temperature::disable_all_heaters() {
         set_heating_message(0);
         (void)wait_for_hotend(0, false);  // Wait for heating or cooling
       }
     #endif
   }
 
 #endif // SINGLENOZZLE_STANDBY_TEMP || SINGLENOZZLE_STANDBY_FAN
 
 #if HAS_MAX_TC
 
+  typedef TERN(HAS_MAX31855, uint32_t, uint16_t) max_tc_temp_t;
+
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 
   /**
    * @brief Read MAX Thermocouple temperature.
    *
    * Reads the thermocouple board via HW or SW SPI, using a library (LIB_USR_x) or raw SPI reads.
    * Doesn't strictly return a temperature; returns an "ADC Value" (i.e. raw register content).
    *
@@ -3413,66 +3450,55 @@ void Temperature::disable_all_heaters() {
         max_tc_temp |= TERN(HAS_MAXTC_SW_SPI, max_tc_spi.receive(), spiRec());
         if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
       }
 
       MAXTC_CS_WRITE(HIGH);  // Disable MAXTC
     #else
       #if HAS_MAX6675_LIBRARY
         MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1, max6675_2);
         max_tc_temp = max6675ref.readRaw16();
       #endif
-
       #if HAS_MAX31855_LIBRARY
         MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1, max31855_2);
         max_tc_temp = max855ref.readRaw32();
       #endif
-
       #if HAS_MAX31865
         MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1, max31865_2);
         max_tc_temp = TERN(LIB_INTERNAL_MAX31865, max865ref.readRaw(), max865ref.readRTD_with_Fault());
       #endif
     #endif
 
     // Handle an error. If there have been more than THERMOCOUPLE_MAX_ERRORS, send an error over serial.
     // Either way, return the TMAX for the thermocouple to trigger a maxtemp_error()
     if (max_tc_temp & MAX_TC_ERROR_MASK) {
       max_tc_errors[hindex]++;
 
       if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
         #if HAS_MAX31855
           SERIAL_ECHOPGM("MAX31855 Fault: (", max_tc_temp & 0x7, ") >> ");
-          if (max_tc_temp & 0x1)
-            SERIAL_ECHOLNPGM("Open Circuit");
-          else if (max_tc_temp & 0x2)
-            SERIAL_ECHOLNPGM("Short to GND");
-          else if (max_tc_temp & 0x4)
-            SERIAL_ECHOLNPGM("Short to VCC");
+               if (max_tc_temp & 0x1) SERIAL_ECHOLNPGM("Open Circuit");
+          else if (max_tc_temp & 0x2) SERIAL_ECHOLNPGM("Short to GND");
+          else if (max_tc_temp & 0x4) SERIAL_ECHOLNPGM("Short to VCC");
         #elif HAS_MAX31865
           const uint8_t fault_31865 = max865ref.readFault();
           max865ref.clearFault();
           if (fault_31865) {
             SERIAL_EOL();
             SERIAL_ECHOLNPGM("\nMAX31865 Fault: (", fault_31865, ")  >>");
-            if (fault_31865 & MAX31865_FAULT_HIGHTHRESH)
-              SERIAL_ECHOLNPGM("RTD High Threshold");
-            if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
-              SERIAL_ECHOLNPGM("RTD Low Threshold");
-            if (fault_31865 & MAX31865_FAULT_REFINLOW)
-              SERIAL_ECHOLNPGM("REFIN- > 0.85 x V bias");
-            if (fault_31865 & MAX31865_FAULT_REFINHIGH)
-              SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
-            if (fault_31865 & MAX31865_FAULT_RTDINLOW)
-              SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
-            if (fault_31865 & MAX31865_FAULT_OVUV)
-              SERIAL_ECHOLNPGM("Under/Over voltage");
+            if (fault_31865 & MAX31865_FAULT_HIGHTHRESH) SERIAL_ECHOLNPGM("RTD High Threshold");
+            if (fault_31865 & MAX31865_FAULT_LOWTHRESH)  SERIAL_ECHOLNPGM("RTD Low Threshold");
+            if (fault_31865 & MAX31865_FAULT_REFINLOW)   SERIAL_ECHOLNPGM("REFIN- > 0.85 x V bias");
+            if (fault_31865 & MAX31865_FAULT_REFINHIGH)  SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
+            if (fault_31865 & MAX31865_FAULT_RTDINLOW)   SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
+            if (fault_31865 & MAX31865_FAULT_OVUV)       SERIAL_ECHOLNPGM("Under/Over voltage");
           }
         #else // MAX6675
           SERIAL_ECHOLNPGM("MAX6675 Fault: Open Circuit");
         #endif
 
         // Set thermocouple above max temperature (TMAX)
         max_tc_temp = THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX, TEMP_SENSOR_2_MAX_TC_TMAX) << (MAX_TC_DISCARD_BITS + 1);
       }
     }
     else {
@@ -3486,20 +3512,138 @@ void Temperature::disable_all_heaters() {
       if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000;
     #endif
 
     THERMO_TEMP(hindex) = max_tc_temp;
 
     return max_tc_temp;
   }
 
 #endif // HAS_MAX_TC
 
+#if TEMP_SENSOR_IS_MAX_TC(BED)
+  /**
+   * @brief Read MAX Thermocouple temperature.
+   *
+   * Reads the thermocouple board via HW or SW SPI, using a library (LIB_USR_x) or raw SPI reads.
+   * Doesn't strictly return a temperature; returns an "ADC Value" (i.e. raw register content).
+   *
+   * @return         integer representing the board's buffer, to be converted later if needed
+   */
+  raw_adc_t Temperature::read_max_tc_bed() {
+    #define MAXTC_HEAT_INTERVAL 250UL
+
+    #if TEMP_SENSOR_BED_IS_MAX31855
+      #define BED_MAX_TC_ERROR_MASK    7    // D2-0: SCV, SCG, OC
+      #define BED_MAX_TC_DISCARD_BITS 18    // Data D31-18; sign bit D31
+      #define BED_MAX_TC_SPEED_BITS    3    // ~1MHz
+    #elif TEMP_SENSOR_BED_IS_MAX31865
+      #define BED_MAX_TC_ERROR_MASK    1    // D0 Bit on fault only
+      #define BED_MAX_TC_DISCARD_BITS  1    // Data is in D15-D1
+      #define BED_MAX_TC_SPEED_BITS    3    // ~1MHz
+    #else // MAX6675
+      #define BED_MAX_TC_ERROR_MASK    3    // D2 only; 1 = open circuit
+      #define BED_MAX_TC_DISCARD_BITS  3    // Data D15-D1
+      #define BED_MAX_TC_SPEED_BITS    2    // ~2MHz
+    #endif
+
+    static max_tc_temp_t max_tc_temp = TEMP_SENSOR_BED_MAX_TC_TMAX;
+
+    static uint8_t max_tc_errors = 0;
+    static millis_t next_max_tc_ms = 0;
+
+    // Return last-read value between readings
+    const millis_t ms = millis();
+    if (PENDING(ms, next_max_tc_ms)) return max_tc_temp;
+    next_max_tc_ms = ms + MAXTC_HEAT_INTERVAL;
+
+    #if !HAS_MAXTC_LIBRARIES
+      max_tc_temp = 0;
+
+      #if !HAS_MAXTC_SW_SPI
+        // Initialize SPI using the default Hardware SPI bus.
+        // FIXME: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
+        spiBegin();
+        spiInit(BED_MAX_TC_SPEED_BITS);
+      #endif
+
+      WRITE(TEMP_BED_CS_PIN, LOW);  // Enable MAXTC
+      DELAY_NS(100);        // Ensure 100ns delay
+
+      // Read a big-endian temperature value without using a library
+      for (uint8_t i = sizeof(max_tc_temp); i--;) {
+        max_tc_temp |= TERN(HAS_MAXTC_SW_SPI, max_tc_spi.receive(), spiRec());
+        if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
+      }
+
+      WRITE(TEMP_BED_CS_PIN, HIGH);  // Disable MAXTC
+
+    #elif ALL(TEMP_SENSOR_BED_IS_MAX6675, HAS_MAX6675_LIBRARY)
+      MAX6675 &max6675ref = max6675_BED;
+      max_tc_temp = max6675ref.readRaw16();
+    #elif ALL(TEMP_SENSOR_BED_IS_MAX31855, HAS_MAX31855_LIBRARY)
+      MAX31855 &max855ref = max31855_BED;
+      max_tc_temp = max855ref.readRaw32();
+    #elif TEMP_SENSOR_BED_IS_MAX31865
+      MAX31865 &max865ref = max31865_BED;
+      max_tc_temp = TERN(LIB_INTERNAL_MAX31865, max865ref.readRaw(), max865ref.readRTD_with_Fault());
+    #endif
+
+    // Handle an error. If there have been more than THERMOCOUPLE_MAX_ERRORS, send an error over serial.
+    // Either way, return the TMAX for the thermocouple to trigger a maxtemp_error()
+    if (max_tc_temp & BED_MAX_TC_ERROR_MASK) {
+      max_tc_errors++;
+
+      if (max_tc_errors > THERMOCOUPLE_MAX_ERRORS) {
+        SERIAL_ERROR_START();
+        SERIAL_ECHOPGM("Bed temp measurement error! ");
+        #if TEMP_SENSOR_BED_IS_MAX31855
+          SERIAL_ECHOPGM("MAX31855 Fault: (", max_tc_temp & 0x7, ") >> ");
+               if (max_tc_temp & 0x1) SERIAL_ECHOLNPGM("Open Circuit");
+          else if (max_tc_temp & 0x2) SERIAL_ECHOLNPGM("Short to GND");
+          else if (max_tc_temp & 0x4) SERIAL_ECHOLNPGM("Short to VCC");
+        #elif TEMP_SENSOR_BED_IS_MAX31865
+          const uint8_t fault_31865 = max865ref.readFault();
+          max865ref.clearFault();
+          if (fault_31865) {
+            SERIAL_EOL();
+            SERIAL_ECHOLNPGM("\nMAX31865 Fault: (", fault_31865, ")  >>");
+            if (fault_31865 & MAX31865_FAULT_HIGHTHRESH) SERIAL_ECHOLNPGM("RTD High Threshold");
+            if (fault_31865 & MAX31865_FAULT_LOWTHRESH)  SERIAL_ECHOLNPGM("RTD Low Threshold");
+            if (fault_31865 & MAX31865_FAULT_REFINLOW)   SERIAL_ECHOLNPGM("REFIN- > 0.85 x V bias");
+            if (fault_31865 & MAX31865_FAULT_REFINHIGH)  SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
+            if (fault_31865 & MAX31865_FAULT_RTDINLOW)   SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
+            if (fault_31865 & MAX31865_FAULT_OVUV)       SERIAL_ECHOLNPGM("Under/Over voltage");
+          }
+        #else // MAX6675
+          SERIAL_ECHOLNPGM("MAX6675 Fault: Open Circuit");
+        #endif
+
+        // Set thermocouple above max temperature (TMAX)
+        max_tc_temp = TEMP_SENSOR_BED_MAX_TC_TMAX << (BED_MAX_TC_DISCARD_BITS + 1);
+      }
+    }
+    else {
+      max_tc_errors = 0; // No error bit, reset error count
+    }
+
+    max_tc_temp >>= BED_MAX_TC_DISCARD_BITS;
+
+    #if TEMP_SENSOR_BED_IS_MAX31855
+      // Support negative temperature for MAX38155
+      if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000;
+    #endif
+
+    return max_tc_temp;
+  }
+
+#endif // TEMP_SENSOR_IS_MAX_TC(BED)
+
 /**
  * Update raw temperatures
  *
  * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
  * Applies all the accumulators to the current raw temperatures.
  */
 void Temperature::update_raw_temperatures() {
 
   // TODO: can this be collapsed into a HOTEND_LOOP()?
   #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_IS_MAX_TC(0)
@@ -3511,27 +3655,30 @@ void Temperature::update_raw_temperatures() {
   #endif
 
   #if HAS_TEMP_ADC_2 && !TEMP_SENSOR_IS_MAX_TC(2)
     temp_hotend[2].update();
   #endif
 
   #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
     temp_redundant.update();
   #endif
 
+  #if HAS_TEMP_ADC_BED && !TEMP_SENSOR_IS_MAX_TC(BED)
+    temp_bed.update();
+  #endif
+
   TERN_(HAS_TEMP_ADC_2,       temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());
-  TERN_(HAS_TEMP_ADC_BED,     temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
   TERN_(HAS_TEMP_ADC_PROBE,   temp_probe.update());
   TERN_(HAS_TEMP_ADC_COOLER,  temp_cooler.update());
   TERN_(HAS_TEMP_ADC_BOARD,   temp_board.update());
   TERN_(HAS_TEMP_ADC_SOC,     temp_soc.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 }

commit 15dfbabc9cbfde0551571b550e56f5d2d5271dd4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 3 14:52:04 2023 -0500

    üîß Temp report precision option (#26253)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b2e2915d17..2f8761ec39 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -4198,26 +4198,28 @@ void Temperature::isr() {
       #if HAS_TEMP_BOARD
         case H_BOARD: k = 'M'; show_t = false; break;
       #endif
       #if HAS_TEMP_SOC
         case H_SOC: k = 'S'; show_t = false; break;
       #endif
       #if HAS_TEMP_REDUNDANT
         case H_REDUNDANT: k = 'R'; break;
       #endif
     }
-    #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
+    #ifndef HEATER_STATE_FLOAT_PRECISION
+      #define HEATER_STATE_FLOAT_PRECISION _MIN(SERIAL_FLOAT_PRECISION, 2)
+    #endif
 
     SString<50> s(' ', k);
     if (TERN0(HAS_MULTI_HOTEND, e >= 0)) s += char('0' + e);
-    s += ':'; s += p_float_t(c, SFP);
-    if (show_t) { s += F(" /"); s += p_float_t(t, SFP); }
+    s += ':'; s += p_float_t(c, HEATER_STATE_FLOAT_PRECISION);
+    if (show_t) { s += F(" /"); s += p_float_t(t, HEATER_STATE_FLOAT_PRECISION); }
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       s.append(F(" ("), TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR), ')');
     #endif
     s.echo();
     delay(2);
   }
 
   void Temperature::print_heater_states(const int8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)

commit 88cdf487b433bf2187f2dad31587882ebf02cc59
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 22 17:36:53 2023 -0500

    üö∏ Avoid LCD messages starting with "Error:" (#26164)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6139ebe120..b2e2915d17 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -200,46 +200,22 @@
 #if HAS_HOTEND_THERMISTOR
   #define NEXT_TEMPTABLE(N) ,TEMPTABLE_##N
   #define NEXT_TEMPTABLE_LEN(N) ,TEMPTABLE_##N##_LEN
   static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0 REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
   static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
 #endif
 
 Temperature thermalManager;
 
 PGMSTR(str_t_thermal_runaway, STR_T_THERMAL_RUNAWAY);
-PGMSTR(str_t_temp_malfunction, STR_T_MALFUNCTION);
 PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
-/**
- * Macros to include the heater id in temp errors. The compiler's dead-code
- * elimination should (hopefully) optimize out the unused strings.
- */
-
-#if HAS_HEATED_BED
-  #define _BED_FSTR(h) (h) == H_BED ? GET_TEXT_F(MSG_BED) :
-#else
-  #define _BED_FSTR(h)
-#endif
-#if HAS_HEATED_CHAMBER
-  #define _CHAMBER_FSTR(h) (h) == H_CHAMBER ? GET_TEXT_F(MSG_CHAMBER) :
-#else
-  #define _CHAMBER_FSTR(h)
-#endif
-#if HAS_COOLER
-  #define _COOLER_FSTR(h) (h) == H_COOLER ? GET_TEXT_F(MSG_COOLER) :
-#else
-  #define _COOLER_FSTR(h)
-#endif
-#define _E_FSTR(h,N) ((HOTENDS) > N && (h) == N) ? F(STR_E##N) :
-#define HEATER_FSTR(h) _BED_FSTR(h) _CHAMBER_FSTR(h) _COOLER_FSTR(h) _E_FSTR(h,1) _E_FSTR(h,2) _E_FSTR(h,3) _E_FSTR(h,4) _E_FSTR(h,5) _E_FSTR(h,6) _E_FSTR(h,7) F(STR_E0)
-
 //
 // Initialize MAX TC objects/SPI
 //
 #if HAS_MAX_TC
 
   #if HAS_MAXTC_SW_SPI
     // Initialize SoftSPI for non-lib Software SPI; Libraries take care of it themselves.
     template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin>
       SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
     SPIclass<SW_SPI_MISO_PIN, SW_SPI_MOSI_PIN, SW_SPI_SCK_PIN> max_tc_spi;
@@ -832,24 +808,24 @@ volatile bool Temperature::raw_temps_ready = false;
         // Make sure heating is actually working
         #if WATCH_PID
           if (ALL(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);   // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
-                _TEMP_ERROR(heater_id, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, current_temp);
+                _TEMP_ERROR(heater_id, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, current_temp);
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_THERMAL_RUNAWAY, current_temp);
+              _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_ERR_THERMAL_RUNAWAY, current_temp);
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
@@ -1457,20 +1433,29 @@ inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
       hal.watchdog_refresh();
     }
     buzzer.on();
   #endif
   #if ENABLED(NOZZLE_PARK_FEATURE)
     if (!homing_needed_error()) {
       nozzle.park(0);
       planner.synchronize();
     }
   #endif
+
+  #define _FSTR_BED(h)     TERN(HAS_HEATED_BED,     (h) == H_BED      ? GET_TEXT_F(MSG_BED) :,)
+  #define _FSTR_CHAMBER(h) TERN(HAS_HEATED_CHAMBER, (h) == H_CHAMBER  ? GET_TEXT_F(MSG_CHAMBER) :,)
+  #define _FSTR_COOLER(h)  TERN(HAS_COOLER,         (h) == H_COOLER   ? GET_TEXT_F(MSG_COOLER) :,)
+  #define _FSTR_E(h,N)     TERN(HAS_HOTEND,        ((h) == N && (HOTENDS) > N) ? F(STR_E##N) :,)
+  #define HEATER_FSTR(h) _FSTR_BED(h) _FSTR_CHAMBER(h) _FSTR_COOLER(h) \
+                         _FSTR_E(h,1) _FSTR_E(h,2) _FSTR_E(h,3) _FSTR_E(h,4) \
+                         _FSTR_E(h,5) _FSTR_E(h,6) _FSTR_E(h,7) F(STR_E0)
+
   kill(lcd_msg, HEATER_FSTR(heater_id));
 }
 
 void Temperature::_temp_error(
   const heater_id_t heater_id, FSTR_P const serial_msg, FSTR_P const lcd_msg
   OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg)
 ) {
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
@@ -1758,21 +1743,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
         && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           auto temp = degHotend(e);
           if (watch_hotend[e].check(temp))          // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
             TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-            _TEMP_ERROR(e, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, temp);
+            _TEMP_ERROR(e, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, temp);
           }
         }
       #endif
 
     } // HOTEND_LOOP
   }
 
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
@@ -1788,21 +1773,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
 
     #if WATCH_BED
     {
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         const auto deg = degBed();
         if (watch_bed.check(deg))               // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
           TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-          _TEMP_ERROR(H_BED, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, deg);
+          _TEMP_ERROR(H_BED, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, deg);
         }
       }
     }
     #endif // WATCH_BED
 
     #if ALL(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
@@ -1883,21 +1868,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
     #endif
 
     #if WATCH_CHAMBER
     {
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
         const auto deg = degChamber();
         if (watch_chamber.check(deg))           // Increased enough? Error below.
           start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
-          _TEMP_ERROR(H_CHAMBER, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, deg);
+          _TEMP_ERROR(H_CHAMBER, FPSTR(str_t_heating_failed), MSG_ERR_HEATING_FAILED, deg);
       }
     }
     #endif
 
     #if ANY(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
       static bool flag_chamber_excess_heat; // = false;
     #endif
 
     #if ANY(CHAMBER_FAN, CHAMBER_VENT)
       static bool flag_chamber_off; // = false
@@ -2012,21 +1997,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_T
       const auto deg = degCooler();
       if (deg > COOLER_MAXTEMP) MAXTEMP_ERROR(H_COOLER, deg);
     }
     #endif
 
     #if WATCH_COOLER
       // Make sure temperature is decreasing
       if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
         const auto deg = degCooler();
         if (deg > watch_cooler.target)            // Failed to decrease enough?
-          _TEMP_ERROR(H_COOLER, GET_TEXT_F(MSG_COOLING_FAILED), MSG_COOLING_FAILED, deg);
+          _TEMP_ERROR(H_COOLER, GET_EN_TEXT_F(MSG_ERR_COOLING_FAILED), MSG_ERR_COOLING_FAILED, deg);
         else
           start_watching_cooler();                // Start again if the target is still far off
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
     if (cooler.enabled) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
       if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
@@ -3214,27 +3199,27 @@ void Temperature::init() {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-        _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_THERMAL_RUNAWAY, current);
+        _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_ERR_THERMAL_RUNAWAY, current);
         break;
 
       #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
         case TRMalfunction:
           TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-          _TEMP_ERROR(heater_id, FPSTR(str_t_temp_malfunction), MSG_TEMP_MALFUNCTION, current);
+          _TEMP_ERROR(heater_id, F(STR_T_THERMAL_MALFUNCTION), MSG_ERR_TEMP_MALFUNCTION, current);
           break;
       #endif
     }
   }
 
   #pragma GCC diagnostic pop
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {

commit fecadaca82e49c2558b42684382ede121274bfea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 7 04:24:04 2023 -0500

    üîß Clarify WIFISUPPORT (#26097)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c7e35c5754..6139ebe120 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3073,21 +3073,23 @@ void Temperature::init() {
       #else
         temp_hotend[HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET)]
       #endif
     );
   #endif
 }
 
 #if HAS_THERMAL_PROTECTION
 
   #pragma GCC diagnostic push
-  #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+  #if __has_cpp_attribute(fallthrough)
+    #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+  #endif
 
   Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
    * @param hysteresis_degc  allowed distance from target
@@ -3971,21 +3973,23 @@ void Temperature::isr() {
   #define ACCUMULATE_ADC(obj) do{ \
     if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; \
     else obj.sample(hal.adc_value()); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     #pragma GCC diagnostic push
-    #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+    #if __has_cpp_attribute(fallthrough)
+      #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+    #endif
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
       static uint8_t delay_count = 0;
       if (extra_loops > 0) {
         if (delay_count == 0) delay_count = extra_loops;  // Init this delay
         if (--delay_count)                                // While delaying...
           next_sensor_state = SensorsReady;               // retain this state (else, next state will be 0)

commit ad112b4d3d47ff841334b16dcf497917fb8c1ec6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 4 23:49:38 2023 -0500

    üêõ Fix case TRRunaway

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1f9928f88e..c7e35c5754 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3213,25 +3213,27 @@ void Temperature::init() {
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
         _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_THERMAL_RUNAWAY, current);
+        break;
 
       #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
         case TRMalfunction:
           TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
           _TEMP_ERROR(heater_id, FPSTR(str_t_temp_malfunction), MSG_TEMP_MALFUNCTION, current);
+          break;
       #endif
     }
   }
 
   #pragma GCC diagnostic pop
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 

commit 820d2b58b3cfe16affd421f4925ae924cb60826f
Author: Martin Turski <turningtides@outlook.de>
Date:   Fri Aug 4 04:40:38 2023 +0200

    üö∏ Option to report temperature on error (#25341)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d7c764540b..1f9928f88e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -832,24 +832,24 @@ volatile bool Temperature::raw_temps_ready = false;
         // Make sure heating is actually working
         #if WATCH_PID
           if (ALL(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);   // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
-                _temp_error(heater_id, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
+                _TEMP_ERROR(heater_id, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, current_temp);
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
+              _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_THERMAL_RUNAWAY, current_temp);
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
@@ -1460,22 +1460,24 @@ inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   #endif
   #if ENABLED(NOZZLE_PARK_FEATURE)
     if (!homing_needed_error()) {
       nozzle.park(0);
       planner.synchronize();
     }
   #endif
   kill(lcd_msg, HEATER_FSTR(heater_id));
 }
 
-void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_msg, FSTR_P const lcd_msg) {
-
+void Temperature::_temp_error(
+  const heater_id_t heater_id, FSTR_P const serial_msg, FSTR_P const lcd_msg
+  OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg)
+) {
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     SERIAL_ECHO(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
 
     heater_id_t real_heater_id = heater_id;
 
     #if HAS_TEMP_REDUNDANT
@@ -1486,24 +1488,27 @@ void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_m
     #endif
 
     switch (real_heater_id) {
       OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
       OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
       OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
       OPTCODE(HAS_TEMP_SOC,     case H_SOC:     SERIAL_ECHOPGM(STR_SOC);            break)
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
-        if (real_heater_id >= 0)
-          SERIAL_ECHOLNPGM("E", real_heater_id);
+        if (real_heater_id >= 0) SERIAL_ECHO('E', real_heater_id);
     }
-    SERIAL_EOL();
+    #if ENABLED(ERR_INCLUDE_TEMP)
+      SERIAL_ECHOLNPGM(STR_DETECTED_TEMP_B, deg, STR_DETECTED_TEMP_E);
+    #else
+      SERIAL_EOL();
+    #endif
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   hal.watchdog_refresh();
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
       case 0:
@@ -1518,32 +1523,32 @@ void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_m
         ++killed;
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
-void Temperature::maxtemp_error(const heater_id_t heater_id) {
+void Temperature::maxtemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg)) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     dwinPopupTemperature(1);
   #endif
-  _temp_error(heater_id, F(STR_T_MAXTEMP), GET_TEXT_F(MSG_ERR_MAXTEMP));
+  _TEMP_ERROR(heater_id, F(STR_T_MAXTEMP), MSG_ERR_MAXTEMP, deg);
 }
 
-void Temperature::mintemp_error(const heater_id_t heater_id) {
+void Temperature::mintemp_error(const heater_id_t heater_id OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg)) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     dwinPopupTemperature(0);
   #endif
-  _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
+  _TEMP_ERROR(heater_id, F(STR_T_MINTEMP), MSG_ERR_MINTEMP, deg);
 }
 
 #if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
 
 #if HAS_PID_HEATING
 
   template<typename TT>
   class PIDRunner {
@@ -1729,67 +1734,78 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
     return pid_output;
   }
 
 #endif // PIDTEMPCHAMBER
 
 #if HAS_HOTEND
 
   void Temperature::manage_hotends(const millis_t &ms) {
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        if (degHotend(e) > temp_range[e].maxtemp) maxtemp_error((heater_id_t)e);
+      {
+        const auto deg = degHotend(e);
+        if (deg > temp_range[e].maxtemp) MAXTEMP_ERROR(e, deg);
+      }
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
-      temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_hotend_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
+      temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_hotend_preheating(e))
+        && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
-          if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
+          auto temp = degHotend(e);
+          if (watch_hotend[e].check(temp))          // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
             TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-            _temp_error((heater_id_t)e, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
+            _TEMP_ERROR(e, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, temp);
           }
         }
       #endif
 
     } // HOTEND_LOOP
   }
 
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
 
   void Temperature::manage_heated_bed(const millis_t &ms) {
 
     #if ENABLED(THERMAL_PROTECTION_BED)
-      if (degBed() > BED_MAXTEMP) maxtemp_error(H_BED);
+    {
+      const auto deg = degBed();
+      if (deg > BED_MAXTEMP) MAXTEMP_ERROR(H_BED, deg);
+    }
     #endif
 
     #if WATCH_BED
+    {
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
-        if (watch_bed.check(degBed()))          // Increased enough?
+        const auto deg = degBed();
+        if (watch_bed.check(deg))               // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
           TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-          _temp_error(H_BED, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
+          _TEMP_ERROR(H_BED, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, deg);
         }
       }
+    }
     #endif // WATCH_BED
 
     #if ALL(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
       static bool last_pause_state;
     #endif
 
@@ -1853,31 +1869,37 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
 #if HAS_HEATED_CHAMBER
 
   void Temperature::manage_heated_chamber(const millis_t &ms) {
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-      if (degChamber() > (CHAMBER_MAXTEMP)) maxtemp_error(H_CHAMBER);
+    {
+      const auto deg = degChamber();
+      if (deg > CHAMBER_MAXTEMP) MAXTEMP_ERROR(H_CHAMBER, deg);
+    }
     #endif
 
     #if WATCH_CHAMBER
+    {
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
-        if (watch_chamber.check(degChamber()))  // Increased enough? Error below.
+        const auto deg = degChamber();
+        if (watch_chamber.check(deg))           // Increased enough? Error below.
           start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
-          _temp_error(H_CHAMBER, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
+          _TEMP_ERROR(H_CHAMBER, FPSTR(str_t_heating_failed), MSG_HEATING_FAILED_LCD, deg);
       }
+    }
     #endif
 
     #if ANY(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
       static bool flag_chamber_excess_heat; // = false;
     #endif
 
     #if ANY(CHAMBER_FAN, CHAMBER_VENT)
       static bool flag_chamber_off; // = false
 
       if (temp_chamber.target > CHAMBER_MINTEMP) {
@@ -1979,30 +2001,34 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
 #if HAS_COOLER
 
   void Temperature::manage_cooler(const millis_t &ms) {
 
     #ifndef COOLER_CHECK_INTERVAL
       #define COOLER_CHECK_INTERVAL 2000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
-      if (degCooler() > COOLER_MAXTEMP) maxtemp_error(H_COOLER);
+    {
+      const auto deg = degCooler();
+      if (deg > COOLER_MAXTEMP) MAXTEMP_ERROR(H_COOLER, deg);
+    }
     #endif
 
     #if WATCH_COOLER
       // Make sure temperature is decreasing
       if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
-        if (degCooler() > watch_cooler.target)    // Failed to decrease enough?
-          _temp_error(H_COOLER, GET_TEXT_F(MSG_COOLING_FAILED), GET_TEXT_F(MSG_COOLING_FAILED));
+        const auto deg = degCooler();
+        if (deg > watch_cooler.target)            // Failed to decrease enough?
+          _TEMP_ERROR(H_COOLER, GET_TEXT_F(MSG_COOLING_FAILED), MSG_COOLING_FAILED, deg);
         else
-          start_watching_cooler();                 // Start again if the target is still far off
+          start_watching_cooler();                // Start again if the target is still far off
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
     if (cooler.enabled) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
       if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
       if (ELAPSED(ms, next_cooler_check_ms)) {
         next_cooler_check_ms = ms + COOLER_CHECK_INTERVAL;
@@ -2069,48 +2095,63 @@ void Temperature::task() {
         card.flag.abort_sd_printing = true;
         gcode.process_subcommands_now(F("M524"));
       }
     #endif
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_IS_MAX_TC(0)
-      if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) maxtemp_error(H_E0);
-      if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) mintemp_error(H_E0);
+    {
+      const auto deg = degHotend(0);
+      if (deg > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) MAXTEMP_ERROR(H_E0, deg);
+      if (deg < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) MINTEMP_ERROR(H_E0, deg);
+    }
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(1)
-      if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) maxtemp_error(H_E1);
-      if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) mintemp_error(H_E1);
+    {
+      const auto deg = degHotend(1);
+      if (deg > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) MAXTEMP_ERROR(H_E1, deg);
+      if (deg < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) MINTEMP_ERROR(H_E1, deg);
+    }
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(2)
-      if (degHotend(2) > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.0)) maxtemp_error(H_E2);
-      if (degHotend(2) < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + .01)) mintemp_error(H_E2);
+    {
+      const auto deg = degHotend(2);
+      if (deg > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.0)) MAXTEMP_ERROR(H_E2, deg);
+      if (deg < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + .01)) MINTEMP_ERROR(H_E2, deg);
+    }
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
-      if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) maxtemp_error(H_REDUNDANT);
-      if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) mintemp_error(H_REDUNDANT);
+    {
+      const auto deg = degRedundant();
+      if (deg > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) MAXTEMP_ERROR(H_REDUNDANT, deg);
+      if (deg < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) MINTEMP_ERROR(H_REDUNDANT, deg);
+    }
     #endif
   #else
     #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
   #endif
 
   const millis_t ms = millis();
 
   // Handle Hotend Temp Errors, Heating Watch, etc.
   TERN_(HAS_HOTEND, manage_hotends(ms));
 
   #if HAS_TEMP_REDUNDANT
+  {
+    const auto deg = degRedundant();
     // Make sure measured temperatures are close together
-    if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
-      _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), F(STR_REDUNDANCY), GET_TEXT_F(MSG_ERR_REDUNDANT_TEMP));
+    if (ABS(degRedundantTarget() - deg) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
+      _TEMP_ERROR(HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), F(STR_REDUNDANCY), MSG_ERR_REDUNDANT_TEMP, deg);
+  }
   #endif
 
   // Manage extruder auto fans and/or read fan tachometers
   TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
 
   /**
    * Dynamically set the volumetric multiplier based
    * on the delayed Filament Width measurement.
    */
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_volumetric());
@@ -2609,64 +2650,64 @@ void Temperature::updateTemperaturesFromRawValues() {
       #if HOTENDS > 3
         #define _TEMPDIR(N) , TEMPDIR(N)
         REPEAT_S(3, HOTENDS, _TEMPDIR)
       #endif
     };
 
     HOTEND_LOOP() {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
-        maxtemp_error((heater_id_t)e);
+        MAXTEMP_ERROR(e, temp_hotend[e].celsius);
 
       /**
       // DEBUG PREHEATING TIME
       SERIAL_ECHOLNPGM("\nExtruder = ", e, " Preheat On/Off = ", is_preheating(e));
       const float test_is_preheating = (preheat_end_ms_hotend[HOTEND_INDEX] - millis()) * 0.001f;
       if (test_is_preheating < 31) SERIAL_ECHOLNPGM("Extruder = ", e, " Preheat remaining time = ", test_is_preheating, "s", "\n");
       //*/
 
       const bool heater_on = temp_hotend[e].target > 0;
       if (heater_on && !is_hotend_preheating(e) && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
-          mintemp_error((heater_id_t)e);
+          MINTEMP_ERROR(e, temp_hotend[e].celsius);
       }
       else {
         TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
       }
     }
 
   #endif // HAS_HOTEND
 
   #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
-    if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) maxtemp_error(H_BED);
-    if (temp_bed.target > 0 && !is_bed_preheating() && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) mintemp_error(H_BED);
+    if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) MAXTEMP_ERROR(H_BED, temp_bed.celsius);
+    if (temp_bed.target > 0 && !is_bed_preheating() && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) MINTEMP_ERROR(H_BED, temp_bed.celsius);
   #endif
 
   #if ALL(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
-    if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) maxtemp_error(H_CHAMBER);
-    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) mintemp_error(H_CHAMBER);
+    if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) MAXTEMP_ERROR(H_CHAMBER, temp_chamber.celsius);
+    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) MINTEMP_ERROR(H_CHAMBER, temp_chamber.celsius);
   #endif
 
   #if ALL(HAS_COOLER, THERMAL_PROTECTION_COOLER)
-    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) maxtemp_error(H_COOLER);
-    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) mintemp_error(H_COOLER);
+    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) MAXTEMP_ERROR(H_COOLER, temp_cooler.celsius);
+    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) MINTEMP_ERROR(H_COOLER, temp_cooler.celsius);
   #endif
 
   #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
-    if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) maxtemp_error(H_BOARD);
-    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) mintemp_error(H_BOARD);
+    if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) MAXTEMP_ERROR(H_BOARD, temp_board.celsius);
+    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) MINTEMP_ERROR(H_BOARD, temp_board.celsius);
   #endif
 
   #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
-    if (TP_CMP(SOC, temp_soc.getraw(), maxtemp_raw_SOC)) maxtemp_error(H_SOC);
+    if (TP_CMP(SOC, temp_soc.getraw(), maxtemp_raw_SOC)) MAXTEMP_ERROR(H_SOC, temp_soc.celsius);
   #endif
   #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to task()
  *
@@ -3171,26 +3212,26 @@ void Temperature::init() {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-        _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
+        _TEMP_ERROR(heater_id, FPSTR(str_t_thermal_runaway), MSG_THERMAL_RUNAWAY, current);
 
       #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
         case TRMalfunction:
           TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
-          _temp_error(heater_id, FPSTR(str_t_temp_malfunction), GET_TEXT_F(MSG_TEMP_MALFUNCTION));
+          _TEMP_ERROR(heater_id, FPSTR(str_t_temp_malfunction), MSG_TEMP_MALFUNCTION, current);
       #endif
     }
   }
 
   #pragma GCC diagnostic pop
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 

commit 45193b4a1d82023f1b763c0340e40ec5b6fcc51c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 19 21:12:32 2023 -0500

    üî• Always use ISR for BABYSTEPPING (#26035)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d7bf9c8b79..d7c764540b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -153,24 +153,20 @@
 
 #if ENABLED(MPCTEMP)
   #include <math.h>
   #include "probe.h"
 #endif
 
 #if ANY(MPCTEMP, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
-#if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
-  #include "../feature/babystep.h"
-#endif
-
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/e_parser.h"
@@ -4115,24 +4111,20 @@ void Temperature::isr() {
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1kHz Tasks
   //
 
-  #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
-    babystep.task();
-  #endif
-
   // Check fan tachometers
   TERN_(HAS_FANCHECK, fan_check.update_tachometers());
 
   // Poll endstops state, if required
   endstops.poll();
 
   // Periodically call the planner timer service routine
   planner.isr();
 }
 

commit 1a241e6e86512b570267d672e2f00a80df41b2e9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 1 16:50:42 2023 -0500

    üêõ Fix M105 (MString append TS) and EEPROM ver
    
    Followup to #24390

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e209d6f835..d7bf9c8b79 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -4178,21 +4178,21 @@ void Temperature::isr() {
         case H_SOC: k = 'S'; show_t = false; break;
       #endif
       #if HAS_TEMP_REDUNDANT
         case H_REDUNDANT: k = 'R'; break;
       #endif
     }
     #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
 
     SString<50> s(' ', k);
     if (TERN0(HAS_MULTI_HOTEND, e >= 0)) s += char('0' + e);
-    s += TS(':', p_float_t(c, SFP));
+    s += ':'; s += p_float_t(c, SFP);
     if (show_t) { s += F(" /"); s += p_float_t(t, SFP); }
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       s.append(F(" ("), TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR), ')');
     #endif
     s.echo();
     delay(2);
   }
 
   void Temperature::print_heater_states(const int8_t target_extruder

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    üé® Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c38d4968c9..e209d6f835 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -716,26 +716,26 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
-    TERN_(DWIN_PID_TUNE, DWIN_PidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
+    TERN_(PROUI_PID_TUNE, dwinPidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-      TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+      TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
@@ -813,21 +813,21 @@ volatile bool Temperature::raw_temps_ready = false;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+        TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
@@ -850,21 +850,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
-        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TUNING_TIMEOUT));
+        TERN_(PROUI_PID_TUNE, dwinPidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
@@ -903,39 +903,39 @@ volatile bool Temperature::raw_temps_ready = false;
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(AUTOTUNE_DONE));
+        TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
       TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-    TERN_(DWIN_PID_TUNE, DWIN_PidTuning(AUTOTUNE_DONE));
+    TERN_(PROUI_PID_TUNE, dwinPidTuning(AUTOTUNE_DONE));
 
     EXIT_M303:
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
@@ -1140,21 +1140,21 @@ volatile bool Temperature::raw_temps_ready = false;
         #endif
         else if (ELAPSED(curr_time_ms, test_end_ms)) break;
 
         last_temp = current_temp;
         next_test_ms += test_interval_ms;
       }
 
       // Ensure we don't drift too far from the window between the last sampled temp and the target temperature
       if (!WITHIN(current_temp, get_sample_3_temp() - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
-        TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_TEMP_ERROR));
+        TERN_(DWIN_LCD_PROUI, dwinMPCTuning(MPC_TEMP_ERROR));
         wait_for_heatup = false;
         return FAILED;
       }
     }
     wait_for_heatup = false;
 
     power_fan0 = total_energy_fan0 / MS_TO_SEC_PRECISE(test_duration);
     TERN_(HAS_FAN, power_fan255 = (total_energy_fan255 * 1000) / test_duration);
 
     #if ENABLED(DEBUG_MPC_AUTOTUNE)
@@ -1180,21 +1180,21 @@ volatile bool Temperature::raw_temps_ready = false;
       next_report_ms += report_interval_ms;
       print_heater_states(e);
       SERIAL_EOL();
     }
 
     hal.idletask();
     TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
 
     if (!wait_for_heatup) {
       SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
-      TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
+      TERN_(DWIN_LCD_PROUI, dwinMPCTuning(MPC_INTERRUPTED));
       return MeasurementState::CANCELLED;
     }
 
     return MeasurementState::SUCCESS;
   }
 
   void Temperature::MPC_autotune(const uint8_t e, MPCTuningType tuning_type=AUTO) {
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
 
     MPC_autotuner tuner(e);
@@ -1208,21 +1208,21 @@ volatile bool Temperature::raw_temps_ready = false;
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
     // Determine ambient temperature.
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
     #if ENABLED(DWIN_LCD_PROUI)
-      DWIN_MPCTuning(MPCTEMP_START);
+      dwinMPCTuning(MPCTEMP_START);
       LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT);
     #else
       LCD_MESSAGE(MSG_COOLING);
     #endif
 
     if (tuner.measure_ambient_temp() != MPC_autotuner::MeasurementState::SUCCESS) return;
     hotend.modeled_ambient_temp = tuner.get_ambient_temp();
 
     #if HAS_FAN
       set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
@@ -1298,21 +1298,21 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_ECHOLNPGM("block_responsiveness ", p_float_t(block_responsiveness, 4));
       #endif
 
       // Update analytic tuning values based on the above
       mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
       mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
 
     }
 
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
-    TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(AUTOTUNE_DONE));
+    TERN_(DWIN_LCD_PROUI, dwinMPCTuning(AUTOTUNE_DONE));
 
     SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
     SERIAL_ECHOLNPGM("MPC_SENSOR_RESPONSIVENESS ", p_float_t(mpc.sensor_responsiveness, 4));
     SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF ", p_float_t(mpc.ambient_xfer_coeff_fan0, 4));
     TERN_(HAS_FAN, SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF_FAN255 ", p_float_t(ambient_xfer_coeff_fan255, 4)));
   }
 
 #endif // MPC_AUTOTUNE
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {

commit 97e15812fa15cf3ee9f260089282eb5e69915c4e
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Jun 29 13:21:14 2023 -0400

    üî® Makefile + 256K Creality Maple + Heater IDs (#26018)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a5fdc4f1fb..c38d4968c9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2937,21 +2937,21 @@ void Temperature::init() {
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius)) - 1), \
                       tmax = _MIN(HEATER_##NR##_MAXTEMP, tmax_tmp); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (!TEMP_SENSOR_##N##_IS_DUMMY && HOTENDS > N && TEMP_SENSOR_##N##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (!TEMP_SENSOR_##N##_IS_DUMMY && HOTENDS > (N) && TEMP_SENSOR_##N##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif

commit 6474773555274527ac4a24162dfdd9ea4b2b59da
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jun 29 00:06:50 2023 +0200

    üêõ Fix AD4985 with 5V input, add AD595 3.3V warning (#26021)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7688d83c06..a5fdc4f1fb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2135,22 +2135,24 @@ void Temperature::task() {
         TERN_(HAS_DISPLAY, if (cutter.enabled()) ui.flow_fault());
         cutter.disable();
         cutter.cutter_mode = CUTTER_MODE_ERROR;   // Immediately kill stepper inline power output
       }
     #endif
   #endif
 
   UNUSED(ms);
 }
 
-#define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
-#define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
+// For a 5V input the AD595 returns a value scaled with 10mV per ¬∞C. (Minimum input voltage is 5V.)
+#define TEMP_AD595(RAW)  ((RAW) * (ADC_VREF_MV / 10) / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
+// For a 5V input the AD8495 returns a value scaled with 5mV per ¬∞C. (Minimum input voltage is 2.7V.)
+#define TEMP_AD8495(RAW) ((RAW) * (ADC_VREF_MV /  5) / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                                \
   uint8_t l = 0, r = LEN, m;                                              \
   for (;;) {                                                              \
     m = (l + r) >> 1;                                                     \
     if (!m) return celsius_t(pgm_read_word(&TBL[0].celsius));             \

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 11788c3cb1..7688d83c06 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -4172,36 +4172,31 @@ void Temperature::isr() {
       #if HAS_TEMP_BOARD
         case H_BOARD: k = 'M'; show_t = false; break;
       #endif
       #if HAS_TEMP_SOC
         case H_SOC: k = 'S'; show_t = false; break;
       #endif
       #if HAS_TEMP_REDUNDANT
         case H_REDUNDANT: k = 'R'; break;
       #endif
     }
-    SERIAL_CHAR(' ', k);
-    #if HAS_MULTI_HOTEND
-      if (e >= 0) SERIAL_CHAR('0' + e);
-    #endif
-    #ifdef SERIAL_FLOAT_PRECISION
-      #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
-    #else
-      #define SFP 2
-    #endif
-    SERIAL_ECHO(AS_CHAR(':'), p_float_t(c, SFP));
-    if (show_t) { SERIAL_ECHOPGM(" /", p_float_t(t, SFP)); }
+    #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
+
+    SString<50> s(' ', k);
+    if (TERN0(HAS_MULTI_HOTEND, e >= 0)) s += char('0' + e);
+    s += TS(':', p_float_t(c, SFP));
+    if (show_t) { s += F(" /"); s += p_float_t(t, SFP); }
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
-      SERIAL_ECHOPGM(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
-      SERIAL_CHAR(')');
+      s.append(F(" ("), TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR), ')');
     #endif
+    s.echo();
     delay(2);
   }
 
   void Temperature::print_heater_states(const int8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
     #endif
     #if HAS_HEATED_BED
@@ -4221,37 +4216,34 @@ void Temperature::isr() {
     #endif
     #if HAS_TEMP_SOC
       print_heater_state(H_SOC, degSoc(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawSocTemp()));
     #endif
     #if HAS_TEMP_REDUNDANT
       if (include_r) print_heater_state(H_REDUNDANT, degRedundant(), degRedundantTarget() OPTARG(SHOW_TEMP_ADC_VALUES, rawRedundantTemp()));
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
-    SERIAL_ECHOPGM(" @:", getHeaterPower((heater_id_t)target_extruder));
+    SString<100> s(F(" @:"), getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
-      SERIAL_ECHOPGM(" B@:", getHeaterPower(H_BED));
+      s.append(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
-      SERIAL_ECHOPGM(" C@:", getHeaterPower(H_CHAMBER));
+      s.append(" C@:", getHeaterPower(H_CHAMBER));
     #endif
     #if HAS_COOLER
-      SERIAL_ECHOPGM(" C@:", getHeaterPower(H_COOLER));
+      s.append(" C@:", getHeaterPower(H_COOLER));
     #endif
     #if HAS_MULTI_HOTEND
-      HOTEND_LOOP() {
-        SERIAL_ECHOPGM(" @", e);
-        SERIAL_CHAR(':');
-        SERIAL_ECHO(getHeaterPower((heater_id_t)e));
-      }
+      HOTEND_LOOP() s.append(F(" @"), e, ':', getHeaterPower((heater_id_t)e));
     #endif
+    s.echo();
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
     void Temperature::AutoReportTemp::report() {
       print_heater_states(active_extruder OPTARG(HAS_TEMP_REDUNDANT, ENABLED(AUTO_REPORT_REDUNDANT)));
       SERIAL_EOL();
     }
   #endif
 
@@ -4324,25 +4316,26 @@ void Temperature::isr() {
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { // Print temp & remaining time every 1s while waiting
           next_temp_ms = now + 1000UL;
           print_heater_states(target_extruder);
           #if TEMP_RESIDENCY_TIME > 0
-            SERIAL_ECHOPGM(" W:");
+            SString<20> s(F(" W:"));
             if (residency_start_ms)
-              SERIAL_ECHO(long((SEC_TO_MS(TEMP_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
+              s += long((SEC_TO_MS(TEMP_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL);
             else
-              SERIAL_CHAR('?');
+              s += '?';
+            s.echo();
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const celsius_float_t temp = degHotend(target_extruder);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
@@ -4461,25 +4454,26 @@ void Temperature::isr() {
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_BED_RESIDENCY_TIME > 0
-            SERIAL_ECHOPGM(" W:");
+            SString<20> s(F(" W:"));
             if (residency_start_ms)
-              SERIAL_ECHO(long((SEC_TO_MS(TEMP_BED_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
+              s += long((SEC_TO_MS(TEMP_BED_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL);
             else
-              SERIAL_CHAR('?');
+              s += '?';
+            s.echo();
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const celsius_float_t temp = degBed();
 
         #if ENABLED(PRINTER_EVENT_LEDS)
@@ -4555,21 +4549,21 @@ void Temperature::isr() {
     #endif
     #ifndef MIN_DELTA_SLOPE_TIME_PROBE
       #define MIN_DELTA_SLOPE_TIME_PROBE 600
     #endif
 
     bool Temperature::wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling/*=true*/) {
 
       const bool wants_to_cool = isProbeAboveTemp(target_temp),
                  will_wait = !(wants_to_cool && no_wait_for_cooling);
       if (will_wait)
-        SERIAL_ECHOLNPGM("Waiting for probe to ", wants_to_cool ? F("cool down") : F("heat up"), " to ", target_temp, " degrees.");
+        SString<60>(F("Waiting for probe to "), wants_to_cool ? F("cool down") : F("heat up"), F(" to "), target_temp, F(" degrees.")).echoln();
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       float old_temp = 9999;
       millis_t next_temp_ms = 0, next_delta_check_ms = 0;
       wait_for_heatup = true;
       while (will_wait && wait_for_heatup) {
 
@@ -4593,23 +4587,22 @@ void Temperature::isr() {
           if (delta_temp < float(MIN_DELTA_SLOPE_DEG_PROBE)) {
             SERIAL_ECHOLNPGM("Timed out waiting for probe temperature.");
             break;
           }
           next_delta_check_ms = now + SEC_TO_MS(MIN_DELTA_SLOPE_TIME_PROBE);
           old_temp = temp;
         }
 
         // Loop until the temperature is very close target
         if (!(wants_to_cool ? isProbeAboveTemp(target_temp) : isProbeBelowTemp(target_temp))) {
-            SERIAL_ECHOLN(wants_to_cool ? PSTR("Cooldown") : PSTR("Heatup"));
-            SERIAL_ECHOLNPGM(" complete, target probe temperature reached.");
-            break;
+          SString<60>(wants_to_cool ? F("Cooldown") : F("Heatup"), F(" complete, target probe temperature reached.")).echoln();
+          break;
         }
       }
 
       // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }
       else if (will_wait)
@@ -4656,25 +4649,26 @@ void Temperature::isr() {
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { // Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_CHAMBER_RESIDENCY_TIME > 0
-            SERIAL_ECHOPGM(" W:");
+            SString<20> s(F(" W:"));
             if (residency_start_ms)
-              SERIAL_ECHO(long((SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
+              s += long((SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL);
             else
-              SERIAL_CHAR('?');
+              s += '?';
+            s.echo();
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degChamber();
 
         #if TEMP_CHAMBER_RESIDENCY_TIME > 0
@@ -4755,25 +4749,26 @@ void Temperature::isr() {
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { // Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_COOLER_RESIDENCY_TIME > 0
-            SERIAL_ECHOPGM(" W:");
+            SString<20> s(F(" W:"));
             if (residency_start_ms)
-              SERIAL_ECHO(long((SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
+              s += long((SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL);
             else
-              SERIAL_CHAR('?');
+              s += '?';
+            s.echo();
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const celsius_float_t current_temp = degCooler();
 
         #if TEMP_COOLER_RESIDENCY_TIME > 0

commit 858916d628526b5d56c34c5c9663e3535bfc7788
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Jun 23 04:57:22 2023 -0500

    üö∏ Update DWIN ProUI (#26003)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a1bebca4a0..11788c3cb1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -903,39 +903,39 @@ volatile bool Temperature::raw_temps_ready = false;
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
+        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(AUTOTUNE_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
       TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-    TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
+    TERN_(DWIN_PID_TUNE, DWIN_PidTuning(AUTOTUNE_DONE));
 
     EXIT_M303:
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
@@ -1298,21 +1298,21 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_ECHOLNPGM("block_responsiveness ", p_float_t(block_responsiveness, 4));
       #endif
 
       // Update analytic tuning values based on the above
       mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
       mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
 
     }
 
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
-    TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_DONE));
+    TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(AUTOTUNE_DONE));
 
     SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
     SERIAL_ECHOLNPGM("MPC_SENSOR_RESPONSIVENESS ", p_float_t(mpc.sensor_responsiveness, 4));
     SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF ", p_float_t(mpc.ambient_xfer_coeff_fan0, 4));
     TERN_(HAS_FAN, SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF_FAN255 ", p_float_t(ambient_xfer_coeff_fan255, 4)));
   }
 
 #endif // MPC_AUTOTUNE
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
@@ -4384,21 +4384,21 @@ void Temperature::isr() {
             wait_for_heatup = false;
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
-        #if HAS_DWIN_E3V2_BASIC
+        #if ENABLED(DWIN_CREALITY_LCD)
           hmiFlag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // Print timer
           dwin_heat_time = elapsed.value;
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
         return true;
       }
 

commit 41a5fbb16ad985220f1cee1b823950c3bb771186
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:12:01 2023 -0500

    üé® More lowercase
    
    Followup to #25939

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1f0e1a9755..a1bebca4a0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1224,21 +1224,21 @@ volatile bool Temperature::raw_temps_ready = false;
     if (tuner.measure_ambient_temp() != MPC_autotuner::MeasurementState::SUCCESS) return;
     hotend.modeled_ambient_temp = tuner.get_ambient_temp();
 
     #if HAS_FAN
       set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     // Heat to 200 degrees
     SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
-    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
+    LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200);
 
     if (tuner.measure_heatup() != MPC_autotuner::MeasurementState::SUCCESS) return;
 
     // Calculate physical constants from three equally-spaced samples
     const float t1 = tuner.get_sample_1_temp(),
                 t2 = tuner.get_sample_2_temp(),
                 t3 = tuner.get_sample_3_temp();
     float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
           block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / tuner.get_sample_interval();
 
@@ -1524,28 +1524,28 @@ void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_m
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
 void Temperature::maxtemp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
-    DWIN_Popup_Temperature(1);
+    dwinPopupTemperature(1);
   #endif
   _temp_error(heater_id, F(STR_T_MAXTEMP), GET_TEXT_F(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::mintemp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
-    DWIN_Popup_Temperature(0);
+    dwinPopupTemperature(0);
   #endif
   _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
 
 #if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
 
 #if HAS_PID_HEATING
 
@@ -1751,21 +1751,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_hotend_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
-            TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
+            TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
             _temp_error((heater_id_t)e, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
           }
         }
       #endif
 
     } // HOTEND_LOOP
   }
 
 #endif // HAS_HOTEND
 
@@ -1776,21 +1776,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP) maxtemp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         if (watch_bed.check(degBed()))          // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
-          TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
+          TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
           _temp_error(H_BED, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
         }
       }
     #endif // WATCH_BED
 
     #if ALL(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
@@ -3172,26 +3172,26 @@ void Temperature::init() {
         if (rdiff <= hysteresis_degc) {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
-        TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
+        TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
         _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
 
       #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
         case TRMalfunction:
-          TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
+          TERN_(HAS_DWIN_E3V2_BASIC, dwinPopupTemperature(0));
           _temp_error(heater_id, FPSTR(str_t_temp_malfunction), GET_TEXT_F(MSG_TEMP_MALFUNCTION));
       #endif
     }
   }
 
   #pragma GCC diagnostic pop
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
@@ -4385,21 +4385,21 @@ void Temperature::isr() {
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         #if HAS_DWIN_E3V2_BASIC
-          HMI_flag.heat_flag = 0;
+          hmiFlag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // Print timer
           dwin_heat_time = elapsed.value;
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
         return true;
       }
 
       return false;

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d671e7ce89..1f0e1a9755 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -849,21 +849,21 @@ volatile bool Temperature::raw_temps_ready = false;
               _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
-        TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
+        TERN_(DWIN_CREALITY_LCD, dwinPopupTemperature(0));
         TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
@@ -912,21 +912,21 @@ volatile bool Temperature::raw_temps_ready = false;
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
-      TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
+      TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
 
@@ -1176,21 +1176,21 @@ volatile bool Temperature::raw_temps_ready = false;
       TERN_(HAS_FAN_LOGIC, manage_extruder_fans(curr_time_ms));
     }
 
     if (ELAPSED(curr_time_ms, next_report_ms)) {
       next_report_ms += report_interval_ms;
       print_heater_states(e);
       SERIAL_EOL();
     }
 
     hal.idletask();
-    TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
+    TERN(DWIN_CREALITY_LCD, dwinUpdate(), ui.update());
 
     if (!wait_for_heatup) {
       SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
       TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
       return MeasurementState::CANCELLED;
     }
 
     return MeasurementState::SUCCESS;
   }
 

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4d366198c1..d671e7ce89 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -863,23 +863,23 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if ANY(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
-          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
-          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
-          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
+          say_default_(); SERIAL_ECHO(estring, F("Kp "), tune_pid.p);
+          say_default_(); SERIAL_ECHO(estring, F("Ki "), tune_pid.i);
+          say_default_(); SERIAL_ECHO(estring, F("Kd "), tune_pid.d);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
           say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
           say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #endif
 
         auto _set_hotend_pid = [](const uint8_t tool, const raw_pid_t &in_pid) {
           #if ENABLED(PIDTEMP)
             #if ENABLED(PID_PARAMS_PER_HOTEND)
               thermalManager.temp_hotend[tool].pid.set(in_pid);
@@ -1237,21 +1237,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
     // Calculate physical constants from three equally-spaced samples
     const float t1 = tuner.get_sample_1_temp(),
                 t2 = tuner.get_sample_2_temp(),
                 t3 = tuner.get_sample_3_temp();
     float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
           block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / tuner.get_sample_interval();
 
     #if ENABLED(DEBUG_MPC_AUTOTUNE)
       SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
-      SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
+      SERIAL_ECHOLNPGM("block_responsiveness ", p_float_t(block_responsiveness, 4));
     #endif
 
     // Make initial guess at transfer coefficients
     mpc.ambient_xfer_coeff_fan0 = mpc.heater_power * (MPC_MAX) / 255 / (asymp_temp - tuner.get_ambient_temp());
     TERN_(MPC_INCLUDE_FAN, mpc.fan255_adjustment = 0.0f);
 
     if (tuning_type == AUTO || tuning_type == FORCE_ASYMPTOTIC) {
       // Analytic tuning
       mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
       mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
@@ -1286,38 +1286,38 @@ volatile bool Temperature::raw_temps_ready = false;
       const float ambient_xfer_coeff_fan255 = tuner.get_power_fan255() / (hotend.target - tuner.get_ambient_temp());
       mpc.applyFanAdjustment(ambient_xfer_coeff_fan255);
     #endif
 
     if (tuning_type == AUTO || tuning_type == FORCE_ASYMPTOTIC) {
       // Calculate a new and better asymptotic temperature and re-evaluate the other constants
       asymp_temp = tuner.get_ambient_temp() + mpc.heater_power * (MPC_MAX) / 255 / mpc.ambient_xfer_coeff_fan0;
       block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / tuner.get_sample_interval();
 
       #if ENABLED(DEBUG_MPC_AUTOTUNE)
-        SERIAL_ECHOLN("Refining estimates for:");
+        SERIAL_ECHOLNPGM("Refining estimates for:");
         SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
-        SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
+        SERIAL_ECHOLNPGM("block_responsiveness ", p_float_t(block_responsiveness, 4));
       #endif
 
       // Update analytic tuning values based on the above
       mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
       mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
 
     }
 
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
     TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_DONE));
 
     SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
-    SERIAL_ECHOLNPAIR_F("MPC_SENSOR_RESPONSIVENESS ", mpc.sensor_responsiveness, 4);
-    SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF ", mpc.ambient_xfer_coeff_fan0, 4);
-    TERN_(HAS_FAN, SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF_FAN255 ", ambient_xfer_coeff_fan255, 4));
+    SERIAL_ECHOLNPGM("MPC_SENSOR_RESPONSIVENESS ", p_float_t(mpc.sensor_responsiveness, 4));
+    SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF ", p_float_t(mpc.ambient_xfer_coeff_fan0, 4));
+    TERN_(HAS_FAN, SERIAL_ECHOLNPGM("MPC_AMBIENT_XFER_COEFF_FAN255 ", p_float_t(ambient_xfer_coeff_fan255, 4)));
   }
 
 #endif // MPC_AUTOTUNE
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
@@ -1470,21 +1470,21 @@ inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   #endif
   kill(lcd_msg, HEATER_FSTR(heater_id));
 }
 
 void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_msg, FSTR_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
-    SERIAL_ECHOF(serial_msg);
+    SERIAL_ECHO(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
 
     heater_id_t real_heater_id = heater_id;
 
     #if HAS_TEMP_REDUNDANT
       if (heater_id == H_REDUNDANT) {
         SERIAL_ECHOPGM(STR_REDUNDANT); // print redundant and cascade to print target, too.
         real_heater_id = (heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET);
       }
     #endif
@@ -1576,21 +1576,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
         #endif
 
         return constrain(out, tempinfo.pid.low(), tempinfo.pid.high());
 
       #endif // !PID_OPENLOOP
     }
 
     FORCE_INLINE void debug(const_celsius_float_t c, const_float_t pid_out, FSTR_P const name=nullptr, const int8_t index=-1) {
       if (TERN0(HAS_PID_DEBUG, thermalManager.pid_debug_flag)) {
         SERIAL_ECHO_START();
-        if (name) SERIAL_ECHOF(name);
+        if (name) SERIAL_ECHO(name);
         if (index >= 0) SERIAL_ECHO(index);
         SERIAL_ECHOLNPGM(
           STR_PID_DEBUG_INPUT, c,
           STR_PID_DEBUG_OUTPUT, pid_out
           #if DISABLED(PID_OPENLOOP)
             , " pTerm ", tempinfo.pid.pTerm(), " iTerm ", tempinfo.pid.iTerm(), " dTerm ", tempinfo.pid.dTerm()
             , " cTerm ", tempinfo.pid.cTerm(), " fTerm ", tempinfo.pid.fTerm()
           #endif
         );
       }
@@ -2218,43 +2218,42 @@ void Temperature::task() {
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::M305_report(const uint8_t t_index, const bool forReplay/*=true*/) {
     gcode.report_heading_etc(forReplay, F(STR_USER_THERMISTORS));
     SERIAL_ECHOPGM("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
-    SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
-    SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
-    SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
-    SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
-    SERIAL_ECHOPGM(" ; ");
-    SERIAL_ECHOF(
+    SERIAL_ECHO(
+      F(" R"), p_float_t(t.series_res, 1), FPSTR(SP_T_STR), p_float_t(t.res_25, 1),
+      FPSTR(SP_B_STR), p_float_t(t.beta, 1), FPSTR(SP_C_STR), p_float_t(t.sh_c_coeff, 9),
+      F(" ; ")
+    );
+    SERIAL_ECHOLN(
       TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? F("HOTEND 0") :)
       TERN_(TEMP_SENSOR_1_IS_CUSTOM, t_index == CTI_HOTEND_1 ? F("HOTEND 1") :)
       TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? F("HOTEND 2") :)
       TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? F("HOTEND 3") :)
       TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? F("HOTEND 4") :)
       TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? F("HOTEND 5") :)
       TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? F("HOTEND 6") :)
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? F("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? F("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? F("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? F("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? F("PROBE") :)
       TERN_(TEMP_SENSOR_BOARD_IS_CUSTOM, t_index == CTI_BOARD ? F("BOARD") :)
       TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? F("REDUNDANT") :)
-      nullptr
+      FSTR_P(nullptr)
     );
-    SERIAL_EOL();
   }
 
   celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const raw_adc_t raw) {
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
       t.pre_calc     = false;
       t.res_25_recip = 1.0f / t.res_25;
@@ -4182,22 +4181,22 @@ void Temperature::isr() {
     }
     SERIAL_CHAR(' ', k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
       #define SFP 2
     #endif
-    SERIAL_CHAR(':'); SERIAL_PRINT(c, SFP);
-    if (show_t) { SERIAL_ECHOPGM(" /"); SERIAL_PRINT(t, SFP); }
+    SERIAL_ECHO(AS_CHAR(':'), p_float_t(c, SFP));
+    if (show_t) { SERIAL_ECHOPGM(" /", p_float_t(t, SFP)); }
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       SERIAL_ECHOPGM(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const int8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)

commit 3706c16729ba095a9845128022408a0c07cde221
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri Jun 9 19:59:23 2023 +1200

    üêõ Fix dummy thermistors 998-999 (#25956)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 56f5f8b983..4d366198c1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2936,21 +2936,21 @@ void Temperature::init() {
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius)) - 1), \
                       tmax = _MIN(HEATER_##NR##_MAXTEMP, tmax_tmp); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##N##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (!TEMP_SENSOR_##N##_IS_DUMMY && HOTENDS > N && TEMP_SENSOR_##N##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif

commit 34e23bcf950fa89737289c76953af7b24d5c22c4
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jun 8 20:47:35 2023 -0500

    üêõ Fix _MINMAX_TEST typo (#25954)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7383f6a1c3..56f5f8b983 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2936,21 +2936,21 @@ void Temperature::init() {
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius)) - 1), \
                       tmax = _MIN(HEATER_##NR##_MAXTEMP, tmax_tmp); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##NR##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##N##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 315cf88830..7383f6a1c3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1393,21 +1393,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                   \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)           \
         hal.set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                                \
         WRITE(P##_AUTO_FAN_PIN, D);                       \
     }while(0)
 
     uint8_t fanDone = 0;
-    LOOP_L_N(f, COUNT(fanBit)) {
+    for (uint8_t f = 0; f < COUNT(fanBit); ++f) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
         #if ENABLED(AUTO_POWER_CHAMBER_FAN)
           case CHAMBER_FAN_INDEX:
             chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
             break;
         #endif
         #if ENABLED(AUTO_POWER_COOLER_FAN)

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f785a683eb..315cf88830 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -30,21 +30,21 @@
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 #include "../lcd/marlinui.h"
 #include "../gcode/gcode.h"
 
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
 #include "printcounter.h"
 
-#if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
+#if ANY(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "../feature/controllerfan.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
@@ -149,21 +149,21 @@
   #ifndef SW_SPI_MOSI_PIN
     #define SW_SPI_MOSI_PIN   SD_MOSI_PIN
   #endif
 #endif
 
 #if ENABLED(MPCTEMP)
   #include <math.h>
   #include "probe.h"
 #endif
 
-#if EITHER(MPCTEMP, PID_EXTRUSION_SCALING)
+#if ANY(MPCTEMP, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
@@ -366,33 +366,33 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
       CHECK_PREHEAT(10)
     #endif
   #endif // HAS_PREHEAT
 
 #endif // HAS_HOTEND
 
 #if HAS_TEMP_REDUNDANT
   redundant_info_t Temperature::temp_redundant;
 #endif
 
-#if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
+#if ANY(AUTO_POWER_E_FANS, HAS_FANCHECK)
   uint8_t Temperature::autofan_speed[HOTENDS] = ARRAY_N_1(HOTENDS, FAN_OFF_PWM);
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed = FAN_OFF_PWM;
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed = FAN_OFF_PWM;
 #endif
 
-#if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
+#if ALL(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
   uint8_t Temperature::soft_pwm_controller_speed = FAN_OFF_PWM;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef BOARD_OPENDRAIN_MOSFETS
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
@@ -432,21 +432,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
           set_fan_speed(fan, extra_fan_speed[fan].speed);
           break;
         default:
           extra_fan_speed[fan].speed = _MIN(command_or_speed, 255U);
           break;
       }
     }
 
   #endif
 
-  #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
+  #if ANY(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
     uint8_t Temperature::saved_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, FAN_OFF_PWM);
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 128);
   #endif
 
   /**
    * Set the print fan speed for a target extruder
@@ -482,21 +482,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
     /**
      * Report print fan speed for a target extruder
      */
     void Temperature::report_fan_speed(const uint8_t fan) {
       if (fan >= FAN_COUNT) return;
       PORT_REDIRECT(SerialMask::All);
       SERIAL_ECHOLNPGM("M106 P", fan, " S", fan_speed[fan]);
     }
   #endif
 
-  #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
+  #if ANY(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else
           FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }
     }
@@ -566,21 +566,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
     raw_adc_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
               Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
   #endif
 #endif
 
 #if HAS_TEMP_SOC
   soc_info_t Temperature::temp_soc; // = { 0 }
   raw_adc_t Temperature::maxtemp_raw_SOC = TEMP_SENSOR_SOC_RAW_HI_TEMP;
 #endif
 
-#if BOTH(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
+#if ALL(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
   bool Temperature::allow_cold_extrude_override = false;
 #else
   constexpr bool Temperature::allow_cold_extrude_override;
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #else
   constexpr bool Temperature::allow_cold_extrude;
@@ -691,29 +691,29 @@ volatile bool Temperature::raw_temps_ready = false;
     #if ENABLED(PIDTEMPBED)
       #define B_TERN(T,A,B) ((T) ? (A) : (B))
     #else
       #define B_TERN(T,A,B) (B)
     #endif
     #define GHV(C,B,H) C_TERN(ischamber, C, B_TERN(isbed, B, H))
     #define SHV(V) C_TERN(ischamber, temp_chamber.soft_pwm_amount = V, B_TERN(isbed, temp_bed.soft_pwm_amount = V, temp_hotend[heater_id].soft_pwm_amount = V))
     #define ONHEATINGSTART() C_TERN(ischamber, printerEventLEDs.onChamberHeatingStart(), B_TERN(isbed, printerEventLEDs.onBedHeatingStart(), printerEventLEDs.onHotendHeatingStart()))
     #define ONHEATING(S,C,T) C_TERN(ischamber, printerEventLEDs.onChamberHeating(S,C,T), B_TERN(isbed, printerEventLEDs.onBedHeating(S,C,T), printerEventLEDs.onHotendHeating(S,C,T)))
 
-    #define WATCH_PID DISABLED(NO_WATCH_PID_TUNING) && (BOTH(WATCH_CHAMBER, PIDTEMPCHAMBER) || BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP))
+    #define WATCH_PID DISABLED(NO_WATCH_PID_TUNING) && (ALL(WATCH_CHAMBER, PIDTEMPCHAMBER) || ALL(WATCH_BED, PIDTEMPBED) || ALL(WATCH_HOTENDS, PIDTEMP))
 
     #if WATCH_PID
-      #if BOTH(THERMAL_PROTECTION_CHAMBER, PIDTEMPCHAMBER)
+      #if ALL(THERMAL_PROTECTION_CHAMBER, PIDTEMPCHAMBER)
         #define C_GTV(T,A,B) ((T) ? (A) : (B))
       #else
         #define C_GTV(T,A,B) (B)
       #endif
-      #if BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
+      #if ALL(THERMAL_PROTECTION_BED, PIDTEMPBED)
         #define B_GTV(T,A,B) ((T) ? (A) : (B))
       #else
         #define B_GTV(T,A,B) (B)
       #endif
       #define GTV(C,B,H) C_GTV(ischamber, C, B_GTV(isbed, B, H))
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
@@ -828,21 +828,21 @@ volatile bool Temperature::raw_temps_ready = false;
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_PID
-          if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
+          if (ALL(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);   // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _temp_error(heater_id, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
@@ -861,21 +861,21 @@ volatile bool Temperature::raw_temps_ready = false;
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
-        #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
+        #if ANY(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
           say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
           say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #endif
 
@@ -932,21 +932,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
     EXIT_M303:
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
-  #if EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
+  #if ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
     #define SINGLEFAN 1
   #endif
 
   #define DEBUG_MPC_AUTOTUNE 1
 
   millis_t Temperature::MPC_autotuner::curr_time_ms, Temperature::MPC_autotuner::next_report_ms;
 
   celsius_float_t Temperature::MPC_autotuner::temp_samples[16];
   uint8_t Temperature::MPC_autotuner::sample_count;
   uint16_t Temperature::MPC_autotuner::sample_distance;
@@ -1409,27 +1409,27 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
           case CHAMBER_FAN_INDEX:
             chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
             break;
         #endif
         #if ENABLED(AUTO_POWER_COOLER_FAN)
           case COOLER_FAN_INDEX:
             coolerfan_speed = fan_on ? COOLER_AUTO_FAN_SPEED : 0;
             break;
         #endif
         default:
-          #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
+          #if ANY(AUTO_POWER_E_FANS, HAS_FANCHECK)
             autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
           #endif
           break;
       }
 
-      #if BOTH(HAS_FANCHECK, HAS_PWMFANCHECK)
+      #if ALL(HAS_FANCHECK, HAS_PWMFANCHECK)
         #define _AUTOFAN_SPEED() fan_check.is_measuring() ? 255 : EXTRUDER_AUTO_FAN_SPEED
       #else
         #define _AUTOFAN_SPEED() EXTRUDER_AUTO_FAN_SPEED
       #endif
       #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break;
       #define _AUTOFAN_NOT(N)
       #define AUTOFAN_CASE(N) TERN(HAS_AUTO_FAN_##N, _AUTOFAN_CASE, _AUTOFAN_NOT)(N)
 
       switch (f) {
         REPEAT(HOTENDS, AUTOFAN_CASE)
@@ -1782,21 +1782,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         if (watch_bed.check(degBed()))          // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
           TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
           _temp_error(H_BED, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
         }
       }
     #endif // WATCH_BED
 
-    #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+    #if ALL(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
       static bool last_pause_state;
     #endif
 
     do {
 
       #if DISABLED(PIDTEMPBED)
@@ -1870,25 +1870,25 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
         if (watch_chamber.check(degChamber()))  // Increased enough? Error below.
           start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
           _temp_error(H_CHAMBER, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
       }
     #endif
 
-    #if EITHER(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
+    #if ANY(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
       static bool flag_chamber_excess_heat; // = false;
     #endif
 
-    #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
+    #if ANY(CHAMBER_FAN, CHAMBER_VENT)
       static bool flag_chamber_off; // = false
 
       if (temp_chamber.target > CHAMBER_MINTEMP) {
         flag_chamber_off = false;
 
         #if ENABLED(CHAMBER_FAN)
           int16_t fan_chamber_pwm;
           #if CHAMBER_FAN_MODE == 0
             fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
@@ -2639,36 +2639,36 @@ void Temperature::updateTemperaturesFromRawValues() {
     }
 
   #endif // HAS_HOTEND
 
   #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
     if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) maxtemp_error(H_BED);
     if (temp_bed.target > 0 && !is_bed_preheating() && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) mintemp_error(H_BED);
   #endif
 
-  #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
+  #if ALL(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
     if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) maxtemp_error(H_CHAMBER);
     if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) mintemp_error(H_CHAMBER);
   #endif
 
-  #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
+  #if ALL(HAS_COOLER, THERMAL_PROTECTION_COOLER)
     if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) maxtemp_error(H_COOLER);
     if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) mintemp_error(H_COOLER);
   #endif
 
-  #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
+  #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
     if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) maxtemp_error(H_BOARD);
     if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) mintemp_error(H_BOARD);
   #endif
 
-  #if BOTH(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
+  #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
     if (TP_CMP(SOC, temp_soc.getraw(), maxtemp_raw_SOC)) maxtemp_error(H_SOC);
   #endif
   #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to task()
@@ -3004,26 +3004,26 @@ void Temperature::init() {
   #if HAS_HEATED_CHAMBER
     while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
     while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
     while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
 
-  #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
+  #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
     while (analog_to_celsius_board(mintemp_raw_BOARD) < BOARD_MINTEMP) mintemp_raw_BOARD += TEMPDIR(BOARD) * (OVERSAMPLENR);
     while (analog_to_celsius_board(maxtemp_raw_BOARD) > BOARD_MAXTEMP) maxtemp_raw_BOARD -= TEMPDIR(BOARD) * (OVERSAMPLENR);
   #endif
 
-  #if BOTH(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
+  #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
     while (analog_to_celsius_soc(maxtemp_raw_SOC) > SOC_MAXTEMP) maxtemp_raw_SOC -= OVERSAMPLENR;
   #endif
 
   #if HAS_TEMP_REDUNDANT
     temp_redundant.target = &(
       #if REDUNDANT_TEMP_MATCH(TARGET, COOLER) && HAS_TEMP_COOLER
         temp_cooler
       #elif REDUNDANT_TEMP_MATCH(TARGET, PROBE) && HAS_TEMP_PROBE
         temp_probe
       #elif REDUNDANT_TEMP_MATCH(TARGET, BOARD) && HAS_TEMP_BOARD
@@ -3265,21 +3265,21 @@ void Temperature::disable_all_heaters() {
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
-#if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
+#if ANY(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
 
   void Temperature::singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool) {
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       singlenozzle_fan_speed[old_tool] = fan_speed[0];
       fan_speed[0] = singlenozzle_fan_speed[new_tool];
     #endif
     #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
       singlenozzle_temp[old_tool] = temp_hotend[0].target;
       if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
         setTargetHotend(singlenozzle_temp[new_tool], 0);
@@ -3634,21 +3634,21 @@ void Temperature::isr() {
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
   #if HAS_COOLER
     static SoftPWM soft_pwm_cooler;
   #endif
 
-  #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
+  #if ALL(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
     static SoftPWM soft_pwm_controller;
   #endif
 
   #define WRITE_FAN(n, v) WRITE(FAN##n##_PIN, (v) ^ FAN_INVERTING)
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
     #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, HAS_COOLER, FAN_SOFT_PWM)
       constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \

commit 6e5f41fe6b996e074b042c6ac521475b8e8aab91
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 19:48:30 2023 -0500

    üßë‚Äçüíª Serial ternary args, etc.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 685f5dab2f..f785a683eb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3138,21 +3138,21 @@ void Temperature::init() {
             else if (rdiff <= hysteresis_degc * 0.5f)
               scale = 64;
             else if (rdiff <= hysteresis_degc * 0.8f)
               scale = 32;
             else
               scale = 0;
 
             if (TERN0(REPORT_ADAPTIVE_FAN_SLOWING, DEBUGGING(INFO))) {
               const uint8_t fss7 = fan_speed_scaler[fan_index] & 0x80;
               if (fss7 ^ (scale & 0x80))
-                serial_ternary(fss7, F("Adaptive Fan Slowing "), nullptr, F("de"), F("activated.\n"));
+                serial_ternary(F("Adaptive Fan Slowing "), fss7, nullptr, F("de"), F("activated.\n"));
             }
 
             fan_speed_scaler[fan_index] = scale;
           }
         #endif // ADAPTIVE_FAN_SLOWING
 
         const millis_t now = millis();
 
         #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
           if (PENDING(now, variance_timer)) {

commit f97a813a2ac315cd925c3651bd7c32d609e6d70f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 13 18:09:48 2023 -0500

    ‚ú® NUM_REDUNDANT_FANS too

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d84b475765..685f5dab2f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -464,21 +464,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
     TERN_(SINGLENOZZLE, if (fan < EXTRUDERS) fan = 0); // Always fan 0 for SINGLENOZZLE E fan
 
     if (fan >= FAN_COUNT) return;
 
     fan_speed[fan] = speed;
 
     #if NUM_REDUNDANT_FANS
       if (fan == 0) {
         for (uint8_t f = REDUNDANT_PART_COOLING_FAN; f < REDUNDANT_PART_COOLING_FAN + NUM_REDUNDANT_FANS; ++f)
-          thermalManager.set_fan_speed(f, 0);
+          thermalManager.set_fan_speed(f, speed);
       }
     #endif
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(fan));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */

commit 5859ff0280b51b3130e1d13740bfae79eff4d23e
Author: Vert <45634861+Vertabreak@users.noreply.github.com>
Date:   Sat May 13 17:51:12 2023 -0400

    ‚ú® NUM_REDUNDANT_FANS (#25808)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fa960443ca..d84b475765 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -460,22 +460,26 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
         if (fan < EXTRUDERS) singlenozzle_fan_speed[fan] = speed;
         return;
       }
     #endif
 
     TERN_(SINGLENOZZLE, if (fan < EXTRUDERS) fan = 0); // Always fan 0 for SINGLENOZZLE E fan
 
     if (fan >= FAN_COUNT) return;
 
     fan_speed[fan] = speed;
-    #if REDUNDANT_PART_COOLING_FAN
-      if (fan == 0) fan_speed[REDUNDANT_PART_COOLING_FAN] = speed;
+
+    #if NUM_REDUNDANT_FANS
+      if (fan == 0) {
+        for (uint8_t f = REDUNDANT_PART_COOLING_FAN; f < REDUNDANT_PART_COOLING_FAN + NUM_REDUNDANT_FANS; ++f)
+          thermalManager.set_fan_speed(f, 0);
+      }
     #endif
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(fan));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */
     void Temperature::report_fan_speed(const uint8_t fan) {

commit e89e67fde0d3d745d7d468e5972456f7484f9027
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat May 13 23:36:23 2023 +0200

    üßë‚Äçüíª Assume Auto Fans < HOTENDS (#25815)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 09c5ef0cdf..fa960443ca 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1421,21 +1421,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
       #if BOTH(HAS_FANCHECK, HAS_PWMFANCHECK)
         #define _AUTOFAN_SPEED() fan_check.is_measuring() ? 255 : EXTRUDER_AUTO_FAN_SPEED
       #else
         #define _AUTOFAN_SPEED() EXTRUDER_AUTO_FAN_SPEED
       #endif
       #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break;
       #define _AUTOFAN_NOT(N)
       #define AUTOFAN_CASE(N) TERN(HAS_AUTO_FAN_##N, _AUTOFAN_CASE, _AUTOFAN_NOT)(N)
 
       switch (f) {
-        REPEAT(8, AUTOFAN_CASE)
+        REPEAT(HOTENDS, AUTOFAN_CASE)
         #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
           case CHAMBER_FAN_INDEX: _UPDATE_AUTO_FAN(CHAMBER, fan_on, CHAMBER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_COOLER_FAN && !AUTO_COOLER_IS_E
           case COOLER_FAN_INDEX: _UPDATE_AUTO_FAN(COOLER, fan_on, COOLER_AUTO_FAN_SPEED); break;
         #endif
       }
       SBI(fanDone, realFan);
     }
   }

commit de78b60252d83bcf96435c53f1bb2a6c0593c9fd
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat May 13 23:31:31 2023 +0200

    ü©π Remove extraneous MPC temp check (#25816)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8bcaf5d83f..09c5ef0cdf 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1057,22 +1057,20 @@ volatile bool Temperature::raw_temps_ready = false;
           if (sample_count == COUNT(temp_samples)) {
             for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
               temp_samples[i] = temp_samples[i * 2];
             sample_count /= 2;
             sample_distance *= 2;
           }
 
           if (sample_count == 0) t1_time = MS_TO_SEC_PRECISE(curr_time_ms - heat_start_time_ms);
           temp_samples[sample_count++] = current_temp;
 
-          if (current_temp >= 200.0f) break;
-
           next_test_time_ms += test_interval_ms * sample_distance;
 
         }
         else {
           // Third regime (after 200deg) finished gathering data so finish
           break;
         }
       }
     }
     wait_for_heatup = false;

commit 01f5bd333055e919677d95e05bec1f5f067374a4
Author: StevilKnevil <stevilknevil@hotmail.co.uk>
Date:   Fri May 12 01:09:02 2023 +0100

    üö∏ Improved MPCTEMP autotune (#25503)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a92d070183..8bcaf5d83f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -715,30 +715,28 @@ volatile bool Temperature::raw_temps_ready = false;
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(DWIN_PID_TUNE, DWIN_PidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
-      SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
-      SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
+      SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
-    SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
-    SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
+    SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
@@ -809,22 +807,21 @@ volatile bool Temperature::raw_temps_ready = false;
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
-        SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
-        SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
+        SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
@@ -852,28 +849,26 @@ volatile bool Temperature::raw_temps_ready = false;
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
-        SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
-        SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
+        SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
-        SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
-        SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
+        SERIAL_ECHOPGM(STR_PID_AUTOTUNE); SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
           say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
@@ -937,251 +932,386 @@ volatile bool Temperature::raw_temps_ready = false;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
   #if EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
     #define SINGLEFAN 1
   #endif
 
-  void Temperature::MPC_autotune(const uint8_t e) {
-    auto housekeeping = [] (millis_t &ms, const uint8_t e, celsius_float_t &current_temp, millis_t &next_report_ms) {
-      ms = millis();
+  #define DEBUG_MPC_AUTOTUNE 1
 
-      if (updateTemperaturesIfReady()) { // temp sample ready
-        current_temp = degHotend(e);
-        TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
-      }
+  millis_t Temperature::MPC_autotuner::curr_time_ms, Temperature::MPC_autotuner::next_report_ms;
 
-      if (ELAPSED(ms, next_report_ms)) {
-        next_report_ms += 1000UL;
+  celsius_float_t Temperature::MPC_autotuner::temp_samples[16];
+  uint8_t Temperature::MPC_autotuner::sample_count;
+  uint16_t Temperature::MPC_autotuner::sample_distance;
 
-        print_heater_states(e);
-        SERIAL_EOL();
-      }
+  // Parameters from differential analysis
+  celsius_float_t Temperature::MPC_autotuner::temp_fastest;
 
-      hal.idletask();
-      TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
-
-      if (!wait_for_heatup) {
-        SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
-        TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
-        return true;
-      }
-
-      return false;
-    };
-
-    struct OnExit {
-      uint8_t e;
-      OnExit(const uint8_t _e) { this->e = _e; }
-      ~OnExit() {
-        wait_for_heatup = false;
-
-        ui.reset_status();
-
-        temp_hotend[e].target = 0.0f;
-        temp_hotend[e].soft_pwm_amount = 0;
-        #if HAS_FAN
-          set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
-          planner.sync_fan_speeds(fan_speed);
-        #endif
-
-        do_z_clearance(MPC_TUNING_END_Z, false);
+  #if HAS_FAN
+    float Temperature::MPC_autotuner::power_fan255;
+  #endif
 
-        TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
-      }
-    } on_exit(e);
+  Temperature::MPC_autotuner::MPC_autotuner(const uint8_t extruderIdx) : e(extruderIdx) {
+    TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
+  }
 
-    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
-    MPCHeaterInfo &hotend = temp_hotend[e];
-    MPC_t &mpc = hotend.mpc;
+  Temperature::MPC_autotuner::~MPC_autotuner() {
+    wait_for_heatup = false;
 
-    TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
+    ui.reset_status();
 
-    // Move to center of bed, just above bed height and cool with max fan
-    gcode.home_all_axes(true);
-    disable_all_heaters();
+    temp_hotend[e].target = 0.0f;
+    temp_hotend[e].soft_pwm_amount = 0;
     #if HAS_FAN
-      zero_fan_speeds();
-      set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
+      set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
-    do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
-    SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
-    #if ENABLED(DWIN_LCD_PROUI)
-      DWIN_MPCTuning(MPCTEMP_START);
-      LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT);
-    #else
-      LCD_MESSAGE(MSG_COOLING);
-    #endif
+    do_z_clearance(MPC_TUNING_END_Z, false);
 
-    millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
-    celsius_float_t current_temp = degHotend(e),
-                    ambient_temp = current_temp;
+    TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
+  }
 
+  Temperature::MPC_autotuner::MeasurementState Temperature::MPC_autotuner::measure_ambient_temp() {
+    init_timers();
+    const millis_t test_interval_ms = 10000UL;
+    millis_t next_test_ms = curr_time_ms + test_interval_ms;
+    ambient_temp = current_temp = degHotend(e);
     wait_for_heatup = true;
+
     for (;;) { // Can be interrupted with M108
-      if (housekeeping(ms, e, current_temp, next_report_ms)) return;
+      if (housekeeping() == CANCELLED) return CANCELLED;
 
-      if (ELAPSED(ms, next_test_ms)) {
+      if (ELAPSED(curr_time_ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
-        next_test_ms += 10000UL;
+        next_test_ms += test_interval_ms;
       }
     }
     wait_for_heatup = false;
 
-    #if HAS_FAN
-      set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
-      planner.sync_fan_speeds(fan_speed);
+    #if ENABLED(DEBUG_MPC_AUTOTUNE)
+      SERIAL_ECHOLNPGM("MPC_autotuner::measure_ambient_temp() Completed");
+      SERIAL_ECHOLNPGM("=====");
+      SERIAL_ECHOLNPGM("ambient_temp ", get_ambient_temp());
     #endif
 
-    hotend.modeled_ambient_temp = ambient_temp;
+    return SUCCESS;
+  }
+
+  Temperature::MPC_autotuner::MeasurementState Temperature::MPC_autotuner::measure_heatup() {
+    init_timers();
+    constexpr millis_t test_interval_ms = 1000UL;
+    millis_t next_test_time_ms = curr_time_ms + test_interval_ms;
+    MPCHeaterInfo &hotend = temp_hotend[e];
+
+    current_temp = degHotend(e);
+    millis_t heat_start_time_ms = curr_time_ms;
+    sample_count = 0;
+    sample_distance = 1;
+    t1_time = 0;
 
-    SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
-    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
     hotend.target = 200.0f;   // So M105 looks nice
     hotend.soft_pwm_amount = (MPC_MAX) >> 1;
-    const millis_t heat_start_time = next_test_ms = ms;
-    celsius_float_t temp_samples[16];
-    uint8_t sample_count = 0;
-    uint16_t sample_distance = 1;
-    float t1_time = 0;
+
+    // Initialise rate of change to to steady state at current time
+    temp_samples[0] = temp_samples[1] = temp_samples[2] = current_temp;
+    time_fastest = rate_fastest = 0;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (housekeeping(ms, e, current_temp, next_report_ms)) return;
+      if (housekeeping() == CANCELLED) return CANCELLED;
+
+      if (ELAPSED(curr_time_ms, next_test_time_ms)) {
+        if (current_temp < 100.0f) {
+          // Initial regime (below 100deg): Measure rate of change of heating for differential tuning
+
+          // Update the buffer of previous readings
+          temp_samples[0] = temp_samples[1];
+          temp_samples[1] = temp_samples[2];
+          temp_samples[2] = current_temp;
+
+          // Measure the rate of change of temperature, https://en.wikipedia.org/wiki/Symmetric_derivative
+          const float h = MS_TO_SEC_PRECISE(test_interval_ms),
+              curr_rate = (temp_samples[2] - temp_samples[0]) / 2 * h;
+          if (curr_rate > rate_fastest) {
+            // Update fastest values
+            rate_fastest = curr_rate;
+            temp_fastest = temp_samples[1];
+            time_fastest = get_elapsed_heating_time();
+          }
+
+          next_test_time_ms += test_interval_ms;
+
+        }
+        else if (current_temp < 200.0f) {
+          // Second regime (after 100deg) measure 3 points to determine asymptotic temperature
 
-      if (ELAPSED(ms, next_test_ms)) {
-        // Record samples between 100C and 200C
-        if (current_temp >= 100.0f) {
           // If there are too many samples, space them more widely
           if (sample_count == COUNT(temp_samples)) {
             for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
-              temp_samples[i] = temp_samples[i*2];
+              temp_samples[i] = temp_samples[i * 2];
             sample_count /= 2;
             sample_distance *= 2;
           }
 
-          if (sample_count == 0) t1_time = float(ms - heat_start_time) / 1000.0f;
+          if (sample_count == 0) t1_time = MS_TO_SEC_PRECISE(curr_time_ms - heat_start_time_ms);
           temp_samples[sample_count++] = current_temp;
-        }
 
-        if (current_temp >= 200.0f) break;
+          if (current_temp >= 200.0f) break;
+
+          next_test_time_ms += test_interval_ms * sample_distance;
 
-        next_test_ms += 1000UL * sample_distance;
+        }
+        else {
+          // Third regime (after 200deg) finished gathering data so finish
+          break;
+        }
       }
     }
     wait_for_heatup = false;
 
     hotend.soft_pwm_amount = 0;
 
-    // Calculate physical constants from three equally-spaced samples
-    sample_count = (sample_count + 1) / 2 * 2 - 1;
-    const float t1 = temp_samples[0],
-                t2 = temp_samples[(sample_count - 1) >> 1],
-                t3 = temp_samples[sample_count - 1];
-    float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
-          block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
+    elapsed_heating_time = MS_TO_SEC_PRECISE(curr_time_ms - heat_start_time_ms);
 
-    mpc.ambient_xfer_coeff_fan0 = mpc.heater_power * (MPC_MAX) / 255 / (asymp_temp - ambient_temp);
-    mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
-    mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
-    TERN_(MPC_INCLUDE_FAN, mpc.fan255_adjustment = 0.0f);
+    // Ensure sample count is odd so that we have 3 equally spaced samples
+    if (sample_count == 0) return FAILED;
+    if (sample_count % 2 == 0) sample_count--;
 
-    hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
-    hotend.modeled_sensor_temp = current_temp;
+    #if ENABLED(DEBUG_MPC_AUTOTUNE)
+      SERIAL_ECHOLNPGM("MPC_autotuner::measure_heatup() Completed");
+      SERIAL_ECHOLNPGM("=====");
+      SERIAL_ECHOLNPGM("t1_time ", t1_time);
+      SERIAL_ECHOLNPGM("sample_count ", sample_count);
+      SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
+      for (uint8_t i = 0; i < sample_count; i++)
+        SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
+      SERIAL_ECHOLNPGM("t1 ", get_sample_1_temp(), " t2 ", get_sample_2_temp(), " t3 ", get_sample_3_temp());
+    #endif
+
+    return SUCCESS;
+  }
+
+  Temperature::MPC_autotuner::MeasurementState Temperature::MPC_autotuner::measure_transfer() {
+    init_timers();
+    const millis_t test_interval_ms = SEC_TO_MS(MPC_dT);
+    millis_t next_test_ms = curr_time_ms + test_interval_ms;
+    MPCHeaterInfo &hotend = temp_hotend[e];
+    MPC_t &mpc = hotend.mpc;
 
-    // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
-    SERIAL_ECHOLNPGM(STR_MPC_MEASURING_AMBIENT, hotend.modeled_block_temp);
-    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_MEASURING_AMBIENT), LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT));
-    hotend.target = hotend.modeled_block_temp;
-    next_test_ms = ms + MPC_dT * 1000;
     constexpr millis_t settle_time = 20000UL, test_duration = 20000UL;
-    millis_t settle_end_ms = ms + settle_time,
+    millis_t settle_end_ms = curr_time_ms + settle_time,
              test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (housekeeping(ms, e, current_temp, next_report_ms)) return;
+      if (housekeeping() == CANCELLED) return CANCELLED;
 
-      if (ELAPSED(ms, next_test_ms)) {
+      if (ELAPSED(curr_time_ms, next_test_ms)) {
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(e) >> 1;
 
-        if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
+        if (ELAPSED(curr_time_ms, settle_end_ms) && !ELAPSED(curr_time_ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #if HAS_FAN
-          else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
+          else if (ELAPSED(curr_time_ms, test_end_ms) && !fan0_done) {
             set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
             planner.sync_fan_speeds(fan_speed);
-            settle_end_ms = ms + settle_time;
+            settle_end_ms = curr_time_ms + settle_time;
             test_end_ms = settle_end_ms + test_duration;
             fan0_done = true;
           }
-          else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
+          else if (ELAPSED(curr_time_ms, settle_end_ms) && !ELAPSED(curr_time_ms, test_end_ms))
             total_energy_fan255 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #endif
-        else if (ELAPSED(ms, test_end_ms)) break;
+        else if (ELAPSED(curr_time_ms, test_end_ms)) break;
 
         last_temp = current_temp;
-        next_test_ms += MPC_dT * 1000;
+        next_test_ms += test_interval_ms;
       }
 
-      if (!WITHIN(current_temp, t3 - 15.0f, hotend.target + 15.0f)) {
+      // Ensure we don't drift too far from the window between the last sampled temp and the target temperature
+      if (!WITHIN(current_temp, get_sample_3_temp() - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
         TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_TEMP_ERROR));
-        break;
+        wait_for_heatup = false;
+        return FAILED;
       }
     }
     wait_for_heatup = false;
 
-    const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
-    mpc.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
+    power_fan0 = total_energy_fan0 / MS_TO_SEC_PRECISE(test_duration);
+    TERN_(HAS_FAN, power_fan255 = (total_energy_fan255 * 1000) / test_duration);
+
+    #if ENABLED(DEBUG_MPC_AUTOTUNE)
+      SERIAL_ECHOLNPGM("MPC_autotuner::measure_transfer() Completed");
+      SERIAL_ECHOLNPGM("=====");
+      SERIAL_ECHOLNPGM("power_fan0 ", power_fan0);
+      TERN_(HAS_FAN, SERIAL_ECHOLNPGM("power_fan255 ", power_fan255));
+    #endif
+
+    return SUCCESS;
+  }
+
+  Temperature::MPC_autotuner::MeasurementState Temperature::MPC_autotuner::housekeeping() {
+    const millis_t report_interval_ms = 1000UL;
+    curr_time_ms = millis();
+
+    if (updateTemperaturesIfReady()) { // temp sample ready
+      current_temp = degHotend(e);
+      TERN_(HAS_FAN_LOGIC, manage_extruder_fans(curr_time_ms));
+    }
+
+    if (ELAPSED(curr_time_ms, next_report_ms)) {
+      next_report_ms += report_interval_ms;
+      print_heater_states(e);
+      SERIAL_EOL();
+    }
+
+    hal.idletask();
+    TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
+
+    if (!wait_for_heatup) {
+      SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
+      TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
+      return MeasurementState::CANCELLED;
+    }
+
+    return MeasurementState::SUCCESS;
+  }
+
+  void Temperature::MPC_autotune(const uint8_t e, MPCTuningType tuning_type=AUTO) {
+    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
+
+    MPC_autotuner tuner(e);
+
+    MPCHeaterInfo &hotend = temp_hotend[e];
+    MPC_t &mpc = hotend.mpc;
 
+    // Move to center of bed, just above bed height and cool with max fan
+    gcode.home_all_axes(true);
+    disable_all_heaters();
     #if HAS_FAN
-      const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
-                  ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
-      mpc.applyFanAdjustment(ambient_xfer_coeff_fan255);
+      zero_fan_speeds();
+      set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
+      planner.sync_fan_speeds(fan_speed);
     #endif
+    do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
-    // Calculate a new and better asymptotic temperature and re-evaluate the other constants
-    asymp_temp = ambient_temp + mpc.heater_power * (MPC_MAX) / 255 / mpc.ambient_xfer_coeff_fan0;
-    block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
-    mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
-    mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
+    // Determine ambient temperature.
+    SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
+    #if ENABLED(DWIN_LCD_PROUI)
+      DWIN_MPCTuning(MPCTEMP_START);
+      LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT);
+    #else
+      LCD_MESSAGE(MSG_COOLING);
+    #endif
 
-    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
-    TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_DONE));
+    if (tuner.measure_ambient_temp() != MPC_autotuner::MeasurementState::SUCCESS) return;
+    hotend.modeled_ambient_temp = tuner.get_ambient_temp();
 
-    #if 0
-      SERIAL_ECHOLNPGM("t1_time ", t1_time);
-      SERIAL_ECHOLNPGM("sample_count ", sample_count);
-      SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
-      for (uint8_t i = 0; i < sample_count; i++)
-        SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
-      SERIAL_ECHOLNPGM("t1 ", t1, " t2 ", t2, " t3 ", t3);
+    #if HAS_FAN
+      set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
+      planner.sync_fan_speeds(fan_speed);
+    #endif
+
+    // Heat to 200 degrees
+    SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
+    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
+
+    if (tuner.measure_heatup() != MPC_autotuner::MeasurementState::SUCCESS) return;
+
+    // Calculate physical constants from three equally-spaced samples
+    const float t1 = tuner.get_sample_1_temp(),
+                t2 = tuner.get_sample_2_temp(),
+                t3 = tuner.get_sample_3_temp();
+    float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
+          block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / tuner.get_sample_interval();
+
+    #if ENABLED(DEBUG_MPC_AUTOTUNE)
       SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
       SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
     #endif
 
+    // Make initial guess at transfer coefficients
+    mpc.ambient_xfer_coeff_fan0 = mpc.heater_power * (MPC_MAX) / 255 / (asymp_temp - tuner.get_ambient_temp());
+    TERN_(MPC_INCLUDE_FAN, mpc.fan255_adjustment = 0.0f);
+
+    if (tuning_type == AUTO || tuning_type == FORCE_ASYMPTOTIC) {
+      // Analytic tuning
+      mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
+      mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
+    }
+
+    // If analytic tuning fails, fall back to differential tuning
+    if (tuning_type == AUTO) {
+      if (mpc.sensor_responsiveness <= 0 || mpc.block_heat_capacity <= 0)
+        tuning_type = FORCE_DIFFERENTIAL;
+    }
+
+    if (tuning_type == FORCE_DIFFERENTIAL) {
+      // Differential tuning
+      mpc.block_heat_capacity = mpc.heater_power / tuner.get_rate_fastest();
+      mpc.sensor_responsiveness = tuner.get_rate_fastest() / (tuner.get_rate_fastest() * tuner.get_time_fastest() + tuner.get_ambient_temp() - tuner.get_time_fastest());
+    }
+
+    hotend.modeled_block_temp = asymp_temp + (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_elapsed_heating_time());
+    hotend.modeled_sensor_temp = tuner.get_last_measured_temp();
+
+    // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
+    SERIAL_ECHOLNPGM(STR_MPC_MEASURING_AMBIENT, hotend.modeled_block_temp);
+    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_MEASURING_AMBIENT), LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT));
+
+    // Use the estimated overshoot of the temperature as the target to achieve.
+    hotend.target = hotend.modeled_block_temp;
+    if (tuner.measure_transfer() != MPC_autotuner::MeasurementState::SUCCESS) return;
+
+    // Update the transfer coefficients
+    mpc.ambient_xfer_coeff_fan0 = tuner.get_power_fan0() / (hotend.target - tuner.get_ambient_temp());
+    #if HAS_FAN
+      const float ambient_xfer_coeff_fan255 = tuner.get_power_fan255() / (hotend.target - tuner.get_ambient_temp());
+      mpc.applyFanAdjustment(ambient_xfer_coeff_fan255);
+    #endif
+
+    if (tuning_type == AUTO || tuning_type == FORCE_ASYMPTOTIC) {
+      // Calculate a new and better asymptotic temperature and re-evaluate the other constants
+      asymp_temp = tuner.get_ambient_temp() + mpc.heater_power * (MPC_MAX) / 255 / mpc.ambient_xfer_coeff_fan0;
+      block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / tuner.get_sample_interval();
+
+      #if ENABLED(DEBUG_MPC_AUTOTUNE)
+        SERIAL_ECHOLN("Refining estimates for:");
+        SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
+        SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
+      #endif
+
+      // Update analytic tuning values based on the above
+      mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
+      mpc.sensor_responsiveness = block_responsiveness / (1.0f - (tuner.get_ambient_temp() - asymp_temp) * exp(-block_responsiveness * tuner.get_sample_1_time()) / (t1 - asymp_temp));
+
+    }
+
+    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
+    TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_DONE));
+
     SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
     SERIAL_ECHOLNPAIR_F("MPC_SENSOR_RESPONSIVENESS ", mpc.sensor_responsiveness, 4);
     SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF ", mpc.ambient_xfer_coeff_fan0, 4);
     TERN_(HAS_FAN, SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF_FAN255 ", ambient_xfer_coeff_fan255, 4));
   }
 
 #endif // MPC_AUTOTUNE
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
@@ -1695,23 +1825,23 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
         if (is_bed_preheating()) {
           temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
         }
         else {
           #if ENABLED(PIDTEMPBED)
             temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
           #else
             // Check if temperature is within the correct band
             if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
               #if ENABLED(BED_LIMIT_SWITCHING)
-                if (temp_bed.is_above_target((BED_HYSTERESIS) - 1))
+                if (temp_bed.is_above_target(BED_HYSTERESIS))
                   temp_bed.soft_pwm_amount = 0;
-                else if (temp_bed.is_below_target((BED_HYSTERESIS) - 1))
+                else if (temp_bed.is_below_target(BED_HYSTERESIS))
                   temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
               #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
                 temp_bed.soft_pwm_amount = temp_bed.is_below_target() ? MAX_BED_POWER >> 1 : 0;
               #endif
             }
             else {
               temp_bed.soft_pwm_amount = 0;
               WRITE_HEATER_BED(LOW);
             }
           #endif
@@ -1771,35 +1901,35 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
           set_fan_speed(CHAMBER_FAN_INDEX, fan_chamber_pwm);
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
-          if (!flag_chamber_excess_heat && temp_chamber.is_above_target((HIGH_EXCESS_HEAT_LIMIT) - 1)) {
+          if (!flag_chamber_excess_heat && temp_chamber.is_above_target(HIGH_EXCESS_HEAT_LIMIT)) {
             // Open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds if the
             // temperature didn't drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             if (next_cool_check_ms == 0 || ELAPSED(ms, next_cool_check_ms)) {
               if (temp_chamber.celsius - old_temp > MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)
                 flag_chamber_excess_heat = true; // the bed is heating the chamber too much
               next_cool_check_ms = ms + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER_VENT);
               old_temp = temp_chamber.celsius;
             }
           }
           else {
             next_cool_check_ms = 0;
             old_temp = 9999;
           }
-          if (flag_chamber_excess_heat && temp_chamber.is_above_target((LOW_EXCESS_HEAT_LIMIT) - 1))
+          if (flag_chamber_excess_heat && temp_chamber.is_above_target(LOW_EXCESS_HEAT_LIMIT))
             flag_chamber_excess_heat = false;
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
           set_fan_speed(CHAMBER_FAN_INDEX, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
@@ -1817,23 +1947,23 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
         if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
           if (flag_chamber_excess_heat) {
             temp_chamber.soft_pwm_amount = 0;
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(temp_chamber.is_below_target() ? 0 : 90);
             #endif
           }
           else {
             #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-              if (temp_chamber.is_above_target((TEMP_CHAMBER_HYSTERESIS) - 1))
+              if (temp_chamber.is_above_target(TEMP_CHAMBER_HYSTERESIS))
                 temp_chamber.soft_pwm_amount = 0;
-              else if (temp_chamber.is_below_target((TEMP_CHAMBER_HYSTERESIS) - 1))
+              else if (temp_chamber.is_below_target(TEMP_CHAMBER_HYSTERESIS))
                 temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
             #else
               temp_chamber.soft_pwm_amount = temp_chamber.is_below_target() ? (MAX_CHAMBER_POWER) >> 1 : 0;
             #endif
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(0);
             #endif
           }
         }
         else {

commit 03bb28c277ce1c8e98c7b418ce607ecd58c58c4f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 14 02:21:50 2022 -0500

    üé® Misc. temperature cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4001ae63bf..a92d070183 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -517,21 +517,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
     bed_watch_t Temperature::watch_bed; // = { 0 }
   #endif
   #if DISABLED(PIDTEMPBED)
     millis_t Temperature::next_bed_check_ms;
   #endif
 #endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
-    millis_t next_cool_check_ms_2 = 0;
+    millis_t next_cool_check_ms = 0;
     celsius_float_t old_temp = 9999;
     raw_adc_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
               Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     #if WATCH_CHAMBER
       chamber_watch_t Temperature::watch_chamber; // = { 0 }
     #endif
     #if DISABLED(PIDTEMPCHAMBER)
       millis_t Temperature::next_chamber_check_ms;
     #endif
   #endif
@@ -539,21 +539,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
 #if HAS_TEMP_COOLER
   cooler_info_t Temperature::temp_cooler; // = { 0 }
   #if HAS_COOLER
     bool flag_cooler_state;
     //bool flag_cooler_excess = false;
     celsius_float_t previous_temp = 9999;
     raw_adc_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,
               Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
     #if WATCH_COOLER
-      cooler_watch_t Temperature::watch_cooler{0};
+      cooler_watch_t Temperature::watch_cooler; // = { 0 }
     #endif
     millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
   #endif
 #endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if HAS_TEMP_BOARD
@@ -610,25 +610,25 @@ volatile bool Temperature::raw_temps_ready = false;
                          sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_5 { TEMP_SENSOR_5_RAW_LO_TEMP, TEMP_SENSOR_5_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_6 { TEMP_SENSOR_6_RAW_LO_TEMP, TEMP_SENSOR_6_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_7 { TEMP_SENSOR_7_RAW_LO_TEMP, TEMP_SENSOR_7_RAW_HI_TEMP, 0, 16383 };
 
   temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5, sensor_heater_6, sensor_heater_7);
 #endif
 
 #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
   #define MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR 1
-  uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
+  uint8_t Temperature::consecutive_low_temperature_error[HOTENDS]; // = { 0 }
 #endif
 
 #if PREHEAT_TIME_HOTEND_MS > 0
-  millis_t Temperature::preheat_end_ms_hotend[HOTENDS] { 0 };
+  millis_t Temperature::preheat_end_ms_hotend[HOTENDS]; // = { 0 };
 #endif
 #if HAS_HEATED_BED && PREHEAT_TIME_BED_MS > 0
   millis_t Temperature::preheat_end_ms_bed = 0;
 #endif
 
 #if HAS_FAN_LOGIC
   constexpr millis_t Temperature::fan_update_interval_ms;
   millis_t Temperature::fan_update_ms = 0;
 #endif
 
@@ -1774,29 +1774,29 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
           if (!flag_chamber_excess_heat && temp_chamber.is_above_target((HIGH_EXCESS_HEAT_LIMIT) - 1)) {
             // Open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds if the
             // temperature didn't drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
-            if (next_cool_check_ms_2 == 0 || ELAPSED(ms, next_cool_check_ms_2)) {
+            if (next_cool_check_ms == 0 || ELAPSED(ms, next_cool_check_ms)) {
               if (temp_chamber.celsius - old_temp > MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)
                 flag_chamber_excess_heat = true; // the bed is heating the chamber too much
-              next_cool_check_ms_2 = ms + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER_VENT);
+              next_cool_check_ms = ms + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER_VENT);
               old_temp = temp_chamber.celsius;
             }
           }
           else {
-            next_cool_check_ms_2 = 0;
+            next_cool_check_ms = 0;
             old_temp = 9999;
           }
           if (flag_chamber_excess_heat && temp_chamber.is_above_target((LOW_EXCESS_HEAT_LIMIT) - 1))
             flag_chamber_excess_heat = false;
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
           set_fan_speed(CHAMBER_FAN_INDEX, 0);
@@ -2485,21 +2485,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 
     HOTEND_LOOP() {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
         maxtemp_error((heater_id_t)e);
 
       /**
       // DEBUG PREHEATING TIME
       SERIAL_ECHOLNPGM("\nExtruder = ", e, " Preheat On/Off = ", is_preheating(e));
-      const float test_is_preheating = (preheat_end_time[HOTEND_INDEX] - millis()) * 0.001f;
+      const float test_is_preheating = (preheat_end_ms_hotend[HOTEND_INDEX] - millis()) * 0.001f;
       if (test_is_preheating < 31) SERIAL_ECHOLNPGM("Extruder = ", e, " Preheat remaining time = ", test_is_preheating, "s", "\n");
       //*/
 
       const bool heater_on = temp_hotend[e].target > 0;
       if (heater_on && !is_hotend_preheating(e) && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
           mintemp_error((heater_id_t)e);
       }
       else {
         TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
@@ -3544,21 +3544,21 @@ void Temperature::isr() {
         _PWM_MOD(CHAMBER, soft_pwm_chamber, temp_chamber);
       #endif
 
       #if HAS_COOLER
         _PWM_MOD(COOLER, soft_pwm_cooler, temp_cooler);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
 
         #if ENABLED(USE_CONTROLLER_FAN)
-          WRITE(CONTROLLER_FAN_PIN, soft_pwm_controller.add(pwm_mask, soft_pwm_controller_speed));
+          WRITE(CONTROLLER_FAN_PIN, soft_pwm_controller.add(pwm_mask, controllerFan.soft_pwm_speed));
         #endif
 
         #define _FAN_PWM(N) do{                                     \
           uint8_t &spcf = soft_pwm_count_fan[N];                    \
           spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
           WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW);               \
         }while(0)
 
         #if HAS_FAN0
           _FAN_PWM(0);
@@ -4176,21 +4176,21 @@ void Temperature::isr() {
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const celsius_float_t start_temp = degHotend(target_extruder);
         printerEventLEDs.onHotendHeatingStart();
       #endif
 
       bool wants_to_cool = false;
       celsius_float_t target_temp = -1.0, old_temp = 9999.0;
-      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      millis_t now, next_temp_ms = 0, cool_check_ms = 0;
       wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
           target_temp = degTargetHotend(target_extruder);
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
@@ -4234,23 +4234,23 @@ void Temperature::isr() {
           }
 
           first_loop = false;
 
         #endif
 
         // Prevent a wait-forever situation if R is misused i.e. M109 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
-          if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+          if (!cool_check_ms || ELAPSED(now, cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
-            next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME);
+            cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
@@ -4313,21 +4313,21 @@ void Temperature::isr() {
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const celsius_float_t start_temp = degBed();
         printerEventLEDs.onBedHeatingStart();
       #endif
 
       bool wants_to_cool = false;
       celsius_float_t target_temp = -1, old_temp = 9999;
-      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      millis_t now, next_temp_ms = 0, cool_check_ms = 0;
       wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetBed()) {
           wants_to_cool = isCoolingBed();
           target_temp = degTargetBed();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
@@ -4369,23 +4369,23 @@ void Temperature::isr() {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
         #endif // TEMP_BED_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M190 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_BED seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
-          if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+          if (!cool_check_ms || ELAPSED(now, cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
-            next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_BED);
+            cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_BED);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
@@ -4508,21 +4508,21 @@ void Temperature::isr() {
         // Loop until the temperature is very close target
         #define TEMP_CHAMBER_CONDITIONS (wants_to_cool ? isCoolingChamber() : isHeatingChamber())
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       bool wants_to_cool = false;
       float target_temp = -1, old_temp = 9999;
-      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      millis_t now, next_temp_ms = 0, cool_check_ms = 0;
       wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetChamber()) {
           wants_to_cool = isCoolingChamber();
           target_temp = degTargetChamber();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
@@ -4560,23 +4560,23 @@ void Temperature::isr() {
             residency_start_ms = now;
           }
 
           first_loop = false;
         #endif // TEMP_CHAMBER_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M191 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
-          if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+          if (!cool_check_ms || ELAPSED(now, cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_CHAMBER)) break;
-            next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER);
+            cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER);
             old_temp = temp;
           }
         }
       } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
 
       // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;

commit a6404aca45ff1e3f09ad7a0702ae95689fd81338
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue May 9 22:52:59 2023 +0200

    üîß Move SOFT_PWM_SCALE fallback to cpp (#25800)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b4b1ba6372..4001ae63bf 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3472,20 +3472,24 @@ void Temperature::isr() {
   // Shut down the laser if steppers are inactive for > LASER_SAFETY_TIMEOUT_MS ms
   #if LASER_SAFETY_TIMEOUT_MS > 0
     if (cutter.last_power_applied && ELAPSED(millis(), gcode.previous_move_ms + (LASER_SAFETY_TIMEOUT_MS))) {
       cutter.power = 0;       // Prevent planner idle from re-enabling power
       cutter.apply_power(0);
     }
   #endif
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
+
+  #ifndef SOFT_PWM_SCALE
+    #define SOFT_PWM_SCALE 0
+  #endif
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
 
   // Avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static raw_adc_t raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;
   #endif
 

commit f5a905a64121e4ff43894d295ce6990e55aa1149
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Apr 25 04:51:44 2023 +0200

    ‚ú® TEMP_SENSOR_SOC (#25642)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3274136f41..b4b1ba6372 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -557,20 +557,25 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #endif
 
 #if HAS_TEMP_BOARD
   board_info_t Temperature::temp_board; // = { 0 }
   #if ENABLED(THERMAL_PROTECTION_BOARD)
     raw_adc_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
               Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
   #endif
 #endif
 
+#if HAS_TEMP_SOC
+  soc_info_t Temperature::temp_soc; // = { 0 }
+  raw_adc_t Temperature::maxtemp_raw_SOC = TEMP_SENSOR_SOC_RAW_HI_TEMP;
+#endif
+
 #if BOTH(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
   bool Temperature::allow_cold_extrude_override = false;
 #else
   constexpr bool Temperature::allow_cold_extrude_override;
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #else
@@ -1349,20 +1354,21 @@ void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_m
       if (heater_id == H_REDUNDANT) {
         SERIAL_ECHOPGM(STR_REDUNDANT); // print redundant and cascade to print target, too.
         real_heater_id = (heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET);
       }
     #endif
 
     switch (real_heater_id) {
       OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
       OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
       OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
+      OPTCODE(HAS_TEMP_SOC,     case H_SOC:     SERIAL_ECHOPGM(STR_SOC);            break)
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
         if (real_heater_id >= 0)
           SERIAL_ECHOLNPGM("E", real_heater_id);
     }
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
@@ -2361,20 +2367,34 @@ void Temperature::task() {
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BOARD_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_BOARD
 
+#if HAS_TEMP_SOC
+  // For SoC temperature measurement.
+  celsius_float_t Temperature::analog_to_celsius_soc(const raw_adc_t raw) {
+    return (
+      #ifdef TEMP_SOC_SENSOR
+        TEMP_SOC_SENSOR(raw)
+      #else
+        0
+        #error "TEMP_SENSOR_SOC requires the TEMP_SOC_SENSOR(RAW) macro to be defined for your board."
+      #endif
+    );
+  }
+#endif
+
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_redundant(const raw_adc_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E0)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E1)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E2)
@@ -2423,20 +2443,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].getraw(), e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.getraw()));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.getraw()));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.getraw()));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.getraw()));
   TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.getraw()));
+  TERN_(HAS_TEMP_SOC,       temp_soc.celsius       = analog_to_celsius_soc(temp_soc.getraw()));
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.getraw()));
 
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
   #if HAS_HOTEND
     static constexpr int8_t temp_dir[HOTENDS] = {
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         0
       #else
@@ -2500,20 +2521,24 @@ void Temperature::updateTemperaturesFromRawValues() {
 
   #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
     if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) maxtemp_error(H_COOLER);
     if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) mintemp_error(H_COOLER);
   #endif
 
   #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
     if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) maxtemp_error(H_BOARD);
     if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) mintemp_error(H_BOARD);
   #endif
+
+  #if BOTH(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
+    if (TP_CMP(SOC, temp_soc.getraw(), maxtemp_raw_SOC)) maxtemp_error(H_SOC);
+  #endif
   #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to task()
  *
  *  - Init (and disable) SPI thermocouples like MAX6675 and MAX31865
@@ -2715,20 +2740,21 @@ void Temperature::init() {
   TERN_(HAS_TEMP_ADC_6,         hal.adc_enable(TEMP_6_PIN));
   TERN_(HAS_TEMP_ADC_7,         hal.adc_enable(TEMP_7_PIN));
   TERN_(HAS_JOY_ADC_X,          hal.adc_enable(JOY_X_PIN));
   TERN_(HAS_JOY_ADC_Y,          hal.adc_enable(JOY_Y_PIN));
   TERN_(HAS_JOY_ADC_Z,          hal.adc_enable(JOY_Z_PIN));
   TERN_(HAS_TEMP_ADC_BED,       hal.adc_enable(TEMP_BED_PIN));
   TERN_(HAS_TEMP_ADC_CHAMBER,   hal.adc_enable(TEMP_CHAMBER_PIN));
   TERN_(HAS_TEMP_ADC_PROBE,     hal.adc_enable(TEMP_PROBE_PIN));
   TERN_(HAS_TEMP_ADC_COOLER,    hal.adc_enable(TEMP_COOLER_PIN));
   TERN_(HAS_TEMP_ADC_BOARD,     hal.adc_enable(TEMP_BOARD_PIN));
+  TERN_(HAS_TEMP_ADC_SOC,       hal.adc_enable(TEMP_SOC_PIN));
   TERN_(HAS_TEMP_ADC_REDUNDANT, hal.adc_enable(TEMP_REDUNDANT_PIN));
   TERN_(FILAMENT_WIDTH_SENSOR,  hal.adc_enable(FILWIDTH_PIN));
   TERN_(HAS_ADC_BUTTONS,        hal.adc_enable(ADC_KEYPAD_PIN));
   TERN_(POWER_MONITOR_CURRENT,  hal.adc_enable(POWER_MONITOR_CURRENT_PIN));
   TERN_(POWER_MONITOR_VOLTAGE,  hal.adc_enable(POWER_MONITOR_VOLTAGE_PIN));
 
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
 
@@ -2851,20 +2877,24 @@ void Temperature::init() {
   #if HAS_COOLER
     while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
     while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
 
   #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
     while (analog_to_celsius_board(mintemp_raw_BOARD) < BOARD_MINTEMP) mintemp_raw_BOARD += TEMPDIR(BOARD) * (OVERSAMPLENR);
     while (analog_to_celsius_board(maxtemp_raw_BOARD) > BOARD_MAXTEMP) maxtemp_raw_BOARD -= TEMPDIR(BOARD) * (OVERSAMPLENR);
   #endif
 
+  #if BOTH(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
+    while (analog_to_celsius_soc(maxtemp_raw_SOC) > SOC_MAXTEMP) maxtemp_raw_SOC -= OVERSAMPLENR;
+  #endif
+
   #if HAS_TEMP_REDUNDANT
     temp_redundant.target = &(
       #if REDUNDANT_TEMP_MATCH(TARGET, COOLER) && HAS_TEMP_COOLER
         temp_cooler
       #elif REDUNDANT_TEMP_MATCH(TARGET, PROBE) && HAS_TEMP_PROBE
         temp_probe
       #elif REDUNDANT_TEMP_MATCH(TARGET, BOARD) && HAS_TEMP_BOARD
         temp_board
       #elif REDUNDANT_TEMP_MATCH(TARGET, CHAMBER) && HAS_TEMP_CHAMBER
         temp_chamber
@@ -3333,20 +3363,21 @@ void Temperature::update_raw_temperatures() {
   TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED,     temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
   TERN_(HAS_TEMP_ADC_PROBE,   temp_probe.update());
   TERN_(HAS_TEMP_ADC_COOLER,  temp_cooler.update());
   TERN_(HAS_TEMP_ADC_BOARD,   temp_board.update());
+  TERN_(HAS_TEMP_ADC_SOC,     temp_soc.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 }
 
 /**
  * Called by the Temperature ISR when all the ADCs have been processed.
  * Reset all the ADC accumulators for another round of updates.
  */
@@ -3363,20 +3394,21 @@ void Temperature::readings_ready() {
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.reset());
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE,     temp_probe.reset());
   TERN_(HAS_TEMP_COOLER,    temp_cooler.reset());
   TERN_(HAS_TEMP_BOARD,     temp_board.reset());
+  TERN_(HAS_TEMP_SOC,       temp_soc.reset());
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
@@ -3821,20 +3853,25 @@ void Temperature::isr() {
     #if HAS_TEMP_ADC_PROBE
       case PrepareTemp_PROBE: hal.adc_start(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_BOARD
       case PrepareTemp_BOARD: hal.adc_start(TEMP_BOARD_PIN); break;
       case MeasureTemp_BOARD: ACCUMULATE_ADC(temp_board); break;
     #endif
 
+    #if HAS_TEMP_ADC_SOC
+      case PrepareTemp_SOC: hal.adc_start(TEMP_SOC_PIN); break;
+      case MeasureTemp_SOC: ACCUMULATE_ADC(temp_soc); break;
+    #endif
+
     #if HAS_TEMP_ADC_REDUNDANT
       case PrepareTemp_REDUNDANT: hal.adc_start(TEMP_REDUNDANT_PIN); break;
       case MeasureTemp_REDUNDANT: ACCUMULATE_ADC(temp_redundant); break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: hal.adc_start(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
@@ -3960,67 +3997,71 @@ void Temperature::isr() {
 
   // Periodically call the planner timer service routine
   planner.isr();
 }
 
 #if HAS_TEMP_SENSOR
   /**
    * Print a single heater state in the form:
    *        Bed: " B:nnn.nn /nnn.nn"
    *    Chamber: " C:nnn.nn /nnn.nn"
-   *      Probe: " P:nnn.nn /nnn.nn"
+   *      Probe: " P:nnn.nn"
    *     Cooler: " L:nnn.nn /nnn.nn"
+   *      Board: " M:nnn.nn"
+   *        SoC: " S:nnn.nn"
    *  Redundant: " R:nnn.nn /nnn.nn"
    *   Extruder: " T0:nnn.nn /nnn.nn"
    *   With ADC: " T0:nnn.nn /nnn.nn (nnn.nn)"
    */
   static void print_heater_state(const heater_id_t e, const_celsius_float_t c, const_celsius_float_t t
     OPTARG(SHOW_TEMP_ADC_VALUES, const float r)
   ) {
     char k;
+    bool show_t = true;
     switch (e) {
       default:
         #if HAS_TEMP_HOTEND
           k = 'T'; break;
         #endif
       #if HAS_TEMP_BED
         case H_BED: k = 'B'; break;
       #endif
       #if HAS_TEMP_CHAMBER
         case H_CHAMBER: k = 'C'; break;
       #endif
       #if HAS_TEMP_PROBE
-        case H_PROBE: k = 'P'; break;
+        case H_PROBE: k = 'P'; show_t = false; break;
       #endif
       #if HAS_TEMP_COOLER
         case H_COOLER: k = 'L'; break;
       #endif
       #if HAS_TEMP_BOARD
-        case H_BOARD: k = 'M'; break;
+        case H_BOARD: k = 'M'; show_t = false; break;
+      #endif
+      #if HAS_TEMP_SOC
+        case H_SOC: k = 'S'; show_t = false; break;
       #endif
       #if HAS_TEMP_REDUNDANT
         case H_REDUNDANT: k = 'R'; break;
       #endif
     }
     SERIAL_CHAR(' ', k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
       #define SFP 2
     #endif
-    SERIAL_CHAR(':');
-    SERIAL_PRINT(c, SFP);
-    SERIAL_ECHOPGM(" /");
-    SERIAL_PRINT(t, SFP);
+    SERIAL_CHAR(':'); SERIAL_PRINT(c, SFP);
+    if (show_t) { SERIAL_ECHOPGM(" /"); SERIAL_PRINT(t, SFP); }
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       SERIAL_ECHOPGM(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const int8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
@@ -4036,20 +4077,23 @@ void Temperature::isr() {
     #endif
     #if HAS_TEMP_COOLER
       print_heater_state(H_COOLER, degCooler(), TERN0(HAS_COOLER, degTargetCooler()) OPTARG(SHOW_TEMP_ADC_VALUES, rawCoolerTemp()));
     #endif
     #if HAS_TEMP_PROBE
       print_heater_state(H_PROBE, degProbe(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawProbeTemp()));
     #endif
     #if HAS_TEMP_BOARD
       print_heater_state(H_BOARD, degBoard(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawBoardTemp()));
     #endif
+    #if HAS_TEMP_SOC
+      print_heater_state(H_SOC, degSoc(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawSocTemp()));
+    #endif
     #if HAS_TEMP_REDUNDANT
       if (include_r) print_heater_state(H_REDUNDANT, degRedundant(), degRedundantTarget() OPTARG(SHOW_TEMP_ADC_VALUES, rawRedundantTemp()));
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
     SERIAL_ECHOPGM(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPGM(" B@:", getHeaterPower(H_BED));
     #endif

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5bf809c955..3274136f41 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1922,21 +1922,21 @@ void Temperature::task() {
   REMEMBER(mh, no_reentry, true);
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
 
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
       if (emergency_parser.sd_abort_by_M524) { // abort SD print immediately
         emergency_parser.sd_abort_by_M524 = false;
         card.flag.abort_sd_printing = true;
         gcode.process_subcommands_now(F("M524"));
       }
     #endif
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 

commit c8ed7950f40f9f454fc769b02d53f1086b17576c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Apr 22 21:09:17 2023 +1200

    üîß Permit extrude without hotend (#25709)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ce46d3d43d..5bf809c955 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2778,21 +2778,21 @@ void Temperature::init() {
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius)) - 1), \
                       tmax = _MIN(HEATER_##NR##_MAXTEMP, tmax_tmp); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR(N) > 0 && TEMP_SENSOR(N) != 998 && TEMP_SENSOR(N) != 999 && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##NR##_IS_THERMISTOR && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif

commit b6a1a6273fcff835002c5645ebdd157b5f180bab
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Apr 16 06:59:23 2023 +0200

    ü©π Fix MPC compile (#25669)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 43bf31e0e7..ce46d3d43d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1078,23 +1078,23 @@ volatile bool Temperature::raw_temps_ready = false;
 
     // Calculate physical constants from three equally-spaced samples
     sample_count = (sample_count + 1) / 2 * 2 - 1;
     const float t1 = temp_samples[0],
                 t2 = temp_samples[(sample_count - 1) >> 1],
                 t3 = temp_samples[sample_count - 1];
     float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
           block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
 
     mpc.ambient_xfer_coeff_fan0 = mpc.heater_power * (MPC_MAX) / 255 / (asymp_temp - ambient_temp);
-    mpc.fan255_adjustment = 0.0f;
     mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
     mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
+    TERN_(MPC_INCLUDE_FAN, mpc.fan255_adjustment = 0.0f);
 
     hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
     hotend.modeled_sensor_temp = current_temp;
 
     // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
     SERIAL_ECHOLNPGM(STR_MPC_MEASURING_AMBIENT, hotend.modeled_block_temp);
     TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_MEASURING_AMBIENT), LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT));
     hotend.target = hotend.modeled_block_temp;
     next_test_ms = ms + MPC_dT * 1000;
     constexpr millis_t settle_time = 20000UL, test_duration = 20000UL;

commit b3198ed92942c848bea66a6e41b02ec1d11471ff
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 13 04:05:56 2023 -0500

    ü©π Fix AUTOFAN_CASE
    
    Followup to #25554

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 43ef774948..43bf31e0e7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1283,22 +1283,23 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
             autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
           #endif
           break;
       }
 
       #if BOTH(HAS_FANCHECK, HAS_PWMFANCHECK)
         #define _AUTOFAN_SPEED() fan_check.is_measuring() ? 255 : EXTRUDER_AUTO_FAN_SPEED
       #else
         #define _AUTOFAN_SPEED() EXTRUDER_AUTO_FAN_SPEED
       #endif
-      #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break
-      #define AUTOFAN_CASE(N) OPTCODE(HAS_AUTO_FAN_##N, _AUTOFAN_CASE(N))
+      #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break;
+      #define _AUTOFAN_NOT(N)
+      #define AUTOFAN_CASE(N) TERN(HAS_AUTO_FAN_##N, _AUTOFAN_CASE, _AUTOFAN_NOT)(N)
 
       switch (f) {
         REPEAT(8, AUTOFAN_CASE)
         #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
           case CHAMBER_FAN_INDEX: _UPDATE_AUTO_FAN(CHAMBER, fan_on, CHAMBER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_COOLER_FAN && !AUTO_COOLER_IS_E
           case COOLER_FAN_INDEX: _UPDATE_AUTO_FAN(COOLER, fan_on, COOLER_AUTO_FAN_SPEED); break;
         #endif
       }

commit f53217b2c5bf7d61d21ee6784ec251bc7a670eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:43:01 2023 -0500

    üßë‚Äçüíª Probe flag in do_z_clearance

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 29c3a787c5..43ef774948 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -975,21 +975,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
         ui.reset_status();
 
         temp_hotend[e].target = 0.0f;
         temp_hotend[e].soft_pwm_amount = 0;
         #if HAS_FAN
           set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
           planner.sync_fan_speeds(fan_speed);
         #endif
 
-        do_z_clearance(MPC_TUNING_END_Z);
+        do_z_clearance(MPC_TUNING_END_Z, false);
 
         TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       }
     } on_exit(e);
 
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
     MPCHeaterInfo &hotend = temp_hotend[e];
     MPC_t &mpc = hotend.mpc;
 
     TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);

commit 2c6aff5c79310c1b8222f0c2a26994ac728516f8
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Mar 29 15:36:05 2023 +1300

    üîß Impose Hephestos 2 Bed Kit requirements (#25585)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 180dbbc5ad..29c3a787c5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2623,61 +2623,61 @@ void Temperature::init() {
       #endif
     ));
   #endif
 
   #if ENABLED(MPCTEMP)
     HOTEND_LOOP() temp_hotend[e].modeled_block_temp = NAN;
   #endif
 
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
-      OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
+      OUT_WRITE_OD(HEATER_0_PIN, ENABLED(HEATER_0_INVERTING));
     #else
-      OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
+      OUT_WRITE(HEATER_0_PIN, ENABLED(HEATER_0_INVERTING));
     #endif
   #endif
   #if HAS_HEATER_1
-    OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
+    OUT_WRITE(HEATER_1_PIN, ENABLED(HEATER_1_INVERTING));
   #endif
   #if HAS_HEATER_2
-    OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
+    OUT_WRITE(HEATER_2_PIN, ENABLED(HEATER_2_INVERTING));
   #endif
   #if HAS_HEATER_3
-    OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
+    OUT_WRITE(HEATER_3_PIN, ENABLED(HEATER_3_INVERTING));
   #endif
   #if HAS_HEATER_4
-    OUT_WRITE(HEATER_4_PIN, HEATER_4_INVERTING);
+    OUT_WRITE(HEATER_4_PIN, ENABLED(HEATER_4_INVERTING));
   #endif
   #if HAS_HEATER_5
-    OUT_WRITE(HEATER_5_PIN, HEATER_5_INVERTING);
+    OUT_WRITE(HEATER_5_PIN, ENABLED(HEATER_5_INVERTING));
   #endif
   #if HAS_HEATER_6
-    OUT_WRITE(HEATER_6_PIN, HEATER_6_INVERTING);
+    OUT_WRITE(HEATER_6_PIN, ENABLED(HEATER_6_INVERTING));
   #endif
   #if HAS_HEATER_7
-    OUT_WRITE(HEATER_7_PIN, HEATER_7_INVERTING);
+    OUT_WRITE(HEATER_7_PIN, ENABLED(HEATER_7_INVERTING));
   #endif
 
   #if HAS_HEATED_BED
     #ifdef BOARD_OPENDRAIN_MOSFETS
-      OUT_WRITE_OD(HEATER_BED_PIN, HEATER_BED_INVERTING);
+      OUT_WRITE_OD(HEATER_BED_PIN, ENABLED(HEATER_BED_INVERTING));
     #else
-      OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
+      OUT_WRITE(HEATER_BED_PIN, ENABLED(HEATER_BED_INVERTING));
     #endif
   #endif
 
   #if HAS_HEATED_CHAMBER
-    OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
+    OUT_WRITE(HEATER_CHAMBER_PIN, ENABLED(HEATER_CHAMBER_INVERTING));
   #endif
 
   #if HAS_COOLER
-    OUT_WRITE(COOLER_PIN, COOLER_INVERTING);
+    OUT_WRITE(COOLER_PIN, ENABLED(COOLER_INVERTING));
   #endif
 
   #if HAS_FAN0
     INIT_FAN_PIN(FAN0_PIN);
   #endif
   #if HAS_FAN1
     INIT_FAN_PIN(FAN1_PIN);
   #endif
   #if HAS_FAN2
     INIT_FAN_PIN(FAN2_PIN);

commit 24a9a66f0a238cb59cc6bfc7ff235713eefc3614
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 26 04:36:12 2023 -0500

    üßë‚Äçüíª Auto Fan / Cooler Fan updates (#25554)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ad467070d1..180dbbc5ad 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1187,58 +1187,69 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     #if HAS_COOLER
       case H_COOLER: return temp_cooler.soft_pwm_amount;
     #endif
     default:
       return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
   }
 }
 
-#define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
-
 #if HAS_AUTO_FAN
 
+  #define _EFANOVERLAP(I,N) ((I != N) && _FANOVERLAP(I,E##N))
+
   #if EXTRUDER_AUTO_FAN_SPEED != 255
-    #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
+    #define INIT_E_AUTO_FAN_PIN(P) do{ if (PWM_PIN(P)) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else
     #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
   #endif
   #if CHAMBER_AUTO_FAN_SPEED != 255
-    #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
+    #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (PWM_PIN(P)) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else
     #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
   #endif
+  #if COOLER_AUTO_FAN_SPEED != 255
+    #define INIT_COOLER_AUTO_FAN_PIN(P) do{ if (PWM_PIN(P)) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
+  #else
+    #define INIT_COOLER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
+  #endif
 
   #ifndef CHAMBER_FAN_INDEX
     #define CHAMBER_FAN_INDEX HOTENDS
   #endif
 
   void Temperature::update_autofans() {
-    #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
+    #define _EFAN(I,N) _EFANOVERLAP(I,N) ? I :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HAS_MULTI_HOTEND
         #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
         RREPEAT_S(1, HOTENDS, _NEXT_FAN)
       #endif
+      #define _NFAN HOTENDS
       #if HAS_AUTO_CHAMBER_FAN
-        #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
-        , REPEAT(HOTENDS,_CFAN) (HOTENDS)
+        #define _CHFAN(I) _FANOVERLAP(I,CHAMBER) ? I :
+        , (REPEAT(HOTENDS,_CHFAN) (_NFAN))
+        #undef _NFAN
+        #define _NFAN INCREMENT(HOTENDS)
+      #endif
+      #if HAS_AUTO_COOLER_FAN
+        #define _COFAN(I) _FANOVERLAP(I,COOLER) ? I :
+        , (REPEAT(HOTENDS,_COFAN) (_NFAN))
       #endif
     };
 
     uint8_t fanState = 0;
     HOTEND_LOOP() {
-      if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE) {
+      if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
-      }
     }
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
@@ -1255,62 +1266,48 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
     LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
         #if ENABLED(AUTO_POWER_CHAMBER_FAN)
           case CHAMBER_FAN_INDEX:
             chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
             break;
         #endif
+        #if ENABLED(AUTO_POWER_COOLER_FAN)
+          case COOLER_FAN_INDEX:
+            coolerfan_speed = fan_on ? COOLER_AUTO_FAN_SPEED : 0;
+            break;
+        #endif
         default:
           #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
             autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
           #endif
           break;
       }
 
       #if BOTH(HAS_FANCHECK, HAS_PWMFANCHECK)
         #define _AUTOFAN_SPEED() fan_check.is_measuring() ? 255 : EXTRUDER_AUTO_FAN_SPEED
       #else
         #define _AUTOFAN_SPEED() EXTRUDER_AUTO_FAN_SPEED
       #endif
       #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break
+      #define AUTOFAN_CASE(N) OPTCODE(HAS_AUTO_FAN_##N, _AUTOFAN_CASE(N))
 
       switch (f) {
-        #if HAS_AUTO_FAN_0
-          _AUTOFAN_CASE(0);
-        #endif
-        #if HAS_AUTO_FAN_1
-          _AUTOFAN_CASE(1);
-        #endif
-        #if HAS_AUTO_FAN_2
-          _AUTOFAN_CASE(2);
-        #endif
-        #if HAS_AUTO_FAN_3
-          _AUTOFAN_CASE(3);
-        #endif
-        #if HAS_AUTO_FAN_4
-          _AUTOFAN_CASE(4);
-        #endif
-        #if HAS_AUTO_FAN_5
-          _AUTOFAN_CASE(5);
-        #endif
-        #if HAS_AUTO_FAN_6
-          _AUTOFAN_CASE(6);
-        #endif
-        #if HAS_AUTO_FAN_7
-          _AUTOFAN_CASE(7);
-        #endif
+        REPEAT(8, AUTOFAN_CASE)
         #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
           case CHAMBER_FAN_INDEX: _UPDATE_AUTO_FAN(CHAMBER, fan_on, CHAMBER_AUTO_FAN_SPEED); break;
         #endif
+        #if HAS_AUTO_COOLER_FAN && !AUTO_COOLER_IS_E
+          case COOLER_FAN_INDEX: _UPDATE_AUTO_FAN(COOLER, fan_on, COOLER_AUTO_FAN_SPEED); break;
+        #endif
       }
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
@@ -2730,47 +2727,53 @@ void Temperature::init() {
   TERN_(POWER_MONITOR_CURRENT,  hal.adc_enable(POWER_MONITOR_CURRENT_PIN));
   TERN_(POWER_MONITOR_VOLTAGE,  hal.adc_enable(POWER_MONITOR_VOLTAGE_PIN));
 
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
 
   HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
-  #if HAS_AUTO_FAN_0
-    INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
-    INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_2 && !(_EFANOVERLAP(2,0) || _EFANOVERLAP(2,1))
-    INIT_E_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_3 && !(_EFANOVERLAP(3,0) || _EFANOVERLAP(3,1) || _EFANOVERLAP(3,2))
-    INIT_E_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_4 && !(_EFANOVERLAP(4,0) || _EFANOVERLAP(4,1) || _EFANOVERLAP(4,2) || _EFANOVERLAP(4,3))
-    INIT_E_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_5 && !(_EFANOVERLAP(5,0) || _EFANOVERLAP(5,1) || _EFANOVERLAP(5,2) || _EFANOVERLAP(5,3) || _EFANOVERLAP(5,4))
-    INIT_E_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_6 && !(_EFANOVERLAP(6,0) || _EFANOVERLAP(6,1) || _EFANOVERLAP(6,2) || _EFANOVERLAP(6,3) || _EFANOVERLAP(6,4) || _EFANOVERLAP(6,5))
-    INIT_E_AUTO_FAN_PIN(E6_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_FAN_7 && !(_EFANOVERLAP(7,0) || _EFANOVERLAP(7,1) || _EFANOVERLAP(7,2) || _EFANOVERLAP(7,3) || _EFANOVERLAP(7,4) || _EFANOVERLAP(7,5) || _EFANOVERLAP(7,6))
-    INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
-  #endif
-  #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
-    INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
-  #endif
+  #if HAS_AUTO_FAN
+    #define _OREFAN(I,N) || _EFANOVERLAP(I,N)
+    #if HAS_AUTO_FAN_0
+      INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(0,1)
+      INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_2 && !(0 REPEAT2(2, _OREFAN, 2))
+      INIT_E_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_3 && !(0 REPEAT2(3, _OREFAN, 3))
+      INIT_E_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_4 && !(0 REPEAT2(4, _OREFAN, 4))
+      INIT_E_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_5 && !(0 REPEAT2(5, _OREFAN, 5))
+      INIT_E_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_6 && !(0 REPEAT2(6, _OREFAN, 6))
+      INIT_E_AUTO_FAN_PIN(E6_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_FAN_7 && !(0 REPEAT2(7, _OREFAN, 7))
+      INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
+      INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
+    #endif
+    #if HAS_AUTO_COOLER_FAN && !AUTO_COOLER_IS_E
+      INIT_COOLER_AUTO_FAN_PIN(COOLER_AUTO_FAN_PIN);
+    #endif
+  #endif // HAS_AUTO_FAN
 
   #if HAS_HOTEND
     #define _TEMP_MIN_E(NR) do{ \
       const celsius_t tmin_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))), \
                       tmin = _MAX(HEATER_##NR##_MINTEMP, tmin_tmp); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \

commit 2e4bf0ab9b2b4db545665bf976d2e0738c237b80
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 25 18:20:14 2023 -0500

    üé® Rename FAN_PIN to FAN0_PIN (#25568)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ba2563ccdc..ad467070d1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2670,21 +2670,21 @@ void Temperature::init() {
 
   #if HAS_HEATED_CHAMBER
     OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
   #endif
 
   #if HAS_COOLER
     OUT_WRITE(COOLER_PIN, COOLER_INVERTING);
   #endif
 
   #if HAS_FAN0
-    INIT_FAN_PIN(FAN_PIN);
+    INIT_FAN_PIN(FAN0_PIN);
   #endif
   #if HAS_FAN1
     INIT_FAN_PIN(FAN1_PIN);
   #endif
   #if HAS_FAN2
     INIT_FAN_PIN(FAN2_PIN);
   #endif
   #if HAS_FAN3
     INIT_FAN_PIN(FAN3_PIN);
   #endif

commit 7e25e87807c7c3dd213ffa558cf6e6d0383b7650
Author: StevilKnevil <stevilknevil@hotmail.co.uk>
Date:   Sun Mar 19 00:57:34 2023 +0000

    ‚ú® REPORT_ADAPTIVE_FAN_SLOWING (#25537)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cc89d71e50..ba2563ccdc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2969,20 +2969,26 @@ void Temperature::init() {
               scale = 128;
             else if (rdiff <= hysteresis_degc * 0.3335f)
               scale = 96;
             else if (rdiff <= hysteresis_degc * 0.5f)
               scale = 64;
             else if (rdiff <= hysteresis_degc * 0.8f)
               scale = 32;
             else
               scale = 0;
 
+            if (TERN0(REPORT_ADAPTIVE_FAN_SLOWING, DEBUGGING(INFO))) {
+              const uint8_t fss7 = fan_speed_scaler[fan_index] & 0x80;
+              if (fss7 ^ (scale & 0x80))
+                serial_ternary(fss7, F("Adaptive Fan Slowing "), nullptr, F("de"), F("activated.\n"));
+            }
+
             fan_speed_scaler[fan_index] = scale;
           }
         #endif // ADAPTIVE_FAN_SLOWING
 
         const millis_t now = millis();
 
         #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
           if (PENDING(now, variance_timer)) {
             variance += ABS(current - last_temp);
             last_temp = current;

commit e6ac9ff204b09c0a852f71b77417f99ce4f5473a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 18 17:13:06 2023 -0500

    ‚ö°Ô∏è Misc. optimizations

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2bb88320b5..cc89d71e50 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2883,21 +2883,21 @@ void Temperature::init() {
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
    * @param hysteresis_degc  allowed distance from target
    *
    * TODO: Embed the last 3 parameters during init, if not less optimal
    */
-  void Temperature::tr_state_machine_t::run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc) {
+  void Temperature::tr_state_machine_t::run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_float_t hysteresis_degc) {
 
     #if HEATER_IDLE_HANDLER
       // Convert the given heater_id_t to an idle array index
       const IdleIndex idle_index = idle_index_for_id(heater_id);
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
@@ -2952,55 +2952,60 @@ void Temperature::init() {
       case TRInactive: break;
 
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < running_temp) break;
         state = TRStable;
 
       // While the temperature is stable watch for a bad temperature
       case TRStable: {
 
+        const celsius_float_t rdiff = running_temp - current;
+
         #if ENABLED(ADAPTIVE_FAN_SLOWING)
           if (adaptive_fan_slowing && heater_id >= 0) {
-            const int fan_index = _MIN(heater_id, FAN_COUNT - 1);
-            if (fan_speed[fan_index] == 0 || current >= running_temp - (hysteresis_degc * 0.25f))
-              fan_speed_scaler[fan_index] = 128;
-            else if (current >= running_temp - (hysteresis_degc * 0.3335f))
-              fan_speed_scaler[fan_index] = 96;
-            else if (current >= running_temp - (hysteresis_degc * 0.5f))
-              fan_speed_scaler[fan_index] = 64;
-            else if (current >= running_temp - (hysteresis_degc * 0.8f))
-              fan_speed_scaler[fan_index] = 32;
+            const int_fast8_t fan_index = _MIN(heater_id, FAN_COUNT - 1);
+            uint8_t scale;
+            if (fan_speed[fan_index] == 0 || rdiff <= hysteresis_degc * 0.25f)
+              scale = 128;
+            else if (rdiff <= hysteresis_degc * 0.3335f)
+              scale = 96;
+            else if (rdiff <= hysteresis_degc * 0.5f)
+              scale = 64;
+            else if (rdiff <= hysteresis_degc * 0.8f)
+              scale = 32;
             else
-              fan_speed_scaler[fan_index] = 0;
+              scale = 0;
+
+            fan_speed_scaler[fan_index] = scale;
           }
-        #endif
+        #endif // ADAPTIVE_FAN_SLOWING
 
         const millis_t now = millis();
 
         #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
           if (PENDING(now, variance_timer)) {
             variance += ABS(current - last_temp);
             last_temp = current;
           }
           else {
             if (NEAR_ZERO(variance) && variance_timer) { // valid variance monitoring window
               state = TRMalfunction;
               break;
             }
             variance_timer = now + SEC_TO_MS(VARIANCE_WINDOW);
             variance = 0.0;
             last_temp = current;
           }
         #endif
 
-        if (current >= running_temp - hysteresis_degc) {
+        if (rdiff <= hysteresis_degc) {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));

commit 5be895d906d43a64c5e429683d136388d20341e0
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Sat Mar 18 13:43:15 2023 +0200

    üö∏ Temperature Variance Monitor tweaks (#23571)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 578fd112d2..2bb88320b5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2908,25 +2908,32 @@ void Temperature::init() {
       SERIAL_ECHOLNPGM(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
     */
 
     #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
+
+      #ifdef THERMAL_PROTECTION_VARIANCE_MONITOR_PERIOD
+        #define VARIANCE_WINDOW THERMAL_PROTECTION_VARIANCE_MONITOR_PERIOD
+      #else
+        #define VARIANCE_WINDOW period_seconds
+      #endif
+
       if (state == TRMalfunction) { // temperature invariance may continue, regardless of heater state
         variance += ABS(current - last_temp); // no need for detection window now, a single change in variance is enough
         last_temp = current;
         if (!NEAR_ZERO(variance)) {
-          variance_timer = millis() + SEC_TO_MS(period_seconds);
+          variance_timer = millis() + SEC_TO_MS(VARIANCE_WINDOW);
           variance = 0.0;
           state = TRStable; // resume from where we detected the problem
         }
       }
     #endif
 
     if (TERN1(THERMAL_PROTECTION_VARIANCE_MONITOR, state != TRMalfunction)) {
       // If the heater idle timeout expires, restart
       if (TERN0(HEATER_IDLE_HANDLER, heater_idle[idle_index].timed_out)) {
         state = TRInactive;
@@ -2973,21 +2980,21 @@ void Temperature::init() {
         #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
           if (PENDING(now, variance_timer)) {
             variance += ABS(current - last_temp);
             last_temp = current;
           }
           else {
             if (NEAR_ZERO(variance) && variance_timer) { // valid variance monitoring window
               state = TRMalfunction;
               break;
             }
-            variance_timer = now + SEC_TO_MS(period_seconds);
+            variance_timer = now + SEC_TO_MS(VARIANCE_WINDOW);
             variance = 0.0;
             last_temp = current;
           }
         #endif
 
         if (current >= running_temp - hysteresis_degc) {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;

commit fbb1c82bc2acbbe3339e2283a797126b3c3ea515
Author: Piotr Paczy≈Ñski <ppaczyn@gmail.com>
Date:   Sat Mar 18 11:01:10 2023 +0100

    üêõ Prevent MPC E-permm overrun in Load Filament (#25531)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bafade45dd..578fd112d2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -312,20 +312,25 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
  */
 
 #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   constexpr celsius_t Temperature::hotend_maxtemp[HOTENDS];
 
+  #if ENABLED(MPCTEMP)
+    bool MPC::e_paused; // = false
+    int32_t MPC::e_position; // = 0
+  #endif
+
   // Sanity-check max readable temperatures
   #define CHECK_MAXTEMP_(N,M,S) static_assert( \
     S >= 998 || M <= _MAX(TT_NAME(S)[0].celsius, TT_NAME(S)[COUNT(TT_NAME(S)) - 1].celsius) - HOTEND_OVERSHOOT, \
     "HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") is too high for thermistor_" STRINGIFY(S) ".h with HOTEND_OVERSHOOT=" STRINGIFY(HOTEND_OVERSHOOT) ".");
   #define CHECK_MAXTEMP(N) TERN(TEMP_SENSOR_##N##_IS_THERMISTOR, CHECK_MAXTEMP_, CODE_0)(N, HEATER_##N##_MAXTEMP, TEMP_SENSOR_##N)
   REPEAT(HOTENDS, CHECK_MAXTEMP)
 
   #if HAS_PREHEAT
     #define CHECK_PREHEAT__(N,P,T,M) static_assert(T <= M - HOTEND_OVERSHOOT, "PREHEAT_" STRINGIFY(P) "_TEMP_HOTEND (" STRINGIFY(T) ") must be less than HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") - " STRINGIFY(HOTEND_OVERSHOOT) ".");
     #define CHECK_PREHEAT_(N,P) CHECK_PREHEAT__(N, P, PREHEAT_##P##_TEMP_HOTEND, HEATER_##N##_MAXTEMP)
@@ -581,24 +586,20 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif
 
 /**
  * private:
  */
 
 volatile bool Temperature::raw_temps_ready = false;
 
-#if ENABLED(MPCTEMP)
-  int32_t Temperature::mpc_e_position; // = 0
-#endif
-
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
 
 #if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
   constexpr temp_range_t sensor_heater_0 { TEMP_SENSOR_0_RAW_LO_TEMP, TEMP_SENSOR_0_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_1 { TEMP_SENSOR_1_RAW_LO_TEMP, TEMP_SENSOR_1_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_2 { TEMP_SENSOR_2_RAW_LO_TEMP, TEMP_SENSOR_2_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_3 { TEMP_SENSOR_3_RAW_LO_TEMP, TEMP_SENSOR_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
@@ -1504,28 +1505,28 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
       float ambient_xfer_coeff = mpc.ambient_xfer_coeff_fan0;
       #if ENABLED(MPC_INCLUDE_FAN)
         const uint8_t fan_index = TERN(SINGLEFAN, 0, ee);
         const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
         ambient_xfer_coeff += fan_fraction * mpc.fan255_adjustment;
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
-        const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
+        const float e_speed = (e_position - MPC::e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
         // The position can appear to make big jumps when, e.g., homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])
-          mpc_e_position = e_position;
+          MPC::e_position = e_position;
         else if (e_speed > 0.0f) {  // Ignore retract/recover moves
-          ambient_xfer_coeff += e_speed * mpc.filament_heat_capacity_permm;
-          mpc_e_position = e_position;
+          if (!MPC::e_paused) ambient_xfer_coeff += e_speed * mpc.filament_heat_capacity_permm;
+          MPC::e_position = e_position;
         }
       }
 
       // Update the modeled temperatures
       float blocktempdelta = hotend.soft_pwm_amount * mpc.heater_power * (MPC_dT / 127) / mpc.block_heat_capacity;
       blocktempdelta += (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff * MPC_dT / mpc.block_heat_capacity;
       hotend.modeled_block_temp += blocktempdelta;
 
       const float sensortempdelta = (hotend.modeled_block_temp - hotend.modeled_sensor_temp) * (mpc.sensor_responsiveness * MPC_dT);
       hotend.modeled_sensor_temp += sensortempdelta;

commit f50603ff1d380f759addffd2e54ac008ebec5985
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 18 01:22:50 2023 -0500

    üßë‚Äçüíª More IntelliSense-friendly declares

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bc978077f0..bafade45dd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -501,33 +501,41 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #endif
 #if HEATER_IDLE_HANDLER
   Temperature::heater_idle_t Temperature::heater_idle[NR_HEATER_IDLE]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   raw_adc_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP,
             Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
-  TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
-  IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
+  #if WATCH_BED
+    bed_watch_t Temperature::watch_bed; // = { 0 }
+  #endif
+  #if DISABLED(PIDTEMPBED)
+    millis_t Temperature::next_bed_check_ms;
+  #endif
 #endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     millis_t next_cool_check_ms_2 = 0;
     celsius_float_t old_temp = 9999;
     raw_adc_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
               Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
-    TERN_(WATCH_CHAMBER, chamber_watch_t Temperature::watch_chamber{0});
-    IF_DISABLED(PIDTEMPCHAMBER, millis_t Temperature::next_chamber_check_ms);
+    #if WATCH_CHAMBER
+      chamber_watch_t Temperature::watch_chamber; // = { 0 }
+    #endif
+    #if DISABLED(PIDTEMPCHAMBER)
+      millis_t Temperature::next_chamber_check_ms;
+    #endif
   #endif
 #endif
 
 #if HAS_TEMP_COOLER
   cooler_info_t Temperature::temp_cooler; // = { 0 }
   #if HAS_COOLER
     bool flag_cooler_state;
     //bool flag_cooler_excess = false;
     celsius_float_t previous_temp = 9999;
     raw_adc_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,

commit b5836b243ac9321841daa9380d55b298375aaa2e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 17 20:12:36 2023 -0500

    üîß Optional MPC_AUTOTUNE to save 5.5 - 5.8KB

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b572690256..bc978077f0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -573,21 +573,20 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif
 
 /**
  * private:
  */
 
 volatile bool Temperature::raw_temps_ready = false;
 
-
 #if ENABLED(MPCTEMP)
   int32_t Temperature::mpc_e_position; // = 0
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
 
 #if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
   constexpr temp_range_t sensor_heater_0 { TEMP_SENSOR_0_RAW_LO_TEMP, TEMP_SENSOR_0_RAW_HI_TEMP, 0, 16383 },
@@ -918,21 +917,21 @@ volatile bool Temperature::raw_temps_ready = false;
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
-#if ENABLED(MPCTEMP)
+#if ENABLED(MPC_AUTOTUNE)
 
   #if EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
     #define SINGLEFAN 1
   #endif
 
   void Temperature::MPC_autotune(const uint8_t e) {
     auto housekeeping = [] (millis_t &ms, const uint8_t e, celsius_float_t &current_temp, millis_t &next_report_ms) {
       ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
@@ -944,21 +943,20 @@ volatile bool Temperature::raw_temps_ready = false;
         next_report_ms += 1000UL;
 
         print_heater_states(e);
         SERIAL_EOL();
       }
 
       hal.idletask();
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
 
       if (!wait_for_heatup) {
-        SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
         TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
         return true;
       }
 
       return false;
     };
 
     struct OnExit {
       uint8_t e;
@@ -974,21 +972,20 @@ volatile bool Temperature::raw_temps_ready = false;
           set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
           planner.sync_fan_speeds(fan_speed);
         #endif
 
         do_z_clearance(MPC_TUNING_END_Z);
 
         TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       }
     } on_exit(e);
 
-    SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
     MPCHeaterInfo &hotend = temp_hotend[e];
     MPC_t &mpc = hotend.mpc;
 
     TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
 
     // Move to center of bed, just above bed height and cool with max fan
     gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
@@ -1143,42 +1140,41 @@ volatile bool Temperature::raw_temps_ready = false;
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
       mpc.applyFanAdjustment(ambient_xfer_coeff_fan255);
     #endif
 
     // Calculate a new and better asymptotic temperature and re-evaluate the other constants
     asymp_temp = ambient_temp + mpc.heater_power * (MPC_MAX) / 255 / mpc.ambient_xfer_coeff_fan0;
     block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
     mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
     mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
-    SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
     TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_DONE));
 
     #if 0
       SERIAL_ECHOLNPGM("t1_time ", t1_time);
       SERIAL_ECHOLNPGM("sample_count ", sample_count);
       SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
       for (uint8_t i = 0; i < sample_count; i++)
         SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
       SERIAL_ECHOLNPGM("t1 ", t1, " t2 ", t2, " t3 ", t3);
       SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
       SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
     #endif
 
     SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
     SERIAL_ECHOLNPAIR_F("MPC_SENSOR_RESPONSIVENESS ", mpc.sensor_responsiveness, 4);
     SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF ", mpc.ambient_xfer_coeff_fan0, 4);
     TERN_(HAS_FAN, SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF_FAN255 ", ambient_xfer_coeff_fan255, 4));
   }
 
-#endif // MPCTEMP
+#endif // MPC_AUTOTUNE
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     #if HAS_COOLER
@@ -1502,21 +1498,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       #if ENABLED(MPC_INCLUDE_FAN)
         const uint8_t fan_index = TERN(SINGLEFAN, 0, ee);
         const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
         ambient_xfer_coeff += fan_fraction * mpc.fan255_adjustment;
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
         const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
-        // The position can appear to make big jumps when, e.g. homing
+        // The position can appear to make big jumps when, e.g., homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])
           mpc_e_position = e_position;
         else if (e_speed > 0.0f) {  // Ignore retract/recover moves
           ambient_xfer_coeff += e_speed * mpc.filament_heat_capacity_permm;
           mpc_e_position = e_position;
         }
       }
 
       // Update the modeled temperatures
       float blocktempdelta = hotend.soft_pwm_amount * mpc.heater_power * (MPC_dT / 127) / mpc.block_heat_capacity;

commit df44424388ee5b2105270ad7086c37f84263dc5a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 21 15:08:25 2023 -0600

    üßë‚Äçüíª Fix preheat tests (nested macro limit ~256)
    
    Followup to #25407

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fc3149d4f0..b572690256 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -310,37 +310,66 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 /**
  * public:
  */
 
 #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
-  const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+  constexpr celsius_t Temperature::hotend_maxtemp[HOTENDS];
 
   // Sanity-check max readable temperatures
   #define CHECK_MAXTEMP_(N,M,S) static_assert( \
     S >= 998 || M <= _MAX(TT_NAME(S)[0].celsius, TT_NAME(S)[COUNT(TT_NAME(S)) - 1].celsius) - HOTEND_OVERSHOOT, \
     "HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") is too high for thermistor_" STRINGIFY(S) ".h with HOTEND_OVERSHOOT=" STRINGIFY(HOTEND_OVERSHOOT) ".");
   #define CHECK_MAXTEMP(N) TERN(TEMP_SENSOR_##N##_IS_THERMISTOR, CHECK_MAXTEMP_, CODE_0)(N, HEATER_##N##_MAXTEMP, TEMP_SENSOR_##N)
   REPEAT(HOTENDS, CHECK_MAXTEMP)
 
   #if HAS_PREHEAT
     #define CHECK_PREHEAT__(N,P,T,M) static_assert(T <= M - HOTEND_OVERSHOOT, "PREHEAT_" STRINGIFY(P) "_TEMP_HOTEND (" STRINGIFY(T) ") must be less than HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") - " STRINGIFY(HOTEND_OVERSHOOT) ".");
-    #define CHECK_PREHEAT_(N,P) CHECK_PREHEAT__(N, P, PREHEAT_##P##_TEMP_HOTEND, HEATER_##N##_MAXTEMP);
-    #define CHECK_PREHEAT(P) REPEAT2(HOTENDS, CHECK_PREHEAT_, P);
-    RREPEAT_1(PREHEAT_COUNT, CHECK_PREHEAT)
-  #endif
+    #define CHECK_PREHEAT_(N,P) CHECK_PREHEAT__(N, P, PREHEAT_##P##_TEMP_HOTEND, HEATER_##N##_MAXTEMP)
+    #define CHECK_PREHEAT(P) REPEAT2(HOTENDS, CHECK_PREHEAT_, P)
+    #if PREHEAT_COUNT >= 1
+      CHECK_PREHEAT(1)
+    #endif
+    #if PREHEAT_COUNT >= 2
+      CHECK_PREHEAT(2)
+    #endif
+    #if PREHEAT_COUNT >= 3
+      CHECK_PREHEAT(3)
+    #endif
+    #if PREHEAT_COUNT >= 4
+      CHECK_PREHEAT(4)
+    #endif
+    #if PREHEAT_COUNT >= 5
+      CHECK_PREHEAT(5)
+    #endif
+    #if PREHEAT_COUNT >= 6
+      CHECK_PREHEAT(6)
+    #endif
+    #if PREHEAT_COUNT >= 7
+      CHECK_PREHEAT(7)
+    #endif
+    #if PREHEAT_COUNT >= 8
+      CHECK_PREHEAT(8)
+    #endif
+    #if PREHEAT_COUNT >= 9
+      CHECK_PREHEAT(9)
+    #endif
+    #if PREHEAT_COUNT >= 10
+      CHECK_PREHEAT(10)
+    #endif
+  #endif // HAS_PREHEAT
 
-#endif
+#endif // HAS_HOTEND
 
 #if HAS_TEMP_REDUNDANT
   redundant_info_t Temperature::temp_redundant;
 #endif
 
 #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
   uint8_t Temperature::autofan_speed[HOTENDS] = ARRAY_N_1(HOTENDS, FAN_OFF_PWM);
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)

commit 03a43786703d84f1b8c6374755b2764aeb9e04eb
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Feb 21 15:25:22 2023 +1300

    üîß Sanity-check hotend max / preheat temps (#25407)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f3a1dc7afe..fc3149d4f0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -310,22 +310,36 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 /**
  * public:
  */
 
 #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
-  #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+
+  // Sanity-check max readable temperatures
+  #define CHECK_MAXTEMP_(N,M,S) static_assert( \
+    S >= 998 || M <= _MAX(TT_NAME(S)[0].celsius, TT_NAME(S)[COUNT(TT_NAME(S)) - 1].celsius) - HOTEND_OVERSHOOT, \
+    "HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") is too high for thermistor_" STRINGIFY(S) ".h with HOTEND_OVERSHOOT=" STRINGIFY(HOTEND_OVERSHOOT) ".");
+  #define CHECK_MAXTEMP(N) TERN(TEMP_SENSOR_##N##_IS_THERMISTOR, CHECK_MAXTEMP_, CODE_0)(N, HEATER_##N##_MAXTEMP, TEMP_SENSOR_##N)
+  REPEAT(HOTENDS, CHECK_MAXTEMP)
+
+  #if HAS_PREHEAT
+    #define CHECK_PREHEAT__(N,P,T,M) static_assert(T <= M - HOTEND_OVERSHOOT, "PREHEAT_" STRINGIFY(P) "_TEMP_HOTEND (" STRINGIFY(T) ") must be less than HEATER_" STRINGIFY(N) "_MAXTEMP (" STRINGIFY(M) ") - " STRINGIFY(HOTEND_OVERSHOOT) ".");
+    #define CHECK_PREHEAT_(N,P) CHECK_PREHEAT__(N, P, PREHEAT_##P##_TEMP_HOTEND, HEATER_##N##_MAXTEMP);
+    #define CHECK_PREHEAT(P) REPEAT2(HOTENDS, CHECK_PREHEAT_, P);
+    RREPEAT_1(PREHEAT_COUNT, CHECK_PREHEAT)
+  #endif
+
 #endif
 
 #if HAS_TEMP_REDUNDANT
   redundant_info_t Temperature::temp_redundant;
 #endif
 
 #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
   uint8_t Temperature::autofan_speed[HOTENDS] = ARRAY_N_1(HOTENDS, FAN_OFF_PWM);
 #endif
 

commit c421a2f5dd8e32e48afadee304301befaf40fd49
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Feb 12 07:35:19 2023 +0100

    ‚ú® M306 E for MPC extruder index (#25326)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4b0ee355d4..f3a1dc7afe 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -877,132 +877,138 @@ volatile bool Temperature::raw_temps_ready = false;
 
     EXIT_M303:
       TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPCTEMP)
 
-  void Temperature::MPC_autotune() {
-    auto housekeeping = [] (millis_t &ms, celsius_float_t &current_temp, millis_t &next_report_ms) {
+  #if EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND)
+    #define SINGLEFAN 1
+  #endif
+
+  void Temperature::MPC_autotune(const uint8_t e) {
+    auto housekeeping = [] (millis_t &ms, const uint8_t e, celsius_float_t &current_temp, millis_t &next_report_ms) {
       ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
-        current_temp = degHotend(active_extruder);
+        current_temp = degHotend(e);
         TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
       }
 
       if (ELAPSED(ms, next_report_ms)) {
         next_report_ms += 1000UL;
 
-        print_heater_states(active_extruder);
+        print_heater_states(e);
         SERIAL_EOL();
       }
 
       hal.idletask();
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
 
       if (!wait_for_heatup) {
         SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
         TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
         return true;
       }
 
       return false;
     };
 
     struct OnExit {
+      uint8_t e;
+      OnExit(const uint8_t _e) { this->e = _e; }
       ~OnExit() {
         wait_for_heatup = false;
 
         ui.reset_status();
 
-        temp_hotend[active_extruder].target = 0.0f;
-        temp_hotend[active_extruder].soft_pwm_amount = 0;
+        temp_hotend[e].target = 0.0f;
+        temp_hotend[e].soft_pwm_amount = 0;
         #if HAS_FAN
-          set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
+          set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
           planner.sync_fan_speeds(fan_speed);
         #endif
 
         do_z_clearance(MPC_TUNING_END_Z);
 
         TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       }
-    } on_exit;
+    } on_exit(e);
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
-    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, active_extruder);
-    MPCHeaterInfo &hotend = temp_hotend[active_extruder];
+    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, e);
+    MPCHeaterInfo &hotend = temp_hotend[e];
     MPC_t &mpc = hotend.mpc;
 
     TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
 
     // Move to center of bed, just above bed height and cool with max fan
     gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
-      set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
+      set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
     #if ENABLED(DWIN_LCD_PROUI)
       DWIN_MPCTuning(MPCTEMP_START);
       LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT);
     #else
       LCD_MESSAGE(MSG_COOLING);
     #endif
 
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
-    celsius_float_t current_temp = degHotend(active_extruder),
+    celsius_float_t current_temp = degHotend(e),
                     ambient_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (housekeeping(ms, current_temp, next_report_ms)) return;
+      if (housekeeping(ms, e, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
     wait_for_heatup = false;
 
     #if HAS_FAN
-      set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
+      set_fan_speed(TERN(SINGLEFAN, 0, e), 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     hotend.modeled_ambient_temp = ambient_temp;
 
     SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
     TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
     hotend.target = 200.0f;   // So M105 looks nice
     hotend.soft_pwm_amount = (MPC_MAX) >> 1;
     const millis_t heat_start_time = next_test_ms = ms;
     celsius_float_t temp_samples[16];
     uint8_t sample_count = 0;
     uint16_t sample_distance = 1;
     float t1_time = 0;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (housekeeping(ms, current_temp, next_report_ms)) return;
+      if (housekeeping(ms, e, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         // Record samples between 100C and 200C
         if (current_temp >= 100.0f) {
           // If there are too many samples, space them more widely
           if (sample_count == COUNT(temp_samples)) {
             for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
               temp_samples[i] = temp_samples[i*2];
             sample_count /= 2;
             sample_distance *= 2;
@@ -1047,30 +1053,30 @@ volatile bool Temperature::raw_temps_ready = false;
              test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (housekeeping(ms, current_temp, next_report_ms)) return;
+      if (housekeeping(ms, e, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
-        hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
+        hotend.soft_pwm_amount = (int)get_pid_output_hotend(e) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
-            set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
+            set_fan_speed(TERN(SINGLEFAN, 0, e), 255);
             planner.sync_fan_speeds(fan_speed);
             settle_end_ms = ms + settle_time;
             test_end_ms = settle_end_ms + test_duration;
             fan0_done = true;
           }
           else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
             total_energy_fan255 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #endif
         else if (ELAPSED(ms, test_end_ms)) break;
 
@@ -1444,21 +1450,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       }
 
       #if HOTENDS == 1
         constexpr bool this_hotend = true;
       #else
         const bool this_hotend = (ee == active_extruder);
       #endif
 
       float ambient_xfer_coeff = mpc.ambient_xfer_coeff_fan0;
       #if ENABLED(MPC_INCLUDE_FAN)
-        const uint8_t fan_index = EITHER(MPC_FAN_0_ACTIVE_HOTEND, MPC_FAN_0_ALL_HOTENDS) ? 0 : ee;
+        const uint8_t fan_index = TERN(SINGLEFAN, 0, ee);
         const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
         ambient_xfer_coeff += fan_fraction * mpc.fan255_adjustment;
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
         const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
         // The position can appear to make big jumps when, e.g. homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])

commit 3be967bcb4f2e66500756163ebd036b7d235af1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 1 02:19:47 2023 -0600

    ü©π PID / MPC heating followup
    
    Followup to #25314

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d5508401de..4b0ee355d4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -900,25 +900,24 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_EOL();
       }
 
       hal.idletask();
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
 
       if (!wait_for_heatup) {
         SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
         TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
-        return false;
+        return true;
       }
 
-      wait_for_heatup = false;
-      return true;
+      return false;
     };
 
     struct OnExit {
       ~OnExit() {
         wait_for_heatup = false;
 
         ui.reset_status();
 
         temp_hotend[active_extruder].target = 0.0f;
         temp_hotend[active_extruder].soft_pwm_amount = 0;
@@ -957,52 +956,53 @@ volatile bool Temperature::raw_temps_ready = false;
     #else
       LCD_MESSAGE(MSG_COOLING);
     #endif
 
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
     celsius_float_t current_temp = degHotend(active_extruder),
                     ambient_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (!housekeeping(ms, current_temp, next_report_ms)) return;
+      if (housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
+    wait_for_heatup = false;
 
     #if HAS_FAN
       set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     hotend.modeled_ambient_temp = ambient_temp;
 
     SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
     TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
     hotend.target = 200.0f;   // So M105 looks nice
-    hotend.soft_pwm_amount = MPC_MAX >> 1;
+    hotend.soft_pwm_amount = (MPC_MAX) >> 1;
     const millis_t heat_start_time = next_test_ms = ms;
     celsius_float_t temp_samples[16];
     uint8_t sample_count = 0;
     uint16_t sample_distance = 1;
     float t1_time = 0;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (!housekeeping(ms, current_temp, next_report_ms)) return;
+      if (housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         // Record samples between 100C and 200C
         if (current_temp >= 100.0f) {
           // If there are too many samples, space them more widely
           if (sample_count == COUNT(temp_samples)) {
             for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
               temp_samples[i] = temp_samples[i*2];
             sample_count /= 2;
             sample_distance *= 2;
@@ -1010,20 +1010,22 @@ volatile bool Temperature::raw_temps_ready = false;
 
           if (sample_count == 0) t1_time = float(ms - heat_start_time) / 1000.0f;
           temp_samples[sample_count++] = current_temp;
         }
 
         if (current_temp >= 200.0f) break;
 
         next_test_ms += 1000UL * sample_distance;
       }
     }
+    wait_for_heatup = false;
+
     hotend.soft_pwm_amount = 0;
 
     // Calculate physical constants from three equally-spaced samples
     sample_count = (sample_count + 1) / 2 * 2 - 1;
     const float t1 = temp_samples[0],
                 t2 = temp_samples[(sample_count - 1) >> 1],
                 t3 = temp_samples[sample_count - 1];
     float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
           block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
 
@@ -1045,21 +1047,21 @@ volatile bool Temperature::raw_temps_ready = false;
              test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
-      if (!housekeeping(ms, current_temp, next_report_ms)) return;
+      if (housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
             set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
             planner.sync_fan_speeds(fan_speed);
@@ -1075,20 +1077,21 @@ volatile bool Temperature::raw_temps_ready = false;
         last_temp = current_temp;
         next_test_ms += MPC_dT * 1000;
       }
 
       if (!WITHIN(current_temp, t3 - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
         TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_TEMP_ERROR));
         break;
       }
     }
+    wait_for_heatup = false;
 
     const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
     mpc.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
 
     #if HAS_FAN
       const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
       mpc.applyFanAdjustment(ambient_xfer_coeff_fan255);
     #endif
 

commit d6f4f24658cd6d307d395077020be85ecb0d2210
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Wed Feb 1 07:25:13 2023 +0000

    ü©π Fix PID / MPC heating flags (#25314)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5d4ccc0a51..d5508401de 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -304,21 +304,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   #endif
 
   #undef MAXTC_INIT
 
 #endif
 
 /**
  * public:
  */
 
-#if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
+#if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if HAS_TEMP_REDUNDANT
@@ -681,21 +681,21 @@ volatile bool Temperature::raw_temps_ready = false;
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
     #endif
 
-    TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
+    TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
 
     LCD_MESSAGE(MSG_HEATING);
 
     // PID Tuning loop
     wait_for_heatup = true;
     while (wait_for_heatup) { // Can be interrupted with M108
 
       const millis_t ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
@@ -869,21 +869,21 @@ volatile bool Temperature::raw_temps_ready = false;
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
-      TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
+      TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPCTEMP)
 
   void Temperature::MPC_autotune() {
     auto housekeeping = [] (millis_t &ms, celsius_float_t &current_temp, millis_t &next_report_ms) {
       ms = millis();
@@ -903,45 +903,50 @@ volatile bool Temperature::raw_temps_ready = false;
       hal.idletask();
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
 
       if (!wait_for_heatup) {
         SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
         TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
         return false;
       }
 
+      wait_for_heatup = false;
       return true;
     };
 
     struct OnExit {
       ~OnExit() {
         wait_for_heatup = false;
 
         ui.reset_status();
 
         temp_hotend[active_extruder].target = 0.0f;
         temp_hotend[active_extruder].soft_pwm_amount = 0;
         #if HAS_FAN
           set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
           planner.sync_fan_speeds(fan_speed);
         #endif
 
         do_z_clearance(MPC_TUNING_END_Z);
+
+        TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = true);
       }
     } on_exit;
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, active_extruder);
     MPCHeaterInfo &hotend = temp_hotend[active_extruder];
     MPC_t &mpc = hotend.mpc;
 
+    TERN_(TEMP_TUNING_MAINTAIN_FAN, adaptive_fan_slowing = false);
+
     // Move to center of bed, just above bed height and cool with max fan
     gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
@@ -963,39 +968,39 @@ volatile bool Temperature::raw_temps_ready = false;
 
       if (ELAPSED(ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
-    wait_for_heatup = false;
 
     #if HAS_FAN
       set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     hotend.modeled_ambient_temp = ambient_temp;
 
     SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
     TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
     hotend.target = 200.0f;   // So M105 looks nice
     hotend.soft_pwm_amount = MPC_MAX >> 1;
     const millis_t heat_start_time = next_test_ms = ms;
     celsius_float_t temp_samples[16];
     uint8_t sample_count = 0;
     uint16_t sample_distance = 1;
     float t1_time = 0;
 
+    wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         // Record samples between 100C and 200C
         if (current_temp >= 100.0f) {
           // If there are too many samples, space them more widely
           if (sample_count == COUNT(temp_samples)) {
             for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
               temp_samples[i] = temp_samples[i*2];
@@ -1038,20 +1043,21 @@ volatile bool Temperature::raw_temps_ready = false;
     constexpr millis_t settle_time = 20000UL, test_duration = 20000UL;
     millis_t settle_end_ms = ms + settle_time,
              test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
+    wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
@@ -4117,20 +4123,21 @@ void Temperature::isr() {
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
+      // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         #if HAS_DWIN_E3V2_BASIC
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // Print timer
           dwin_heat_time = elapsed.value;
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
@@ -4255,20 +4262,21 @@ void Temperature::isr() {
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
           first_loop = false;
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
+      // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }
 
       return false;
     }
 
     void Temperature::wait_for_bed_heating() {
@@ -4333,20 +4341,21 @@ void Temperature::isr() {
         }
 
         // Loop until the temperature is very close target
         if (!(wants_to_cool ? isProbeAboveTemp(target_temp) : isProbeBelowTemp(target_temp))) {
             SERIAL_ECHOLN(wants_to_cool ? PSTR("Cooldown") : PSTR("Heatup"));
             SERIAL_ECHOLNPGM(" complete, target probe temperature reached.");
             break;
         }
       }
 
+      // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }
       else if (will_wait)
         SERIAL_ECHOLNPGM("Canceled wait for probe temperature.");
 
       return false;
     }
@@ -4432,20 +4441,21 @@ void Temperature::isr() {
           // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_CHAMBER)) break;
             next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER);
             old_temp = temp;
           }
         }
       } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
 
+      // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }
 
       return false;
     }
 
   #endif // HAS_HEATED_CHAMBER
@@ -4518,33 +4528,34 @@ void Temperature::isr() {
               residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_COOLER_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
         #endif // TEMP_COOLER_RESIDENCY_TIME > 0
 
+        // Prevent a wait-forever situation if R is misused i.e. M191 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
           if (!next_cooling_check_ms || ELAPSED(now, next_cooling_check_ms)) {
             if (previous_temp - current_temp < float(MIN_COOLING_SLOPE_DEG_COOLER)) break;
             next_cooling_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_COOLER);
             previous_temp = current_temp;
           }
         }
 
       } while (wait_for_heatup && TEMP_COOLER_CONDITIONS);
 
-      // Prevent a wait-forever situation if R is misused i.e. M191 R0
+      // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }
 
       return false;
     }
 
   #endif // HAS_COOLER

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 99d5603566..5d4ccc0a51 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -510,20 +510,23 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
 #if BOTH(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
   bool Temperature::allow_cold_extrude_override = false;
 #else
   constexpr bool Temperature::allow_cold_extrude_override;
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
+#else
+  constexpr bool Temperature::allow_cold_extrude;
+  constexpr celsius_t Temperature::extrude_min_temp;
 #endif
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint16_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif

commit b3f65b674f23db5c32e4d7e96ad2dff97c77c717
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Jan 17 18:41:36 2023 -0500

    üö∏ ProUI MPC menu (#25232)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a4f528a4c8..99d5603566 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -896,20 +896,21 @@ volatile bool Temperature::raw_temps_ready = false;
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
 
       hal.idletask();
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
 
       if (!wait_for_heatup) {
         SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
+        TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_INTERRUPTED));
         return false;
       }
 
       return true;
     };
 
     struct OnExit {
       ~OnExit() {
         wait_for_heatup = false;
 
@@ -935,21 +936,26 @@ volatile bool Temperature::raw_temps_ready = false;
     gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
-    LCD_MESSAGE(MSG_COOLING);
+    #if ENABLED(DWIN_LCD_PROUI)
+      DWIN_MPCTuning(MPCTEMP_START);
+      LCD_ALERTMESSAGE(MSG_MPC_COOLING_TO_AMBIENT);
+    #else
+      LCD_MESSAGE(MSG_COOLING);
+    #endif
 
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
     celsius_float_t current_temp = degHotend(active_extruder),
                     ambient_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
@@ -1056,20 +1062,21 @@ volatile bool Temperature::raw_temps_ready = false;
             total_energy_fan255 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #endif
         else if (ELAPSED(ms, test_end_ms)) break;
 
         last_temp = current_temp;
         next_test_ms += MPC_dT * 1000;
       }
 
       if (!WITHIN(current_temp, t3 - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
+        TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_TEMP_ERROR));
         break;
       }
     }
 
     const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
     mpc.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
 
     #if HAS_FAN
       const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
@@ -1077,20 +1084,21 @@ volatile bool Temperature::raw_temps_ready = false;
     #endif
 
     // Calculate a new and better asymptotic temperature and re-evaluate the other constants
     asymp_temp = ambient_temp + mpc.heater_power * (MPC_MAX) / 255 / mpc.ambient_xfer_coeff_fan0;
     block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
     mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
     mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
+    TERN_(DWIN_LCD_PROUI, DWIN_MPCTuning(MPC_DONE));
 
     #if 0
       SERIAL_ECHOLNPGM("t1_time ", t1_time);
       SERIAL_ECHOLNPGM("sample_count ", sample_count);
       SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
       for (uint8_t i = 0; i < sample_count; i++)
         SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
       SERIAL_ECHOLNPGM("t1 ", t1, " t2 ", t2, " t3 ", t3);
       SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
       SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);

commit 6fe387b6f0722033e6cca96fd5e8215ea7b162eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 15 06:48:17 2023 -0600

    üßë‚Äçüíª Adjust PID / MPC / ProUI
    
    Changes to simplify #25232 WIP

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c53fa5df14..a4f528a4c8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -653,27 +653,27 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
-    TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
+    TERN_(DWIN_PID_TUNE, DWIN_PidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-      TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+      TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
@@ -753,21 +753,21 @@ volatile bool Temperature::raw_temps_ready = false;
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-        TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
@@ -790,21 +790,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
-        TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TUNING_TIMEOUT));
+        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
@@ -845,51 +845,51 @@ volatile bool Temperature::raw_temps_ready = false;
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-        TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
+        TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-    TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
+    TERN_(DWIN_PID_TUNE, DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPCTEMP)
 
   void Temperature::MPC_autotune() {
-    auto housekeeping = [] (millis_t& ms, celsius_float_t& current_temp, millis_t& next_report_ms) {
+    auto housekeeping = [] (millis_t &ms, celsius_float_t &current_temp, millis_t &next_report_ms) {
       ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
         current_temp = degHotend(active_extruder);
         TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
       }
 
       if (ELAPSED(ms, next_report_ms)) {
         next_report_ms += 1000UL;
 
@@ -922,62 +922,63 @@ volatile bool Temperature::raw_temps_ready = false;
           planner.sync_fan_speeds(fan_speed);
         #endif
 
         do_z_clearance(MPC_TUNING_END_Z);
       }
     } on_exit;
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, active_extruder);
     MPCHeaterInfo &hotend = temp_hotend[active_extruder];
-    MPC_t &constants = hotend.constants;
+    MPC_t &mpc = hotend.mpc;
 
     // Move to center of bed, just above bed height and cool with max fan
     gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
-    const xyz_pos_t tuningpos = MPC_TUNING_POS;
-    do_blocking_move_to(tuningpos);
+    do_blocking_move_to(xyz_pos_t(MPC_TUNING_POS));
 
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
     LCD_MESSAGE(MSG_COOLING);
+
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
     celsius_float_t current_temp = degHotend(active_extruder),
                     ambient_temp = current_temp;
 
     wait_for_heatup = true;
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
+    wait_for_heatup = false;
 
     #if HAS_FAN
       set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     hotend.modeled_ambient_temp = ambient_temp;
 
     SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
-    LCD_MESSAGE(MSG_HEATING);
+    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_HEATING_PAST_200), LCD_MESSAGE(MSG_HEATING));
     hotend.target = 200.0f;   // So M105 looks nice
     hotend.soft_pwm_amount = MPC_MAX >> 1;
     const millis_t heat_start_time = next_test_ms = ms;
     celsius_float_t temp_samples[16];
     uint8_t sample_count = 0;
     uint16_t sample_distance = 1;
     float t1_time = 0;
 
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
@@ -1005,105 +1006,106 @@ volatile bool Temperature::raw_temps_ready = false;
     hotend.soft_pwm_amount = 0;
 
     // Calculate physical constants from three equally-spaced samples
     sample_count = (sample_count + 1) / 2 * 2 - 1;
     const float t1 = temp_samples[0],
                 t2 = temp_samples[(sample_count - 1) >> 1],
                 t3 = temp_samples[sample_count - 1];
     float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
           block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
 
-    constants.ambient_xfer_coeff_fan0 = constants.heater_power * (MPC_MAX) / 255 / (asymp_temp - ambient_temp);
-    constants.fan255_adjustment = 0.0f;
-    constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
-    constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
+    mpc.ambient_xfer_coeff_fan0 = mpc.heater_power * (MPC_MAX) / 255 / (asymp_temp - ambient_temp);
+    mpc.fan255_adjustment = 0.0f;
+    mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
+    mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
     hotend.modeled_sensor_temp = current_temp;
 
     // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
     SERIAL_ECHOLNPGM(STR_MPC_MEASURING_AMBIENT, hotend.modeled_block_temp);
-    LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT);
+    TERN(DWIN_LCD_PROUI, LCD_ALERTMESSAGE(MSG_MPC_MEASURING_AMBIENT), LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT));
     hotend.target = hotend.modeled_block_temp;
     next_test_ms = ms + MPC_dT * 1000;
     constexpr millis_t settle_time = 20000UL, test_duration = 20000UL;
     millis_t settle_end_ms = ms + settle_time,
              test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
-          total_energy_fan0 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
+          total_energy_fan0 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
             set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
             planner.sync_fan_speeds(fan_speed);
             settle_end_ms = ms + settle_time;
             test_end_ms = settle_end_ms + test_duration;
             fan0_done = true;
           }
           else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
-            total_energy_fan255 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
+            total_energy_fan255 += mpc.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * mpc.block_heat_capacity;
         #endif
         else if (ELAPSED(ms, test_end_ms)) break;
 
         last_temp = current_temp;
         next_test_ms += MPC_dT * 1000;
       }
 
       if (!WITHIN(current_temp, t3 - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
         break;
       }
     }
 
     const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
-    constants.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
+    mpc.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
 
     #if HAS_FAN
       const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
-      constants.fan255_adjustment = ambient_xfer_coeff_fan255 - constants.ambient_xfer_coeff_fan0;
+      mpc.applyFanAdjustment(ambient_xfer_coeff_fan255);
     #endif
 
     // Calculate a new and better asymptotic temperature and re-evaluate the other constants
-    asymp_temp = ambient_temp + constants.heater_power * (MPC_MAX) / 255 / constants.ambient_xfer_coeff_fan0;
+    asymp_temp = ambient_temp + mpc.heater_power * (MPC_MAX) / 255 / mpc.ambient_xfer_coeff_fan0;
     block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
-    constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
-    constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
+    mpc.block_heat_capacity = mpc.ambient_xfer_coeff_fan0 / block_responsiveness;
+    mpc.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
 
-    /* <-- add a slash to enable
+    #if 0
       SERIAL_ECHOLNPGM("t1_time ", t1_time);
       SERIAL_ECHOLNPGM("sample_count ", sample_count);
       SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
       for (uint8_t i = 0; i < sample_count; i++)
         SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
       SERIAL_ECHOLNPGM("t1 ", t1, " t2 ", t2, " t3 ", t3);
       SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
       SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
-    //*/
-    SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", constants.block_heat_capacity);
-    SERIAL_ECHOLNPAIR_F("MPC_SENSOR_RESPONSIVENESS ", constants.sensor_responsiveness, 4);
-    SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF ", constants.ambient_xfer_coeff_fan0, 4);
+    #endif
+
+    SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", mpc.block_heat_capacity);
+    SERIAL_ECHOLNPAIR_F("MPC_SENSOR_RESPONSIVENESS ", mpc.sensor_responsiveness, 4);
+    SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF ", mpc.ambient_xfer_coeff_fan0, 4);
     TERN_(HAS_FAN, SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF_FAN255 ", ambient_xfer_coeff_fan255, 4));
   }
 
 #endif // MPCTEMP
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
@@ -1406,80 +1408,80 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       const float pid_output = is_idling ? 0 : hotend_pid[ee].get_pid_output(ee);
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder)
           hotend_pid[ee].debug(temp_hotend[ee].celsius, pid_output, F("E"), ee);
       #endif
 
     #elif ENABLED(MPCTEMP)
 
       MPCHeaterInfo &hotend = temp_hotend[ee];
-      MPC_t &constants = hotend.constants;
+      MPC_t &mpc = hotend.mpc;
 
       // At startup, initialize modeled temperatures
       if (isnan(hotend.modeled_block_temp)) {
         hotend.modeled_ambient_temp = _MIN(30.0f, hotend.celsius);   // Cap initial value at reasonable max room temperature of 30C
         hotend.modeled_block_temp = hotend.modeled_sensor_temp = hotend.celsius;
       }
 
       #if HOTENDS == 1
         constexpr bool this_hotend = true;
       #else
         const bool this_hotend = (ee == active_extruder);
       #endif
 
-      float ambient_xfer_coeff = constants.ambient_xfer_coeff_fan0;
+      float ambient_xfer_coeff = mpc.ambient_xfer_coeff_fan0;
       #if ENABLED(MPC_INCLUDE_FAN)
         const uint8_t fan_index = EITHER(MPC_FAN_0_ACTIVE_HOTEND, MPC_FAN_0_ALL_HOTENDS) ? 0 : ee;
         const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
-        ambient_xfer_coeff += fan_fraction * constants.fan255_adjustment;
+        ambient_xfer_coeff += fan_fraction * mpc.fan255_adjustment;
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
         const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
         // The position can appear to make big jumps when, e.g. homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])
           mpc_e_position = e_position;
         else if (e_speed > 0.0f) {  // Ignore retract/recover moves
-          ambient_xfer_coeff += e_speed * constants.filament_heat_capacity_permm;
+          ambient_xfer_coeff += e_speed * mpc.filament_heat_capacity_permm;
           mpc_e_position = e_position;
         }
       }
 
       // Update the modeled temperatures
-      float blocktempdelta = hotend.soft_pwm_amount * constants.heater_power * (MPC_dT / 127) / constants.block_heat_capacity;
-      blocktempdelta += (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff * MPC_dT / constants.block_heat_capacity;
+      float blocktempdelta = hotend.soft_pwm_amount * mpc.heater_power * (MPC_dT / 127) / mpc.block_heat_capacity;
+      blocktempdelta += (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff * MPC_dT / mpc.block_heat_capacity;
       hotend.modeled_block_temp += blocktempdelta;
 
-      const float sensortempdelta = (hotend.modeled_block_temp - hotend.modeled_sensor_temp) * (constants.sensor_responsiveness * MPC_dT);
+      const float sensortempdelta = (hotend.modeled_block_temp - hotend.modeled_sensor_temp) * (mpc.sensor_responsiveness * MPC_dT);
       hotend.modeled_sensor_temp += sensortempdelta;
 
       // Any delta between hotend.modeled_sensor_temp and hotend.celsius is either model
       // error diverging slowly or (fast) noise. Slowly correct towards this temperature and noise will average out.
       const float delta_to_apply = (hotend.celsius - hotend.modeled_sensor_temp) * (MPC_SMOOTHING_FACTOR);
       hotend.modeled_block_temp += delta_to_apply;
       hotend.modeled_sensor_temp += delta_to_apply;
 
       // Only correct ambient when close to steady state (output power is not clipped or asymptotic temperature is reached)
       if (WITHIN(hotend.soft_pwm_amount, 1, 126) || fabs(blocktempdelta + delta_to_apply) < (MPC_STEADYSTATE * MPC_dT))
         hotend.modeled_ambient_temp += delta_to_apply > 0.f ? _MAX(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : _MIN(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
 
       float power = 0.0;
       if (hotend.target != 0 && !is_idling) {
         // Plan power level to get to target temperature in 2 seconds
-        power = (hotend.target - hotend.modeled_block_temp) * constants.block_heat_capacity / 2.0f;
+        power = (hotend.target - hotend.modeled_block_temp) * mpc.block_heat_capacity / 2.0f;
         power -= (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff;
       }
 
-      float pid_output = power * 254.0f / constants.heater_power + 1.0f;        // Ensure correct quantization into a range of 0 to 127
+      float pid_output = power * 254.0f / mpc.heater_power + 1.0f;        // Ensure correct quantization into a range of 0 to 127
       pid_output = constrain(pid_output, 0, MPC_MAX);
 
       /* <-- add a slash to enable
         static uint32_t nexttime = millis() + 1000;
         if (ELAPSED(millis(), nexttime)) {
           nexttime += 1000;
           SERIAL_ECHOLNPGM("block temp ", hotend.modeled_block_temp,
                            ", celsius ", hotend.celsius,
                            ", blocktempdelta ", blocktempdelta,
                            ", delta_to_apply ", delta_to_apply,

commit 64167dfe79df4ef5f69b2632e3c0cc162fb22914
Author: Powerlated <zjia08@gmail.com>
Date:   Wed Jan 11 00:40:15 2023 -0500

    ‚ú® PREHEAT_TIME_BED_MS (#25146)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d01b4bc142..c53fa5df14 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -554,22 +554,25 @@ volatile bool Temperature::raw_temps_ready = false;
                          sensor_heater_7 { TEMP_SENSOR_7_RAW_LO_TEMP, TEMP_SENSOR_7_RAW_HI_TEMP, 0, 16383 };
 
   temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5, sensor_heater_6, sensor_heater_7);
 #endif
 
 #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
   #define MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR 1
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
-#if MILLISECONDS_PREHEAT_TIME > 0
-  millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
+#if PREHEAT_TIME_HOTEND_MS > 0
+  millis_t Temperature::preheat_end_ms_hotend[HOTENDS] { 0 };
+#endif
+#if HAS_HEATED_BED && PREHEAT_TIME_BED_MS > 0
+  millis_t Temperature::preheat_end_ms_bed = 0;
 #endif
 
 #if HAS_FAN_LOGIC
   constexpr millis_t Temperature::fan_update_interval_ms;
   millis_t Temperature::fan_update_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
@@ -1528,21 +1531,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
         if (degHotend(e) > temp_range[e].maxtemp) maxtemp_error((heater_id_t)e);
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
-      temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
+      temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_hotend_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
             TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
           }
@@ -1602,39 +1605,44 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
         const bool bed_timed_out = heater_idle[IDLE_INDEX_BED].timed_out;
         if (bed_timed_out) {
           temp_bed.soft_pwm_amount = 0;
           if (DISABLED(PIDTEMPBED)) WRITE_HEATER_BED(LOW);
         }
       #else
         constexpr bool bed_timed_out = false;
       #endif
 
       if (!bed_timed_out) {
-        #if ENABLED(PIDTEMPBED)
-          temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
-        #else
-          // Check if temperature is within the correct band
-          if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
-            #if ENABLED(BED_LIMIT_SWITCHING)
-              if (temp_bed.is_above_target((BED_HYSTERESIS) - 1))
-                temp_bed.soft_pwm_amount = 0;
-              else if (temp_bed.is_below_target((BED_HYSTERESIS) - 1))
-                temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
-            #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
-              temp_bed.soft_pwm_amount = temp_bed.is_below_target() ? MAX_BED_POWER >> 1 : 0;
-            #endif
-          }
-          else {
-            temp_bed.soft_pwm_amount = 0;
-            WRITE_HEATER_BED(LOW);
-          }
-        #endif
+        if (is_bed_preheating()) {
+          temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
+        }
+        else {
+          #if ENABLED(PIDTEMPBED)
+            temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
+          #else
+            // Check if temperature is within the correct band
+            if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
+              #if ENABLED(BED_LIMIT_SWITCHING)
+                if (temp_bed.is_above_target((BED_HYSTERESIS) - 1))
+                  temp_bed.soft_pwm_amount = 0;
+                else if (temp_bed.is_below_target((BED_HYSTERESIS) - 1))
+                  temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
+              #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
+                temp_bed.soft_pwm_amount = temp_bed.is_below_target() ? MAX_BED_POWER >> 1 : 0;
+              #endif
+            }
+            else {
+              temp_bed.soft_pwm_amount = 0;
+              WRITE_HEATER_BED(LOW);
+            }
+          #endif
+        }
       }
 
     } while (false);
   }
 
 #endif // HAS_HEATED_BED
 
 #if HAS_HEATED_CHAMBER
 
   void Temperature::manage_heated_chamber(const millis_t &ms) {
@@ -2387,35 +2395,35 @@ void Temperature::updateTemperaturesFromRawValues() {
         maxtemp_error((heater_id_t)e);
 
       /**
       // DEBUG PREHEATING TIME
       SERIAL_ECHOLNPGM("\nExtruder = ", e, " Preheat On/Off = ", is_preheating(e));
       const float test_is_preheating = (preheat_end_time[HOTEND_INDEX] - millis()) * 0.001f;
       if (test_is_preheating < 31) SERIAL_ECHOLNPGM("Extruder = ", e, " Preheat remaining time = ", test_is_preheating, "s", "\n");
       //*/
 
       const bool heater_on = temp_hotend[e].target > 0;
-      if (heater_on && !is_preheating(e) && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
+      if (heater_on && !is_hotend_preheating(e) && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
           mintemp_error((heater_id_t)e);
       }
       else {
         TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
       }
     }
 
   #endif // HAS_HOTEND
 
   #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
     if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) maxtemp_error(H_BED);
-    if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) mintemp_error(H_BED);
+    if (temp_bed.target > 0 && !is_bed_preheating() && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) mintemp_error(H_BED);
   #endif
 
   #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
     if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) maxtemp_error(H_CHAMBER);
     if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) mintemp_error(H_CHAMBER);
   #endif
 
   #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
     if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) maxtemp_error(H_COOLER);
     if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) mintemp_error(H_COOLER);

commit c66b3cf8a429c427c014f33171407c634da735f1
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun Jan 8 04:22:21 2023 -0500

    üö∏ ProUI updates (#25176)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cd76dac326..d01b4bc142 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -650,21 +650,21 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
-    TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
+    TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PIDTEMPBED_START : PIDTEMP_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 

commit 0e72c90f49c8262fac0e6eafa9dde7d20acfe5fc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 3 19:40:23 2023 -0600

    üßë‚Äçüíª Add Temperature::is_above_target

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ead7e97a81..cd76dac326 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1592,36 +1592,39 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
         TERN_(PAUSE_CHANGE_REQD, last_pause_state = paused_for_probing);
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[IDLE_INDEX_BED].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_BED)
         tr_state_machine[RUNAWAY_IND_BED].run(temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
       #endif
 
       #if HEATER_IDLE_HANDLER
-        if (heater_idle[IDLE_INDEX_BED].timed_out) {
+        const bool bed_timed_out = heater_idle[IDLE_INDEX_BED].timed_out;
+        if (bed_timed_out) {
           temp_bed.soft_pwm_amount = 0;
           if (DISABLED(PIDTEMPBED)) WRITE_HEATER_BED(LOW);
         }
-        else
+      #else
+        constexpr bool bed_timed_out = false;
       #endif
-      {
+
+      if (!bed_timed_out) {
         #if ENABLED(PIDTEMPBED)
           temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
         #else
           // Check if temperature is within the correct band
           if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
             #if ENABLED(BED_LIMIT_SWITCHING)
-              if (temp_bed.celsius >= temp_bed.target + BED_HYSTERESIS)
+              if (temp_bed.is_above_target((BED_HYSTERESIS) - 1))
                 temp_bed.soft_pwm_amount = 0;
-              else if (temp_bed.is_below_target(-(BED_HYSTERESIS) + 1))
+              else if (temp_bed.is_below_target((BED_HYSTERESIS) - 1))
                 temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
             #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
               temp_bed.soft_pwm_amount = temp_bed.is_below_target() ? MAX_BED_POWER >> 1 : 0;
             #endif
           }
           else {
             temp_bed.soft_pwm_amount = 0;
             WRITE_HEATER_BED(LOW);
           }
         #endif
@@ -1634,21 +1637,21 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
 #if HAS_HEATED_CHAMBER
 
   void Temperature::manage_heated_chamber(const millis_t &ms) {
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-      if (degChamber() > CHAMBER_MAXTEMP) maxtemp_error(H_CHAMBER);
+      if (degChamber() > (CHAMBER_MAXTEMP)) maxtemp_error(H_CHAMBER);
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
         if (watch_chamber.check(degChamber()))  // Increased enough? Error below.
           start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
           _temp_error(H_CHAMBER, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
       }
@@ -1662,54 +1665,53 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       static bool flag_chamber_off; // = false
 
       if (temp_chamber.target > CHAMBER_MINTEMP) {
         flag_chamber_off = false;
 
         #if ENABLED(CHAMBER_FAN)
           int16_t fan_chamber_pwm;
           #if CHAMBER_FAN_MODE == 0
             fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
-            fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
+            fan_chamber_pwm = temp_chamber.is_above_target() ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
-            if (temp_chamber.soft_pwm_amount)
-              fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
+            if (temp_chamber.soft_pwm_amount) fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #elif CHAMBER_FAN_MODE == 3
-            fan_chamber_pwm = CHAMBER_FAN_BASE + _MAX((CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target), 0);
+            fan_chamber_pwm = (CHAMBER_FAN_BASE) + _MAX((CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target), 0);
           #endif
           NOMORE(fan_chamber_pwm, 255);
           set_fan_speed(CHAMBER_FAN_INDEX, fan_chamber_pwm);
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
-          if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {
+          if (!flag_chamber_excess_heat && temp_chamber.is_above_target((HIGH_EXCESS_HEAT_LIMIT) - 1)) {
             // Open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds if the
             // temperature didn't drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             if (next_cool_check_ms_2 == 0 || ELAPSED(ms, next_cool_check_ms_2)) {
               if (temp_chamber.celsius - old_temp > MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)
                 flag_chamber_excess_heat = true; // the bed is heating the chamber too much
               next_cool_check_ms_2 = ms + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER_VENT);
               old_temp = temp_chamber.celsius;
             }
           }
           else {
             next_cool_check_ms_2 = 0;
             old_temp = 9999;
           }
-          if (flag_chamber_excess_heat && (temp_chamber.target - temp_chamber.celsius >= LOW_EXCESS_HEAT_LIMIT))
+          if (flag_chamber_excess_heat && temp_chamber.is_above_target((LOW_EXCESS_HEAT_LIMIT) - 1))
             flag_chamber_excess_heat = false;
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
           set_fan_speed(CHAMBER_FAN_INDEX, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
@@ -1727,23 +1729,23 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
         if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
           if (flag_chamber_excess_heat) {
             temp_chamber.soft_pwm_amount = 0;
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(temp_chamber.is_below_target() ? 0 : 90);
             #endif
           }
           else {
             #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-              if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
+              if (temp_chamber.is_above_target((TEMP_CHAMBER_HYSTERESIS) - 1))
                 temp_chamber.soft_pwm_amount = 0;
-              else if (temp_chamber.is_below_target(-(TEMP_CHAMBER_HYSTERESIS) + 1))
+              else if (temp_chamber.is_below_target((TEMP_CHAMBER_HYSTERESIS) - 1))
                 temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
             #else
               temp_chamber.soft_pwm_amount = temp_chamber.is_below_target() ? (MAX_CHAMBER_POWER) >> 1 : 0;
             #endif
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(0);
             #endif
           }
         }
         else {
@@ -1781,34 +1783,32 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
     if (cooler.enabled) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
       if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
       if (ELAPSED(ms, next_cooler_check_ms)) {
         next_cooler_check_ms = ms + COOLER_CHECK_INTERVAL;
-        if (temp_cooler.celsius > temp_cooler.target) {
-          temp_cooler.soft_pwm_amount = temp_cooler.celsius > temp_cooler.target ? MAX_COOLER_POWER : 0;
-          flag_cooler_state = temp_cooler.soft_pwm_amount > 0 ? true : false; // used to allow M106 fan control when cooler is disabled
+        if (temp_cooler.is_above_target()) { // too warm?
+          temp_cooler.soft_pwm_amount = MAX_COOLER_POWER;
           #if ENABLED(COOLER_FAN)
-            int16_t fan_cooler_pwm = (COOLER_FAN_BASE) + (COOLER_FAN_FACTOR) * ABS(temp_cooler.celsius - temp_cooler.target);
-            NOMORE(fan_cooler_pwm, 255);
-            set_fan_speed(COOLER_FAN_INDEX, fan_cooler_pwm); // Set cooler fan pwm
+            const int16_t fan_cooler_pwm = (COOLER_FAN_BASE) + (COOLER_FAN_FACTOR) * ABS(temp_cooler.celsius - temp_cooler.target);
+            set_fan_speed(COOLER_FAN_INDEX, _MIN(fan_cooler_pwm, 255)); // Set cooler fan pwm
             cooler_fan_flush_ms = ms + 5000;
           #endif
         }
         else {
           temp_cooler.soft_pwm_amount = 0;
           #if ENABLED(COOLER_FAN)
-            set_fan_speed(COOLER_FAN_INDEX, temp_cooler.celsius > temp_cooler.target - 2 ? COOLER_FAN_BASE : 0);
+            set_fan_speed(COOLER_FAN_INDEX, temp_cooler.is_above_target(-2) ? COOLER_FAN_BASE : 0);
           #endif
           WRITE_HEATER_COOLER(LOW);
         }
       }
     }
     else {
       temp_cooler.soft_pwm_amount = 0;
       if (flag_cooler_state) {
         flag_cooler_state = false;
         thermalManager.set_fan_speed(COOLER_FAN_INDEX, 0);

commit 2dcf3b8550a7aae34923ad95ace3ee59de47bccd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 3 18:57:33 2023 -0600

    üé® Rename *_temp_error to *temp_error

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d7c31ebbeb..ead7e97a81 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1307,28 +1307,28 @@ void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_m
         ++killed;
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
-void Temperature::max_temp_error(const heater_id_t heater_id) {
+void Temperature::maxtemp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(1);
   #endif
   _temp_error(heater_id, F(STR_T_MAXTEMP), GET_TEXT_F(MSG_ERR_MAXTEMP));
 }
 
-void Temperature::min_temp_error(const heater_id_t heater_id) {
+void Temperature::mintemp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(0);
   #endif
   _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
 
 #if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
 
@@ -1518,21 +1518,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
     return pid_output;
   }
 
 #endif // PIDTEMPCHAMBER
 
 #if HAS_HOTEND
 
   void Temperature::manage_hotends(const millis_t &ms) {
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
+        if (degHotend(e) > temp_range[e].maxtemp) maxtemp_error((heater_id_t)e);
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
@@ -1552,21 +1552,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
     } // HOTEND_LOOP
   }
 
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
 
   void Temperature::manage_heated_bed(const millis_t &ms) {
 
     #if ENABLED(THERMAL_PROTECTION_BED)
-      if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
+      if (degBed() > BED_MAXTEMP) maxtemp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         if (watch_bed.check(degBed()))          // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
           TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
           _temp_error(H_BED, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
@@ -1634,21 +1634,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
 
 #if HAS_HEATED_CHAMBER
 
   void Temperature::manage_heated_chamber(const millis_t &ms) {
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-      if (degChamber() > CHAMBER_MAXTEMP) max_temp_error(H_CHAMBER);
+      if (degChamber() > CHAMBER_MAXTEMP) maxtemp_error(H_CHAMBER);
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
         if (watch_chamber.check(degChamber()))  // Increased enough? Error below.
           start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
           _temp_error(H_CHAMBER, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
       }
@@ -1761,21 +1761,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
 
 #if HAS_COOLER
 
   void Temperature::manage_cooler(const millis_t &ms) {
 
     #ifndef COOLER_CHECK_INTERVAL
       #define COOLER_CHECK_INTERVAL 2000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
-      if (degCooler() > COOLER_MAXTEMP) max_temp_error(H_COOLER);
+      if (degCooler() > COOLER_MAXTEMP) maxtemp_error(H_COOLER);
     #endif
 
     #if WATCH_COOLER
       // Make sure temperature is decreasing
       if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
         if (degCooler() > watch_cooler.target)    // Failed to decrease enough?
           _temp_error(H_COOLER, GET_TEXT_F(MSG_COOLING_FAILED), GET_TEXT_F(MSG_COOLING_FAILED));
         else
           start_watching_cooler();                 // Start again if the target is still far off
       }
@@ -1853,34 +1853,34 @@ void Temperature::task() {
         card.flag.abort_sd_printing = true;
         gcode.process_subcommands_now(F("M524"));
       }
     #endif
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_IS_MAX_TC(0)
-      if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
-      if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
+      if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) maxtemp_error(H_E0);
+      if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) mintemp_error(H_E0);
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(1)
-      if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
-      if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
+      if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) maxtemp_error(H_E1);
+      if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) mintemp_error(H_E1);
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(2)
-      if (degHotend(2) > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.0)) max_temp_error(H_E2);
-      if (degHotend(2) < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + .01)) min_temp_error(H_E2);
+      if (degHotend(2) > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.0)) maxtemp_error(H_E2);
+      if (degHotend(2) < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + .01)) mintemp_error(H_E2);
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
-      if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
-      if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
+      if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) maxtemp_error(H_REDUNDANT);
+      if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) mintemp_error(H_REDUNDANT);
     #endif
   #else
     #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
   #endif
 
   const millis_t ms = millis();
 
   // Handle Hotend Temp Errors, Heating Watch, etc.
   TERN_(HAS_HOTEND, manage_hotends(ms));
 
@@ -2377,60 +2377,60 @@ void Temperature::updateTemperaturesFromRawValues() {
       #if HOTENDS > 3
         #define _TEMPDIR(N) , TEMPDIR(N)
         REPEAT_S(3, HOTENDS, _TEMPDIR)
       #endif
     };
 
     HOTEND_LOOP() {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
-        max_temp_error((heater_id_t)e);
+        maxtemp_error((heater_id_t)e);
 
       /**
       // DEBUG PREHEATING TIME
       SERIAL_ECHOLNPGM("\nExtruder = ", e, " Preheat On/Off = ", is_preheating(e));
       const float test_is_preheating = (preheat_end_time[HOTEND_INDEX] - millis()) * 0.001f;
       if (test_is_preheating < 31) SERIAL_ECHOLNPGM("Extruder = ", e, " Preheat remaining time = ", test_is_preheating, "s", "\n");
       //*/
 
       const bool heater_on = temp_hotend[e].target > 0;
       if (heater_on && !is_preheating(e) && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
-          min_temp_error((heater_id_t)e);
+          mintemp_error((heater_id_t)e);
       }
       else {
         TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
       }
     }
 
   #endif // HAS_HOTEND
 
   #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
-    if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) max_temp_error(H_BED);
-    if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) min_temp_error(H_BED);
+    if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) maxtemp_error(H_BED);
+    if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) mintemp_error(H_BED);
   #endif
 
   #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
-    if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
-    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) min_temp_error(H_CHAMBER);
+    if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) maxtemp_error(H_CHAMBER);
+    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) mintemp_error(H_CHAMBER);
   #endif
 
   #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
-    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
-    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) min_temp_error(H_COOLER);
+    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) maxtemp_error(H_COOLER);
+    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) mintemp_error(H_COOLER);
   #endif
 
   #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
-    if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) max_temp_error(H_BOARD);
-    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) min_temp_error(H_BOARD);
+    if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) maxtemp_error(H_BOARD);
+    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) mintemp_error(H_BOARD);
   #endif
   #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to task()
  *
@@ -3131,21 +3131,21 @@ void Temperature::disable_all_heaters() {
         max_tc_temp = max855ref.readRaw32();
       #endif
 
       #if HAS_MAX31865
         MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1, max31865_2);
         max_tc_temp = TERN(LIB_INTERNAL_MAX31865, max865ref.readRaw(), max865ref.readRTD_with_Fault());
       #endif
     #endif
 
     // Handle an error. If there have been more than THERMOCOUPLE_MAX_ERRORS, send an error over serial.
-    // Either way, return the TMAX for the thermocouple to trigger a max_temp_error()
+    // Either way, return the TMAX for the thermocouple to trigger a maxtemp_error()
     if (max_tc_temp & MAX_TC_ERROR_MASK) {
       max_tc_errors[hindex]++;
 
       if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
         #if HAS_MAX31855
           SERIAL_ECHOPGM("MAX31855 Fault: (", max_tc_temp & 0x7, ") >> ");
           if (max_tc_temp & 0x1)
             SERIAL_ECHOLNPGM("Open Circuit");

commit c7e84e8ef145a35b2c90e1a6f1d908929cc46d83
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Dec 31 15:59:13 2022 +1300

    ‚ú® Persistent AUTOTEMP settings (#25093)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b88f19a86b..d7c31ebbeb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2923,21 +2923,21 @@ void Temperature::init() {
     }
   }
 
   #pragma GCC diagnostic pop
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   // Disable autotemp, unpause and reset everything
-  TERN_(AUTOTEMP, planner.autotemp_enabled = false);
+  TERN_(AUTOTEMP, planner.autotemp.enabled = false);
   TERN_(PROBING_HEATERS_OFF, pause_heaters(false));
 
   #if HAS_HOTEND
     HOTEND_LOOP() {
       setTargetHotend(0, e);
       temp_hotend[e].soft_pwm_amount = 0;
     }
   #endif
 
   #if HAS_TEMP_HOTEND
@@ -3998,21 +3998,21 @@ void Temperature::isr() {
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60
     #endif
 
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/
       OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel/*=false*/)
     ) {
       #if ENABLED(AUTOTEMP)
-        REMEMBER(1, planner.autotemp_enabled, false);
+        REMEMBER(1, planner.autotemp.enabled, false);
       #endif
 
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))

commit 5200b36ae44a814963bba0d68c4b76364dc98847
Author: MarkMan0 <38912829+MarkMan0@users.noreply.github.com>
Date:   Sun Dec 18 06:48:33 2022 +0100

    üêõ Fix, Refactor PID scaling (#25096)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fb3953841b..b88f19a86b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -527,24 +527,20 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif
 
 /**
  * private:
  */
 
 volatile bool Temperature::raw_temps_ready = false;
 
-#if ENABLED(PID_EXTRUSION_SCALING)
-  int32_t Temperature::pes_e_position, Temperature::lpq[LPQ_MAX_LEN];
-  lpq_ptr_t Temperature::lpq_ptr = 0;
-#endif
 
 #if ENABLED(MPCTEMP)
   int32_t Temperature::mpc_e_position; // = 0
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
 
 #if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
@@ -1331,103 +1327,87 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
   #endif
   _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
 
 #if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
 
 #if HAS_PID_HEATING
 
-  template<typename TT, int MIN_POW, int MAX_POW>
+  template<typename TT>
   class PIDRunner {
   public:
     TT &tempinfo;
-    __typeof__(TT::pid) work_pid{0};
-    float temp_iState = 0, temp_dState = 0;
-    bool pid_reset = true;
 
     PIDRunner(TT &t) : tempinfo(t) { }
 
-    float get_pid_output() {
-
+    float get_pid_output(const uint8_t extr=0) {
       #if ENABLED(PID_OPENLOOP)
 
         return constrain(tempinfo.target, 0, MAX_POW);
 
       #else // !PID_OPENLOOP
 
-        const float pid_error = tempinfo.target - tempinfo.celsius;
-        if (!tempinfo.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
-          pid_reset = true;
-          return 0;
-        }
-        else if (pid_error > PID_FUNCTIONAL_RANGE) {
-          pid_reset = true;
-          return MAX_POW;
-        }
+        float out = tempinfo.pid.get_pid_output(tempinfo.target, tempinfo.celsius);
 
-        if (pid_reset) {
-          pid_reset = false;
-          temp_iState = 0.0;
-          work_pid.Kd = 0.0;
-        }
-
-        const float max_power_over_i_gain = float(MAX_POW) / tempinfo.pid.Ki - float(MIN_POW);
-        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
-
-        work_pid.Kp = tempinfo.pid.Kp * pid_error;
-        work_pid.Ki = tempinfo.pid.Ki * temp_iState;
-        work_pid.Kd = work_pid.Kd + PID_K2 * (tempinfo.pid.Kd * (temp_dState - tempinfo.celsius) - work_pid.Kd);
+        #if ENABLED(PID_FAN_SCALING)
+          out += tempinfo.pid.get_fan_scale_output(thermalManager.fan_speed[extr]);
+        #endif
 
-        temp_dState = tempinfo.celsius;
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          out += tempinfo.pid.get_extrusion_scale_output(
+            extr == active_extruder, stepper.position(E_AXIS), planner.mm_per_step[E_AXIS], thermalManager.lpq_len
+          );
+        #endif
 
-        return constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_POW), 0, MAX_POW);
+        return constrain(out, tempinfo.pid.low(), tempinfo.pid.high());
 
       #endif // !PID_OPENLOOP
     }
 
     FORCE_INLINE void debug(const_celsius_float_t c, const_float_t pid_out, FSTR_P const name=nullptr, const int8_t index=-1) {
       if (TERN0(HAS_PID_DEBUG, thermalManager.pid_debug_flag)) {
         SERIAL_ECHO_START();
         if (name) SERIAL_ECHOF(name);
         if (index >= 0) SERIAL_ECHO(index);
         SERIAL_ECHOLNPGM(
           STR_PID_DEBUG_INPUT, c,
           STR_PID_DEBUG_OUTPUT, pid_out
           #if DISABLED(PID_OPENLOOP)
-            , " pTerm ", work_pid.Kp, " iTerm ", work_pid.Ki, " dTerm ", work_pid.Kd
+            , " pTerm ", tempinfo.pid.pTerm(), " iTerm ", tempinfo.pid.iTerm(), " dTerm ", tempinfo.pid.dTerm()
+            , " cTerm ", tempinfo.pid.cTerm(), " fTerm ", tempinfo.pid.fTerm()
           #endif
         );
       }
     }
   };
 
 #endif // HAS_PID_HEATING
 
 #if HAS_HOTEND
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
 
     const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
 
     #if ENABLED(PIDTEMP)
 
-      typedef PIDRunner<hotend_info_t, 0, PID_MAX> PIDRunnerHotend;
+      typedef PIDRunner<hotend_info_t> PIDRunnerHotend;
 
       static PIDRunnerHotend hotend_pid[HOTENDS] = {
         #define _HOTENDPID(E) temp_hotend[E],
         REPEAT(HOTENDS, _HOTENDPID)
       };
 
-      const float pid_output = is_idling ? 0 : hotend_pid[ee].get_pid_output();
+      const float pid_output = is_idling ? 0 : hotend_pid[ee].get_pid_output(ee);
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder)
           hotend_pid[ee].debug(temp_hotend[ee].celsius, pid_output, F("E"), ee);
       #endif
 
     #elif ENABLED(MPCTEMP)
 
       MPCHeaterInfo &hotend = temp_hotend[ee];
       MPC_t &constants = hotend.constants;
@@ -1514,32 +1494,32 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
     #endif
 
     return pid_output;
   }
 
 #endif // HAS_HOTEND
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
-    static PIDRunner<bed_info_t, MIN_BED_POWER, MAX_BED_POWER> bed_pid(temp_bed);
+    static PIDRunner<bed_info_t> bed_pid(temp_bed);
     const float pid_output = bed_pid.get_pid_output();
     TERN_(PID_BED_DEBUG, bed_pid.debug(temp_bed.celsius, pid_output, F("(Bed)")));
     return pid_output;
   }
 
 #endif // PIDTEMPBED
 
 #if ENABLED(PIDTEMPCHAMBER)
 
   float Temperature::get_pid_output_chamber() {
-    static PIDRunner<chamber_info_t, MIN_CHAMBER_POWER, MAX_CHAMBER_POWER> chamber_pid(temp_chamber);
+    static PIDRunner<chamber_info_t> chamber_pid(temp_chamber);
     const float pid_output = chamber_pid.get_pid_output();
     TERN_(PID_CHAMBER_DEBUG, chamber_pid.debug(temp_chamber.celsius, pid_output, F("(Chamber)")));
     return pid_output;
   }
 
 #endif // PIDTEMPCHAMBER
 
 #if HAS_HOTEND
 
   void Temperature::manage_hotends(const millis_t &ms) {
@@ -2464,23 +2444,20 @@ void Temperature::updateTemperaturesFromRawValues() {
  *  - Set thermistor pins to analog inputs according to the HAL
  *  - Start the Temperature ISR timer
  *  - Init the AUTO FAN pins as PWM or OUTPUT
  *  - Wait 250ms for temperatures to settle
  *  - Init temp_range[], used for catching min/maxtemp
  */
 void Temperature::init() {
 
   TERN_(PROBING_HEATERS_OFF, paused_for_probing = false);
 
-  #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
-    pes_e_position = 0;
-  #endif
 
   // Init (and disable) SPI thermocouples
   #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && PIN_EXISTS(TEMP_0_CS)
     OUT_WRITE(TEMP_0_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && PIN_EXISTS(TEMP_1_CS)
     OUT_WRITE(TEMP_1_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_ANY_MAX_TC(2) && PIN_EXISTS(TEMP_2_CS)
     OUT_WRITE(TEMP_2_CS_PIN, HIGH);

commit 84ae7d5f729d66af9c11066bc789d9cafe61e36f
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Sun Nov 27 04:29:13 2022 +0100

    üêõ Fix MILLISECONDS_PREHEAT_TIME / mintemp (#24967)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8742cf36df..fb3953841b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2399,22 +2399,29 @@ void Temperature::updateTemperaturesFromRawValues() {
         REPEAT_S(3, HOTENDS, _TEMPDIR)
       #endif
     };
 
     HOTEND_LOOP() {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
         max_temp_error((heater_id_t)e);
 
+      /**
+      // DEBUG PREHEATING TIME
+      SERIAL_ECHOLNPGM("\nExtruder = ", e, " Preheat On/Off = ", is_preheating(e));
+      const float test_is_preheating = (preheat_end_time[HOTEND_INDEX] - millis()) * 0.001f;
+      if (test_is_preheating < 31) SERIAL_ECHOLNPGM("Extruder = ", e, " Preheat remaining time = ", test_is_preheating, "s", "\n");
+      //*/
+
       const bool heater_on = temp_hotend[e].target > 0;
-      if (heater_on && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
+      if (heater_on && !is_preheating(e) && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
           min_temp_error((heater_id_t)e);
       }
       else {
         TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
       }
     }
 
   #endif // HAS_HOTEND
 

commit 00156a3e3139179d505b685809736481d65fa5d4
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon Nov 14 21:35:24 2022 +1300

    ü©π Fix 2 thermocouples (#24982)
    
    Followup to #24898

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 37996a80ea..8742cf36df 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3069,22 +3069,27 @@ void Temperature::disable_all_heaters() {
     #else // MAX6675
       #define MAX_TC_ERROR_MASK    3        // D2 only; 1 = open circuit
       #define MAX_TC_DISCARD_BITS  3        // Data D15-D1
       #define MAX_TC_SPEED_BITS    2        // ~2MHz
     #endif
 
     #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
       static raw_adc_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
       #define THERMO_TEMP(I) max_tc_temp_previous[I]
-      #define THERMO_SEL(A,B,C) (hindex > 1 ? (C) : hindex == 1 ? (B) : (A))
-      #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; case 2: WRITE(TEMP_2_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
+      #if MAX_TC_COUNT > 2
+        #define THERMO_SEL(A,B,C) (hindex > 1 ? (C) : hindex == 1 ? (B) : (A))
+        #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; case 2: WRITE(TEMP_2_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
+      #elif MAX_TC_COUNT > 1
+        #define THERMO_SEL(A,B,C) ( hindex == 1 ? (B) : (A))
+        #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
+      #endif
     #else
       // When we have only 1 max tc, THERMO_SEL will pick the appropriate sensor
       // variable, and MAXTC_*() macros will be hardcoded to the correct CS pin.
       constexpr uint8_t hindex = 0;
       #define THERMO_TEMP(I) max_tc_temp
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         #define THERMO_SEL(A,B,C) A
         #define MAXTC_CS_WRITE(V)  WRITE(TEMP_0_CS_PIN, V)
       #elif TEMP_SENSOR_IS_ANY_MAX_TC(1)
         #define THERMO_SEL(A,B,C) B

commit 726321bc845bb45628a62158059157b455c9d39b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 4 20:10:59 2022 -0500

    ü©π MAX Thermocouple followup
    
    Followup to #24898

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8843582f4e..37996a80ea 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2367,45 +2367,47 @@ void Temperature::updateTemperaturesFromRawValues() {
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.getraw()));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.getraw()));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.getraw()));
   TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.getraw()));
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.getraw()));
 
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
   #if HAS_HOTEND
-    static constexpr int8_t temp_dir[] = {
+    static constexpr int8_t temp_dir[HOTENDS] = {
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         0
       #else
         TEMPDIR(0)
       #endif
       #if HAS_MULTI_HOTEND
         #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
           , 0
         #else
           , TEMPDIR(1)
         #endif
+      #endif
+      #if HOTENDS > 2
         #if TEMP_SENSOR_IS_ANY_MAX_TC(2)
           , 0
         #else
           , TEMPDIR(2)
         #endif
-        #if HOTENDS > 3
-          #define _TEMPDIR(N) , TEMPDIR(N)
-          REPEAT_S(3, HOTENDS, _TEMPDIR)
-        #endif
+      #endif
+      #if HOTENDS > 3
+        #define _TEMPDIR(N) , TEMPDIR(N)
+        REPEAT_S(3, HOTENDS, _TEMPDIR)
       #endif
     };
 
-    LOOP_L_N(e, COUNT(temp_dir)) {
+    HOTEND_LOOP() {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
         max_temp_error((heater_id_t)e);
 
       const bool heater_on = temp_hotend[e].target > 0;
       if (heater_on && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
           min_temp_error((heater_id_t)e);
       }

commit 1b31a7cf2c1b5cc1f7b58041604fa8b8ebb3ffe7
Author: kurtis-potier-geofabrica <77456752+kurtis-potier-geofabrica@users.noreply.github.com>
Date:   Sat Oct 22 00:13:56 2022 -0400

    üö∏ Up to 3 MAX Thermocouples (#24898)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7515396fbe..8843582f4e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -106,43 +106,52 @@
 
 // If we have a MAX TC with SCK and MISO pins defined, it's either on a separate/dedicated Hardware
 // SPI bus, or some pins for Software SPI. Alternate Hardware SPI buses are not supported yet, so
 // your SPI options are:
 //
 //  1. Only CS pin(s) defined:                  Hardware SPI on the default bus (usually the SD card SPI).
 //  2. CS, MISO, and SCK pins defined:          Software SPI on a separate bus, as defined by MISO, SCK.
 //  3. CS, MISO, and SCK pins w/ FORCE_HW_SPI:  Hardware SPI on the default bus, ignoring MISO, SCK.
 //
 #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && TEMP_SENSOR_0_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
-    #define TEMP_SENSOR_0_USES_SW_SPI 1
+  #define TEMP_SENSOR_0_USES_SW_SPI 1
 #endif
 #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && TEMP_SENSOR_1_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
-    #define TEMP_SENSOR_1_USES_SW_SPI 1
+  #define TEMP_SENSOR_1_USES_SW_SPI 1
+#endif
+#if TEMP_SENSOR_IS_ANY_MAX_TC(2) && TEMP_SENSOR_2_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
+  #define TEMP_SENSOR_2_USES_SW_SPI 1
 #endif
 
-#if (TEMP_SENSOR_0_USES_SW_SPI || TEMP_SENSOR_1_USES_SW_SPI) && !HAS_MAXTC_LIBRARIES
+#if (TEMP_SENSOR_0_USES_SW_SPI || TEMP_SENSOR_1_USES_SW_SPI || TEMP_SENSOR_2_USES_SW_SPI) && !HAS_MAXTC_LIBRARIES
   #include "../libs/private_spi.h"
   #define HAS_MAXTC_SW_SPI 1
 
   // Define pins for SPI-based sensors
   #if TEMP_SENSOR_0_USES_SW_SPI
     #define SW_SPI_SCK_PIN    TEMP_0_SCK_PIN
     #define SW_SPI_MISO_PIN   TEMP_0_MISO_PIN
     #if PIN_EXISTS(TEMP_0_MOSI)
       #define SW_SPI_MOSI_PIN TEMP_0_MOSI_PIN
     #endif
-  #else
+  #elif TEMP_SENSOR_1_USES_SW_SPI
     #define SW_SPI_SCK_PIN    TEMP_1_SCK_PIN
     #define SW_SPI_MISO_PIN   TEMP_1_MISO_PIN
     #if PIN_EXISTS(TEMP_1_MOSI)
       #define SW_SPI_MOSI_PIN TEMP_1_MOSI_PIN
     #endif
+  #elif TEMP_SENSOR_2_USES_SW_SPI
+    #define SW_SPI_SCK_PIN    TEMP_2_SCK_PIN
+    #define SW_SPI_MISO_PIN   TEMP_2_MISO_PIN
+    #if PIN_EXISTS(TEMP_2_MOSI)
+      #define SW_SPI_MOSI_PIN TEMP_2_MOSI_PIN
+    #endif
   #endif
   #ifndef SW_SPI_MOSI_PIN
     #define SW_SPI_MOSI_PIN   SD_MOSI_PIN
   #endif
 #endif
 
 #if ENABLED(MPCTEMP)
   #include <math.h>
   #include "probe.h"
 #endif
@@ -249,45 +258,56 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
         OPTARG(LARGE_PINMAP, HIGH) \
       )
 
   #if HAS_MAX6675_LIBRARY
     #if TEMP_SENSOR_IS_MAX(0, 6675)
       MAXTC_INIT(0, 6675);
     #endif
     #if TEMP_SENSOR_IS_MAX(1, 6675)
       MAXTC_INIT(1, 6675);
     #endif
+    #if TEMP_SENSOR_IS_MAX(2, 6675)
+      MAXTC_INIT(2, 6675);
+    #endif
   #endif
 
   #if HAS_MAX31855_LIBRARY
     #if TEMP_SENSOR_IS_MAX(0, 31855)
       MAXTC_INIT(0, 31855);
     #endif
     #if TEMP_SENSOR_IS_MAX(1, 31855)
       MAXTC_INIT(1, 31855);
     #endif
+    #if TEMP_SENSOR_IS_MAX(2, 31855)
+      MAXTC_INIT(2, 31855);
+    #endif
   #endif
 
   // MAX31865 always uses a library, unlike '55 & 6675
   #if HAS_MAX31865
     #define _MAX31865_0_SW TEMP_SENSOR_0_USES_SW_SPI
     #define _MAX31865_1_SW TEMP_SENSOR_1_USES_SW_SPI
+    #define _MAX31865_2_SW TEMP_SENSOR_2_USES_SW_SPI
 
     #if TEMP_SENSOR_IS_MAX(0, 31865)
       MAXTC_INIT(0, 31865);
     #endif
     #if TEMP_SENSOR_IS_MAX(1, 31865)
       MAXTC_INIT(1, 31865);
     #endif
+    #if TEMP_SENSOR_IS_MAX(2, 31865)
+      MAXTC_INIT(2, 31865);
+    #endif
 
     #undef _MAX31865_0_SW
     #undef _MAX31865_1_SW
+    #undef _MAX31865_2_SW
   #endif
 
   #undef MAXTC_INIT
 
 #endif
 
 /**
  * public:
  */
 
@@ -534,20 +554,21 @@ volatile bool Temperature::raw_temps_ready = false;
                          sensor_heater_3 { TEMP_SENSOR_3_RAW_LO_TEMP, TEMP_SENSOR_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_5 { TEMP_SENSOR_5_RAW_LO_TEMP, TEMP_SENSOR_5_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_6 { TEMP_SENSOR_6_RAW_LO_TEMP, TEMP_SENSOR_6_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_7 { TEMP_SENSOR_7_RAW_LO_TEMP, TEMP_SENSOR_7_RAW_HI_TEMP, 0, 16383 };
 
   temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5, sensor_heater_6, sensor_heater_7);
 #endif
 
 #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
+  #define MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR 1
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #if MILLISECONDS_PREHEAT_TIME > 0
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
 #if HAS_FAN_LOGIC
   constexpr millis_t Temperature::fan_update_interval_ms;
   millis_t Temperature::fan_update_ms = 0;
@@ -1859,20 +1880,24 @@ void Temperature::task() {
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_IS_MAX_TC(0)
       if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(1)
       if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
       if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
     #endif
+    #if TEMP_SENSOR_IS_MAX_TC(2)
+      if (degHotend(2) > _MIN(HEATER_2_MAXTEMP, TEMP_SENSOR_2_MAX_TC_TMAX - 1.0)) max_temp_error(H_E2);
+      if (degHotend(2) < _MAX(HEATER_2_MINTEMP, TEMP_SENSOR_2_MAX_TC_TMIN + .01)) min_temp_error(H_E2);
+    #endif
     #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
       if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
       if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
     #endif
   #else
     #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
   #endif
 
   const millis_t ms = millis();
 
@@ -2105,20 +2130,29 @@ void Temperature::task() {
         #elif TEMP_SENSOR_1_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_1_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
         #if TEMP_SENSOR_2_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
+        #elif TEMP_SENSOR_IS_MAX_TC(2)
+          #if TEMP_SENSOR_0_IS_MAX31865
+            return TERN(LIB_INTERNAL_MAX31865,
+              max31865_2.temperature(raw),
+              max31865_2.temperature(MAX31865_SENSOR_OHMS_2, MAX31865_CALIBRATION_OHMS_2)
+            );
+          #else
+            return (int16_t)raw * 0.25;
+          #endif
         #elif TEMP_SENSOR_2_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_2_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 3:
         #if TEMP_SENSOR_3_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_3, raw);
@@ -2274,20 +2308,22 @@ void Temperature::task() {
 
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_redundant(const raw_adc_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E0)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E1)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(raw), (int16_t)raw * 0.25);
+    #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E2)
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_2.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
@@ -2309,20 +2345,23 @@ void Temperature::task() {
 void Temperature::updateTemperaturesFromRawValues() {
 
   hal.watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
   #if TEMP_SENSOR_IS_MAX_TC(0)
     temp_hotend[0].setraw(READ_MAX_TC(0));
   #endif
   #if TEMP_SENSOR_IS_MAX_TC(1)
     temp_hotend[1].setraw(READ_MAX_TC(1));
   #endif
+  #if TEMP_SENSOR_IS_MAX_TC(2)
+    temp_hotend[2].setraw(READ_MAX_TC(2));
+  #endif
   #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
     temp_redundant.setraw(READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE)));
   #endif
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].getraw(), e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.getraw()));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.getraw()));
@@ -2340,44 +2379,46 @@ void Temperature::updateTemperaturesFromRawValues() {
         0
       #else
         TEMPDIR(0)
       #endif
       #if HAS_MULTI_HOTEND
         #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
           , 0
         #else
           , TEMPDIR(1)
         #endif
-        #if HOTENDS > 2
+        #if TEMP_SENSOR_IS_ANY_MAX_TC(2)
+          , 0
+        #else
+          , TEMPDIR(2)
+        #endif
+        #if HOTENDS > 3
           #define _TEMPDIR(N) , TEMPDIR(N)
-          REPEAT_S(2, HOTENDS, _TEMPDIR)
+          REPEAT_S(3, HOTENDS, _TEMPDIR)
         #endif
       #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const raw_adc_t r = temp_hotend[e].getraw();
       const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
       if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
         max_temp_error((heater_id_t)e);
 
       const bool heater_on = temp_hotend[e].target > 0;
       if (heater_on && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
-        #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
-          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
-        #endif
-            min_temp_error((heater_id_t)e);
+        if (TERN1(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, ++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED))
+          min_temp_error((heater_id_t)e);
+      }
+      else {
+        TERN_(MULTI_MAX_CONSECUTIVE_LOW_TEMP_ERR, consecutive_low_temperature_error[e] = 0);
       }
-      #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
-        else
-          consecutive_low_temperature_error[e] = 0;
-      #endif
     }
 
   #endif // HAS_HOTEND
 
   #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
     if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) max_temp_error(H_BED);
     if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) min_temp_error(H_BED);
   #endif
 
@@ -2425,20 +2466,23 @@ void Temperature::init() {
     pes_e_position = 0;
   #endif
 
   // Init (and disable) SPI thermocouples
   #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && PIN_EXISTS(TEMP_0_CS)
     OUT_WRITE(TEMP_0_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && PIN_EXISTS(TEMP_1_CS)
     OUT_WRITE(TEMP_1_CS_PIN, HIGH);
   #endif
+  #if TEMP_SENSOR_IS_ANY_MAX_TC(2) && PIN_EXISTS(TEMP_2_CS)
+    OUT_WRITE(TEMP_2_CS_PIN, HIGH);
+  #endif
 
   // Setup objects for library-based polling of MAX TCs
   #if HAS_MAXTC_LIBRARIES
     #define _MAX31865_WIRES(n) MAX31865_##n##WIRE
     #define MAX31865_WIRES(n) _MAX31865_WIRES(n)
 
     #if TEMP_SENSOR_IS_MAX(0, 6675) && HAS_MAX6675_LIBRARY
       max6675_0.begin();
     #elif TEMP_SENSOR_IS_MAX(0, 31855) && HAS_MAX31855_LIBRARY
       max31855_0.begin();
@@ -2452,20 +2496,32 @@ void Temperature::init() {
     #if TEMP_SENSOR_IS_MAX(1, 6675) && HAS_MAX6675_LIBRARY
       max6675_1.begin();
     #elif TEMP_SENSOR_IS_MAX(1, 31855) && HAS_MAX31855_LIBRARY
       max31855_1.begin();
     #elif TEMP_SENSOR_IS_MAX(1, 31865)
       max31865_1.begin(
         MAX31865_WIRES(MAX31865_SENSOR_WIRES_1) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
         OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1, MAX31865_WIRE_OHMS_1)
       );
     #endif
+
+    #if TEMP_SENSOR_IS_MAX(2, 6675) && HAS_MAX6675_LIBRARY
+      max6675_2.begin();
+    #elif TEMP_SENSOR_IS_MAX(2, 31855) && HAS_MAX31855_LIBRARY
+      max31855_2.begin();
+    #elif TEMP_SENSOR_IS_MAX(2, 31865)
+      max31865_2.begin(
+        MAX31865_WIRES(MAX31865_SENSOR_WIRES_2) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_2, MAX31865_CALIBRATION_OHMS_2, MAX31865_WIRE_OHMS_2)
+      );
+    #endif
+
     #undef MAX31865_WIRES
     #undef _MAX31865_WIRES
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
@@ -2484,20 +2540,29 @@ void Temperature::init() {
   #endif
   #if PIN_EXISTS(TEMP_1_TR_ENABLE)
     OUT_WRITE(TEMP_1_TR_ENABLE_PIN, (
       #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
         HIGH
       #else
         LOW
       #endif
     ));
   #endif
+  #if PIN_EXISTS(TEMP_2_TR_ENABLE)
+    OUT_WRITE(TEMP_2_TR_ENABLE_PIN, (
+      #if TEMP_SENSOR_IS_ANY_MAX_TC(2)
+        HIGH
+      #else
+        LOW
+      #endif
+    ));
+  #endif
 
   #if ENABLED(MPCTEMP)
     HOTEND_LOOP() temp_hotend[e].modeled_block_temp = NAN;
   #endif
 
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
@@ -3002,39 +3067,43 @@ void Temperature::disable_all_heaters() {
     #else // MAX6675
       #define MAX_TC_ERROR_MASK    3        // D2 only; 1 = open circuit
       #define MAX_TC_DISCARD_BITS  3        // Data D15-D1
       #define MAX_TC_SPEED_BITS    2        // ~2MHz
     #endif
 
     #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
       static raw_adc_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
       #define THERMO_TEMP(I) max_tc_temp_previous[I]
-      #define THERMO_SEL(A,B) (hindex ? (B) : (A))
-      #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
+      #define THERMO_SEL(A,B,C) (hindex > 1 ? (C) : hindex == 1 ? (B) : (A))
+      #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; case 2: WRITE(TEMP_2_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
     #else
       // When we have only 1 max tc, THERMO_SEL will pick the appropriate sensor
       // variable, and MAXTC_*() macros will be hardcoded to the correct CS pin.
       constexpr uint8_t hindex = 0;
       #define THERMO_TEMP(I) max_tc_temp
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
-        #define THERMO_SEL(A,B) A
+        #define THERMO_SEL(A,B,C) A
         #define MAXTC_CS_WRITE(V)  WRITE(TEMP_0_CS_PIN, V)
-      #else
-        #define THERMO_SEL(A,B) B
+      #elif TEMP_SENSOR_IS_ANY_MAX_TC(1)
+        #define THERMO_SEL(A,B,C) B
         #define MAXTC_CS_WRITE(V)  WRITE(TEMP_1_CS_PIN, V)
+      #elif TEMP_SENSOR_IS_ANY_MAX_TC(2)
+        #define THERMO_SEL(A,B,C) C
+        #define MAXTC_CS_WRITE(V)  WRITE(TEMP_2_CS_PIN, V)
       #endif
     #endif
 
     static TERN(HAS_MAX31855, uint32_t, uint16_t) max_tc_temp = THERMO_SEL(
       TEMP_SENSOR_0_MAX_TC_TMAX,
-      TEMP_SENSOR_1_MAX_TC_TMAX
+      TEMP_SENSOR_1_MAX_TC_TMAX,
+      TEMP_SENSOR_2_MAX_TC_TMAX
     );
 
     static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
     static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
 
     // Return last-read value between readings
     const millis_t ms = millis();
     if (PENDING(ms, next_max_tc_ms[hindex]))
       return THERMO_TEMP(hindex);
 
@@ -3055,31 +3124,31 @@ void Temperature::disable_all_heaters() {
 
       // Read a big-endian temperature value without using a library
       for (uint8_t i = sizeof(max_tc_temp); i--;) {
         max_tc_temp |= TERN(HAS_MAXTC_SW_SPI, max_tc_spi.receive(), spiRec());
         if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
       }
 
       MAXTC_CS_WRITE(HIGH);  // Disable MAXTC
     #else
       #if HAS_MAX6675_LIBRARY
-        MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1);
+        MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1, max6675_2);
         max_tc_temp = max6675ref.readRaw16();
       #endif
 
       #if HAS_MAX31855_LIBRARY
-        MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1);
+        MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1, max31855_2);
         max_tc_temp = max855ref.readRaw32();
       #endif
 
       #if HAS_MAX31865
-        MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1);
+        MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1, max31865_2);
         max_tc_temp = TERN(LIB_INTERNAL_MAX31865, max865ref.readRaw(), max865ref.readRTD_with_Fault());
       #endif
     #endif
 
     // Handle an error. If there have been more than THERMOCOUPLE_MAX_ERRORS, send an error over serial.
     // Either way, return the TMAX for the thermocouple to trigger a max_temp_error()
     if (max_tc_temp & MAX_TC_ERROR_MASK) {
       max_tc_errors[hindex]++;
 
       if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
@@ -3110,21 +3179,21 @@ void Temperature::disable_all_heaters() {
             if (fault_31865 & MAX31865_FAULT_RTDINLOW)
               SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
             if (fault_31865 & MAX31865_FAULT_OVUV)
               SERIAL_ECHOLNPGM("Under/Over voltage");
           }
         #else // MAX6675
           SERIAL_ECHOLNPGM("MAX6675 Fault: Open Circuit");
         #endif
 
         // Set thermocouple above max temperature (TMAX)
-        max_tc_temp = THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX) << (MAX_TC_DISCARD_BITS + 1);
+        max_tc_temp = THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX, TEMP_SENSOR_2_MAX_TC_TMAX) << (MAX_TC_DISCARD_BITS + 1);
       }
     }
     else {
       max_tc_errors[hindex] = 0; // No error bit, reset error count
     }
 
     max_tc_temp >>= MAX_TC_DISCARD_BITS;
 
     #if HAS_MAX31855
       // Support negative temperature for MAX38155
@@ -3148,20 +3217,24 @@ void Temperature::update_raw_temperatures() {
 
   // TODO: can this be collapsed into a HOTEND_LOOP()?
   #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_IS_MAX_TC(0)
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1 && !TEMP_SENSOR_IS_MAX_TC(1)
     temp_hotend[1].update();
   #endif
 
+  #if HAS_TEMP_ADC_2 && !TEMP_SENSOR_IS_MAX_TC(2)
+    temp_hotend[2].update();
+  #endif
+
   #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
     temp_redundant.update();
   #endif
 
   TERN_(HAS_TEMP_ADC_2,       temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());

commit 02c43f44c73b76c8d8d1e48b8e595ced62da2459
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Oct 21 14:03:38 2022 -0400

    ‚ú® Controllerfan PWM scaling, kickstart (#24873)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 349264606a..7515396fbe 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -299,33 +299,33 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if HAS_TEMP_REDUNDANT
   redundant_info_t Temperature::temp_redundant;
 #endif
 
 #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
-  uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
+  uint8_t Temperature::autofan_speed[HOTENDS] = ARRAY_N_1(HOTENDS, FAN_OFF_PWM);
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
-  uint8_t Temperature::chamberfan_speed; // = 0
+  uint8_t Temperature::chamberfan_speed = FAN_OFF_PWM;
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
-  uint8_t Temperature::coolerfan_speed; // = 0
+  uint8_t Temperature::coolerfan_speed = FAN_OFF_PWM;
 #endif
 
 #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
-  uint8_t Temperature::soft_pwm_controller_speed;
+  uint8_t Temperature::soft_pwm_controller_speed = FAN_OFF_PWM;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef BOARD_OPENDRAIN_MOSFETS
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
@@ -335,25 +335,25 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if ENABLED(FAST_PWM_FAN)
   #define SET_FAST_PWM_FREQ(P) hal.set_pwm_frequency(pin_t(P), FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
 #define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
 
 // HAS_FAN does not include CONTROLLER_FAN
 #if HAS_FAN
 
-  uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
+  uint8_t Temperature::fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, FAN_OFF_PWM);
 
   #if ENABLED(EXTRA_FAN_SPEED)
 
-    Temperature::extra_fan_t Temperature::extra_fan_speed[FAN_COUNT];
+    Temperature::extra_fan_t Temperature::extra_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, FAN_OFF_PWM);
 
     /**
      * Handle the M106 P<fan> T<speed> command:
      *  T1       = Restore fan speed saved on the last T2
      *  T2       = Save the fan speed, then set to the last T<3-255> value
      *  T<3-255> = Set the "extra fan speed"
      */
     void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t command_or_speed) {
       switch (command_or_speed) {
         case 1:
@@ -366,21 +366,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
         default:
           extra_fan_speed[fan].speed = _MIN(command_or_speed, 255U);
           break;
       }
     }
 
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
-    uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
+    uint8_t Temperature::saved_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, FAN_OFF_PWM);
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 128);
   #endif
 
   /**
    * Set the print fan speed for a target extruder
    */
   void Temperature::set_fan_speed(uint8_t fan, uint16_t speed) {

commit 6ad57118077740f87c472d3a91259b5889bb6bea
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Thu Oct 13 01:57:22 2022 +0300

    ü©π Fix temperature include (#24834)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7954611bc4..349264606a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -23,20 +23,21 @@
 /**
  * temperature.cpp - temperature control
  */
 
 // Useful when debugging thermocouples
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 #include "../lcd/marlinui.h"
+#include "../gcode/gcode.h"
 
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
 #include "printcounter.h"
 
 #if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
@@ -56,24 +57,20 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
-#if EITHER(HAS_TEMP_SENSOR, LASER_FEATURE)
-  #include "../gcode/gcode.h"
-#endif
-
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "../libs/nozzle.h"
 #endif
 
 #if LASER_SAFETY_TIMEOUT_MS > 0
   #include "../feature/spindle_laser.h"
 #endif
 
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))

commit 11f82445738ae885668f29c9fa7feb4c47e673ca
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Oct 1 09:19:51 2022 -0700

    üîß Thermistor (66) sanity-check (#24803)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8c662948bc..7954611bc4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2642,21 +2642,21 @@ void Temperature::init() {
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius)) - 1), \
                       tmax = _MIN(HEATER_##NR##_MAXTEMP, tmax_tmp); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##N > 0 && TEMP_SENSOR_##N != 998 && TEMP_SENSOR_##N != 999 && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR(N) > 0 && TEMP_SENSOR(N) != 998 && TEMP_SENSOR(N) != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif

commit 8aa3273242e993c76c12ba50c34138a9d18f550c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Sep 27 10:25:54 2022 +1300

    ‚úèÔ∏è Followup for M524 (#24775)
    
    Followup to #24761

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cb9043f347..8c662948bc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1842,25 +1842,27 @@ void Temperature::task() {
   REMEMBER(mh, no_reentry, true);
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
 
-    if (emergency_parser.sd_abort_by_M524) { // abort SD print immediately
-      emergency_parser.sd_abort_by_M524 = false;
-      card.flag.abort_sd_printing = true;
-      gcode.process_subcommands_now(F("M524"));
-    }
+    #if ENABLED(SDSUPPORT)
+      if (emergency_parser.sd_abort_by_M524) { // abort SD print immediately
+        emergency_parser.sd_abort_by_M524 = false;
+        card.flag.abort_sd_printing = true;
+        gcode.process_subcommands_now(F("M524"));
+      }
+    #endif
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_IS_MAX_TC(0)
       if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(1)

commit 6c813fcd16aa4020db8aab8b2106b0d1f9c3b858
Author: Arkadiusz Mi≈õkiewicz <arekm@maven.pl>
Date:   Sun Sep 18 03:51:37 2022 +0200

    üö∏ Emergency Parse M524 (#24761)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index dd5712e1b0..cb9043f347 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1841,20 +1841,26 @@ void Temperature::task() {
   if (no_reentry) return;
   REMEMBER(mh, no_reentry, true);
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
+
+    if (emergency_parser.sd_abort_by_M524) { // abort SD print immediately
+      emergency_parser.sd_abort_by_M524 = false;
+      card.flag.abort_sd_printing = true;
+      gcode.process_subcommands_now(F("M524"));
+    }
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_IS_MAX_TC(0)
       if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_IS_MAX_TC(1)

commit dc0b490bf0ad4f3e5a5bcaad13e88c84d220fb62
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Sep 9 20:54:29 2022 +0200

    üêõ Fix heater timeout PID output (#24682)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1372f2ec72..dd5712e1b0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1384,30 +1384,32 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
     }
   };
 
 #endif // HAS_PID_HEATING
 
 #if HAS_HOTEND
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
 
+    const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
+
     #if ENABLED(PIDTEMP)
 
       typedef PIDRunner<hotend_info_t, 0, PID_MAX> PIDRunnerHotend;
 
       static PIDRunnerHotend hotend_pid[HOTENDS] = {
         #define _HOTENDPID(E) temp_hotend[E],
         REPEAT(HOTENDS, _HOTENDPID)
       };
 
-      const float pid_output = hotend_pid[ee].get_pid_output();
+      const float pid_output = is_idling ? 0 : hotend_pid[ee].get_pid_output();
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder)
           hotend_pid[ee].debug(temp_hotend[ee].celsius, pid_output, F("E"), ee);
       #endif
 
     #elif ENABLED(MPCTEMP)
 
       MPCHeaterInfo &hotend = temp_hotend[ee];
       MPC_t &constants = hotend.constants;
@@ -1456,21 +1458,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
       // error diverging slowly or (fast) noise. Slowly correct towards this temperature and noise will average out.
       const float delta_to_apply = (hotend.celsius - hotend.modeled_sensor_temp) * (MPC_SMOOTHING_FACTOR);
       hotend.modeled_block_temp += delta_to_apply;
       hotend.modeled_sensor_temp += delta_to_apply;
 
       // Only correct ambient when close to steady state (output power is not clipped or asymptotic temperature is reached)
       if (WITHIN(hotend.soft_pwm_amount, 1, 126) || fabs(blocktempdelta + delta_to_apply) < (MPC_STEADYSTATE * MPC_dT))
         hotend.modeled_ambient_temp += delta_to_apply > 0.f ? _MAX(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : _MIN(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
 
       float power = 0.0;
-      if (hotend.target != 0 && TERN1(HEATER_IDLE_HANDLER, !heater_idle[ee].timed_out)) {
+      if (hotend.target != 0 && !is_idling) {
         // Plan power level to get to target temperature in 2 seconds
         power = (hotend.target - hotend.modeled_block_temp) * constants.block_heat_capacity / 2.0f;
         power -= (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff;
       }
 
       float pid_output = power * 254.0f / constants.heater_power + 1.0f;        // Ensure correct quantization into a range of 0 to 127
       pid_output = constrain(pid_output, 0, MPC_MAX);
 
       /* <-- add a slash to enable
         static uint32_t nexttime = millis() + 1000;
@@ -1482,21 +1484,20 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
                            ", delta_to_apply ", delta_to_apply,
                            ", ambient ", hotend.modeled_ambient_temp,
                            ", power ", power,
                            ", pid_output ", pid_output,
                            ", pwm ", (int)pid_output >> 1);
         }
       //*/
 
     #else // No PID or MPC enabled
 
-      const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
       const float pid_output = (!is_idling && temp_hotend[ee].is_below_target()) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
 #endif // HAS_HOTEND
 
 #if ENABLED(PIDTEMPBED)

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    üêõ Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c8e69e7010..1372f2ec72 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -590,21 +590,21 @@ volatile bool Temperature::raw_temps_ready = false;
    * temperature to succeed.
    */
   void Temperature::PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
     celsius_float_t current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
-    PID_t tune_pid = { 0, 0, 0 };
+    raw_pid_t tune_pid = { 0, 0, 0 };
     celsius_float_t maxT = 0, minT = 10000;
 
     const bool isbed = (heater_id == H_BED),
            ischamber = (heater_id == H_CHAMBER);
 
     #if ENABLED(PIDTEMPCHAMBER)
       #define C_TERN(T,A,B) ((T) ? (A) : (B))
     #else
       #define C_TERN(T,A,B) (B)
     #endif
@@ -709,30 +709,30 @@ volatile bool Temperature::raw_temps_ready = false;
             LIMIT(bias, 20, max_pow - 20);
             d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
             SERIAL_ECHOPGM(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
             if (cycles > 2) {
               const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
                           Tu = float(t_low + t_high) * 0.001f,
                           pf = (ischamber || isbed) ? 0.2f : 0.6f,
                           df = (ischamber || isbed) ? 1.0f / 3.0f : 1.0f / 8.0f;
 
-              tune_pid.Kp = Ku * pf;
-              tune_pid.Ki = tune_pid.Kp * 2.0f / Tu;
-              tune_pid.Kd = tune_pid.Kp * Tu * df;
+              tune_pid.p = Ku * pf;
+              tune_pid.i = tune_pid.p * 2.0f / Tu;
+              tune_pid.d = tune_pid.p * Tu * df;
 
               SERIAL_ECHOLNPGM(STR_KU, Ku, STR_TU, Tu);
               if (ischamber || isbed)
                 SERIAL_ECHOLNPGM(" No overshoot");
               else
                 SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
-              SERIAL_ECHOLNPGM(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
+              SERIAL_ECHOLNPGM(STR_KP, tune_pid.p, STR_KI, tune_pid.i, STR_KD, tune_pid.d);
             }
           }
           SHV((bias + d) >> 1);
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PID_CYCLE), cycles, ncycles));
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
@@ -788,53 +788,50 @@ volatile bool Temperature::raw_temps_ready = false;
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
-          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
-          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
-          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
+          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
+          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #else
-          say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
-          say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
-          say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.p);
+          say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.i);
+          say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.d);
         #endif
 
-        auto _set_hotend_pid = [](const uint8_t e, const PID_t &in_pid) {
+        auto _set_hotend_pid = [](const uint8_t tool, const raw_pid_t &in_pid) {
           #if ENABLED(PIDTEMP)
-            PID_PARAM(Kp, e) = in_pid.Kp;
-            PID_PARAM(Ki, e) = scalePID_i(in_pid.Ki);
-            PID_PARAM(Kd, e) = scalePID_d(in_pid.Kd);
+            #if ENABLED(PID_PARAMS_PER_HOTEND)
+              thermalManager.temp_hotend[tool].pid.set(in_pid);
+            #else
+              HOTEND_LOOP() thermalManager.temp_hotend[e].pid.set(in_pid);
+            #endif
             updatePID();
-          #else
-            UNUSED(e); UNUSED(in_pid);
           #endif
+          UNUSED(tool); UNUSED(in_pid);
         };
 
         #if ENABLED(PIDTEMPBED)
-          auto _set_bed_pid = [](const PID_t &in_pid) {
-            temp_bed.pid.Kp = in_pid.Kp;
-            temp_bed.pid.Ki = scalePID_i(in_pid.Ki);
-            temp_bed.pid.Kd = scalePID_d(in_pid.Kd);
+          auto _set_bed_pid = [](const raw_pid_t &in_pid) {
+            temp_bed.pid.set(in_pid);
           };
         #endif
 
         #if ENABLED(PIDTEMPCHAMBER)
-          auto _set_chamber_pid = [](const PID_t &in_pid) {
-            temp_chamber.pid.Kp = in_pid.Kp;
-            temp_chamber.pid.Ki = scalePID_i(in_pid.Ki);
-            temp_chamber.pid.Kd = scalePID_d(in_pid.Kd);
+          auto _set_chamber_pid = [](const raw_pid_t &in_pid) {
+            temp_chamber.pid.set(in_pid);
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));

commit 66e61f4de32c495484319e15ecdeaba31b78f9bc
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri Aug 26 10:51:11 2022 +1200

    ü©π Fix PID debug output (#24647)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ecd95b5e8f..c8e69e7010 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1367,27 +1367,27 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
         temp_dState = tempinfo.celsius;
 
         return constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_POW), 0, MAX_POW);
 
       #endif // !PID_OPENLOOP
     }
 
     FORCE_INLINE void debug(const_celsius_float_t c, const_float_t pid_out, FSTR_P const name=nullptr, const int8_t index=-1) {
       if (TERN0(HAS_PID_DEBUG, thermalManager.pid_debug_flag)) {
         SERIAL_ECHO_START();
-        if (name) SERIAL_ECHOLNF(name);
+        if (name) SERIAL_ECHOF(name);
         if (index >= 0) SERIAL_ECHO(index);
         SERIAL_ECHOLNPGM(
           STR_PID_DEBUG_INPUT, c,
           STR_PID_DEBUG_OUTPUT, pid_out
           #if DISABLED(PID_OPENLOOP)
-            , "pTerm", work_pid.Kp, "iTerm", work_pid.Ki, "dTerm", work_pid.Kd
+            , " pTerm ", work_pid.Kp, " iTerm ", work_pid.Ki, " dTerm ", work_pid.Kd
           #endif
         );
       }
     }
   };
 
 #endif // HAS_PID_HEATING
 
 #if HAS_HOTEND
 

commit 1bed10c38075a15bfec380c9c7763fea336e787e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 4 02:38:15 2022 -0500

    üîß Config INI, dump options (#24528)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 56eceea39d..ecd95b5e8f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -70,21 +70,21 @@
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "../libs/nozzle.h"
 #endif
 
 #if LASER_SAFETY_TIMEOUT_MS > 0
   #include "../feature/spindle_laser.h"
 #endif
 
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
-#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
+#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (TEMP_SENSOR_IS_MAX_TC(n) || (TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
 #if HAS_MAX6675 && USE_LIB_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
 
 // LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library.
 // If LIB_MAX31855 is not on the build_flags then raw SPI reads will be used.
@@ -1310,22 +1310,21 @@ void Temperature::max_temp_error(const heater_id_t heater_id) {
   _temp_error(heater_id, F(STR_T_MAXTEMP), GET_TEXT_F(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(0);
   #endif
   _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
 
-#if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
-  #define HAS_PID_DEBUG 1
+#if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
 
 #if HAS_PID_HEATING
 
   template<typename TT, int MIN_POW, int MAX_POW>
   class PIDRunner {
   public:
     TT &tempinfo;
     __typeof__(TT::pid) work_pid{0};
@@ -1849,29 +1848,29 @@ void Temperature::task() {
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
-    #if TEMP_SENSOR_0_IS_MAX_TC
+    #if TEMP_SENSOR_IS_MAX_TC(0)
       if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
-    #if TEMP_SENSOR_1_IS_MAX_TC
+    #if TEMP_SENSOR_IS_MAX_TC(1)
       if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
       if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
     #endif
-    #if TEMP_SENSOR_REDUNDANT_IS_MAX_TC
+    #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
       if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
       if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
     #endif
   #else
     #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
   #endif
 
   const millis_t ms = millis();
 
   // Handle Hotend Temp Errors, Heating Watch, etc.
@@ -2065,40 +2064,40 @@ void Temperature::task() {
       SERIAL_ECHO(e);
       SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
       kill();
       return 0;
     }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
-        #elif TEMP_SENSOR_0_IS_MAX_TC
+        #elif TEMP_SENSOR_IS_MAX_TC(0)
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
               max31865_0.temperature(raw),
               max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
             );
           #else
             return (int16_t)raw * 0.25;
           #endif
         #elif TEMP_SENSOR_0_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_0_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
         #if TEMP_SENSOR_1_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
-        #elif TEMP_SENSOR_1_IS_MAX_TC
+        #elif TEMP_SENSOR_IS_MAX_TC(1)
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
               max31865_1.temperature(raw),
               max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1)
             );
           #else
             return (int16_t)raw * 0.25;
           #endif
         #elif TEMP_SENSOR_1_IS_AD595
           return TEMP_AD595(raw);
@@ -2268,23 +2267,23 @@ void Temperature::task() {
       return 0;
     #endif
   }
 #endif // HAS_TEMP_BOARD
 
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_redundant(const raw_adc_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
-    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && REDUNDANT_TEMP_MATCH(SOURCE, E0)
+    #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E0)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(raw), (int16_t)raw * 0.25);
-    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && REDUNDANT_TEMP_MATCH(SOURCE, E1)
+    #elif TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E1)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
@@ -2301,23 +2300,29 @@ void Temperature::task() {
  * set by update_raw_temperatures().
  *
  * The watchdog is dependent on this method. If 'raw_temps_ready' stops
  * being set by the interrupt so that this method is not called for over
  * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
 
   hal.watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
-  TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].setraw(READ_MAX_TC(0)));
-  TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].setraw(READ_MAX_TC(1)));
-  TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.setraw(READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE))));
+  #if TEMP_SENSOR_IS_MAX_TC(0)
+    temp_hotend[0].setraw(READ_MAX_TC(0));
+  #endif
+  #if TEMP_SENSOR_IS_MAX_TC(1)
+    temp_hotend[1].setraw(READ_MAX_TC(1));
+  #endif
+  #if TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
+    temp_redundant.setraw(READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE)));
+  #endif
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].getraw(), e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.getraw()));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.getraw()));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.getraw()));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.getraw()));
   TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.getraw()));
@@ -3132,29 +3137,29 @@ void Temperature::disable_all_heaters() {
 
 /**
  * Update raw temperatures
  *
  * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
  * Applies all the accumulators to the current raw temperatures.
  */
 void Temperature::update_raw_temperatures() {
 
   // TODO: can this be collapsed into a HOTEND_LOOP()?
-  #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_0_IS_MAX_TC
+  #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_IS_MAX_TC(0)
     temp_hotend[0].update();
   #endif
 
-  #if HAS_TEMP_ADC_1 && !TEMP_SENSOR_1_IS_MAX_TC
+  #if HAS_TEMP_ADC_1 && !TEMP_SENSOR_IS_MAX_TC(1)
     temp_hotend[1].update();
   #endif
 
-  #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_REDUNDANT_IS_MAX_TC
+  #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
     temp_redundant.update();
   #endif
 
   TERN_(HAS_TEMP_ADC_2,       temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED,     temp_bed.update());

commit aba35ec1afc9168c92782f384166e45333649998
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Jul 31 03:05:16 2022 +0100

    ü©π Use _MIN/_MAX macros for native compatibility (#24570)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9374971741..56eceea39d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1411,21 +1411,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
           hotend_pid[ee].debug(temp_hotend[ee].celsius, pid_output, F("E"), ee);
       #endif
 
     #elif ENABLED(MPCTEMP)
 
       MPCHeaterInfo &hotend = temp_hotend[ee];
       MPC_t &constants = hotend.constants;
 
       // At startup, initialize modeled temperatures
       if (isnan(hotend.modeled_block_temp)) {
-        hotend.modeled_ambient_temp = min(30.0f, hotend.celsius);   // Cap initial value at reasonable max room temperature of 30C
+        hotend.modeled_ambient_temp = _MIN(30.0f, hotend.celsius);   // Cap initial value at reasonable max room temperature of 30C
         hotend.modeled_block_temp = hotend.modeled_sensor_temp = hotend.celsius;
       }
 
       #if HOTENDS == 1
         constexpr bool this_hotend = true;
       #else
         const bool this_hotend = (ee == active_extruder);
       #endif
 
       float ambient_xfer_coeff = constants.ambient_xfer_coeff_fan0;
@@ -1457,21 +1457,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
       hotend.modeled_sensor_temp += sensortempdelta;
 
       // Any delta between hotend.modeled_sensor_temp and hotend.celsius is either model
       // error diverging slowly or (fast) noise. Slowly correct towards this temperature and noise will average out.
       const float delta_to_apply = (hotend.celsius - hotend.modeled_sensor_temp) * (MPC_SMOOTHING_FACTOR);
       hotend.modeled_block_temp += delta_to_apply;
       hotend.modeled_sensor_temp += delta_to_apply;
 
       // Only correct ambient when close to steady state (output power is not clipped or asymptotic temperature is reached)
       if (WITHIN(hotend.soft_pwm_amount, 1, 126) || fabs(blocktempdelta + delta_to_apply) < (MPC_STEADYSTATE * MPC_dT))
-        hotend.modeled_ambient_temp += delta_to_apply > 0.f ? max(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : min(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
+        hotend.modeled_ambient_temp += delta_to_apply > 0.f ? _MAX(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : _MIN(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
 
       float power = 0.0;
       if (hotend.target != 0 && TERN1(HEATER_IDLE_HANDLER, !heater_idle[ee].timed_out)) {
         // Plan power level to get to target temperature in 2 seconds
         power = (hotend.target - hotend.modeled_block_temp) * constants.block_heat_capacity / 2.0f;
         power -= (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff;
       }
 
       float pid_output = power * 254.0f / constants.heater_power + 1.0f;        // Ensure correct quantization into a range of 0 to 127
       pid_output = constrain(pid_output, 0, MPC_MAX);

commit 0138cb05526215cb0c434b72ee4d6efb48893e72
Author: Frederik Kemner <stuff+github@fredo.org>
Date:   Wed Jul 20 23:25:15 2022 +0200

    ü©π Fix gcode.h include (#24527)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e15e843051..9374971741 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -56,21 +56,21 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
-#if HAS_TEMP_SENSOR
+#if EITHER(HAS_TEMP_SENSOR, LASER_FEATURE)
   #include "../gcode/gcode.h"
 #endif
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "../libs/nozzle.h"
 #endif
 
 #if LASER_SAFETY_TIMEOUT_MS > 0
   #include "../feature/spindle_laser.h"
 #endif

commit 8a1643587becba9a303572a451ee250de1865919
Author: Nikolay-Po <54221205+Nikolay-Po@users.noreply.github.com>
Date:   Sat Jul 16 03:56:15 2022 +0300

    ‚ú® Steinhart-Hart C Coeff for Custom Thermistor (#24428)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 97d248864e..e15e843051 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1940,60 +1940,60 @@ void Temperature::task() {
   }                                                                       \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
     user_thermistor_t default_user_thermistor[USER_THERMISTORS] = {
       #if TEMP_SENSOR_0_IS_CUSTOM
-        { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
+        { true, HOTEND0_SH_C_COEFF, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
       #endif
       #if TEMP_SENSOR_1_IS_CUSTOM
-        { true, 0, 0, HOTEND1_PULLUP_RESISTOR_OHMS, HOTEND1_RESISTANCE_25C_OHMS, 0, 0, HOTEND1_BETA, 0 },
+        { true, HOTEND1_SH_C_COEFF, 0, HOTEND1_PULLUP_RESISTOR_OHMS, HOTEND1_RESISTANCE_25C_OHMS, 0, 0, HOTEND1_BETA, 0 },
       #endif
       #if TEMP_SENSOR_2_IS_CUSTOM
-        { true, 0, 0, HOTEND2_PULLUP_RESISTOR_OHMS, HOTEND2_RESISTANCE_25C_OHMS, 0, 0, HOTEND2_BETA, 0 },
+        { true, HOTEND2_SH_C_COEFF, 0, HOTEND2_PULLUP_RESISTOR_OHMS, HOTEND2_RESISTANCE_25C_OHMS, 0, 0, HOTEND2_BETA, 0 },
       #endif
       #if TEMP_SENSOR_3_IS_CUSTOM
-        { true, 0, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
+        { true, HOTEND3_SH_C_COEFF, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
       #endif
       #if TEMP_SENSOR_4_IS_CUSTOM
-        { true, 0, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
+        { true, HOTEND4_SH_C_COEFF, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
       #endif
       #if TEMP_SENSOR_5_IS_CUSTOM
-        { true, 0, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
+        { true, HOTEND5_SH_C_COEFF, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
       #endif
       #if TEMP_SENSOR_6_IS_CUSTOM
-        { true, 0, 0, HOTEND6_PULLUP_RESISTOR_OHMS, HOTEND6_RESISTANCE_25C_OHMS, 0, 0, HOTEND6_BETA, 0 },
+        { true, HOTEND6_SH_C_COEFF, 0, HOTEND6_PULLUP_RESISTOR_OHMS, HOTEND6_RESISTANCE_25C_OHMS, 0, 0, HOTEND6_BETA, 0 },
       #endif
       #if TEMP_SENSOR_7_IS_CUSTOM
-        { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
+        { true, HOTEND7_SH_C_COEFF, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
       #endif
       #if TEMP_SENSOR_BED_IS_CUSTOM
-        { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
+        { true, BED_SH_C_COEFF, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
       #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
-        { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 },
+        { true, CHAMBER_SH_C_COEFF, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 },
       #endif
       #if TEMP_SENSOR_COOLER_IS_CUSTOM
-        { true, 0, 0, COOLER_PULLUP_RESISTOR_OHMS, COOLER_RESISTANCE_25C_OHMS, 0, 0, COOLER_BETA, 0 },
+        { true, COOLER_SH_C_COEFF, 0, COOLER_PULLUP_RESISTOR_OHMS, COOLER_RESISTANCE_25C_OHMS, 0, 0, COOLER_BETA, 0 },
       #endif
       #if TEMP_SENSOR_PROBE_IS_CUSTOM
-        { true, 0, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 },
+        { true, PROBE_SH_C_COEFF, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 },
       #endif
       #if TEMP_SENSOR_BOARD_IS_CUSTOM
-        { true, 0, 0, BOARD_PULLUP_RESISTOR_OHMS, BOARD_RESISTANCE_25C_OHMS, 0, 0, BOARD_BETA, 0 },
+        { true, BOARD_SH_C_COEFF, 0, BOARD_PULLUP_RESISTOR_OHMS, BOARD_RESISTANCE_25C_OHMS, 0, 0, BOARD_BETA, 0 },
       #endif
       #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
-        { true, 0, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
+        { true, REDUNDANT_SH_C_COEFF, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::M305_report(const uint8_t t_index, const bool forReplay/*=true*/) {
     gcode.report_heading_etc(forReplay, F(STR_USER_THERMISTORS));
     SERIAL_ECHOPGM("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];

commit 2dc543c4f58c39e6cdf7a4a001c15100268cdf46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 13 21:22:53 2022 -0500

    üé® ANY => EITHER

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 65b79d8bc4..97d248864e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -897,39 +897,39 @@ volatile bool Temperature::raw_temps_ready = false;
 
     struct OnExit {
       ~OnExit() {
         wait_for_heatup = false;
 
         ui.reset_status();
 
         temp_hotend[active_extruder].target = 0.0f;
         temp_hotend[active_extruder].soft_pwm_amount = 0;
         #if HAS_FAN
-          set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
+          set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
           planner.sync_fan_speeds(fan_speed);
         #endif
 
         do_z_clearance(MPC_TUNING_END_Z);
       }
     } on_exit;
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, active_extruder);
     MPCHeaterInfo &hotend = temp_hotend[active_extruder];
     MPC_t &constants = hotend.constants;
 
     // Move to center of bed, just above bed height and cool with max fan
     gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
-      set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
+      set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
     const xyz_pos_t tuningpos = MPC_TUNING_POS;
     do_blocking_move_to(tuningpos);
 
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
     LCD_MESSAGE(MSG_COOLING);
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
     celsius_float_t current_temp = degHotend(active_extruder),
                     ambient_temp = current_temp;
@@ -942,21 +942,21 @@ volatile bool Temperature::raw_temps_ready = false;
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
 
     #if HAS_FAN
-      set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
+      set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
       planner.sync_fan_speeds(fan_speed);
     #endif
 
     hotend.modeled_ambient_temp = ambient_temp;
 
     SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
     LCD_MESSAGE(MSG_HEATING);
     hotend.target = 200.0f;   // So M105 looks nice
     hotend.soft_pwm_amount = MPC_MAX >> 1;
     const millis_t heat_start_time = next_test_ms = ms;
@@ -1024,21 +1024,21 @@ volatile bool Temperature::raw_temps_ready = false;
     for (;;) { // Can be interrupted with M108
       if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
-            set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
+            set_fan_speed(EITHER(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
             planner.sync_fan_speeds(fan_speed);
             settle_end_ms = ms + settle_time;
             test_end_ms = settle_end_ms + test_duration;
             fan0_done = true;
           }
           else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
             total_energy_fan255 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
         #endif
         else if (ELAPSED(ms, test_end_ms)) break;
 
@@ -1423,21 +1423,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
       }
 
       #if HOTENDS == 1
         constexpr bool this_hotend = true;
       #else
         const bool this_hotend = (ee == active_extruder);
       #endif
 
       float ambient_xfer_coeff = constants.ambient_xfer_coeff_fan0;
       #if ENABLED(MPC_INCLUDE_FAN)
-        const uint8_t fan_index = ANY(MPC_FAN_0_ACTIVE_HOTEND, MPC_FAN_0_ALL_HOTENDS) ? 0 : ee;
+        const uint8_t fan_index = EITHER(MPC_FAN_0_ACTIVE_HOTEND, MPC_FAN_0_ALL_HOTENDS) ? 0 : ee;
         const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
         ambient_xfer_coeff += fan_fraction * constants.fan255_adjustment;
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
         const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
         // The position can appear to make big jumps when, e.g. homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])

commit f73fad1b2fa6e70b3d632969ecf2773bee826643
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 6 19:34:45 2022 -0500

    üî• Remove JyersUI (#24459)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f03213be1f..65b79d8bc4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -46,22 +46,20 @@
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-  #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
@@ -639,28 +637,26 @@ volatile bool Temperature::raw_temps_ready = false;
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
-      TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
@@ -741,21 +737,20 @@ volatile bool Temperature::raw_temps_ready = false;
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
-        TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
@@ -780,21 +775,20 @@ volatile bool Temperature::raw_temps_ready = false;
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
-        TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
@@ -838,40 +832,38 @@ volatile bool Temperature::raw_temps_ready = false;
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
-        TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPCTEMP)
 

commit 509dfe92d0c2227ddece025fb97875582ca47aed
Author: Meilleur Gars <98503100+LCh-77@users.noreply.github.com>
Date:   Wed Jul 6 13:46:11 2022 -0700

    üö∏ JyersUI updates (#24451)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 65b79d8bc4..f03213be1f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -46,20 +46,22 @@
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
@@ -637,26 +639,28 @@ volatile bool Temperature::raw_temps_ready = false;
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+      TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
@@ -737,20 +741,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+        TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
@@ -775,20 +780,21 @@ volatile bool Temperature::raw_temps_ready = false;
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
+        TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
@@ -832,38 +838,40 @@ volatile bool Temperature::raw_temps_ready = false;
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
+        TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWINClass::DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPCTEMP)
 

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ‚ö°Ô∏è Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9bdc6eced7..65b79d8bc4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1897,23 +1897,24 @@ void Temperature::task() {
 
   // Handle Heated Chamber Temp Errors, Heating Watch, etc.
   TERN_(HAS_HEATED_CHAMBER, manage_heated_chamber(ms));
 
   // Handle Cooler Temp Errors, Cooling Watch, etc.
   TERN_(HAS_COOLER, manage_cooler(ms));
 
   #if ENABLED(LASER_COOLANT_FLOW_METER)
     cooler.flowmeter_task(ms);
     #if ENABLED(FLOWMETER_SAFETY)
-      if (cutter.enabled() && cooler.check_flow_too_low()) {
+      if (cooler.check_flow_too_low()) {
+        TERN_(HAS_DISPLAY, if (cutter.enabled()) ui.flow_fault());
         cutter.disable();
-        TERN_(HAS_DISPLAY, ui.flow_fault());
+        cutter.cutter_mode = CUTTER_MODE_ERROR;   // Immediately kill stepper inline power output
       }
     #endif
   #endif
 
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 

commit fc287b44da27d435e588f7d83ae61dcb4e929a5b
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Jul 3 09:08:43 2022 -0700

    üö∏ MPCTEMP: Home before cooling (#24434)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0de922d1a8..9bdc6eced7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -911,27 +911,27 @@ volatile bool Temperature::raw_temps_ready = false;
         do_z_clearance(MPC_TUNING_END_Z);
       }
     } on_exit;
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, active_extruder);
     MPCHeaterInfo &hotend = temp_hotend[active_extruder];
     MPC_t &constants = hotend.constants;
 
     // Move to center of bed, just above bed height and cool with max fan
+    gcode.home_all_axes(true);
     disable_all_heaters();
     #if HAS_FAN
       zero_fan_speeds();
       set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
       planner.sync_fan_speeds(fan_speed);
     #endif
-    gcode.home_all_axes(true);
     const xyz_pos_t tuningpos = MPC_TUNING_POS;
     do_blocking_move_to(tuningpos);
 
     SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
     LCD_MESSAGE(MSG_COOLING);
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
     celsius_float_t current_temp = degHotend(active_extruder),
                     ambient_temp = current_temp;
 
     wait_for_heatup = true;

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 17ab08d4c2..0de922d1a8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1311,118 +1311,115 @@ void Temperature::max_temp_error(const heater_id_t heater_id) {
 }
 
 void Temperature::min_temp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(0);
   #endif
   _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
 
 #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
-  bool Temperature::pid_debug_flag; // = 0
+  #define HAS_PID_DEBUG 1
+  bool Temperature::pid_debug_flag; // = false
 #endif
 
-#if HAS_HOTEND
+#if HAS_PID_HEATING
 
-  float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
-    const uint8_t ee = HOTEND_INDEX;
-    #if ENABLED(PIDTEMP)
-      #if DISABLED(PID_OPENLOOP)
-        static hotend_pid_t work_pid[HOTENDS];
-        static float temp_iState[HOTENDS] = { 0 },
-                     temp_dState[HOTENDS] = { 0 };
-        static Flags<HOTENDS> pid_reset;
-        const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
-
-        float pid_output;
-
-        if (temp_hotend[ee].target == 0
-          || pid_error < -(PID_FUNCTIONAL_RANGE)
-          || TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out)
-        ) {
-          pid_output = 0;
-          pid_reset.set(ee);
+  template<typename TT, int MIN_POW, int MAX_POW>
+  class PIDRunner {
+  public:
+    TT &tempinfo;
+    __typeof__(TT::pid) work_pid{0};
+    float temp_iState = 0, temp_dState = 0;
+    bool pid_reset = true;
+
+    PIDRunner(TT &t) : tempinfo(t) { }
+
+    float get_pid_output() {
+
+      #if ENABLED(PID_OPENLOOP)
+
+        return constrain(tempinfo.target, 0, MAX_POW);
+
+      #else // !PID_OPENLOOP
+
+        const float pid_error = tempinfo.target - tempinfo.celsius;
+        if (!tempinfo.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
+          pid_reset = true;
+          return 0;
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
-          pid_output = PID_MAX;
-          pid_reset.set(ee);
+          pid_reset = true;
+          return MAX_POW;
         }
-        else {
-          if (pid_reset[ee]) {
-            temp_iState[ee] = 0.0;
-            work_pid[ee].Kd = 0.0;
-            pid_reset.clear(ee);
-          }
 
-          work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
-          const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
-          temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
-          work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
-          work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
+        if (pid_reset) {
+          pid_reset = false;
+          temp_iState = 0.0;
+          work_pid.Kd = 0.0;
+        }
 
-          pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
+        const float max_power_over_i_gain = float(MAX_POW) / tempinfo.pid.Ki - float(MIN_POW);
+        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
 
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            #if HOTENDS == 1
-              constexpr bool this_hotend = true;
-            #else
-              const bool this_hotend = (ee == active_extruder);
-            #endif
-            work_pid[ee].Kc = 0;
-            if (this_hotend) {
-              const long e_position = stepper.position(E_AXIS);
-              if (e_position > pes_e_position) {
-                lpq[lpq_ptr] = e_position - pes_e_position;
-                pes_e_position = e_position;
-              }
-              else
-                lpq[lpq_ptr] = 0;
+        work_pid.Kp = tempinfo.pid.Kp * pid_error;
+        work_pid.Ki = tempinfo.pid.Ki * temp_iState;
+        work_pid.Kd = work_pid.Kd + PID_K2 * (tempinfo.pid.Kd * (temp_dState - tempinfo.celsius) - work_pid.Kd);
 
-              if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-              work_pid[ee].Kc = (lpq[lpq_ptr] * planner.mm_per_step[E_AXIS]) * PID_PARAM(Kc, ee);
-              pid_output += work_pid[ee].Kc;
-            }
-          #endif // PID_EXTRUSION_SCALING
-          #if ENABLED(PID_FAN_SCALING)
-            if (fan_speed[active_extruder] > PID_FAN_SCALING_MIN_SPEED) {
-              work_pid[ee].Kf = PID_PARAM(Kf, ee) + (PID_FAN_SCALING_LIN_FACTOR) * fan_speed[active_extruder];
-              pid_output += work_pid[ee].Kf;
-            }
-            //pid_output -= work_pid[ee].Ki;
-            //pid_output += work_pid[ee].Ki * work_pid[ee].Kf
-          #endif // PID_FAN_SCALING
-          LIMIT(pid_output, 0, PID_MAX);
-        }
-        temp_dState[ee] = temp_hotend[ee].celsius;
+        temp_dState = tempinfo.celsius;
 
-      #else // PID_OPENLOOP
+        return constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_POW), 0, MAX_POW);
 
-        const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
+      #endif // !PID_OPENLOOP
+    }
 
-      #endif // PID_OPENLOOP
+    FORCE_INLINE void debug(const_celsius_float_t c, const_float_t pid_out, FSTR_P const name=nullptr, const int8_t index=-1) {
+      if (TERN0(HAS_PID_DEBUG, thermalManager.pid_debug_flag)) {
+        SERIAL_ECHO_START();
+        if (name) SERIAL_ECHOLNF(name);
+        if (index >= 0) SERIAL_ECHO(index);
+        SERIAL_ECHOLNPGM(
+          STR_PID_DEBUG_INPUT, c,
+          STR_PID_DEBUG_OUTPUT, pid_out
+          #if DISABLED(PID_OPENLOOP)
+            , "pTerm", work_pid.Kp, "iTerm", work_pid.Ki, "dTerm", work_pid.Kd
+          #endif
+        );
+      }
+    }
+  };
+
+#endif // HAS_PID_HEATING
+
+#if HAS_HOTEND
+
+  float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
+    const uint8_t ee = HOTEND_INDEX;
+
+    #if ENABLED(PIDTEMP)
+
+      typedef PIDRunner<hotend_info_t, 0, PID_MAX> PIDRunnerHotend;
+
+      static PIDRunnerHotend hotend_pid[HOTENDS] = {
+        #define _HOTENDPID(E) temp_hotend[E],
+        REPEAT(HOTENDS, _HOTENDPID)
+      };
+
+      const float pid_output = hotend_pid[ee].get_pid_output();
 
       #if ENABLED(PID_DEBUG)
-        if (ee == active_extruder && pid_debug_flag) {
-          SERIAL_ECHO_MSG(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output
-            #if DISABLED(PID_OPENLOOP)
-              , STR_PID_DEBUG_PTERM, work_pid[ee].Kp
-              , STR_PID_DEBUG_ITERM, work_pid[ee].Ki
-              , STR_PID_DEBUG_DTERM, work_pid[ee].Kd
-              #if ENABLED(PID_EXTRUSION_SCALING)
-                , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
-              #endif
-            #endif
-          );
-        }
+        if (ee == active_extruder)
+          hotend_pid[ee].debug(temp_hotend[ee].celsius, pid_output, F("E"), ee);
       #endif
 
     #elif ENABLED(MPCTEMP)
+
       MPCHeaterInfo &hotend = temp_hotend[ee];
       MPC_t &constants = hotend.constants;
 
       // At startup, initialize modeled temperatures
       if (isnan(hotend.modeled_block_temp)) {
         hotend.modeled_ambient_temp = min(30.0f, hotend.celsius);   // Cap initial value at reasonable max room temperature of 30C
         hotend.modeled_block_temp = hotend.modeled_sensor_temp = hotend.celsius;
       }
 
       #if HOTENDS == 1
@@ -1490,203 +1487,54 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
                            ", ambient ", hotend.modeled_ambient_temp,
                            ", power ", power,
                            ", pid_output ", pid_output,
                            ", pwm ", (int)pid_output >> 1);
         }
       //*/
 
     #else // No PID or MPC enabled
 
       const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
-      const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
+      const float pid_output = (!is_idling && temp_hotend[ee].is_below_target()) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
 #endif // HAS_HOTEND
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
-
-    #if DISABLED(PID_OPENLOOP)
-
-      static PID_t work_pid{0};
-      static float temp_iState = 0, temp_dState = 0;
-      static bool pid_reset = true;
-      float pid_output = 0;
-      const float max_power_over_i_gain = float(MAX_BED_POWER) / temp_bed.pid.Ki - float(MIN_BED_POWER),
-                  pid_error = temp_bed.target - temp_bed.celsius;
-
-      if (!temp_bed.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
-        pid_output = 0;
-        pid_reset = true;
-      }
-      else if (pid_error > PID_FUNCTIONAL_RANGE) {
-        pid_output = MAX_BED_POWER;
-        pid_reset = true;
-      }
-      else {
-        if (pid_reset) {
-          temp_iState = 0.0;
-          work_pid.Kd = 0.0;
-          pid_reset = false;
-        }
-
-        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
-
-        work_pid.Kp = temp_bed.pid.Kp * pid_error;
-        work_pid.Ki = temp_bed.pid.Ki * temp_iState;
-        work_pid.Kd = work_pid.Kd + PID_K2 * (temp_bed.pid.Kd * (temp_dState - temp_bed.celsius) - work_pid.Kd);
-
-        temp_dState = temp_bed.celsius;
-
-        pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_BED_POWER), 0, MAX_BED_POWER);
-      }
-
-    #else // PID_OPENLOOP
-
-      const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
-
-    #endif // PID_OPENLOOP
-
-    #if ENABLED(PID_BED_DEBUG)
-      if (pid_debug_flag) {
-        SERIAL_ECHO_MSG(
-          " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output
-          #if DISABLED(PID_OPENLOOP)
-            , STR_PID_DEBUG_PTERM, work_pid.Kp
-            , STR_PID_DEBUG_ITERM, work_pid.Ki
-            , STR_PID_DEBUG_DTERM, work_pid.Kd
-          #endif
-        );
-      }
-    #endif
-
+    static PIDRunner<bed_info_t, MIN_BED_POWER, MAX_BED_POWER> bed_pid(temp_bed);
+    const float pid_output = bed_pid.get_pid_output();
+    TERN_(PID_BED_DEBUG, bed_pid.debug(temp_bed.celsius, pid_output, F("(Bed)")));
     return pid_output;
   }
 
 #endif // PIDTEMPBED
 
 #if ENABLED(PIDTEMPCHAMBER)
 
   float Temperature::get_pid_output_chamber() {
-
-    #if DISABLED(PID_OPENLOOP)
-
-      static PID_t work_pid{0};
-      static float temp_iState = 0, temp_dState = 0;
-      static bool pid_reset = true;
-      float pid_output = 0;
-      const float max_power_over_i_gain = float(MAX_CHAMBER_POWER) / temp_chamber.pid.Ki - float(MIN_CHAMBER_POWER),
-                  pid_error = temp_chamber.target - temp_chamber.celsius;
-
-      if (!temp_chamber.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
-        pid_output = 0;
-        pid_reset = true;
-      }
-      else if (pid_error > PID_FUNCTIONAL_RANGE) {
-        pid_output = MAX_CHAMBER_POWER;
-        pid_reset = true;
-      }
-      else {
-        if (pid_reset) {
-          temp_iState = 0.0;
-          work_pid.Kd = 0.0;
-          pid_reset = false;
-        }
-
-        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
-
-        work_pid.Kp = temp_chamber.pid.Kp * pid_error;
-        work_pid.Ki = temp_chamber.pid.Ki * temp_iState;
-        work_pid.Kd = work_pid.Kd + PID_K2 * (temp_chamber.pid.Kd * (temp_dState - temp_chamber.celsius) - work_pid.Kd);
-
-        temp_dState = temp_chamber.celsius;
-
-        pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_CHAMBER_POWER), 0, MAX_CHAMBER_POWER);
-      }
-
-    #else // PID_OPENLOOP
-
-      const float pid_output = constrain(temp_chamber.target, 0, MAX_CHAMBER_POWER);
-
-    #endif // PID_OPENLOOP
-
-    #if ENABLED(PID_CHAMBER_DEBUG)
-    {
-      SERIAL_ECHO_MSG(
-        " PID_CHAMBER_DEBUG : Input ", temp_chamber.celsius, " Output ", pid_output
-        #if DISABLED(PID_OPENLOOP)
-          , STR_PID_DEBUG_PTERM, work_pid.Kp
-          , STR_PID_DEBUG_ITERM, work_pid.Ki
-          , STR_PID_DEBUG_DTERM, work_pid.Kd
-        #endif
-      );
-    }
-    #endif
-
+    static PIDRunner<chamber_info_t, MIN_CHAMBER_POWER, MAX_CHAMBER_POWER> chamber_pid(temp_chamber);
+    const float pid_output = chamber_pid.get_pid_output();
+    TERN_(PID_CHAMBER_DEBUG, chamber_pid.debug(temp_chamber.celsius, pid_output, F("(Chamber)")));
     return pid_output;
   }
 
 #endif // PIDTEMPCHAMBER
 
-/**
- * Manage heating activities for extruder hot-ends and a heated bed
- *  - Acquire updated temperature readings
- *    - Also resets the watchdog timer
- *  - Invoke thermal runaway protection
- *  - Manage extruder auto-fan
- *  - Apply filament width to the extrusion rate (may move)
- *  - Update the heated bed PID output value
- */
-void Temperature::manage_heater() {
-  if (marlin_state == MF_INITIALIZING) return hal.watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
-
-  static bool no_reentry = false;  // Prevent recursion
-  if (no_reentry) return;
-  REMEMBER(mh, no_reentry, true);
-
-  #if ENABLED(EMERGENCY_PARSER)
-    if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
-
-    if (emergency_parser.quickstop_by_M410) {
-      emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
-      quickstop_stepper();
-    }
-  #endif
-
-  if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
-
-  #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
-    #if TEMP_SENSOR_0_IS_MAX_TC
-      if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
-      if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
-    #endif
-    #if TEMP_SENSOR_1_IS_MAX_TC
-      if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
-      if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
-    #endif
-    #if TEMP_SENSOR_REDUNDANT_IS_MAX_TC
-      if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
-      if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
-    #endif
-  #else
-    #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
-  #endif
-
-  millis_t ms = millis();
-
-  #if HAS_HOTEND
+#if HAS_HOTEND
 
+  void Temperature::manage_hotends(const millis_t &ms) {
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
@@ -1700,39 +1548,27 @@ void Temperature::manage_heater() {
           if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
             TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
           }
         }
       #endif
 
     } // HOTEND_LOOP
+  }
 
-  #endif // HAS_HOTEND
-
-  #if HAS_TEMP_REDUNDANT
-    // Make sure measured temperatures are close together
-    if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
-      _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), F(STR_REDUNDANCY), GET_TEXT_F(MSG_ERR_REDUNDANT_TEMP));
-  #endif
-
-  // Manage extruder auto fans and/or read fan tachometers
-  TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
+#endif // HAS_HOTEND
 
-  /**
-   * Dynamically set the volumetric multiplier based
-   * on the delayed Filament Width measurement.
-   */
-  TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_volumetric());
+#if HAS_HEATED_BED
 
-  #if HAS_HEATED_BED
+  void Temperature::manage_heated_bed(const millis_t &ms) {
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         if (watch_bed.check(degBed()))          // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
@@ -1763,53 +1599,54 @@ void Temperature::manage_heater() {
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[IDLE_INDEX_BED].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_BED)
         tr_state_machine[RUNAWAY_IND_BED].run(temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
       #endif
 
       #if HEATER_IDLE_HANDLER
         if (heater_idle[IDLE_INDEX_BED].timed_out) {
           temp_bed.soft_pwm_amount = 0;
-          #if DISABLED(PIDTEMPBED)
-            WRITE_HEATER_BED(LOW);
-          #endif
+          if (DISABLED(PIDTEMPBED)) WRITE_HEATER_BED(LOW);
         }
         else
       #endif
       {
         #if ENABLED(PIDTEMPBED)
           temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
         #else
           // Check if temperature is within the correct band
           if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
             #if ENABLED(BED_LIMIT_SWITCHING)
               if (temp_bed.celsius >= temp_bed.target + BED_HYSTERESIS)
                 temp_bed.soft_pwm_amount = 0;
-              else if (temp_bed.celsius <= temp_bed.target - (BED_HYSTERESIS))
+              else if (temp_bed.is_below_target(-(BED_HYSTERESIS) + 1))
                 temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
             #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
-              temp_bed.soft_pwm_amount = temp_bed.celsius < temp_bed.target ? MAX_BED_POWER >> 1 : 0;
+              temp_bed.soft_pwm_amount = temp_bed.is_below_target() ? MAX_BED_POWER >> 1 : 0;
             #endif
           }
           else {
             temp_bed.soft_pwm_amount = 0;
             WRITE_HEATER_BED(LOW);
           }
         #endif
       }
 
     } while (false);
+  }
 
-  #endif // HAS_HEATED_BED
+#endif // HAS_HEATED_BED
 
-  #if HAS_HEATED_CHAMBER
+#if HAS_HEATED_CHAMBER
+
+  void Temperature::manage_heated_chamber(const millis_t &ms) {
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (degChamber() > CHAMBER_MAXTEMP) max_temp_error(H_CHAMBER);
     #endif
 
     #if WATCH_CHAMBER
@@ -1890,50 +1727,53 @@ void Temperature::manage_heater() {
       // PIDTEMPCHAMBER doesn't support a CHAMBER_VENT yet.
       temp_chamber.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
     #else
       if (ELAPSED(ms, next_chamber_check_ms)) {
         next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
         if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
           if (flag_chamber_excess_heat) {
             temp_chamber.soft_pwm_amount = 0;
             #if ENABLED(CHAMBER_VENT)
-              if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
+              if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(temp_chamber.is_below_target() ? 0 : 90);
             #endif
           }
           else {
             #if ENABLED(CHAMBER_LIMIT_SWITCHING)
               if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
                 temp_chamber.soft_pwm_amount = 0;
-              else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
+              else if (temp_chamber.is_below_target(-(TEMP_CHAMBER_HYSTERESIS) + 1))
                 temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
             #else
-              temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? (MAX_CHAMBER_POWER) >> 1 : 0;
+              temp_chamber.soft_pwm_amount = temp_chamber.is_below_target() ? (MAX_CHAMBER_POWER) >> 1 : 0;
             #endif
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(0);
             #endif
           }
         }
         else {
           temp_chamber.soft_pwm_amount = 0;
           WRITE_HEATER_CHAMBER(LOW);
         }
      }
      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
        tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
      #endif
    #endif
+  }
 
-  #endif // HAS_HEATED_CHAMBER
+#endif // HAS_HEATED_CHAMBER
 
-  #if HAS_COOLER
+#if HAS_COOLER
+
+  void Temperature::manage_cooler(const millis_t &ms) {
 
     #ifndef COOLER_CHECK_INTERVAL
       #define COOLER_CHECK_INTERVAL 2000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
       if (degCooler() > COOLER_MAXTEMP) max_temp_error(H_COOLER);
     #endif
 
     #if WATCH_COOLER
@@ -1977,22 +1817,96 @@ void Temperature::manage_heater() {
       if (flag_cooler_state) {
         flag_cooler_state = false;
         thermalManager.set_fan_speed(COOLER_FAN_INDEX, 0);
       }
       WRITE_HEATER_COOLER(LOW);
     }
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
       tr_state_machine[RUNAWAY_IND_COOLER].run(temp_cooler.celsius, temp_cooler.target, H_COOLER, THERMAL_PROTECTION_COOLER_PERIOD, THERMAL_PROTECTION_COOLER_HYSTERESIS);
     #endif
+  }
 
-  #endif // HAS_COOLER
+#endif // HAS_COOLER
+
+/**
+ * Manage heating activities for extruder hot-ends and a heated bed
+ *  - Acquire updated temperature readings
+ *    - Also resets the watchdog timer
+ *  - Invoke thermal runaway protection
+ *  - Manage extruder auto-fan
+ *  - Apply filament width to the extrusion rate (may move)
+ *  - Update the heated bed PID output value
+ */
+void Temperature::task() {
+  if (marlin_state == MF_INITIALIZING) return hal.watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
+
+  static bool no_reentry = false;  // Prevent recursion
+  if (no_reentry) return;
+  REMEMBER(mh, no_reentry, true);
+
+  #if ENABLED(EMERGENCY_PARSER)
+    if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
+
+    if (emergency_parser.quickstop_by_M410) {
+      emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
+      quickstop_stepper();
+    }
+  #endif
+
+  if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
+
+  #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
+    #if TEMP_SENSOR_0_IS_MAX_TC
+      if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
+      if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
+    #endif
+    #if TEMP_SENSOR_1_IS_MAX_TC
+      if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
+      if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
+    #endif
+    #if TEMP_SENSOR_REDUNDANT_IS_MAX_TC
+      if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
+      if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
+    #endif
+  #else
+    #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
+  #endif
+
+  const millis_t ms = millis();
+
+  // Handle Hotend Temp Errors, Heating Watch, etc.
+  TERN_(HAS_HOTEND, manage_hotends(ms));
+
+  #if HAS_TEMP_REDUNDANT
+    // Make sure measured temperatures are close together
+    if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
+      _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), F(STR_REDUNDANCY), GET_TEXT_F(MSG_ERR_REDUNDANT_TEMP));
+  #endif
+
+  // Manage extruder auto fans and/or read fan tachometers
+  TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
+
+  /**
+   * Dynamically set the volumetric multiplier based
+   * on the delayed Filament Width measurement.
+   */
+  TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_volumetric());
+
+  // Handle Bed Temp Errors, Heating Watch, etc.
+  TERN_(HAS_HEATED_BED, manage_heated_bed(ms));
+
+  // Handle Heated Chamber Temp Errors, Heating Watch, etc.
+  TERN_(HAS_HEATED_CHAMBER, manage_heated_chamber(ms));
+
+  // Handle Cooler Temp Errors, Cooling Watch, etc.
+  TERN_(HAS_COOLER, manage_cooler(ms));
 
   #if ENABLED(LASER_COOLANT_FLOW_METER)
     cooler.flowmeter_task(ms);
     #if ENABLED(FLOWMETER_SAFETY)
       if (cutter.enabled() && cooler.check_flow_too_low()) {
         cutter.disable();
         TERN_(HAS_DISPLAY, ui.flow_fault());
       }
     #endif
   #endif
@@ -2472,21 +2386,21 @@ void Temperature::updateTemperaturesFromRawValues() {
     if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) max_temp_error(H_BOARD);
     if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) min_temp_error(H_BOARD);
   #endif
   #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
- * The manager is implemented by periodic calls to manage_heater()
+ * The manager is implemented by periodic calls to task()
  *
  *  - Init (and disable) SPI thermocouples like MAX6675 and MAX31865
  *  - Disable RUMBA JTAG to accommodate a thermocouple extension
  *  - Read-enable thermistors with a read-enable pin
  *  - Init HEATER and COOLER pins for OUTPUT in OFF state
  *  - Init the FAN pins as PWM or OUTPUT
  *  - Init the SPI interface for SPI thermocouples
  *  - Init ADC according to the HAL
  *  - Set thermistor pins to analog inputs according to the HAL
  *  - Start the Temperature ISR timer
@@ -3104,21 +3018,21 @@ void Temperature::disable_all_heaters() {
 
     static TERN(HAS_MAX31855, uint32_t, uint16_t) max_tc_temp = THERMO_SEL(
       TEMP_SENSOR_0_MAX_TC_TMAX,
       TEMP_SENSOR_1_MAX_TC_TMAX
     );
 
     static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
     static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
 
     // Return last-read value between readings
-    millis_t ms = millis();
+    const millis_t ms = millis();
     if (PENDING(ms, next_max_tc_ms[hindex]))
       return THERMO_TEMP(hindex);
 
     next_max_tc_ms[hindex] = ms + MAXTC_HEAT_INTERVAL;
 
     #if !HAS_MAXTC_LIBRARIES
       max_tc_temp = 0;
 
       #if !HAS_MAXTC_SW_SPI
         // Initialize SPI using the default Hardware SPI bus.
@@ -3412,30 +3326,32 @@ void Temperature::isr() {
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER, soft_pwm_chamber, temp_chamber);
       #endif
 
       #if HAS_COOLER
         _PWM_MOD(COOLER, soft_pwm_cooler, temp_cooler);
       #endif
 
-      #if BOTH(USE_CONTROLLER_FAN, FAN_SOFT_PWM)
-        WRITE(CONTROLLER_FAN_PIN, soft_pwm_controller.add(pwm_mask, soft_pwm_controller_speed));
-      #endif
-
       #if ENABLED(FAN_SOFT_PWM)
+
+        #if ENABLED(USE_CONTROLLER_FAN)
+          WRITE(CONTROLLER_FAN_PIN, soft_pwm_controller.add(pwm_mask, soft_pwm_controller_speed));
+        #endif
+
         #define _FAN_PWM(N) do{                                     \
           uint8_t &spcf = soft_pwm_count_fan[N];                    \
           spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
           WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW);               \
         }while(0)
+
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif
         #if HAS_FAN3

commit e4e6abe5af0f97ff5cb0c9334cb298d3584968e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 9 00:51:08 2022 -0500

    üßë‚Äçüíª Remove servo macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 531c52c09d..17ab08d4c2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1874,50 +1874,50 @@ void Temperature::manage_heater() {
             flag_chamber_excess_heat = false;
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
           set_fan_speed(CHAMBER_FAN_INDEX, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
-          MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
+          servo[CHAMBER_VENT_SERVO_NR].move(90);
         #endif
       }
     #endif
 
     #if ENABLED(PIDTEMPCHAMBER)
       // PIDTEMPCHAMBER doesn't support a CHAMBER_VENT yet.
       temp_chamber.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
     #else
       if (ELAPSED(ms, next_chamber_check_ms)) {
         next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
         if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
           if (flag_chamber_excess_heat) {
             temp_chamber.soft_pwm_amount = 0;
             #if ENABLED(CHAMBER_VENT)
-              if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
+              if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
             #endif
           }
           else {
             #if ENABLED(CHAMBER_LIMIT_SWITCHING)
               if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
                 temp_chamber.soft_pwm_amount = 0;
               else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
                 temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
             #else
               temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? (MAX_CHAMBER_POWER) >> 1 : 0;
             #endif
             #if ENABLED(CHAMBER_VENT)
-              if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 0);
+              if (!flag_chamber_off) servo[CHAMBER_VENT_SERVO_NR].move(0);
             #endif
           }
         }
         else {
           temp_chamber.soft_pwm_amount = 0;
           WRITE_HEATER_CHAMBER(LOW);
         }
      }
      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
        tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);

commit 9c872b214c1cef9791d7d7da45348d562c18d0ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 22:06:32 2022 -0500

    üêõ Fix min/max temp evaluation
    
    Fixes #24257

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4fe71d3fef..531c52c09d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2702,27 +2702,29 @@ void Temperature::init() {
   #endif
   #if HAS_AUTO_FAN_7 && !(_EFANOVERLAP(7,0) || _EFANOVERLAP(7,1) || _EFANOVERLAP(7,2) || _EFANOVERLAP(7,3) || _EFANOVERLAP(7,4) || _EFANOVERLAP(7,5) || _EFANOVERLAP(7,6))
     INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   #if HAS_HOTEND
     #define _TEMP_MIN_E(NR) do{ \
-      const celsius_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
+      const celsius_t tmin_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))), \
+                      tmin = _MAX(HEATER_##NR##_MINTEMP, tmin_tmp); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
-      const celsius_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
+      const celsius_t tmax_tmp = TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, int16_t(pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius)) - 1), \
+                      tmax = _MIN(HEATER_##NR##_MAXTEMP, tmax_tmp); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
     #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##N > 0 && TEMP_SENSOR_##N != 998 && TEMP_SENSOR_##N != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif

commit 85c0875db28477d7ed6515c39376b93407353b27
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue May 31 23:09:44 2022 +0100

    ‚ú® Laser Safety Timeout (#24189)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e3d276b4ee..4fe71d3fef 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -64,20 +64,24 @@
 #endif
 
 #if HAS_TEMP_SENSOR
   #include "../gcode/gcode.h"
 #endif
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "../libs/nozzle.h"
 #endif
 
+#if LASER_SAFETY_TIMEOUT_MS > 0
+  #include "../feature/spindle_laser.h"
+#endif
+
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 #define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
 #if HAS_MAX6675 && USE_LIB_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
@@ -3321,29 +3325,38 @@ public:
         state_heater = v;
         state_timer_heater = MIN_STATE_TIME;
       }
       return rdy;
     }
   #endif
 };
 
 /**
  * Handle various ~1kHz tasks associated with temperature
+ *  - Check laser safety timeout
  *  - Heater PWM (~1kHz with scaler)
  *  - LCD Button polling (~500Hz)
  *  - Start / Read one ADC sensor
  *  - Advance Babysteps
  *  - Endstop polling
  *  - Planner clean buffer
  */
 void Temperature::isr() {
 
+  // Shut down the laser if steppers are inactive for > LASER_SAFETY_TIMEOUT_MS ms
+  #if LASER_SAFETY_TIMEOUT_MS > 0
+    if (cutter.last_power_applied && ELAPSED(millis(), gcode.previous_move_ms + (LASER_SAFETY_TIMEOUT_MS))) {
+      cutter.power = 0;       // Prevent planner idle from re-enabling power
+      cutter.apply_power(0);
+    }
+  #endif
+
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
 
   // Avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static raw_adc_t raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;

commit 6ecf52f196d08d399c24b1516fc0b33b227ed66c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat May 28 23:40:08 2022 +0100

    üö© MPC update (#24253)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index aa1cc04a3a..e3d276b4ee 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -987,21 +987,21 @@ volatile bool Temperature::raw_temps_ready = false;
     hotend.soft_pwm_amount = 0;
 
     // Calculate physical constants from three equally-spaced samples
     sample_count = (sample_count + 1) / 2 * 2 - 1;
     const float t1 = temp_samples[0],
                 t2 = temp_samples[(sample_count - 1) >> 1],
                 t3 = temp_samples[sample_count - 1];
     float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
           block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
 
-    constants.ambient_xfer_coeff_fan0 = constants.heater_power * MPC_MAX / 255 / (asymp_temp - ambient_temp);
+    constants.ambient_xfer_coeff_fan0 = constants.heater_power * (MPC_MAX) / 255 / (asymp_temp - ambient_temp);
     constants.fan255_adjustment = 0.0f;
     constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
     constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
     hotend.modeled_sensor_temp = current_temp;
 
     // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
     SERIAL_ECHOLNPGM(STR_MPC_MEASURING_AMBIENT, hotend.modeled_block_temp);
     LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT);
@@ -1051,21 +1051,21 @@ volatile bool Temperature::raw_temps_ready = false;
     const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
     constants.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
 
     #if HAS_FAN
       const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
       constants.fan255_adjustment = ambient_xfer_coeff_fan255 - constants.ambient_xfer_coeff_fan0;
     #endif
 
     // Calculate a new and better asymptotic temperature and re-evaluate the other constants
-    asymp_temp = ambient_temp + constants.heater_power / constants.ambient_xfer_coeff_fan0;
+    asymp_temp = ambient_temp + constants.heater_power * (MPC_MAX) / 255 / constants.ambient_xfer_coeff_fan0;
     block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
     constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
     constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
 
     /* <-- add a slash to enable
       SERIAL_ECHOLNPGM("t1_time ", t1_time);
       SERIAL_ECHOLNPGM("sample_count ", sample_count);
@@ -1435,21 +1435,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
         const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
         // The position can appear to make big jumps when, e.g. homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])
           mpc_e_position = e_position;
         else if (e_speed > 0.0f) {  // Ignore retract/recover moves
-          ambient_xfer_coeff += e_speed * FILAMENT_HEAT_CAPACITY_PERMM;
+          ambient_xfer_coeff += e_speed * constants.filament_heat_capacity_permm;
           mpc_e_position = e_position;
         }
       }
 
       // Update the modeled temperatures
       float blocktempdelta = hotend.soft_pwm_amount * constants.heater_power * (MPC_dT / 127) / constants.block_heat_capacity;
       blocktempdelta += (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff * MPC_dT / constants.block_heat_capacity;
       hotend.modeled_block_temp += blocktempdelta;
 
       const float sensortempdelta = (hotend.modeled_block_temp - hotend.modeled_sensor_temp) * (constants.sensor_responsiveness * MPC_dT);

commit 52eefa90e1c18616f127cdf43798907880e05ee5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 11:36:13 2022 -0500

    ‚ôªÔ∏è Move watchdog to MarlinHAL

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 84bd1c5007..aa1cc04a3a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1219,24 +1219,24 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
   thermalManager.disable_all_heaters();
   #if HAS_BEEPER
     for (uint8_t i = 20; i--;) {
-      watchdog_refresh();
+      hal.watchdog_refresh();
       buzzer.click(25);
       delay(80);
-      watchdog_refresh();
+      hal.watchdog_refresh();
     }
     buzzer.on();
   #endif
   #if ENABLED(NOZZLE_PARK_FEATURE)
     if (!homing_needed_error()) {
       nozzle.park(0);
       planner.synchronize();
     }
   #endif
   kill(lcd_msg, HEATER_FSTR(heater_id));
@@ -1267,21 +1267,21 @@ void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_m
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
         if (real_heater_id >= 0)
           SERIAL_ECHOLNPGM("E", real_heater_id);
     }
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
-  watchdog_refresh();
+  hal.watchdog_refresh();
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
       case 0:
         expire_ms = ms + BOGUS_TEMPERATURE_GRACE_PERIOD;
         ++killed;
         break;
       case 1:
@@ -1631,21 +1631,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
-  if (marlin_state == MF_INITIALIZING) return watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
+  if (marlin_state == MF_INITIALIZING) return hal.watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
 
   static bool no_reentry = false;  // Prevent recursion
   if (no_reentry) return;
   REMEMBER(mh, no_reentry, true);
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
@@ -2380,21 +2380,21 @@ void Temperature::manage_heater() {
  * The raw values are generated entirely in interrupt context, and this
  * method is called from normal context once 'raw_temps_ready' has been
  * set by update_raw_temperatures().
  *
  * The watchdog is dependent on this method. If 'raw_temps_ready' stops
  * being set by the interrupt so that this method is not called for over
  * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
 
-  watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
+  hal.watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].setraw(READ_MAX_TC(0)));
   TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].setraw(READ_MAX_TC(1)));
   TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.setraw(READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE))));
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].getraw(), e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.getraw()));

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ‚ú® SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9cadcdc84e..84bd1c5007 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -171,21 +171,21 @@
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
-#if USE_BEEPER
+#if HAS_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if ANY(TEMP_SENSOR_0_IS_THERMISTOR, TEMP_SENSOR_1_IS_THERMISTOR, TEMP_SENSOR_2_IS_THERMISTOR, TEMP_SENSOR_3_IS_THERMISTOR, \
         TEMP_SENSOR_4_IS_THERMISTOR, TEMP_SENSOR_5_IS_THERMISTOR, TEMP_SENSOR_6_IS_THERMISTOR, TEMP_SENSOR_7_IS_THERMISTOR )
   #define HAS_HOTEND_THERMISTOR 1
@@ -1217,32 +1217,28 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
   thermalManager.disable_all_heaters();
-  #if USE_BEEPER
+  #if HAS_BEEPER
     for (uint8_t i = 20; i--;) {
-      WRITE(BEEPER_PIN, HIGH);
-      delay(25);
       watchdog_refresh();
-      WRITE(BEEPER_PIN, LOW);
-      delay(40);
-      watchdog_refresh();
-      delay(40);
+      buzzer.click(25);
+      delay(80);
       watchdog_refresh();
     }
-    WRITE(BEEPER_PIN, HIGH);
+    buzzer.on();
   #endif
   #if ENABLED(NOZZLE_PARK_FEATURE)
     if (!homing_needed_error()) {
       nozzle.park(0);
       planner.synchronize();
     }
   #endif
   kill(lcd_msg, HEATER_FSTR(heater_id));
 }
 

commit 5005c7b64c1763eca767ad476f404301d6ef754a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Apr 19 15:03:42 2022 +1200

    üêõ Fix Manual Move cold extrude override (#24045)
    
    Followup to #19606
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2db2487b78..9cadcdc84e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -480,20 +480,26 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #endif
 
 #if HAS_TEMP_BOARD
   board_info_t Temperature::temp_board; // = { 0 }
   #if ENABLED(THERMAL_PROTECTION_BOARD)
     raw_adc_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
               Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
   #endif
 #endif
 
+#if BOTH(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
+  bool Temperature::allow_cold_extrude_override = false;
+#else
+  constexpr bool Temperature::allow_cold_extrude_override;
+#endif
+
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint16_t Temperature::ADCKey_count = 0;
 #endif
 

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b713a5ba47..2db2487b78 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -734,21 +734,21 @@ volatile bool Temperature::raw_temps_ready = false;
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
-          print_heater_states(ischamber ? active_extruder : (isbed ? active_extruder : heater_id));
+          print_heater_states(heater_id < 0 ? active_extruder : (int8_t)heater_id);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_PID
           if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
@@ -2802,20 +2802,23 @@ void Temperature::init() {
         temp_bed
       #else
         temp_hotend[HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET)]
       #endif
     );
   #endif
 }
 
 #if HAS_THERMAL_PROTECTION
 
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+
   Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
    * @param hysteresis_degc  allowed distance from target
    *
@@ -2931,20 +2934,22 @@ void Temperature::init() {
         _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
 
       #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
         case TRMalfunction:
           TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
           _temp_error(heater_id, FPSTR(str_t_temp_malfunction), GET_TEXT_F(MSG_TEMP_MALFUNCTION));
       #endif
     }
   }
 
+  #pragma GCC diagnostic pop
+
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   // Disable autotemp, unpause and reset everything
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
   TERN_(PROBING_HEATERS_OFF, pause_heaters(false));
 
   #if HAS_HOTEND
     HOTEND_LOOP() {
@@ -3645,37 +3650,42 @@ void Temperature::isr() {
    */
   #define ACCUMULATE_ADC(obj) do{ \
     if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; \
     else obj.sample(hal.adc_value()); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
+    #pragma GCC diagnostic push
+    #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
+
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
       static uint8_t delay_count = 0;
       if (extra_loops > 0) {
         if (delay_count == 0) delay_count = extra_loops;  // Init this delay
         if (--delay_count)                                // While delaying...
           next_sensor_state = SensorsReady;               // retain this state (else, next state will be 0)
         break;
       }
       else {
         adc_sensor_state = StartSampling;                 // Fall-through to start sampling
         next_sensor_state = (ADCSensorState)(int(StartSampling) + 1);
       }
     }
 
+    #pragma GCC diagnostic pop
+
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
       if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
       case PrepareTemp_0: hal.adc_start(TEMP_0_PIN); break;
       case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
@@ -3893,21 +3903,21 @@ void Temperature::isr() {
     SERIAL_ECHOPGM(" /");
     SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       SERIAL_ECHOPGM(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
-  void Temperature::print_heater_states(const uint8_t target_extruder
+  void Temperature::print_heater_states(const int8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
     #endif
     #if HAS_HEATED_BED
       print_heater_state(H_BED, degBed(), degTargetBed() OPTARG(SHOW_TEMP_ADC_VALUES, rawBedTemp()));
     #endif
     #if HAS_TEMP_CHAMBER
       print_heater_state(H_CHAMBER, degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber()) OPTARG(SHOW_TEMP_ADC_VALUES, rawChamberTemp()));

commit cec7836959ab13908cbf469b485b219e52323576
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 10 03:58:58 2022 -0500

    ‚ú® Autoreport Redundant Sensor option (#24014)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 58e6c816e8..b713a5ba47 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3941,21 +3941,24 @@ void Temperature::isr() {
       HOTEND_LOOP() {
         SERIAL_ECHOPGM(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
-    void Temperature::AutoReportTemp::report() { print_heater_states(active_extruder); SERIAL_EOL(); }
+    void Temperature::AutoReportTemp::report() {
+      print_heater_states(active_extruder OPTARG(HAS_TEMP_REDUNDANT, ENABLED(AUTO_REPORT_REDUNDANT)));
+      SERIAL_EOL();
+    }
   #endif
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e, const bool isM104/*=false*/) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf(0,
         #if HAS_MULTI_HOTEND
           F("E%c " S_FMT), '1' + e
         #else
           F("E1 " S_FMT)

commit 3da29b4a04691d4e8dc8691b006cf51c0bf46fc9
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Apr 10 07:20:05 2022 +0100

    üö∏ Improve MPC tuning, add menu items (#23984)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c82b76579c..58e6c816e8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -134,22 +134,26 @@
     #define SW_SPI_MISO_PIN   TEMP_1_MISO_PIN
     #if PIN_EXISTS(TEMP_1_MOSI)
       #define SW_SPI_MOSI_PIN TEMP_1_MOSI_PIN
     #endif
   #endif
   #ifndef SW_SPI_MOSI_PIN
     #define SW_SPI_MOSI_PIN   SD_MOSI_PIN
   #endif
 #endif
 
-#if EITHER(MPCTEMP, PID_EXTRUSION_SCALING)
+#if ENABLED(MPCTEMP)
   #include <math.h>
+  #include "probe.h"
+#endif
+
+#if EITHER(MPCTEMP, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
@@ -857,78 +861,114 @@ volatile bool Temperature::raw_temps_ready = false;
     auto housekeeping = [] (millis_t& ms, celsius_float_t& current_temp, millis_t& next_report_ms) {
       ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
         current_temp = degHotend(active_extruder);
         TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
       }
 
       if (ELAPSED(ms, next_report_ms)) {
         next_report_ms += 1000UL;
-        SERIAL_ECHOLNPGM("Temperature ", current_temp);
+
+        print_heater_states(active_extruder);
+        SERIAL_EOL();
       }
 
       hal.idletask();
+      TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
+
+      if (!wait_for_heatup) {
+        SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
+        SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_INTERRUPTED);
+        return false;
+      }
+
+      return true;
     };
 
-    SERIAL_ECHOLNPGM("Measuring MPC constants for E", active_extruder);
-    MPCHeaterInfo& hotend = temp_hotend[active_extruder];
-    MPC_t& constants = hotend.constants;
+    struct OnExit {
+      ~OnExit() {
+        wait_for_heatup = false;
+
+        ui.reset_status();
+
+        temp_hotend[active_extruder].target = 0.0f;
+        temp_hotend[active_extruder].soft_pwm_amount = 0;
+        #if HAS_FAN
+          set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
+          planner.sync_fan_speeds(fan_speed);
+        #endif
 
-    // move to center of bed, just above bed height and cool with max fan
-    TERN_(HAS_FAN, zero_fan_speeds());
+        do_z_clearance(MPC_TUNING_END_Z);
+      }
+    } on_exit;
+
+    SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
+    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_START, active_extruder);
+    MPCHeaterInfo &hotend = temp_hotend[active_extruder];
+    MPC_t &constants = hotend.constants;
+
+    // Move to center of bed, just above bed height and cool with max fan
     disable_all_heaters();
-    TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255));
-    TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
+    #if HAS_FAN
+      zero_fan_speeds();
+      set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
+      planner.sync_fan_speeds(fan_speed);
+    #endif
     gcode.home_all_axes(true);
     const xyz_pos_t tuningpos = MPC_TUNING_POS;
     do_blocking_move_to(tuningpos);
 
-    SERIAL_ECHOLNPGM("Cooling to ambient");
+    SERIAL_ECHOLNPGM(STR_MPC_COOLING_TO_AMBIENT);
+    LCD_MESSAGE(MSG_COOLING);
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
     celsius_float_t current_temp = degHotend(active_extruder),
                     ambient_temp = current_temp;
 
-    wait_for_heatup = true; // Can be interrupted with M108
-    while (wait_for_heatup) {
-      housekeeping(ms, current_temp, next_report_ms);
+    wait_for_heatup = true;
+    for (;;) { // Can be interrupted with M108
+      if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
 
-    TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0));
-    TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
+    #if HAS_FAN
+      set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0);
+      planner.sync_fan_speeds(fan_speed);
+    #endif
 
     hotend.modeled_ambient_temp = ambient_temp;
 
-    SERIAL_ECHOLNPGM("Heating to 200C");
+    SERIAL_ECHOLNPGM(STR_MPC_HEATING_PAST_200);
+    LCD_MESSAGE(MSG_HEATING);
+    hotend.target = 200.0f;   // So M105 looks nice
     hotend.soft_pwm_amount = MPC_MAX >> 1;
     const millis_t heat_start_time = next_test_ms = ms;
     celsius_float_t temp_samples[16];
     uint8_t sample_count = 0;
     uint16_t sample_distance = 1;
     float t1_time = 0;
 
-    while (wait_for_heatup) {
-      housekeeping(ms, current_temp, next_report_ms);
+    for (;;) { // Can be interrupted with M108
+      if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
-        // record samples between 100C and 200C
+        // Record samples between 100C and 200C
         if (current_temp >= 100.0f) {
-          // if there are too many samples, space them more widely
+          // If there are too many samples, space them more widely
           if (sample_count == COUNT(temp_samples)) {
             for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
               temp_samples[i] = temp_samples[i*2];
             sample_count /= 2;
             sample_distance *= 2;
           }
 
           if (sample_count == 0) t1_time = float(ms - heat_start_time) / 1000.0f;
           temp_samples[sample_count++] = current_temp;
         }
@@ -937,98 +977,95 @@ volatile bool Temperature::raw_temps_ready = false;
 
         next_test_ms += 1000UL * sample_distance;
       }
     }
     hotend.soft_pwm_amount = 0;
 
     // Calculate physical constants from three equally-spaced samples
     sample_count = (sample_count + 1) / 2 * 2 - 1;
     const float t1 = temp_samples[0],
                 t2 = temp_samples[(sample_count - 1) >> 1],
-                t3 = temp_samples[sample_count - 1],
-                asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
-                block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
+                t3 = temp_samples[sample_count - 1];
+    float asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
+          block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
 
     constants.ambient_xfer_coeff_fan0 = constants.heater_power * MPC_MAX / 255 / (asymp_temp - ambient_temp);
     constants.fan255_adjustment = 0.0f;
     constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
     constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
     hotend.modeled_sensor_temp = current_temp;
 
     // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
-    SERIAL_ECHOLNPGM("Measuring ambient heatloss at target ", hotend.modeled_block_temp);
+    SERIAL_ECHOLNPGM(STR_MPC_MEASURING_AMBIENT, hotend.modeled_block_temp);
+    LCD_MESSAGE(MSG_MPC_MEASURING_AMBIENT);
     hotend.target = hotend.modeled_block_temp;
     next_test_ms = ms + MPC_dT * 1000;
     constexpr millis_t settle_time = 20000UL, test_duration = 20000UL;
     millis_t settle_end_ms = ms + settle_time,
              test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
-    while (wait_for_heatup) {
-      housekeeping(ms, current_temp, next_report_ms);
+    for (;;) { // Can be interrupted with M108
+      if (!housekeeping(ms, current_temp, next_report_ms)) return;
 
       if (ELAPSED(ms, next_test_ms)) {
-        // use MPC to control the temperature, let it settle for 30s and then track power output for 10s
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
-            SERIAL_ECHOLNPGM("Measuring ambient heatloss with full fan");
             set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
             planner.sync_fan_speeds(fan_speed);
             settle_end_ms = ms + settle_time;
             test_end_ms = settle_end_ms + test_duration;
             fan0_done = true;
           }
           else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
             total_energy_fan255 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
         #endif
         else if (ELAPSED(ms, test_end_ms)) break;
 
         last_temp = current_temp;
         next_test_ms += MPC_dT * 1000;
       }
 
-      if (!WITHIN(current_temp, hotend.target - 15.0f, hotend.target + 15.0f)) {
-        SERIAL_ECHOLNPGM("Temperature error while measuring ambient loss");
+      if (!WITHIN(current_temp, t3 - 15.0f, hotend.target + 15.0f)) {
+        SERIAL_ECHOLNPGM(STR_MPC_TEMPERATURE_ERROR);
         break;
       }
     }
 
     const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
     constants.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
 
     #if HAS_FAN
       const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
       constants.fan255_adjustment = ambient_xfer_coeff_fan255 - constants.ambient_xfer_coeff_fan0;
     #endif
 
-    hotend.target = 0.0f;
-    hotend.soft_pwm_amount = 0;
-    TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0));
-    TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
-
-    if (!wait_for_heatup) SERIAL_ECHOLNPGM("Test was interrupted");
-
-    wait_for_heatup = false;
+    // Calculate a new and better asymptotic temperature and re-evaluate the other constants
+    asymp_temp = ambient_temp + constants.heater_power / constants.ambient_xfer_coeff_fan0;
+    block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
+    constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
+    constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
-    SERIAL_ECHOLNPGM("Done");
+    SERIAL_ECHOPGM(STR_MPC_AUTOTUNE);
+    SERIAL_ECHOLNPGM(STR_MPC_AUTOTUNE_FINISHED);
 
     /* <-- add a slash to enable
       SERIAL_ECHOLNPGM("t1_time ", t1_time);
       SERIAL_ECHOLNPGM("sample_count ", sample_count);
       SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
       for (uint8_t i = 0; i < sample_count; i++)
         SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
       SERIAL_ECHOLNPGM("t1 ", t1, " t2 ", t2, " t3 ", t3);
       SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
       SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
@@ -1371,76 +1408,76 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
           );
         }
       #endif
 
     #elif ENABLED(MPCTEMP)
       MPCHeaterInfo &hotend = temp_hotend[ee];
       MPC_t &constants = hotend.constants;
 
       // At startup, initialize modeled temperatures
       if (isnan(hotend.modeled_block_temp)) {
-        hotend.modeled_ambient_temp = min(30.0f, hotend.celsius);   // cap initial value at reasonable max room temperature of 30C
+        hotend.modeled_ambient_temp = min(30.0f, hotend.celsius);   // Cap initial value at reasonable max room temperature of 30C
         hotend.modeled_block_temp = hotend.modeled_sensor_temp = hotend.celsius;
       }
 
       #if HOTENDS == 1
         constexpr bool this_hotend = true;
       #else
         const bool this_hotend = (ee == active_extruder);
       #endif
 
       float ambient_xfer_coeff = constants.ambient_xfer_coeff_fan0;
       #if ENABLED(MPC_INCLUDE_FAN)
         const uint8_t fan_index = ANY(MPC_FAN_0_ACTIVE_HOTEND, MPC_FAN_0_ALL_HOTENDS) ? 0 : ee;
         const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
         ambient_xfer_coeff += fan_fraction * constants.fan255_adjustment;
       #endif
 
       if (this_hotend) {
         const int32_t e_position = stepper.position(E_AXIS);
         const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
 
-        // the position can appear to make big jumps when, e.g. homing
+        // The position can appear to make big jumps when, e.g. homing
         if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])
           mpc_e_position = e_position;
-        else if (e_speed > 0.0f) {  // ignore retract/recover moves
+        else if (e_speed > 0.0f) {  // Ignore retract/recover moves
           ambient_xfer_coeff += e_speed * FILAMENT_HEAT_CAPACITY_PERMM;
           mpc_e_position = e_position;
         }
       }
 
-      // update the modeled temperatures
+      // Update the modeled temperatures
       float blocktempdelta = hotend.soft_pwm_amount * constants.heater_power * (MPC_dT / 127) / constants.block_heat_capacity;
       blocktempdelta += (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff * MPC_dT / constants.block_heat_capacity;
       hotend.modeled_block_temp += blocktempdelta;
 
       const float sensortempdelta = (hotend.modeled_block_temp - hotend.modeled_sensor_temp) * (constants.sensor_responsiveness * MPC_dT);
       hotend.modeled_sensor_temp += sensortempdelta;
 
       // Any delta between hotend.modeled_sensor_temp and hotend.celsius is either model
       // error diverging slowly or (fast) noise. Slowly correct towards this temperature and noise will average out.
       const float delta_to_apply = (hotend.celsius - hotend.modeled_sensor_temp) * (MPC_SMOOTHING_FACTOR);
       hotend.modeled_block_temp += delta_to_apply;
       hotend.modeled_sensor_temp += delta_to_apply;
 
-      // only correct ambient when close to steady state (output power is not clipped or asymptotic temperature is reached)
+      // Only correct ambient when close to steady state (output power is not clipped or asymptotic temperature is reached)
       if (WITHIN(hotend.soft_pwm_amount, 1, 126) || fabs(blocktempdelta + delta_to_apply) < (MPC_STEADYSTATE * MPC_dT))
         hotend.modeled_ambient_temp += delta_to_apply > 0.f ? max(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : min(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
 
       float power = 0.0;
       if (hotend.target != 0 && TERN1(HEATER_IDLE_HANDLER, !heater_idle[ee].timed_out)) {
-        // plan power level to get to target temperature in 2 seconds
+        // Plan power level to get to target temperature in 2 seconds
         power = (hotend.target - hotend.modeled_block_temp) * constants.block_heat_capacity / 2.0f;
         power -= (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff;
       }
 
-      float pid_output = power * 254.0f / constants.heater_power + 1.0f;        // ensure correct quantization into a range of 0 to 127
+      float pid_output = power * 254.0f / constants.heater_power + 1.0f;        // Ensure correct quantization into a range of 0 to 127
       pid_output = constrain(pid_output, 0, MPC_MAX);
 
       /* <-- add a slash to enable
         static uint32_t nexttime = millis() + 1000;
         if (ELAPSED(millis(), nexttime)) {
           nexttime += 1000;
           SERIAL_ECHOLNPGM("block temp ", hotend.modeled_block_temp,
                            ", celsius ", hotend.celsius,
                            ", blocktempdelta ", blocktempdelta,
                            ", delta_to_apply ", delta_to_apply,
@@ -2072,21 +2109,21 @@ void Temperature::manage_heater() {
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
       t.pre_calc     = false;
       t.res_25_recip = 1.0f / t.res_25;
       t.res_25_log   = logf(t.res_25);
       t.beta_recip   = 1.0f / t.beta;
       t.sh_alpha     = RECIPROCAL(THERMISTOR_RESISTANCE_NOMINAL_C - (THERMISTOR_ABS_ZERO_C))
                         - (t.beta_recip * t.res_25_log) - (t.sh_c_coeff * cu(t.res_25_log));
     }
 
-    // maximum adc value .. take into account the over sampling
+    // Maximum ADC value .. take into account the over sampling
     constexpr raw_adc_t adc_max = MAX_RAW_THERMISTOR_VALUE;
     const raw_adc_t adc_raw = constrain(raw, 1, adc_max - 1); // constrain to prevent divide-by-zero
 
     const float adc_inverse = (adc_max - adc_raw) - 0.5f,
                 resistance = t.series_res * (adc_raw + 0.5f) / adc_inverse,
                 log_resistance = logf(resistance);
 
     float value = t.sh_alpha;
     value += log_resistance * t.beta_recip;
     if (t.sh_c_coeff != 0)
@@ -3070,30 +3107,30 @@ void Temperature::disable_all_heaters() {
     #if !HAS_MAXTC_LIBRARIES
       max_tc_temp = 0;
 
       #if !HAS_MAXTC_SW_SPI
         // Initialize SPI using the default Hardware SPI bus.
         // FIXME: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
         spiBegin();
         spiInit(MAX_TC_SPEED_BITS);
       #endif
 
-      MAXTC_CS_WRITE(LOW);  // enable MAXTC
+      MAXTC_CS_WRITE(LOW);  // Enable MAXTC
       DELAY_NS(100);        // Ensure 100ns delay
 
       // Read a big-endian temperature value without using a library
       for (uint8_t i = sizeof(max_tc_temp); i--;) {
         max_tc_temp |= TERN(HAS_MAXTC_SW_SPI, max_tc_spi.receive(), spiRec());
         if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
       }
 
-      MAXTC_CS_WRITE(HIGH);  // disable MAXTC
+      MAXTC_CS_WRITE(HIGH);  // Disable MAXTC
     #else
       #if HAS_MAX6675_LIBRARY
         MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1);
         max_tc_temp = max6675ref.readRaw16();
       #endif
 
       #if HAS_MAX31855_LIBRARY
         MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1);
         max_tc_temp = max855ref.readRaw32();
       #endif
@@ -3290,21 +3327,21 @@ public:
  *  - Advance Babysteps
  *  - Endstop polling
  *  - Planner clean buffer
  */
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
 
-  // avoid multiple loads of pwm_count
+  // Avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static raw_adc_t raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;
   #endif
 
   #if HAS_HOTEND
     static SoftPWM soft_pwm_hotend[HOTENDS];
   #endif
@@ -3568,22 +3605,22 @@ void Temperature::isr() {
     // SOFT_PWM_SCALE to frequency:
     //
     // 0: 16000000/64/256/128 =   7.6294 Hz
     // 1:                / 64 =  15.2588 Hz
     // 2:                / 32 =  30.5176 Hz
     // 3:                / 16 =  61.0352 Hz
     // 4:                /  8 = 122.0703 Hz
     // 5:                /  4 = 244.1406 Hz
     pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
 
-    // increment slow_pwm_count only every 64th pwm_count,
-    // i.e. yielding a PWM frequency of 16/128 Hz (8s).
+    // Increment slow_pwm_count only every 64th pwm_count,
+    // i.e., yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
       #if HAS_HOTEND
         HOTEND_LOOP() soft_pwm_hotend[e].dec();
       #endif
       TERN_(HAS_HEATED_BED, soft_pwm_bed.dec());
       TERN_(HAS_HEATED_CHAMBER, soft_pwm_chamber.dec());
       TERN_(HAS_COOLER, soft_pwm_cooler.dec());
@@ -4022,21 +4059,21 @@ void Temperature::isr() {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
 
         #endif
 
         // Prevent a wait-forever situation if R is misused i.e. M109 R0
         if (wants_to_cool) {
-          // break after MIN_COOLING_SLOPE_TIME seconds
+          // Break after MIN_COOLING_SLOPE_TIME seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
             next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
@@ -4044,21 +4081,21 @@ void Temperature::isr() {
             TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         wait_for_heatup = false;
         #if HAS_DWIN_E3V2_BASIC
           HMI_flag.heat_flag = 0;
-          duration_t elapsed = print_job_timer.duration();  // print timer
+          duration_t elapsed = print_job_timer.duration();  // Print timer
           dwin_heat_time = elapsed.value;
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
         return true;
       }
 
       return false;
     }

commit e2353be24f2c7914c51441c2135cf2eb4cb1262d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 9 22:52:36 2022 -0500

    üé® Misc. cleanup, string optimization

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 783423a01c..c82b76579c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -625,46 +625,49 @@ volatile bool Temperature::raw_temps_ready = false;
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
+      SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
+    SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
-    // PID Tuning loop
-    wait_for_heatup = true; // Can be interrupted with M108
     LCD_MESSAGE(MSG_HEATING);
-    while (wait_for_heatup) {
+
+    // PID Tuning loop
+    wait_for_heatup = true;
+    while (wait_for_heatup) { // Can be interrupted with M108
 
       const millis_t ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
@@ -716,20 +719,21 @@ volatile bool Temperature::raw_temps_ready = false;
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
+        SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
@@ -758,25 +762,27 @@ volatile bool Temperature::raw_temps_ready = false;
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
+        SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
+        SERIAL_ECHOPGM(STR_PID_AUTOTUNE);
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
@@ -862,21 +868,20 @@ volatile bool Temperature::raw_temps_ready = false;
       }
 
       hal.idletask();
     };
 
     SERIAL_ECHOLNPGM("Measuring MPC constants for E", active_extruder);
     MPCHeaterInfo& hotend = temp_hotend[active_extruder];
     MPC_t& constants = hotend.constants;
 
     // move to center of bed, just above bed height and cool with max fan
-    SERIAL_ECHOLNPGM("Moving to tuning position");
     TERN_(HAS_FAN, zero_fan_speeds());
     disable_all_heaters();
     TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255));
     TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
     gcode.home_all_axes(true);
     const xyz_pos_t tuningpos = MPC_TUNING_POS;
     do_blocking_move_to(tuningpos);
 
     SERIAL_ECHOLNPGM("Cooling to ambient");
     millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
@@ -889,29 +894,29 @@ volatile bool Temperature::raw_temps_ready = false;
 
       if (ELAPSED(ms, next_test_ms)) {
         if (current_temp >= ambient_temp) {
           ambient_temp = (ambient_temp + current_temp) / 2.0f;
           break;
         }
         ambient_temp = current_temp;
         next_test_ms += 10000UL;
       }
     }
+
     TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0));
     TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
 
     hotend.modeled_ambient_temp = ambient_temp;
 
     SERIAL_ECHOLNPGM("Heating to 200C");
     hotend.soft_pwm_amount = MPC_MAX >> 1;
-    const millis_t heat_start_time = ms;
-    next_test_ms = ms;
+    const millis_t heat_start_time = next_test_ms = ms;
     celsius_float_t temp_samples[16];
     uint8_t sample_count = 0;
     uint16_t sample_distance = 1;
     float t1_time = 0;
 
     while (wait_for_heatup) {
       housekeeping(ms, current_temp, next_report_ms);
 
       if (ELAPSED(ms, next_test_ms)) {
         // record samples between 100C and 200C
@@ -928,44 +933,43 @@ volatile bool Temperature::raw_temps_ready = false;
           temp_samples[sample_count++] = current_temp;
         }
 
         if (current_temp >= 200.0f) break;
 
         next_test_ms += 1000UL * sample_distance;
       }
     }
     hotend.soft_pwm_amount = 0;
 
-    // calculate physical constants from three equally spaced samples
+    // Calculate physical constants from three equally-spaced samples
     sample_count = (sample_count + 1) / 2 * 2 - 1;
     const float t1 = temp_samples[0],
                 t2 = temp_samples[(sample_count - 1) >> 1],
                 t3 = temp_samples[sample_count - 1],
                 asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
                 block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
 
     constants.ambient_xfer_coeff_fan0 = constants.heater_power * MPC_MAX / 255 / (asymp_temp - ambient_temp);
     constants.fan255_adjustment = 0.0f;
     constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
     constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
 
     hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
     hotend.modeled_sensor_temp = current_temp;
 
-    // let the system stabilise under MPC control then get a better measure of ambient loss without and with fan
+    // Allow the system to stabilize under MPC, then get a better measure of ambient loss with and without fan
     SERIAL_ECHOLNPGM("Measuring ambient heatloss at target ", hotend.modeled_block_temp);
     hotend.target = hotend.modeled_block_temp;
     next_test_ms = ms + MPC_dT * 1000;
-    constexpr millis_t settle_time = 20000UL,
-                       test_length = 20000UL;
+    constexpr millis_t settle_time = 20000UL, test_duration = 20000UL;
     millis_t settle_end_ms = ms + settle_time,
-             test_end_ms = settle_end_ms + test_length;
+             test_end_ms = settle_end_ms + test_duration;
     float total_energy_fan0 = 0.0f;
     #if HAS_FAN
       bool fan0_done = false;
       float total_energy_fan255 = 0.0f;
     #endif
     float last_temp = current_temp;
 
     while (wait_for_heatup) {
       housekeeping(ms, current_temp, next_report_ms);
 
@@ -974,43 +978,43 @@ volatile bool Temperature::raw_temps_ready = false;
         hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
 
         if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
           total_energy_fan0 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
         #if HAS_FAN
           else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
             SERIAL_ECHOLNPGM("Measuring ambient heatloss with full fan");
             set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
             planner.sync_fan_speeds(fan_speed);
             settle_end_ms = ms + settle_time;
-            test_end_ms = settle_end_ms + test_length;
+            test_end_ms = settle_end_ms + test_duration;
             fan0_done = true;
           }
           else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
             total_energy_fan255 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
         #endif
         else if (ELAPSED(ms, test_end_ms)) break;
 
         last_temp = current_temp;
         next_test_ms += MPC_dT * 1000;
       }
 
       if (!WITHIN(current_temp, hotend.target - 15.0f, hotend.target + 15.0f)) {
         SERIAL_ECHOLNPGM("Temperature error while measuring ambient loss");
         break;
       }
     }
 
-    const float power_fan0 = total_energy_fan0 * 1000 / test_length;
+    const float power_fan0 = total_energy_fan0 * 1000 / test_duration;
     constants.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
 
     #if HAS_FAN
-      const float power_fan255 = total_energy_fan255 * 1000 / test_length,
+      const float power_fan255 = total_energy_fan255 * 1000 / test_duration,
                   ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
       constants.fan255_adjustment = ambient_xfer_coeff_fan255 - constants.ambient_xfer_coeff_fan0;
     #endif
 
     hotend.target = 0.0f;
     hotend.soft_pwm_amount = 0;
     TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0));
     TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
 
     if (!wait_for_heatup) SERIAL_ECHOLNPGM("Test was interrupted");
@@ -1362,22 +1366,22 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
               , STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             #endif
           );
         }
       #endif
 
     #elif ENABLED(MPCTEMP)
-      MPCHeaterInfo& hotend = temp_hotend[ee];
-      MPC_t& constants = hotend.constants;
+      MPCHeaterInfo &hotend = temp_hotend[ee];
+      MPC_t &constants = hotend.constants;
 
       // At startup, initialize modeled temperatures
       if (isnan(hotend.modeled_block_temp)) {
         hotend.modeled_ambient_temp = min(30.0f, hotend.celsius);   // cap initial value at reasonable max room temperature of 30C
         hotend.modeled_block_temp = hotend.modeled_sensor_temp = hotend.celsius;
       }
 
       #if HOTENDS == 1
         constexpr bool this_hotend = true;
       #else

commit c4873a64ecd54dc0bbccb1eaeecd1b5ae2f6aef5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:14:02 2022 -0500

    üßë‚Äçüíª General and Axis-based bitfield flags (#23989)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4bd43705ad..783423a01c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1276,41 +1276,41 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
 
 #if HAS_HOTEND
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
-        static bool pid_reset[HOTENDS] = { false };
+        static Flags<HOTENDS> pid_reset;
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
 
         float pid_output;
 
         if (temp_hotend[ee].target == 0
           || pid_error < -(PID_FUNCTIONAL_RANGE)
           || TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out)
         ) {
           pid_output = 0;
-          pid_reset[ee] = true;
+          pid_reset.set(ee);
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
           pid_output = PID_MAX;
-          pid_reset[ee] = true;
+          pid_reset.set(ee);
         }
         else {
           if (pid_reset[ee]) {
             temp_iState[ee] = 0.0;
             work_pid[ee].Kd = 0.0;
-            pid_reset[ee] = false;
+            pid_reset.clear(ee);
           }
 
           work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
           const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
           temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
           work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
           work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
 
           pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
 

commit 72b2e2b2c7230245dea9fcb46b9b8a92bcb11bcc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 08:14:14 2022 +0100

    ‚öóÔ∏è Temperature Model Predictive Control (#23751)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6660d9a8f8..4bd43705ad 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -134,21 +134,22 @@
     #define SW_SPI_MISO_PIN   TEMP_1_MISO_PIN
     #if PIN_EXISTS(TEMP_1_MOSI)
       #define SW_SPI_MOSI_PIN TEMP_1_MOSI_PIN
     #endif
   #endif
   #ifndef SW_SPI_MOSI_PIN
     #define SW_SPI_MOSI_PIN   SD_MOSI_PIN
   #endif
 #endif
 
-#if ENABLED(PID_EXTRUSION_SCALING)
+#if EITHER(MPCTEMP, PID_EXTRUSION_SCALING)
+  #include <math.h>
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
@@ -496,24 +497,28 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif
 
 /**
  * private:
  */
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
-  int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
+  int32_t Temperature::pes_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
+#if ENABLED(MPCTEMP)
+  int32_t Temperature::mpc_e_position; // = 0
+#endif
+
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
 
 #if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
   constexpr temp_range_t sensor_heater_0 { TEMP_SENSOR_0_RAW_LO_TEMP, TEMP_SENSOR_0_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_1 { TEMP_SENSOR_1_RAW_LO_TEMP, TEMP_SENSOR_1_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_2 { TEMP_SENSOR_2_RAW_LO_TEMP, TEMP_SENSOR_2_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_3 { TEMP_SENSOR_3_RAW_LO_TEMP, TEMP_SENSOR_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
@@ -574,22 +579,22 @@ volatile bool Temperature::raw_temps_ready = false;
     celsius_float_t current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     PID_t tune_pid = { 0, 0, 0 };
     celsius_float_t maxT = 0, minT = 10000;
 
-    const bool isbed = (heater_id == H_BED);
-    const bool ischamber = (heater_id == H_CHAMBER);
+    const bool isbed = (heater_id == H_BED),
+           ischamber = (heater_id == H_CHAMBER);
 
     #if ENABLED(PIDTEMPCHAMBER)
       #define C_TERN(T,A,B) ((T) ? (A) : (B))
     #else
       #define C_TERN(T,A,B) (B)
     #endif
     #if ENABLED(PIDTEMPBED)
       #define B_TERN(T,A,B) ((T) ? (A) : (B))
     #else
       #define B_TERN(T,A,B) (B)
@@ -833,20 +838,212 @@ volatile bool Temperature::raw_temps_ready = false;
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
+#if ENABLED(MPCTEMP)
+
+  void Temperature::MPC_autotune() {
+    auto housekeeping = [] (millis_t& ms, celsius_float_t& current_temp, millis_t& next_report_ms) {
+      ms = millis();
+
+      if (updateTemperaturesIfReady()) { // temp sample ready
+        current_temp = degHotend(active_extruder);
+        TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
+      }
+
+      if (ELAPSED(ms, next_report_ms)) {
+        next_report_ms += 1000UL;
+        SERIAL_ECHOLNPGM("Temperature ", current_temp);
+      }
+
+      hal.idletask();
+    };
+
+    SERIAL_ECHOLNPGM("Measuring MPC constants for E", active_extruder);
+    MPCHeaterInfo& hotend = temp_hotend[active_extruder];
+    MPC_t& constants = hotend.constants;
+
+    // move to center of bed, just above bed height and cool with max fan
+    SERIAL_ECHOLNPGM("Moving to tuning position");
+    TERN_(HAS_FAN, zero_fan_speeds());
+    disable_all_heaters();
+    TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255));
+    TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
+    gcode.home_all_axes(true);
+    const xyz_pos_t tuningpos = MPC_TUNING_POS;
+    do_blocking_move_to(tuningpos);
+
+    SERIAL_ECHOLNPGM("Cooling to ambient");
+    millis_t ms = millis(), next_report_ms = ms, next_test_ms = ms + 10000UL;
+    celsius_float_t current_temp = degHotend(active_extruder),
+                    ambient_temp = current_temp;
+
+    wait_for_heatup = true; // Can be interrupted with M108
+    while (wait_for_heatup) {
+      housekeeping(ms, current_temp, next_report_ms);
+
+      if (ELAPSED(ms, next_test_ms)) {
+        if (current_temp >= ambient_temp) {
+          ambient_temp = (ambient_temp + current_temp) / 2.0f;
+          break;
+        }
+        ambient_temp = current_temp;
+        next_test_ms += 10000UL;
+      }
+    }
+    TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0));
+    TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
+
+    hotend.modeled_ambient_temp = ambient_temp;
+
+    SERIAL_ECHOLNPGM("Heating to 200C");
+    hotend.soft_pwm_amount = MPC_MAX >> 1;
+    const millis_t heat_start_time = ms;
+    next_test_ms = ms;
+    celsius_float_t temp_samples[16];
+    uint8_t sample_count = 0;
+    uint16_t sample_distance = 1;
+    float t1_time = 0;
+
+    while (wait_for_heatup) {
+      housekeeping(ms, current_temp, next_report_ms);
+
+      if (ELAPSED(ms, next_test_ms)) {
+        // record samples between 100C and 200C
+        if (current_temp >= 100.0f) {
+          // if there are too many samples, space them more widely
+          if (sample_count == COUNT(temp_samples)) {
+            for (uint8_t i = 0; i < COUNT(temp_samples) / 2; i++)
+              temp_samples[i] = temp_samples[i*2];
+            sample_count /= 2;
+            sample_distance *= 2;
+          }
+
+          if (sample_count == 0) t1_time = float(ms - heat_start_time) / 1000.0f;
+          temp_samples[sample_count++] = current_temp;
+        }
+
+        if (current_temp >= 200.0f) break;
+
+        next_test_ms += 1000UL * sample_distance;
+      }
+    }
+    hotend.soft_pwm_amount = 0;
+
+    // calculate physical constants from three equally spaced samples
+    sample_count = (sample_count + 1) / 2 * 2 - 1;
+    const float t1 = temp_samples[0],
+                t2 = temp_samples[(sample_count - 1) >> 1],
+                t3 = temp_samples[sample_count - 1],
+                asymp_temp = (t2 * t2 - t1 * t3) / (2 * t2 - t1 - t3),
+                block_responsiveness = -log((t2 - asymp_temp) / (t1 - asymp_temp)) / (sample_distance * (sample_count >> 1));
+
+    constants.ambient_xfer_coeff_fan0 = constants.heater_power * MPC_MAX / 255 / (asymp_temp - ambient_temp);
+    constants.fan255_adjustment = 0.0f;
+    constants.block_heat_capacity = constants.ambient_xfer_coeff_fan0 / block_responsiveness;
+    constants.sensor_responsiveness = block_responsiveness / (1.0f - (ambient_temp - asymp_temp) * exp(-block_responsiveness * t1_time) / (t1 - asymp_temp));
+
+    hotend.modeled_block_temp = asymp_temp + (ambient_temp - asymp_temp) * exp(-block_responsiveness * (ms - heat_start_time) / 1000.0f);
+    hotend.modeled_sensor_temp = current_temp;
+
+    // let the system stabilise under MPC control then get a better measure of ambient loss without and with fan
+    SERIAL_ECHOLNPGM("Measuring ambient heatloss at target ", hotend.modeled_block_temp);
+    hotend.target = hotend.modeled_block_temp;
+    next_test_ms = ms + MPC_dT * 1000;
+    constexpr millis_t settle_time = 20000UL,
+                       test_length = 20000UL;
+    millis_t settle_end_ms = ms + settle_time,
+             test_end_ms = settle_end_ms + test_length;
+    float total_energy_fan0 = 0.0f;
+    #if HAS_FAN
+      bool fan0_done = false;
+      float total_energy_fan255 = 0.0f;
+    #endif
+    float last_temp = current_temp;
+
+    while (wait_for_heatup) {
+      housekeeping(ms, current_temp, next_report_ms);
+
+      if (ELAPSED(ms, next_test_ms)) {
+        // use MPC to control the temperature, let it settle for 30s and then track power output for 10s
+        hotend.soft_pwm_amount = (int)get_pid_output_hotend(active_extruder) >> 1;
+
+        if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms) && TERN1(HAS_FAN, !fan0_done))
+          total_energy_fan0 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
+        #if HAS_FAN
+          else if (ELAPSED(ms, test_end_ms) && !fan0_done) {
+            SERIAL_ECHOLNPGM("Measuring ambient heatloss with full fan");
+            set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 255);
+            planner.sync_fan_speeds(fan_speed);
+            settle_end_ms = ms + settle_time;
+            test_end_ms = settle_end_ms + test_length;
+            fan0_done = true;
+          }
+          else if (ELAPSED(ms, settle_end_ms) && !ELAPSED(ms, test_end_ms))
+            total_energy_fan255 += constants.heater_power * hotend.soft_pwm_amount / 127 * MPC_dT + (last_temp - current_temp) * constants.block_heat_capacity;
+        #endif
+        else if (ELAPSED(ms, test_end_ms)) break;
+
+        last_temp = current_temp;
+        next_test_ms += MPC_dT * 1000;
+      }
+
+      if (!WITHIN(current_temp, hotend.target - 15.0f, hotend.target + 15.0f)) {
+        SERIAL_ECHOLNPGM("Temperature error while measuring ambient loss");
+        break;
+      }
+    }
+
+    const float power_fan0 = total_energy_fan0 * 1000 / test_length;
+    constants.ambient_xfer_coeff_fan0 = power_fan0 / (hotend.target - ambient_temp);
+
+    #if HAS_FAN
+      const float power_fan255 = total_energy_fan255 * 1000 / test_length,
+                  ambient_xfer_coeff_fan255 = power_fan255 / (hotend.target - ambient_temp);
+      constants.fan255_adjustment = ambient_xfer_coeff_fan255 - constants.ambient_xfer_coeff_fan0;
+    #endif
+
+    hotend.target = 0.0f;
+    hotend.soft_pwm_amount = 0;
+    TERN_(HAS_FAN, set_fan_speed(ANY(MPC_FAN_0_ALL_HOTENDS, MPC_FAN_0_ACTIVE_HOTEND) ? 0 : active_extruder, 0));
+    TERN_(HAS_FAN, planner.sync_fan_speeds(fan_speed));
+
+    if (!wait_for_heatup) SERIAL_ECHOLNPGM("Test was interrupted");
+
+    wait_for_heatup = false;
+
+    SERIAL_ECHOLNPGM("Done");
+
+    /* <-- add a slash to enable
+      SERIAL_ECHOLNPGM("t1_time ", t1_time);
+      SERIAL_ECHOLNPGM("sample_count ", sample_count);
+      SERIAL_ECHOLNPGM("sample_distance ", sample_distance);
+      for (uint8_t i = 0; i < sample_count; i++)
+        SERIAL_ECHOLNPGM("sample ", i, " : ", temp_samples[i]);
+      SERIAL_ECHOLNPGM("t1 ", t1, " t2 ", t2, " t3 ", t3);
+      SERIAL_ECHOLNPGM("asymp_temp ", asymp_temp);
+      SERIAL_ECHOLNPAIR_F("block_responsiveness ", block_responsiveness, 4);
+    //*/
+    SERIAL_ECHOLNPGM("MPC_BLOCK_HEAT_CAPACITY ", constants.block_heat_capacity);
+    SERIAL_ECHOLNPAIR_F("MPC_SENSOR_RESPONSIVENESS ", constants.sensor_responsiveness, 4);
+    SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF ", constants.ambient_xfer_coeff_fan0, 4);
+    TERN_(HAS_FAN, SERIAL_ECHOLNPAIR_F("MPC_AMBIENT_XFER_COEFF_FAN255 ", ambient_xfer_coeff_fan255, 4));
+  }
+
+#endif // MPCTEMP
+
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     #if HAS_COOLER
       case H_COOLER: return temp_cooler.soft_pwm_amount;
@@ -1092,21 +1289,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
         float pid_output;
 
         if (temp_hotend[ee].target == 0
           || pid_error < -(PID_FUNCTIONAL_RANGE)
           || TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out)
         ) {
           pid_output = 0;
           pid_reset[ee] = true;
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
-          pid_output = BANG_MAX;
+          pid_output = PID_MAX;
           pid_reset[ee] = true;
         }
         else {
           if (pid_reset[ee]) {
             temp_iState[ee] = 0.0;
             work_pid[ee].Kd = 0.0;
             pid_reset[ee] = false;
           }
 
           work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
@@ -1119,23 +1316,23 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
 
           #if ENABLED(PID_EXTRUSION_SCALING)
             #if HOTENDS == 1
               constexpr bool this_hotend = true;
             #else
               const bool this_hotend = (ee == active_extruder);
             #endif
             work_pid[ee].Kc = 0;
             if (this_hotend) {
               const long e_position = stepper.position(E_AXIS);
-              if (e_position > last_e_position) {
-                lpq[lpq_ptr] = e_position - last_e_position;
-                last_e_position = e_position;
+              if (e_position > pes_e_position) {
+                lpq[lpq_ptr] = e_position - pes_e_position;
+                pes_e_position = e_position;
               }
               else
                 lpq[lpq_ptr] = 0;
 
               if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
               work_pid[ee].Kc = (lpq[lpq_ptr] * planner.mm_per_step[E_AXIS]) * PID_PARAM(Kc, ee);
               pid_output += work_pid[ee].Kc;
             }
           #endif // PID_EXTRUSION_SCALING
           #if ENABLED(PID_FAN_SCALING)
@@ -1164,21 +1361,100 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
               , STR_PID_DEBUG_ITERM, work_pid[ee].Ki
               , STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             #endif
           );
         }
       #endif
 
-    #else // No PID enabled
+    #elif ENABLED(MPCTEMP)
+      MPCHeaterInfo& hotend = temp_hotend[ee];
+      MPC_t& constants = hotend.constants;
+
+      // At startup, initialize modeled temperatures
+      if (isnan(hotend.modeled_block_temp)) {
+        hotend.modeled_ambient_temp = min(30.0f, hotend.celsius);   // cap initial value at reasonable max room temperature of 30C
+        hotend.modeled_block_temp = hotend.modeled_sensor_temp = hotend.celsius;
+      }
+
+      #if HOTENDS == 1
+        constexpr bool this_hotend = true;
+      #else
+        const bool this_hotend = (ee == active_extruder);
+      #endif
+
+      float ambient_xfer_coeff = constants.ambient_xfer_coeff_fan0;
+      #if ENABLED(MPC_INCLUDE_FAN)
+        const uint8_t fan_index = ANY(MPC_FAN_0_ACTIVE_HOTEND, MPC_FAN_0_ALL_HOTENDS) ? 0 : ee;
+        const float fan_fraction = TERN_(MPC_FAN_0_ACTIVE_HOTEND, !this_hotend ? 0.0f : ) fan_speed[fan_index] * RECIPROCAL(255);
+        ambient_xfer_coeff += fan_fraction * constants.fan255_adjustment;
+      #endif
+
+      if (this_hotend) {
+        const int32_t e_position = stepper.position(E_AXIS);
+        const float e_speed = (e_position - mpc_e_position) * planner.mm_per_step[E_AXIS] / MPC_dT;
+
+        // the position can appear to make big jumps when, e.g. homing
+        if (fabs(e_speed) > planner.settings.max_feedrate_mm_s[E_AXIS])
+          mpc_e_position = e_position;
+        else if (e_speed > 0.0f) {  // ignore retract/recover moves
+          ambient_xfer_coeff += e_speed * FILAMENT_HEAT_CAPACITY_PERMM;
+          mpc_e_position = e_position;
+        }
+      }
+
+      // update the modeled temperatures
+      float blocktempdelta = hotend.soft_pwm_amount * constants.heater_power * (MPC_dT / 127) / constants.block_heat_capacity;
+      blocktempdelta += (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff * MPC_dT / constants.block_heat_capacity;
+      hotend.modeled_block_temp += blocktempdelta;
+
+      const float sensortempdelta = (hotend.modeled_block_temp - hotend.modeled_sensor_temp) * (constants.sensor_responsiveness * MPC_dT);
+      hotend.modeled_sensor_temp += sensortempdelta;
+
+      // Any delta between hotend.modeled_sensor_temp and hotend.celsius is either model
+      // error diverging slowly or (fast) noise. Slowly correct towards this temperature and noise will average out.
+      const float delta_to_apply = (hotend.celsius - hotend.modeled_sensor_temp) * (MPC_SMOOTHING_FACTOR);
+      hotend.modeled_block_temp += delta_to_apply;
+      hotend.modeled_sensor_temp += delta_to_apply;
+
+      // only correct ambient when close to steady state (output power is not clipped or asymptotic temperature is reached)
+      if (WITHIN(hotend.soft_pwm_amount, 1, 126) || fabs(blocktempdelta + delta_to_apply) < (MPC_STEADYSTATE * MPC_dT))
+        hotend.modeled_ambient_temp += delta_to_apply > 0.f ? max(delta_to_apply, MPC_MIN_AMBIENT_CHANGE * MPC_dT) : min(delta_to_apply, -MPC_MIN_AMBIENT_CHANGE * MPC_dT);
+
+      float power = 0.0;
+      if (hotend.target != 0 && TERN1(HEATER_IDLE_HANDLER, !heater_idle[ee].timed_out)) {
+        // plan power level to get to target temperature in 2 seconds
+        power = (hotend.target - hotend.modeled_block_temp) * constants.block_heat_capacity / 2.0f;
+        power -= (hotend.modeled_ambient_temp - hotend.modeled_block_temp) * ambient_xfer_coeff;
+      }
+
+      float pid_output = power * 254.0f / constants.heater_power + 1.0f;        // ensure correct quantization into a range of 0 to 127
+      pid_output = constrain(pid_output, 0, MPC_MAX);
+
+      /* <-- add a slash to enable
+        static uint32_t nexttime = millis() + 1000;
+        if (ELAPSED(millis(), nexttime)) {
+          nexttime += 1000;
+          SERIAL_ECHOLNPGM("block temp ", hotend.modeled_block_temp,
+                           ", celsius ", hotend.celsius,
+                           ", blocktempdelta ", blocktempdelta,
+                           ", delta_to_apply ", delta_to_apply,
+                           ", ambient ", hotend.modeled_ambient_temp,
+                           ", power ", power,
+                           ", pid_output ", pid_output,
+                           ", pwm ", (int)pid_output >> 1);
+        }
+      //*/
+
+    #else // No PID or MPC enabled
 
       const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
       const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
 #endif // HAS_HOTEND
@@ -2169,21 +2445,21 @@ void Temperature::updateTemperaturesFromRawValues() {
  *  - Start the Temperature ISR timer
  *  - Init the AUTO FAN pins as PWM or OUTPUT
  *  - Wait 250ms for temperatures to settle
  *  - Init temp_range[], used for catching min/maxtemp
  */
 void Temperature::init() {
 
   TERN_(PROBING_HEATERS_OFF, paused_for_probing = false);
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
-    last_e_position = 0;
+    pes_e_position = 0;
   #endif
 
   // Init (and disable) SPI thermocouples
   #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && PIN_EXISTS(TEMP_0_CS)
     OUT_WRITE(TEMP_0_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && PIN_EXISTS(TEMP_1_CS)
     OUT_WRITE(TEMP_1_CS_PIN, HIGH);
   #endif
 
@@ -2239,20 +2515,24 @@ void Temperature::init() {
   #if PIN_EXISTS(TEMP_1_TR_ENABLE)
     OUT_WRITE(TEMP_1_TR_ENABLE_PIN, (
       #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
         HIGH
       #else
         LOW
       #endif
     ));
   #endif
 
+  #if ENABLED(MPCTEMP)
+    HOTEND_LOOP() temp_hotend[e].modeled_block_temp = NAN;
+  #endif
+
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif
   #endif
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif

commit fd742616ba6fd2db1607df197dea142cbf1a9d3f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:35:00 2022 -0500

    üö∏ Clear "heating/cooling" message on temp reached

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 38cc3663d2..6660d9a8f8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3624,30 +3624,38 @@ void Temperature::isr() {
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
     void Temperature::AutoReportTemp::report() { print_heater_states(active_extruder); SERIAL_EOL(); }
   #endif
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
-    void Temperature::set_heating_message(const uint8_t e) {
+    void Temperature::set_heating_message(const uint8_t e, const bool isM104/*=false*/) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf(0,
         #if HAS_MULTI_HOTEND
           F("E%c " S_FMT), '1' + e
         #else
           F("E1 " S_FMT)
         #endif
         , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );
+
+      if (isM104) {
+        static uint8_t wait_e; wait_e = e;
+        ui.set_status_reset_fn([]{
+          const celsius_t c = degTargetHotend(wait_e);
+          return c < 30 || degHotendNear(wait_e, c);
+        });
+      }
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60

commit 8dfdf51678a4a3975df8250bedf3489fd4835796
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:09:55 2022 -0500

    üé® Format, use status macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a983275b8a..38cc3663d2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -644,21 +644,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
-    TERN_(HAS_STATUS_MESSAGE, ui.set_status(F("Wait for heat up...")));
+    LCD_MESSAGE(MSG_HEATING);
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);

commit 631e35bfd6cec8d61eca31ac2945ff890ab8f2ed
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Mar 18 03:15:26 2022 +0000

    ‚ö°Ô∏è Fix noisy ADC - 16x oversampling with 12-bit ADC (#23867)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 653b3179b0..a983275b8a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -430,62 +430,62 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if WATCH_HOTENDS
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
   Temperature::heater_idle_t Temperature::heater_idle[NR_HEATER_IDLE]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
-  int16_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP,
-          Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
+  raw_adc_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP,
+            Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
 #endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     millis_t next_cool_check_ms_2 = 0;
     celsius_float_t old_temp = 9999;
-    int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
-            Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
+    raw_adc_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
+              Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     TERN_(WATCH_CHAMBER, chamber_watch_t Temperature::watch_chamber{0});
     IF_DISABLED(PIDTEMPCHAMBER, millis_t Temperature::next_chamber_check_ms);
   #endif
 #endif
 
 #if HAS_TEMP_COOLER
   cooler_info_t Temperature::temp_cooler; // = { 0 }
   #if HAS_COOLER
     bool flag_cooler_state;
     //bool flag_cooler_excess = false;
     celsius_float_t previous_temp = 9999;
-    int16_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,
-            Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
+    raw_adc_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,
+              Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
     #if WATCH_COOLER
       cooler_watch_t Temperature::watch_cooler{0};
     #endif
     millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
   #endif
 #endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if HAS_TEMP_BOARD
   board_info_t Temperature::temp_board; // = { 0 }
   #if ENABLED(THERMAL_PROTECTION_BOARD)
-    int16_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
-            Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
+    raw_adc_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
+              Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
   #endif
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
@@ -501,20 +501,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
  */
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
+#define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
 
 #if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
   constexpr temp_range_t sensor_heater_0 { TEMP_SENSOR_0_RAW_LO_TEMP, TEMP_SENSOR_0_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_1 { TEMP_SENSOR_1_RAW_LO_TEMP, TEMP_SENSOR_1_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_2 { TEMP_SENSOR_2_RAW_LO_TEMP, TEMP_SENSOR_2_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_3 { TEMP_SENSOR_3_RAW_LO_TEMP, TEMP_SENSOR_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_5 { TEMP_SENSOR_5_RAW_LO_TEMP, TEMP_SENSOR_5_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_6 { TEMP_SENSOR_6_RAW_LO_TEMP, TEMP_SENSOR_6_RAW_HI_TEMP, 0, 16383 },
@@ -1682,22 +1683,22 @@ void Temperature::manage_heater() {
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                                \
   uint8_t l = 0, r = LEN, m;                                              \
   for (;;) {                                                              \
     m = (l + r) >> 1;                                                     \
     if (!m) return celsius_t(pgm_read_word(&TBL[0].celsius));             \
     if (m == l || m == r) return celsius_t(pgm_read_word(&TBL[LEN-1].celsius)); \
-    int16_t v00 = pgm_read_word(&TBL[m-1].value),                         \
-            v10 = pgm_read_word(&TBL[m-0].value);                         \
+    raw_adc_t v00 = pgm_read_word(&TBL[m-1].value),                       \
+              v10 = pgm_read_word(&TBL[m-0].value);                       \
          if (raw < v00) r = m;                                            \
     else if (raw > v10) l = m;                                            \
     else {                                                                \
       const celsius_t v01 = celsius_t(pgm_read_word(&TBL[m-1].celsius)),  \
                       v11 = celsius_t(pgm_read_word(&TBL[m-0].celsius));  \
       return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);     \
     }                                                                     \
   }                                                                       \
 }while(0)
 
@@ -1777,96 +1778,96 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? F("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? F("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? F("PROBE") :)
       TERN_(TEMP_SENSOR_BOARD_IS_CUSTOM, t_index == CTI_BOARD ? F("BOARD") :)
       TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? F("REDUNDANT") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
-  celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw) {
+  celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const raw_adc_t raw) {
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
       t.pre_calc     = false;
       t.res_25_recip = 1.0f / t.res_25;
       t.res_25_log   = logf(t.res_25);
       t.beta_recip   = 1.0f / t.beta;
       t.sh_alpha     = RECIPROCAL(THERMISTOR_RESISTANCE_NOMINAL_C - (THERMISTOR_ABS_ZERO_C))
                         - (t.beta_recip * t.res_25_log) - (t.sh_c_coeff * cu(t.res_25_log));
     }
 
     // maximum adc value .. take into account the over sampling
-    const int adc_max = MAX_RAW_THERMISTOR_VALUE,
-              adc_raw = constrain(raw, 1, adc_max - 1); // constrain to prevent divide-by-zero
+    constexpr raw_adc_t adc_max = MAX_RAW_THERMISTOR_VALUE;
+    const raw_adc_t adc_raw = constrain(raw, 1, adc_max - 1); // constrain to prevent divide-by-zero
 
     const float adc_inverse = (adc_max - adc_raw) - 0.5f,
                 resistance = t.series_res * (adc_raw + 0.5f) / adc_inverse,
                 log_resistance = logf(resistance);
 
     float value = t.sh_alpha;
     value += log_resistance * t.beta_recip;
     if (t.sh_c_coeff != 0)
       value += t.sh_c_coeff * cu(log_resistance);
     value = 1.0f / value;
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_hotend(const int16_t raw, const uint8_t e) {
+  celsius_float_t Temperature::analog_to_celsius_hotend(const raw_adc_t raw, const uint8_t e) {
     if (e >= HOTENDS) {
       SERIAL_ERROR_START();
       SERIAL_ECHO(e);
       SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
       kill();
       return 0;
     }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif TEMP_SENSOR_0_IS_MAX_TC
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
-              max31865_0.temperature((uint16_t)raw),
+              max31865_0.temperature(raw),
               max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
             );
           #else
-            return raw * 0.25;
+            return (int16_t)raw * 0.25;
           #endif
         #elif TEMP_SENSOR_0_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_0_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
         #if TEMP_SENSOR_1_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
         #elif TEMP_SENSOR_1_IS_MAX_TC
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
-              max31865_1.temperature((uint16_t)raw),
+              max31865_1.temperature(raw),
               max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1)
             );
           #else
-            return raw * 0.25;
+            return (int16_t)raw * 0.25;
           #endif
         #elif TEMP_SENSOR_1_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_1_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
         #if TEMP_SENSOR_2_IS_CUSTOM
@@ -1936,117 +1937,117 @@ void Temperature::manage_heater() {
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // For bed temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_bed(const int16_t raw) {
+  celsius_float_t Temperature::analog_to_celsius_bed(const raw_adc_t raw) {
     #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif TEMP_SENSOR_BED_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
     #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // For chamber temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_chamber(const int16_t raw) {
+  celsius_float_t Temperature::analog_to_celsius_chamber(const raw_adc_t raw) {
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif TEMP_SENSOR_CHAMBER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_CHAMBER, TEMPTABLE_CHAMBER_LEN);
     #elif TEMP_SENSOR_CHAMBER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_CHAMBER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_COOLER
   // For cooler temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_cooler(const int16_t raw) {
+  celsius_float_t Temperature::analog_to_celsius_cooler(const raw_adc_t raw) {
     #if TEMP_SENSOR_COOLER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_COOLER, raw);
     #elif TEMP_SENSOR_COOLER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_COOLER, TEMPTABLE_COOLER_LEN);
     #elif TEMP_SENSOR_COOLER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_COOLER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_COOLER
 
 #if HAS_TEMP_PROBE
   // For probe temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_probe(const int16_t raw) {
+  celsius_float_t Temperature::analog_to_celsius_probe(const raw_adc_t raw) {
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
     #elif TEMP_SENSOR_PROBE_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_PROBE, TEMPTABLE_PROBE_LEN);
     #elif TEMP_SENSOR_PROBE_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
 #if HAS_TEMP_BOARD
   // For motherboard temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_board(const int16_t raw) {
+  celsius_float_t Temperature::analog_to_celsius_board(const raw_adc_t raw) {
     #if TEMP_SENSOR_BOARD_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BOARD, raw);
     #elif TEMP_SENSOR_BOARD_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BOARD, TEMPTABLE_BOARD_LEN);
     #elif TEMP_SENSOR_BOARD_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BOARD_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_BOARD
 
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_redundant(const int16_t raw) {
+  celsius_float_t Temperature::analog_to_celsius_redundant(const raw_adc_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && REDUNDANT_TEMP_MATCH(SOURCE, E0)
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature((uint16_t)raw), raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && REDUNDANT_TEMP_MATCH(SOURCE, E1)
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature((uint16_t)raw), raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(raw), (int16_t)raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
@@ -2062,34 +2063,34 @@ void Temperature::manage_heater() {
  * set by update_raw_temperatures().
  *
  * The watchdog is dependent on this method. If 'raw_temps_ready' stops
  * being set by the interrupt so that this method is not called for over
  * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
 
   watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
-  TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
-  TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
-  TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.raw = READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE)));
+  TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].setraw(READ_MAX_TC(0)));
+  TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].setraw(READ_MAX_TC(1)));
+  TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.setraw(READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE))));
 
   #if HAS_HOTEND
-    HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
+    HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].getraw(), e);
   #endif
 
-  TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.raw));
-  TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.raw));
-  TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.raw));
-  TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.raw));
-  TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.raw));
-  TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.raw));
+  TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.getraw()));
+  TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.getraw()));
+  TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.getraw()));
+  TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.getraw()));
+  TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.getraw()));
+  TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.getraw()));
 
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
   #if HAS_HOTEND
     static constexpr int8_t temp_dir[] = {
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         0
       #else
         TEMPDIR(0)
@@ -2101,60 +2102,59 @@ void Temperature::updateTemperaturesFromRawValues() {
           , TEMPDIR(1)
         #endif
         #if HOTENDS > 2
           #define _TEMPDIR(N) , TEMPDIR(N)
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif
       #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
-      const int8_t tdir = temp_dir[e];
-      if (tdir) {
-        const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
-        if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_id_t)e);
-
-        const bool heater_on = temp_hotend[e].target > 0;
-        if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
-          #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
-            if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
-          #endif
-              min_temp_error((heater_id_t)e);
-        }
+      const raw_adc_t r = temp_hotend[e].getraw();
+      const bool neg = temp_dir[e] < 0, pos = temp_dir[e] > 0;
+      if ((neg && r < temp_range[e].raw_max) || (pos && r > temp_range[e].raw_max))
+        max_temp_error((heater_id_t)e);
+
+      const bool heater_on = temp_hotend[e].target > 0;
+      if (heater_on && ((neg && r > temp_range[e].raw_min) || (pos && r < temp_range[e].raw_min))) {
         #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
-          else
-            consecutive_low_temperature_error[e] = 0;
+          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
         #endif
+            min_temp_error((heater_id_t)e);
       }
+      #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
+        else
+          consecutive_low_temperature_error[e] = 0;
+      #endif
     }
 
   #endif // HAS_HOTEND
 
   #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
-    if (TP_CMP(BED, temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
-    if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
+    if (TP_CMP(BED, temp_bed.getraw(), maxtemp_raw_BED)) max_temp_error(H_BED);
+    if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.getraw())) min_temp_error(H_BED);
   #endif
 
   #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
-    if (TP_CMP(CHAMBER, temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
-    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
+    if (TP_CMP(CHAMBER, temp_chamber.getraw(), maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
+    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.getraw())) min_temp_error(H_CHAMBER);
   #endif
 
   #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
-    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
-    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
+    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.getraw(), maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
+    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.getraw())) min_temp_error(H_COOLER);
   #endif
 
   #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
-    if (TP_CMP(BOARD, temp_board.raw, maxtemp_raw_BOARD)) max_temp_error(H_BOARD);
-    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.raw)) min_temp_error(H_BOARD);
+    if (TP_CMP(BOARD, temp_board.getraw(), maxtemp_raw_BOARD)) max_temp_error(H_BOARD);
+    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.getraw())) min_temp_error(H_BOARD);
   #endif
   #undef TP_CMP
 
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to manage_heater()
  *
@@ -2724,40 +2724,40 @@ void Temperature::disable_all_heaters() {
 
   /**
    * @brief Read MAX Thermocouple temperature.
    *
    * Reads the thermocouple board via HW or SW SPI, using a library (LIB_USR_x) or raw SPI reads.
    * Doesn't strictly return a temperature; returns an "ADC Value" (i.e. raw register content).
    *
    * @param  hindex  the hotend we're referencing (if MULTI_MAX_TC)
    * @return         integer representing the board's buffer, to be converted later if needed
    */
-  int16_t Temperature::read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex/*=0*/)) {
+  raw_adc_t Temperature::read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex/*=0*/)) {
     #define MAXTC_HEAT_INTERVAL 250UL
 
     #if HAS_MAX31855
       #define MAX_TC_ERROR_MASK    7        // D2-0: SCV, SCG, OC
       #define MAX_TC_DISCARD_BITS 18        // Data D31-18; sign bit D31
       #define MAX_TC_SPEED_BITS    3        // ~1MHz
     #elif HAS_MAX31865
       #define MAX_TC_ERROR_MASK    1        // D0 Bit on fault only
       #define MAX_TC_DISCARD_BITS  1        // Data is in D15-D1
       #define MAX_TC_SPEED_BITS    3        // ~1MHz
     #else // MAX6675
       #define MAX_TC_ERROR_MASK    3        // D2 only; 1 = open circuit
       #define MAX_TC_DISCARD_BITS  3        // Data D15-D1
       #define MAX_TC_SPEED_BITS    2        // ~2MHz
     #endif
 
     #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
-      static int16_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
+      static raw_adc_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
       #define THERMO_TEMP(I) max_tc_temp_previous[I]
       #define THERMO_SEL(A,B) (hindex ? (B) : (A))
       #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
     #else
       // When we have only 1 max tc, THERMO_SEL will pick the appropriate sensor
       // variable, and MAXTC_*() macros will be hardcoded to the correct CS pin.
       constexpr uint8_t hindex = 0;
       #define THERMO_TEMP(I) max_tc_temp
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         #define THERMO_SEL(A,B) A
@@ -2772,21 +2772,21 @@ void Temperature::disable_all_heaters() {
       TEMP_SENSOR_0_MAX_TC_TMAX,
       TEMP_SENSOR_1_MAX_TC_TMAX
     );
 
     static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
     static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
 
     // Return last-read value between readings
     millis_t ms = millis();
     if (PENDING(ms, next_max_tc_ms[hindex]))
-      return (int16_t)THERMO_TEMP(hindex);
+      return THERMO_TEMP(hindex);
 
     next_max_tc_ms[hindex] = ms + MAXTC_HEAT_INTERVAL;
 
     #if !HAS_MAXTC_LIBRARIES
       max_tc_temp = 0;
 
       #if !HAS_MAXTC_SW_SPI
         // Initialize SPI using the default Hardware SPI bus.
         // FIXME: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
         spiBegin();
@@ -2869,21 +2869,21 @@ void Temperature::disable_all_heaters() {
 
     max_tc_temp >>= MAX_TC_DISCARD_BITS;
 
     #if HAS_MAX31855
       // Support negative temperature for MAX38155
       if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000;
     #endif
 
     THERMO_TEMP(hindex) = max_tc_temp;
 
-    return (int16_t)max_tc_temp;
+    return max_tc_temp;
   }
 
 #endif // HAS_MAX_TC
 
 /**
  * Update raw temperatures
  *
  * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
  * Applies all the accumulators to the current raw temperatures.
  */
@@ -3010,21 +3010,21 @@ public:
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
 
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
-    static unsigned int raw_ADCKey_value = 0;
+    static raw_adc_t raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;
   #endif
 
   #if HAS_HOTEND
     static SoftPWM soft_pwm_hotend[HOTENDS];
   #endif
 
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif

commit 79b38e0e14074b52e0aeb98b08a686a99a9b1aad
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Mar 11 15:06:49 2022 -0500

    üö∏ Update Ender3 V2/S1 Pro UI (#23878)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4adf968919..653b3179b0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -814,21 +814,21 @@ volatile bool Temperature::raw_temps_ready = false;
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
-      TERN(HAS_DWIN_E3V2_BASIC, DWIN_Update(), ui.update());
+      TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
     TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
 

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    üîß DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 19501bce6e..4adf968919 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -44,21 +44,21 @@
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "../feature/controllerfan.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
@@ -616,26 +616,26 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
-    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
+    TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+      TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
@@ -712,21 +712,21 @@ volatile bool Temperature::raw_temps_ready = false;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
-        TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+        TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(ischamber ? active_extruder : (isbed ? active_extruder : heater_id));
           SERIAL_EOL();
         #endif
@@ -749,21 +749,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
-        TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TUNING_TIMEOUT));
+        TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
         TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
@@ -805,39 +805,39 @@ volatile bool Temperature::raw_temps_ready = false;
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-        TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
+        TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       hal.idletask();
 
       // Run UI update
       TERN(HAS_DWIN_E3V2_BASIC, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
-    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
+    TERN_(DWIN_LCD_PROUI, DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4ccd984b0d..19501bce6e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -320,21 +320,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
-  #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
+  #define SET_FAST_PWM_FREQ(P) hal.set_pwm_frequency(pin_t(P), FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
 #define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
 
 // HAS_FAN does not include CONTROLLER_FAN
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
@@ -811,21 +811,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
-      TERN_(HAL_IDLETASK, HAL_idletask());
+      hal.idletask();
 
       // Run UI update
       TERN(HAS_DWIN_E3V2_BASIC, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
@@ -900,21 +900,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                   \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)           \
-        set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
+        hal.set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                                \
         WRITE(P##_AUTO_FAN_PIN, D);                       \
     }while(0)
 
     uint8_t fanDone = 0;
     LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
@@ -2314,88 +2314,47 @@ void Temperature::init() {
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
   TERN_(HAS_MAXTC_SW_SPI, max_tc_spi.init());
 
-  HAL_adc_init();
+  hal.adc_init();
+
+  TERN_(HAS_TEMP_ADC_0,         hal.adc_enable(TEMP_0_PIN));
+  TERN_(HAS_TEMP_ADC_1,         hal.adc_enable(TEMP_1_PIN));
+  TERN_(HAS_TEMP_ADC_2,         hal.adc_enable(TEMP_2_PIN));
+  TERN_(HAS_TEMP_ADC_3,         hal.adc_enable(TEMP_3_PIN));
+  TERN_(HAS_TEMP_ADC_4,         hal.adc_enable(TEMP_4_PIN));
+  TERN_(HAS_TEMP_ADC_5,         hal.adc_enable(TEMP_5_PIN));
+  TERN_(HAS_TEMP_ADC_6,         hal.adc_enable(TEMP_6_PIN));
+  TERN_(HAS_TEMP_ADC_7,         hal.adc_enable(TEMP_7_PIN));
+  TERN_(HAS_JOY_ADC_X,          hal.adc_enable(JOY_X_PIN));
+  TERN_(HAS_JOY_ADC_Y,          hal.adc_enable(JOY_Y_PIN));
+  TERN_(HAS_JOY_ADC_Z,          hal.adc_enable(JOY_Z_PIN));
+  TERN_(HAS_TEMP_ADC_BED,       hal.adc_enable(TEMP_BED_PIN));
+  TERN_(HAS_TEMP_ADC_CHAMBER,   hal.adc_enable(TEMP_CHAMBER_PIN));
+  TERN_(HAS_TEMP_ADC_PROBE,     hal.adc_enable(TEMP_PROBE_PIN));
+  TERN_(HAS_TEMP_ADC_COOLER,    hal.adc_enable(TEMP_COOLER_PIN));
+  TERN_(HAS_TEMP_ADC_BOARD,     hal.adc_enable(TEMP_BOARD_PIN));
+  TERN_(HAS_TEMP_ADC_REDUNDANT, hal.adc_enable(TEMP_REDUNDANT_PIN));
+  TERN_(FILAMENT_WIDTH_SENSOR,  hal.adc_enable(FILWIDTH_PIN));
+  TERN_(HAS_ADC_BUTTONS,        hal.adc_enable(ADC_KEYPAD_PIN));
+  TERN_(POWER_MONITOR_CURRENT,  hal.adc_enable(POWER_MONITOR_CURRENT_PIN));
+  TERN_(POWER_MONITOR_VOLTAGE,  hal.adc_enable(POWER_MONITOR_VOLTAGE_PIN));
 
-  #if HAS_TEMP_ADC_0
-    HAL_ANALOG_SELECT(TEMP_0_PIN);
-  #endif
-  #if HAS_TEMP_ADC_1
-    HAL_ANALOG_SELECT(TEMP_1_PIN);
-  #endif
-  #if HAS_TEMP_ADC_2
-    HAL_ANALOG_SELECT(TEMP_2_PIN);
-  #endif
-  #if HAS_TEMP_ADC_3
-    HAL_ANALOG_SELECT(TEMP_3_PIN);
-  #endif
-  #if HAS_TEMP_ADC_4
-    HAL_ANALOG_SELECT(TEMP_4_PIN);
-  #endif
-  #if HAS_TEMP_ADC_5
-    HAL_ANALOG_SELECT(TEMP_5_PIN);
-  #endif
-  #if HAS_TEMP_ADC_6
-    HAL_ANALOG_SELECT(TEMP_6_PIN);
-  #endif
-  #if HAS_TEMP_ADC_7
-    HAL_ANALOG_SELECT(TEMP_7_PIN);
-  #endif
-  #if HAS_JOY_ADC_X
-    HAL_ANALOG_SELECT(JOY_X_PIN);
-  #endif
-  #if HAS_JOY_ADC_Y
-    HAL_ANALOG_SELECT(JOY_Y_PIN);
-  #endif
-  #if HAS_JOY_ADC_Z
-    HAL_ANALOG_SELECT(JOY_Z_PIN);
-  #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
-  #if HAS_TEMP_ADC_BED
-    HAL_ANALOG_SELECT(TEMP_BED_PIN);
-  #endif
-  #if HAS_TEMP_ADC_CHAMBER
-    HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
-  #endif
-  #if HAS_TEMP_ADC_PROBE
-    HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
-  #endif
-  #if HAS_TEMP_ADC_COOLER
-    HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
-  #endif
-  #if HAS_TEMP_ADC_BOARD
-    HAL_ANALOG_SELECT(TEMP_BOARD_PIN);
-  #endif
-  #if HAS_TEMP_ADC_REDUNDANT
-    HAL_ANALOG_SELECT(TEMP_REDUNDANT_PIN);
-  #endif
-  #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    HAL_ANALOG_SELECT(FILWIDTH_PIN);
-  #endif
-  #if HAS_ADC_BUTTONS
-    HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
-  #endif
-  #if ENABLED(POWER_MONITOR_CURRENT)
-    HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
-  #endif
-  #if ENABLED(POWER_MONITOR_VOLTAGE)
-    HAL_ANALOG_SELECT(POWER_MONITOR_VOLTAGE_PIN);
-  #endif
 
   HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif
@@ -3357,22 +3316,22 @@ void Temperature::isr() {
   /**
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
   #define ACCUMULATE_ADC(obj) do{ \
-    if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
-    else obj.sample(HAL_READ_ADC()); \
+    if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; \
+    else obj.sample(hal.adc_value()); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
@@ -3390,142 +3349,142 @@ void Temperature::isr() {
     }
 
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
       if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
-      case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
+      case PrepareTemp_0: hal.adc_start(TEMP_0_PIN); break;
       case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
     #endif
 
     #if HAS_TEMP_ADC_BED
-      case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
+      case PrepareTemp_BED: hal.adc_start(TEMP_BED_PIN); break;
       case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
     #if HAS_TEMP_ADC_CHAMBER
-      case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
+      case PrepareTemp_CHAMBER: hal.adc_start(TEMP_CHAMBER_PIN); break;
       case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
     #if HAS_TEMP_ADC_COOLER
-      case PrepareTemp_COOLER: HAL_START_ADC(TEMP_COOLER_PIN); break;
+      case PrepareTemp_COOLER: hal.adc_start(TEMP_COOLER_PIN); break;
       case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
     #endif
 
     #if HAS_TEMP_ADC_PROBE
-      case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
+      case PrepareTemp_PROBE: hal.adc_start(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_BOARD
-      case PrepareTemp_BOARD: HAL_START_ADC(TEMP_BOARD_PIN); break;
+      case PrepareTemp_BOARD: hal.adc_start(TEMP_BOARD_PIN); break;
       case MeasureTemp_BOARD: ACCUMULATE_ADC(temp_board); break;
     #endif
 
     #if HAS_TEMP_ADC_REDUNDANT
-      case PrepareTemp_REDUNDANT: HAL_START_ADC(TEMP_REDUNDANT_PIN); break;
+      case PrepareTemp_REDUNDANT: hal.adc_start(TEMP_REDUNDANT_PIN); break;
       case MeasureTemp_REDUNDANT: ACCUMULATE_ADC(temp_redundant); break;
     #endif
 
     #if HAS_TEMP_ADC_1
-      case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
+      case PrepareTemp_1: hal.adc_start(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2
-      case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
+      case PrepareTemp_2: hal.adc_start(TEMP_2_PIN); break;
       case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
     #if HAS_TEMP_ADC_3
-      case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
+      case PrepareTemp_3: hal.adc_start(TEMP_3_PIN); break;
       case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
     #endif
 
     #if HAS_TEMP_ADC_4
-      case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
+      case PrepareTemp_4: hal.adc_start(TEMP_4_PIN); break;
       case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
     #endif
 
     #if HAS_TEMP_ADC_5
-      case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
+      case PrepareTemp_5: hal.adc_start(TEMP_5_PIN); break;
       case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
 
     #if HAS_TEMP_ADC_6
-      case PrepareTemp_6: HAL_START_ADC(TEMP_6_PIN); break;
+      case PrepareTemp_6: hal.adc_start(TEMP_6_PIN); break;
       case MeasureTemp_6: ACCUMULATE_ADC(temp_hotend[6]); break;
     #endif
 
     #if HAS_TEMP_ADC_7
-      case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
+      case PrepareTemp_7: hal.adc_start(TEMP_7_PIN); break;
       case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
+      case Prepare_FILWIDTH: hal.adc_start(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
-        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
-        else filwidth.accumulate(HAL_READ_ADC());
+        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
+        else filwidth.accumulate(hal.adc_value());
       break;
     #endif
 
     #if ENABLED(POWER_MONITOR_CURRENT)
       case Prepare_POWER_MONITOR_CURRENT:
-        HAL_START_ADC(POWER_MONITOR_CURRENT_PIN);
+        hal.adc_start(POWER_MONITOR_CURRENT_PIN);
         break;
       case Measure_POWER_MONITOR_CURRENT:
-        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
-        else power_monitor.add_current_sample(HAL_READ_ADC());
+        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_current_sample(hal.adc_value());
         break;
     #endif
 
     #if ENABLED(POWER_MONITOR_VOLTAGE)
       case Prepare_POWER_MONITOR_VOLTAGE:
-        HAL_START_ADC(POWER_MONITOR_VOLTAGE_PIN);
+        hal.adc_start(POWER_MONITOR_VOLTAGE_PIN);
         break;
       case Measure_POWER_MONITOR_VOLTAGE:
-        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
-        else power_monitor.add_voltage_sample(HAL_READ_ADC());
+        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_voltage_sample(hal.adc_value());
         break;
     #endif
 
     #if HAS_JOY_ADC_X
-      case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
+      case PrepareJoy_X: hal.adc_start(JOY_X_PIN); break;
       case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
     #endif
 
     #if HAS_JOY_ADC_Y
-      case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
+      case PrepareJoy_Y: hal.adc_start(JOY_Y_PIN); break;
       case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
     #endif
 
     #if HAS_JOY_ADC_Z
-      case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
+      case PrepareJoy_Z: hal.adc_start(JOY_Z_PIN); break;
       case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
     #endif
 
     #if HAS_ADC_BUTTONS
       #ifndef ADC_BUTTON_DEBOUNCE_DELAY
         #define ADC_BUTTON_DEBOUNCE_DELAY 16
       #endif
-      case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
+      case Prepare_ADC_KEY: hal.adc_start(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
-        if (!HAL_ADC_READY())
+        if (!hal.adc_ready())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
-          raw_ADCKey_value = HAL_READ_ADC();
+          raw_ADCKey_value = hal.adc_value();
           if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
           else { //ADC Key release
             if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
             if (ADCKey_pressed) {
               ADCKey_count = 0;
               current_ADCKey_raw = HAL_ADC_RANGE;
             }

commit 7763f9385d506ef79ef81ccb48a972ab56050fb1
Author: Taylor Talkington <taylor.talkington@gmail.com>
Date:   Tue Feb 8 18:36:06 2022 -0500

    ‚ú® Optional HOST_STATUS_NOTIFICATIONS (#22833)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1716ec79dd..4ccd984b0d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -622,20 +622,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
     TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
@@ -712,20 +713,21 @@ volatile bool Temperature::raw_temps_ready = false;
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
+        TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TEMP_TOO_HIGH)));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(ischamber ? active_extruder : (isbed ? active_extruder : heater_id));
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
@@ -749,26 +751,28 @@ volatile bool Temperature::raw_temps_ready = false;
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
+        TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_TIMEOUT)));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
+        TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PID_AUTOTUNE_DONE)));
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    üö∏ Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e59a9f49cb..1716ec79dd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -45,21 +45,21 @@
   #include "../feature/controllerfan.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
-  #include "../lcd/e3v2/enhanced/dwin.h"
+  #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c9107a9b1c..e59a9f49cb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3779,21 +3779,21 @@ void Temperature::isr() {
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
             next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
-            TERN_(HAS_LCD_MENU, ui.quick_feedback());
+            TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         wait_for_heatup = false;
         #if HAS_DWIN_E3V2_BASIC
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // print timer
@@ -3913,21 +3913,21 @@ void Temperature::isr() {
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
             next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_BED);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
-            TERN_(HAS_LCD_MENU, ui.quick_feedback());
+            TERN_(HAS_MARLINUI_MENU, ui.quick_feedback());
           }
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
           first_loop = false;
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) {

commit 9285b6b9edcb42d38736a08785371204aea56501
Author: zerkix <97692157+zerkix@users.noreply.github.com>
Date:   Mon Jan 17 07:05:31 2022 +0100

    üêõ Finish and organize temp sensors (#23519)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 07f72b570a..c9107a9b1c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2354,26 +2354,26 @@ void Temperature::init() {
   #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
   #if HAS_TEMP_ADC_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
-  #if HAS_TEMP_ADC_COOLER
-    HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
-  #endif
   #if HAS_TEMP_ADC_PROBE
     HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
+  #if HAS_TEMP_ADC_COOLER
+    HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
+  #endif
   #if HAS_TEMP_ADC_BOARD
     HAL_ANALOG_SELECT(TEMP_BOARD_PIN);
   #endif
   #if HAS_TEMP_ADC_REDUNDANT
     HAL_ANALOG_SELECT(TEMP_REDUNDANT_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
@@ -2941,22 +2941,22 @@ void Temperature::update_raw_temperatures() {
 
   TERN_(HAS_TEMP_ADC_2,       temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED,     temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
   TERN_(HAS_TEMP_ADC_PROBE,   temp_probe.update());
-  TERN_(HAS_TEMP_ADC_BOARD,   temp_board.update());
   TERN_(HAS_TEMP_ADC_COOLER,  temp_cooler.update());
+  TERN_(HAS_TEMP_ADC_BOARD,   temp_board.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 }
 
 /**
  * Called by the Temperature ISR when all the ADCs have been processed.
  * Reset all the ADC accumulators for another round of updates.
  */

commit af93dbfb4f94a7e50c5f0eae2b0a7e911706e5c5
Author: Anson Liu <ansonl@users.noreply.github.com>
Date:   Mon Jan 17 00:39:09 2022 -0500

    üêõ Fix Ultimain 2 E-autofan pin mapping (#23466)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bb1768054e..07f72b570a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -881,30 +881,20 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
         , REPEAT(HOTENDS,_CFAN) (HOTENDS)
       #endif
     };
 
     uint8_t fanState = 0;
     HOTEND_LOOP() {
       if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE) {
         SBI(fanState, pgm_read_byte(&fanBit[e]));
-        #if MOTHERBOARD == BOARD_ULTIMAIN_2
-          // For the UM2 the head fan is connected to PJ6, which does not have an Arduino PIN definition. So use direct register access.
-          // https://github.com/Ultimaker/Ultimaker2Marlin/blob/master/Marlin/temperature.cpp#L553
-          SBI(DDRJ, 6); SBI(PORTJ, 6);
-        #endif
-      }
-      else {
-        #if MOTHERBOARD == BOARD_ULTIMAIN_2
-          SBI(DDRJ, 6); CBI(PORTJ, 6);
-        #endif
       }
     }
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0305e5e98e..bb1768054e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3039,22 +3039,22 @@ public:
       if (rdy && state_heater != v) {
         state_heater = v;
         state_timer_heater = MIN_STATE_TIME;
       }
       return rdy;
     }
   #endif
 };
 
 /**
- * Handle various ~1KHz tasks associated with temperature
- *  - Heater PWM (~1KHz with scaler)
+ * Handle various ~1kHz tasks associated with temperature
+ *  - Heater PWM (~1kHz with scaler)
  *  - LCD Button polling (~500Hz)
  *  - Start / Read one ADC sensor
  *  - Advance Babysteps
  *  - Endstop polling
  *  - Planner clean buffer
  */
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
@@ -3542,21 +3542,21 @@ void Temperature::isr() {
     #endif // HAS_ADC_BUTTONS
 
     case StartupDelay: break;
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
-  // Additional ~1KHz Tasks
+  // Additional ~1kHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
     babystep.task();
   #endif
 
   // Check fan tachometers
   TERN_(HAS_FANCHECK, fan_check.update_tachometers());
 
   // Poll endstops state, if required

commit 3d79b55c15d26c4181b66d831fca457fb167bc7f
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu Jan 13 04:57:36 2022 +1300

    üöëÔ∏è Fix M105 regression (#23505)
    
    Fixes #23504

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c3cd4f10d6..0305e5e98e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3623,21 +3623,21 @@ void Temperature::isr() {
       SERIAL_ECHOPGM(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
-      print_heater_state(H_E0, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
+      print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
     #endif
     #if HAS_HEATED_BED
       print_heater_state(H_BED, degBed(), degTargetBed() OPTARG(SHOW_TEMP_ADC_VALUES, rawBedTemp()));
     #endif
     #if HAS_TEMP_CHAMBER
       print_heater_state(H_CHAMBER, degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber()) OPTARG(SHOW_TEMP_ADC_VALUES, rawChamberTemp()));
     #endif
     #if HAS_TEMP_COOLER
       print_heater_state(H_COOLER, degCooler(), TERN0(HAS_COOLER, degTargetCooler()) OPTARG(SHOW_TEMP_ADC_VALUES, rawCoolerTemp()));
     #endif

commit 9665a4434cee0386fa2a63a058b6f2598943ee98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 02:51:34 2022 -0600

    üßë‚Äçüíª Fewer string macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f7d53b6da7..c3cd4f10d6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -212,22 +212,22 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if HAS_HEATED_CHAMBER
   #define _CHAMBER_FSTR(h) (h) == H_CHAMBER ? GET_TEXT_F(MSG_CHAMBER) :
 #else
   #define _CHAMBER_FSTR(h)
 #endif
 #if HAS_COOLER
   #define _COOLER_FSTR(h) (h) == H_COOLER ? GET_TEXT_F(MSG_COOLER) :
 #else
   #define _COOLER_FSTR(h)
 #endif
-#define _E_FSTR(h,N) ((HOTENDS) > N && (h) == N) ? F(LCD_STR_E##N) :
-#define HEATER_FSTR(h) _BED_FSTR(h) _CHAMBER_FSTR(h) _COOLER_FSTR(h) _E_FSTR(h,1) _E_FSTR(h,2) _E_FSTR(h,3) _E_FSTR(h,4) _E_FSTR(h,5) F(LCD_STR_E0)
+#define _E_FSTR(h,N) ((HOTENDS) > N && (h) == N) ? F(STR_E##N) :
+#define HEATER_FSTR(h) _BED_FSTR(h) _CHAMBER_FSTR(h) _COOLER_FSTR(h) _E_FSTR(h,1) _E_FSTR(h,2) _E_FSTR(h,3) _E_FSTR(h,4) _E_FSTR(h,5) _E_FSTR(h,6) _E_FSTR(h,7) F(STR_E0)
 
 //
 // Initialize MAX TC objects/SPI
 //
 #if HAS_MAX_TC
 
   #if HAS_MAXTC_SW_SPI
     // Initialize SoftSPI for non-lib Software SPI; Libraries take care of it themselves.
     template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin>
       SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;

commit 63f71d85f2af5c9a352a4fca9b3c1acb1a5f4746
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Sun Jan 2 02:18:07 2022 +0200

    ‚ú® Temperature variance monitor (#23373)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c5c4b3524b..f7d53b6da7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -189,20 +189,21 @@
 #if HAS_HOTEND_THERMISTOR
   #define NEXT_TEMPTABLE(N) ,TEMPTABLE_##N
   #define NEXT_TEMPTABLE_LEN(N) ,TEMPTABLE_##N##_LEN
   static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0 REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
   static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
 #endif
 
 Temperature thermalManager;
 
 PGMSTR(str_t_thermal_runaway, STR_T_THERMAL_RUNAWAY);
+PGMSTR(str_t_temp_malfunction, STR_T_MALFUNCTION);
 PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
   #define _BED_FSTR(h) (h) == H_BED ? GET_TEXT_F(MSG_BED) :
 #else
@@ -2563,28 +2564,44 @@ void Temperature::init() {
       }
       SERIAL_ECHOLNPGM(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
     */
 
-    // If the heater idle timeout expires, restart
-    if (TERN0(HEATER_IDLE_HANDLER, heater_idle[idle_index].timed_out)) {
-      state = TRInactive;
-      running_temp = 0;
-    }
-    else if (running_temp != target) { // If the target temperature changes, restart
-      running_temp = target;
-      state = target > 0 ? TRFirstHeating : TRInactive;
+    #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
+      if (state == TRMalfunction) { // temperature invariance may continue, regardless of heater state
+        variance += ABS(current - last_temp); // no need for detection window now, a single change in variance is enough
+        last_temp = current;
+        if (!NEAR_ZERO(variance)) {
+          variance_timer = millis() + SEC_TO_MS(period_seconds);
+          variance = 0.0;
+          state = TRStable; // resume from where we detected the problem
+        }
+      }
+    #endif
+
+    if (TERN1(THERMAL_PROTECTION_VARIANCE_MONITOR, state != TRMalfunction)) {
+      // If the heater idle timeout expires, restart
+      if (TERN0(HEATER_IDLE_HANDLER, heater_idle[idle_index].timed_out)) {
+        state = TRInactive;
+        running_temp = 0;
+        TERN_(THERMAL_PROTECTION_VARIANCE_MONITOR, variance_timer = 0);
+      }
+      else if (running_temp != target) { // If the target temperature changes, restart
+        running_temp = target;
+        state = target > 0 ? TRFirstHeating : TRInactive;
+        TERN_(THERMAL_PROTECTION_VARIANCE_MONITOR, variance_timer = 0);
+      }
     }
 
     switch (state) {
       // Inactive state waits for a target temperature to be set
       case TRInactive: break;
 
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < running_temp) break;
         state = TRStable;
@@ -2603,32 +2620,54 @@ void Temperature::init() {
               fan_speed_scaler[fan_index] = 64;
             else if (current >= running_temp - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else
               fan_speed_scaler[fan_index] = 0;
           }
         #endif
 
         const millis_t now = millis();
 
+        #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
+          if (PENDING(now, variance_timer)) {
+            variance += ABS(current - last_temp);
+            last_temp = current;
+          }
+          else {
+            if (NEAR_ZERO(variance) && variance_timer) { // valid variance monitoring window
+              state = TRMalfunction;
+              break;
+            }
+            variance_timer = now + SEC_TO_MS(period_seconds);
+            variance = 0.0;
+            last_temp = current;
+          }
+        #endif
+
         if (current >= running_temp - hysteresis_degc) {
           timer = now + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
       } // fall through
 
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
         _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
+
+      #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
+        case TRMalfunction:
+          TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
+          _temp_error(heater_id, FPSTR(str_t_temp_malfunction), GET_TEXT_F(MSG_TEMP_MALFUNCTION));
+      #endif
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   // Disable autotemp, unpause and reset everything
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
   TERN_(PROBING_HEATERS_OFF, pause_heaters(false));

commit b07887687ed96645b3e67ae2586c8198575a3e5d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 31 07:42:07 2021 -0600

    üöëÔ∏è Fix thermal conditionals, structure

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index dccdc55034..c5c4b3524b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1437,21 +1437,21 @@ void Temperature::manage_heater() {
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
           && TERN1(PAUSE_CHANGE_REQD, paused_for_probing == last_pause_state)
         ) break;
         next_bed_check_ms = ms + BED_CHECK_INTERVAL;
         TERN_(PAUSE_CHANGE_REQD, last_pause_state = paused_for_probing);
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[IDLE_INDEX_BED].update(ms));
 
-      #if HAS_THERMALLY_PROTECTED_BED
+      #if ENABLED(THERMAL_PROTECTION_BED)
         tr_state_machine[RUNAWAY_IND_BED].run(temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
       #endif
 
       #if HEATER_IDLE_HANDLER
         if (heater_idle[IDLE_INDEX_BED].timed_out) {
           temp_bed.soft_pwm_amount = 0;
           #if DISABLED(PIDTEMPBED)
             WRITE_HEATER_BED(LOW);
           #endif
         }
@@ -2563,71 +2563,69 @@ void Temperature::init() {
       }
       SERIAL_ECHOLNPGM(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
     */
 
-    #if HEATER_IDLE_HANDLER
-      // If the heater idle timeout expires, restart
-      if (heater_idle[idle_index].timed_out) {
-        state = TRInactive;
-        running_temp = 0;
-      }
-      else
-    #endif
-    {
-      // If the target temperature changes, restart
-      if (running_temp != target) {
-        running_temp = target;
-        state = target > 0 ? TRFirstHeating : TRInactive;
-      }
+    // If the heater idle timeout expires, restart
+    if (TERN0(HEATER_IDLE_HANDLER, heater_idle[idle_index].timed_out)) {
+      state = TRInactive;
+      running_temp = 0;
+    }
+    else if (running_temp != target) { // If the target temperature changes, restart
+      running_temp = target;
+      state = target > 0 ? TRFirstHeating : TRInactive;
     }
 
     switch (state) {
       // Inactive state waits for a target temperature to be set
       case TRInactive: break;
 
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < running_temp) break;
         state = TRStable;
 
       // While the temperature is stable watch for a bad temperature
-      case TRStable:
+      case TRStable: {
 
         #if ENABLED(ADAPTIVE_FAN_SLOWING)
           if (adaptive_fan_slowing && heater_id >= 0) {
             const int fan_index = _MIN(heater_id, FAN_COUNT - 1);
             if (fan_speed[fan_index] == 0 || current >= running_temp - (hysteresis_degc * 0.25f))
               fan_speed_scaler[fan_index] = 128;
             else if (current >= running_temp - (hysteresis_degc * 0.3335f))
               fan_speed_scaler[fan_index] = 96;
             else if (current >= running_temp - (hysteresis_degc * 0.5f))
               fan_speed_scaler[fan_index] = 64;
             else if (current >= running_temp - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else
               fan_speed_scaler[fan_index] = 0;
           }
         #endif
 
+        const millis_t now = millis();
+
         if (current >= running_temp - hysteresis_degc) {
-          timer = millis() + SEC_TO_MS(period_seconds);
+          timer = now + SEC_TO_MS(period_seconds);
           break;
         }
-        else if (PENDING(millis(), timer)) break;
+        else if (PENDING(now, timer)) break;
         state = TRRunaway;
 
+      } // fall through
+
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
         _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ‚è™Ô∏è Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1960dc5d9b..dccdc55034 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -319,21 +319,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
-  #define SET_FAST_PWM_FREQ(P) hal.set_pwm_frequency(pin_t(P), FAST_PWM_FAN_FREQUENCY)
+  #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
 #define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
 
 // HAS_FAN does not include CONTROLLER_FAN
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
@@ -806,21 +806,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
-      hal.idletask();
+      TERN_(HAL_IDLETASK, HAL_idletask());
 
       // Run UI update
       TERN(HAS_DWIN_E3V2_BASIC, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
@@ -905,21 +905,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                   \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)           \
-        hal.set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
+        set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                                \
         WRITE(P##_AUTO_FAN_PIN, D);                       \
     }while(0)
 
     uint8_t fanDone = 0;
     LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
@@ -2319,87 +2319,87 @@ void Temperature::init() {
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
   TERN_(HAS_MAXTC_SW_SPI, max_tc_spi.init());
 
-  hal.adc_init();
+  HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
-    hal.adc_enable(TEMP_0_PIN);
+    HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
-    hal.adc_enable(TEMP_1_PIN);
+    HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
-    hal.adc_enable(TEMP_2_PIN);
+    HAL_ANALOG_SELECT(TEMP_2_PIN);
   #endif
   #if HAS_TEMP_ADC_3
-    hal.adc_enable(TEMP_3_PIN);
+    HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_ADC_4
-    hal.adc_enable(TEMP_4_PIN);
+    HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_ADC_5
-    hal.adc_enable(TEMP_5_PIN);
+    HAL_ANALOG_SELECT(TEMP_5_PIN);
   #endif
   #if HAS_TEMP_ADC_6
-    hal.adc_enable(TEMP_6_PIN);
+    HAL_ANALOG_SELECT(TEMP_6_PIN);
   #endif
   #if HAS_TEMP_ADC_7
-    hal.adc_enable(TEMP_7_PIN);
+    HAL_ANALOG_SELECT(TEMP_7_PIN);
   #endif
   #if HAS_JOY_ADC_X
-    hal.adc_enable(JOY_X_PIN);
+    HAL_ANALOG_SELECT(JOY_X_PIN);
   #endif
   #if HAS_JOY_ADC_Y
-    hal.adc_enable(JOY_Y_PIN);
+    HAL_ANALOG_SELECT(JOY_Y_PIN);
   #endif
   #if HAS_JOY_ADC_Z
-    hal.adc_enable(JOY_Z_PIN);
+    HAL_ANALOG_SELECT(JOY_Z_PIN);
   #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
   #if HAS_TEMP_ADC_BED
-    hal.adc_enable(TEMP_BED_PIN);
+    HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_ADC_CHAMBER
-    hal.adc_enable(TEMP_CHAMBER_PIN);
+    HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if HAS_TEMP_ADC_COOLER
-    hal.adc_enable(TEMP_COOLER_PIN);
+    HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
   #endif
   #if HAS_TEMP_ADC_PROBE
-    hal.adc_enable(TEMP_PROBE_PIN);
+    HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
   #if HAS_TEMP_ADC_BOARD
-    hal.adc_enable(TEMP_BOARD_PIN);
+    HAL_ANALOG_SELECT(TEMP_BOARD_PIN);
   #endif
   #if HAS_TEMP_ADC_REDUNDANT
-    hal.adc_enable(TEMP_REDUNDANT_PIN);
+    HAL_ANALOG_SELECT(TEMP_REDUNDANT_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    hal.adc_enable(FILWIDTH_PIN);
+    HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
-    hal.adc_enable(ADC_KEYPAD_PIN);
+    HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
-    hal.adc_enable(POWER_MONITOR_CURRENT_PIN);
+    HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_VOLTAGE)
-    hal.adc_enable(POWER_MONITOR_VOLTAGE_PIN);
+    HAL_ANALOG_SELECT(POWER_MONITOR_VOLTAGE_PIN);
   #endif
 
   HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
@@ -3326,22 +3326,22 @@ void Temperature::isr() {
   /**
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
   #define ACCUMULATE_ADC(obj) do{ \
-    if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; \
-    else obj.sample(hal.adc_value()); \
+    if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
+    else obj.sample(HAL_READ_ADC()); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
@@ -3359,142 +3359,142 @@ void Temperature::isr() {
     }
 
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
       if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
-      case PrepareTemp_0: hal.adc_start(TEMP_0_PIN); break;
+      case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
       case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
     #endif
 
     #if HAS_TEMP_ADC_BED
-      case PrepareTemp_BED: hal.adc_start(TEMP_BED_PIN); break;
+      case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
       case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
     #if HAS_TEMP_ADC_CHAMBER
-      case PrepareTemp_CHAMBER: hal.adc_start(TEMP_CHAMBER_PIN); break;
+      case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
       case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
     #if HAS_TEMP_ADC_COOLER
-      case PrepareTemp_COOLER: hal.adc_start(TEMP_COOLER_PIN); break;
+      case PrepareTemp_COOLER: HAL_START_ADC(TEMP_COOLER_PIN); break;
       case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
     #endif
 
     #if HAS_TEMP_ADC_PROBE
-      case PrepareTemp_PROBE: hal.adc_start(TEMP_PROBE_PIN); break;
+      case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_BOARD
-      case PrepareTemp_BOARD: hal.adc_start(TEMP_BOARD_PIN); break;
+      case PrepareTemp_BOARD: HAL_START_ADC(TEMP_BOARD_PIN); break;
       case MeasureTemp_BOARD: ACCUMULATE_ADC(temp_board); break;
     #endif
 
     #if HAS_TEMP_ADC_REDUNDANT
-      case PrepareTemp_REDUNDANT: hal.adc_start(TEMP_REDUNDANT_PIN); break;
+      case PrepareTemp_REDUNDANT: HAL_START_ADC(TEMP_REDUNDANT_PIN); break;
       case MeasureTemp_REDUNDANT: ACCUMULATE_ADC(temp_redundant); break;
     #endif
 
     #if HAS_TEMP_ADC_1
-      case PrepareTemp_1: hal.adc_start(TEMP_1_PIN); break;
+      case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2
-      case PrepareTemp_2: hal.adc_start(TEMP_2_PIN); break;
+      case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
       case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
     #if HAS_TEMP_ADC_3
-      case PrepareTemp_3: hal.adc_start(TEMP_3_PIN); break;
+      case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
       case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
     #endif
 
     #if HAS_TEMP_ADC_4
-      case PrepareTemp_4: hal.adc_start(TEMP_4_PIN); break;
+      case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
       case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
     #endif
 
     #if HAS_TEMP_ADC_5
-      case PrepareTemp_5: hal.adc_start(TEMP_5_PIN); break;
+      case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
       case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
 
     #if HAS_TEMP_ADC_6
-      case PrepareTemp_6: hal.adc_start(TEMP_6_PIN); break;
+      case PrepareTemp_6: HAL_START_ADC(TEMP_6_PIN); break;
       case MeasureTemp_6: ACCUMULATE_ADC(temp_hotend[6]); break;
     #endif
 
     #if HAS_TEMP_ADC_7
-      case PrepareTemp_7: hal.adc_start(TEMP_7_PIN); break;
+      case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
       case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Prepare_FILWIDTH: hal.adc_start(FILWIDTH_PIN); break;
+      case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
-        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
-        else filwidth.accumulate(hal.adc_value());
+        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
+        else filwidth.accumulate(HAL_READ_ADC());
       break;
     #endif
 
     #if ENABLED(POWER_MONITOR_CURRENT)
       case Prepare_POWER_MONITOR_CURRENT:
-        hal.adc_start(POWER_MONITOR_CURRENT_PIN);
+        HAL_START_ADC(POWER_MONITOR_CURRENT_PIN);
         break;
       case Measure_POWER_MONITOR_CURRENT:
-        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
-        else power_monitor.add_current_sample(hal.adc_value());
+        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_current_sample(HAL_READ_ADC());
         break;
     #endif
 
     #if ENABLED(POWER_MONITOR_VOLTAGE)
       case Prepare_POWER_MONITOR_VOLTAGE:
-        hal.adc_start(POWER_MONITOR_VOLTAGE_PIN);
+        HAL_START_ADC(POWER_MONITOR_VOLTAGE_PIN);
         break;
       case Measure_POWER_MONITOR_VOLTAGE:
-        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
-        else power_monitor.add_voltage_sample(hal.adc_value());
+        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_voltage_sample(HAL_READ_ADC());
         break;
     #endif
 
     #if HAS_JOY_ADC_X
-      case PrepareJoy_X: hal.adc_start(JOY_X_PIN); break;
+      case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
       case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
     #endif
 
     #if HAS_JOY_ADC_Y
-      case PrepareJoy_Y: hal.adc_start(JOY_Y_PIN); break;
+      case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
       case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
     #endif
 
     #if HAS_JOY_ADC_Z
-      case PrepareJoy_Z: hal.adc_start(JOY_Z_PIN); break;
+      case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
       case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
     #endif
 
     #if HAS_ADC_BUTTONS
       #ifndef ADC_BUTTON_DEBOUNCE_DELAY
         #define ADC_BUTTON_DEBOUNCE_DELAY 16
       #endif
-      case Prepare_ADC_KEY: hal.adc_start(ADC_KEYPAD_PIN); break;
+      case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
-        if (!hal.adc_ready())
+        if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
-          raw_ADCKey_value = hal.adc_value();
+          raw_ADCKey_value = HAL_READ_ADC();
           if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
           else { //ADC Key release
             if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
             if (ADCKey_pressed) {
               ADCKey_count = 0;
               current_ADCKey_raw = HAL_ADC_RANGE;
             }

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index dccdc55034..1960dc5d9b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -319,21 +319,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
-  #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
+  #define SET_FAST_PWM_FREQ(P) hal.set_pwm_frequency(pin_t(P), FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
 #define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
 
 // HAS_FAN does not include CONTROLLER_FAN
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
@@ -806,21 +806,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
         TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
-      TERN_(HAL_IDLETASK, HAL_idletask());
+      hal.idletask();
 
       // Run UI update
       TERN(HAS_DWIN_E3V2_BASIC, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
@@ -905,21 +905,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                   \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)           \
-        set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
+        hal.set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                                \
         WRITE(P##_AUTO_FAN_PIN, D);                       \
     }while(0)
 
     uint8_t fanDone = 0;
     LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
@@ -2319,87 +2319,87 @@ void Temperature::init() {
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
   TERN_(HAS_MAXTC_SW_SPI, max_tc_spi.init());
 
-  HAL_adc_init();
+  hal.adc_init();
 
   #if HAS_TEMP_ADC_0
-    HAL_ANALOG_SELECT(TEMP_0_PIN);
+    hal.adc_enable(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
-    HAL_ANALOG_SELECT(TEMP_1_PIN);
+    hal.adc_enable(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
-    HAL_ANALOG_SELECT(TEMP_2_PIN);
+    hal.adc_enable(TEMP_2_PIN);
   #endif
   #if HAS_TEMP_ADC_3
-    HAL_ANALOG_SELECT(TEMP_3_PIN);
+    hal.adc_enable(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_ADC_4
-    HAL_ANALOG_SELECT(TEMP_4_PIN);
+    hal.adc_enable(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_ADC_5
-    HAL_ANALOG_SELECT(TEMP_5_PIN);
+    hal.adc_enable(TEMP_5_PIN);
   #endif
   #if HAS_TEMP_ADC_6
-    HAL_ANALOG_SELECT(TEMP_6_PIN);
+    hal.adc_enable(TEMP_6_PIN);
   #endif
   #if HAS_TEMP_ADC_7
-    HAL_ANALOG_SELECT(TEMP_7_PIN);
+    hal.adc_enable(TEMP_7_PIN);
   #endif
   #if HAS_JOY_ADC_X
-    HAL_ANALOG_SELECT(JOY_X_PIN);
+    hal.adc_enable(JOY_X_PIN);
   #endif
   #if HAS_JOY_ADC_Y
-    HAL_ANALOG_SELECT(JOY_Y_PIN);
+    hal.adc_enable(JOY_Y_PIN);
   #endif
   #if HAS_JOY_ADC_Z
-    HAL_ANALOG_SELECT(JOY_Z_PIN);
+    hal.adc_enable(JOY_Z_PIN);
   #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
   #if HAS_TEMP_ADC_BED
-    HAL_ANALOG_SELECT(TEMP_BED_PIN);
+    hal.adc_enable(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_ADC_CHAMBER
-    HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
+    hal.adc_enable(TEMP_CHAMBER_PIN);
   #endif
   #if HAS_TEMP_ADC_COOLER
-    HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
+    hal.adc_enable(TEMP_COOLER_PIN);
   #endif
   #if HAS_TEMP_ADC_PROBE
-    HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
+    hal.adc_enable(TEMP_PROBE_PIN);
   #endif
   #if HAS_TEMP_ADC_BOARD
-    HAL_ANALOG_SELECT(TEMP_BOARD_PIN);
+    hal.adc_enable(TEMP_BOARD_PIN);
   #endif
   #if HAS_TEMP_ADC_REDUNDANT
-    HAL_ANALOG_SELECT(TEMP_REDUNDANT_PIN);
+    hal.adc_enable(TEMP_REDUNDANT_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    HAL_ANALOG_SELECT(FILWIDTH_PIN);
+    hal.adc_enable(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
-    HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
+    hal.adc_enable(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
-    HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
+    hal.adc_enable(POWER_MONITOR_CURRENT_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_VOLTAGE)
-    HAL_ANALOG_SELECT(POWER_MONITOR_VOLTAGE_PIN);
+    hal.adc_enable(POWER_MONITOR_VOLTAGE_PIN);
   #endif
 
   HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
@@ -3326,22 +3326,22 @@ void Temperature::isr() {
   /**
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
   #define ACCUMULATE_ADC(obj) do{ \
-    if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
-    else obj.sample(HAL_READ_ADC()); \
+    if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; \
+    else obj.sample(hal.adc_value()); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
@@ -3359,142 +3359,142 @@ void Temperature::isr() {
     }
 
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
       if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
-      case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
+      case PrepareTemp_0: hal.adc_start(TEMP_0_PIN); break;
       case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
     #endif
 
     #if HAS_TEMP_ADC_BED
-      case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
+      case PrepareTemp_BED: hal.adc_start(TEMP_BED_PIN); break;
       case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
     #if HAS_TEMP_ADC_CHAMBER
-      case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
+      case PrepareTemp_CHAMBER: hal.adc_start(TEMP_CHAMBER_PIN); break;
       case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
     #if HAS_TEMP_ADC_COOLER
-      case PrepareTemp_COOLER: HAL_START_ADC(TEMP_COOLER_PIN); break;
+      case PrepareTemp_COOLER: hal.adc_start(TEMP_COOLER_PIN); break;
       case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
     #endif
 
     #if HAS_TEMP_ADC_PROBE
-      case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
+      case PrepareTemp_PROBE: hal.adc_start(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_BOARD
-      case PrepareTemp_BOARD: HAL_START_ADC(TEMP_BOARD_PIN); break;
+      case PrepareTemp_BOARD: hal.adc_start(TEMP_BOARD_PIN); break;
       case MeasureTemp_BOARD: ACCUMULATE_ADC(temp_board); break;
     #endif
 
     #if HAS_TEMP_ADC_REDUNDANT
-      case PrepareTemp_REDUNDANT: HAL_START_ADC(TEMP_REDUNDANT_PIN); break;
+      case PrepareTemp_REDUNDANT: hal.adc_start(TEMP_REDUNDANT_PIN); break;
       case MeasureTemp_REDUNDANT: ACCUMULATE_ADC(temp_redundant); break;
     #endif
 
     #if HAS_TEMP_ADC_1
-      case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
+      case PrepareTemp_1: hal.adc_start(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2
-      case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
+      case PrepareTemp_2: hal.adc_start(TEMP_2_PIN); break;
       case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
     #if HAS_TEMP_ADC_3
-      case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
+      case PrepareTemp_3: hal.adc_start(TEMP_3_PIN); break;
       case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
     #endif
 
     #if HAS_TEMP_ADC_4
-      case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
+      case PrepareTemp_4: hal.adc_start(TEMP_4_PIN); break;
       case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
     #endif
 
     #if HAS_TEMP_ADC_5
-      case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
+      case PrepareTemp_5: hal.adc_start(TEMP_5_PIN); break;
       case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
 
     #if HAS_TEMP_ADC_6
-      case PrepareTemp_6: HAL_START_ADC(TEMP_6_PIN); break;
+      case PrepareTemp_6: hal.adc_start(TEMP_6_PIN); break;
       case MeasureTemp_6: ACCUMULATE_ADC(temp_hotend[6]); break;
     #endif
 
     #if HAS_TEMP_ADC_7
-      case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
+      case PrepareTemp_7: hal.adc_start(TEMP_7_PIN); break;
       case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
+      case Prepare_FILWIDTH: hal.adc_start(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
-        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
-        else filwidth.accumulate(HAL_READ_ADC());
+        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
+        else filwidth.accumulate(hal.adc_value());
       break;
     #endif
 
     #if ENABLED(POWER_MONITOR_CURRENT)
       case Prepare_POWER_MONITOR_CURRENT:
-        HAL_START_ADC(POWER_MONITOR_CURRENT_PIN);
+        hal.adc_start(POWER_MONITOR_CURRENT_PIN);
         break;
       case Measure_POWER_MONITOR_CURRENT:
-        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
-        else power_monitor.add_current_sample(HAL_READ_ADC());
+        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_current_sample(hal.adc_value());
         break;
     #endif
 
     #if ENABLED(POWER_MONITOR_VOLTAGE)
       case Prepare_POWER_MONITOR_VOLTAGE:
-        HAL_START_ADC(POWER_MONITOR_VOLTAGE_PIN);
+        hal.adc_start(POWER_MONITOR_VOLTAGE_PIN);
         break;
       case Measure_POWER_MONITOR_VOLTAGE:
-        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
-        else power_monitor.add_voltage_sample(HAL_READ_ADC());
+        if (!hal.adc_ready()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_voltage_sample(hal.adc_value());
         break;
     #endif
 
     #if HAS_JOY_ADC_X
-      case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
+      case PrepareJoy_X: hal.adc_start(JOY_X_PIN); break;
       case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
     #endif
 
     #if HAS_JOY_ADC_Y
-      case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
+      case PrepareJoy_Y: hal.adc_start(JOY_Y_PIN); break;
       case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
     #endif
 
     #if HAS_JOY_ADC_Z
-      case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
+      case PrepareJoy_Z: hal.adc_start(JOY_Z_PIN); break;
       case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
     #endif
 
     #if HAS_ADC_BUTTONS
       #ifndef ADC_BUTTON_DEBOUNCE_DELAY
         #define ADC_BUTTON_DEBOUNCE_DELAY 16
       #endif
-      case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
+      case Prepare_ADC_KEY: hal.adc_start(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
-        if (!HAL_ADC_READY())
+        if (!hal.adc_ready())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
-          raw_ADCKey_value = HAL_READ_ADC();
+          raw_ADCKey_value = hal.adc_value();
           if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
           else { //ADC Key release
             if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
             if (ADCKey_pressed) {
               ADCKey_count = 0;
               current_ADCKey_raw = HAL_ADC_RANGE;
             }

commit b4727411d5a57a977625b484e3d22f4bea8f0790
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sun Dec 19 05:33:21 2021 +0700

    üêõ Fix loud_kill heater disable (#23314)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 341aec59b4..dccdc55034 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -976,22 +976,22 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
+  thermalManager.disable_all_heaters();
   #if USE_BEEPER
-    thermalManager.disable_all_heaters();
     for (uint8_t i = 20; i--;) {
       WRITE(BEEPER_PIN, HIGH);
       delay(25);
       watchdog_refresh();
       WRITE(BEEPER_PIN, LOW);
       delay(40);
       watchdog_refresh();
       delay(40);
       watchdog_refresh();
     }

commit 504e6fd786abeb06d39cb1cbb1dd83ab3acb1dd0
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Sat Dec 18 01:31:10 2021 +0200

    üîß Warning for IGNORE_THERMOCOUPLE_ERRORS (#23312)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 59d80e0ea8..341aec59b4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1346,20 +1346,22 @@ void Temperature::manage_heater() {
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_1_IS_MAX_TC
       if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
       if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
     #endif
     #if TEMP_SENSOR_REDUNDANT_IS_MAX_TC
       if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
       if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
     #endif
+  #else
+    #warning "Safety Alert! Disable IGNORE_THERMOCOUPLE_ERRORS for the final build!"
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
       #endif

commit 9eb2a5f62c4c98a6f681735da66ca22ac08550e7
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Tue Dec 14 05:07:44 2021 +0700

    ü©π Use EXTRUDER_AUTO_FAN_SPEED for _AUTOFAN_SPEED (#23180)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e068d4fca0..59d80e0ea8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -931,21 +931,21 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
         default:
           #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
             autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
           #endif
           break;
       }
 
       #if BOTH(HAS_FANCHECK, HAS_PWMFANCHECK)
         #define _AUTOFAN_SPEED() fan_check.is_measuring() ? 255 : EXTRUDER_AUTO_FAN_SPEED
       #else
-        #define _AUTOFAN_SPEED() 255
+        #define _AUTOFAN_SPEED() EXTRUDER_AUTO_FAN_SPEED
       #endif
       #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break
 
       switch (f) {
         #if HAS_AUTO_FAN_0
           _AUTOFAN_CASE(0);
         #endif
         #if HAS_AUTO_FAN_1
           _AUTOFAN_CASE(1);
         #endif

commit 9e6ded3cdfb362fb6b0f44ade6baca562708ee1c
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Wed Dec 8 20:55:09 2021 +0200

    üêõ Fix and improve MAX31865 (#23215)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9d6c566ba0..e068d4fca0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2195,39 +2195,33 @@ void Temperature::init() {
     #define _MAX31865_WIRES(n) MAX31865_##n##WIRE
     #define MAX31865_WIRES(n) _MAX31865_WIRES(n)
 
     #if TEMP_SENSOR_IS_MAX(0, 6675) && HAS_MAX6675_LIBRARY
       max6675_0.begin();
     #elif TEMP_SENSOR_IS_MAX(0, 31855) && HAS_MAX31855_LIBRARY
       max31855_0.begin();
     #elif TEMP_SENSOR_IS_MAX(0, 31865)
       max31865_0.begin(
         MAX31865_WIRES(MAX31865_SENSOR_WIRES_0) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
+        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0, MAX31865_WIRE_OHMS_0)
       );
-      #if defined(LIB_INTERNAL_MAX31865) && ENABLED(MAX31865_50HZ_FILTER)
-        max31865_0.enable50HzFilter(1);
-      #endif
     #endif
 
     #if TEMP_SENSOR_IS_MAX(1, 6675) && HAS_MAX6675_LIBRARY
       max6675_1.begin();
     #elif TEMP_SENSOR_IS_MAX(1, 31855) && HAS_MAX31855_LIBRARY
       max31855_1.begin();
     #elif TEMP_SENSOR_IS_MAX(1, 31865)
       max31865_1.begin(
         MAX31865_WIRES(MAX31865_SENSOR_WIRES_1) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1)
+        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1, MAX31865_WIRE_OHMS_1)
       );
-      #if defined(LIB_INTERNAL_MAX31865) && ENABLED(MAX31865_50HZ_FILTER)
-        max31865_1.enable50HzFilter(1);
-      #endif
     #endif
     #undef MAX31865_WIRES
     #undef _MAX31865_WIRES
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);

commit 97400e54b90a4fe40b60ea2f76e90cb14b0bf6ea
Author: ladismrkolj <ladismrkolj@gmail.com>
Date:   Sun Dec 5 22:41:39 2021 +0100

    üîß Chamber Fan index option (#23262)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9d6c8ae061..9d6c566ba0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -858,21 +858,23 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
     #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else
     #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
   #endif
   #if CHAMBER_AUTO_FAN_SPEED != 255
     #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else
     #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
   #endif
 
-  #define CHAMBER_FAN_INDEX HOTENDS
+  #ifndef CHAMBER_FAN_INDEX
+    #define CHAMBER_FAN_INDEX HOTENDS
+  #endif
 
   void Temperature::update_autofans() {
     #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HAS_MULTI_HOTEND
         #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
         RREPEAT_S(1, HOTENDS, _NEXT_FAN)
       #endif
       #if HAS_AUTO_CHAMBER_FAN

commit 7daa76382f858817ea7b52d11f9fae88d252988d
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sun Dec 5 05:14:19 2021 +0700

    üö∏ Park nozzle on "loud kill" (#23172)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 758275d21e..9d6c8ae061 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -60,20 +60,24 @@
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_TEMP_SENSOR
   #include "../gcode/gcode.h"
 #endif
 
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  #include "../libs/nozzle.h"
+#endif
+
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 #define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
 #if HAS_MAX6675 && USE_LIB_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
@@ -984,20 +988,26 @@ inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
       delay(25);
       watchdog_refresh();
       WRITE(BEEPER_PIN, LOW);
       delay(40);
       watchdog_refresh();
       delay(40);
       watchdog_refresh();
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
+  #if ENABLED(NOZZLE_PARK_FEATURE)
+    if (!homing_needed_error()) {
+      nozzle.park(0);
+      planner.synchronize();
+    }
+  #endif
   kill(lcd_msg, HEATER_FSTR(heater_id));
 }
 
 void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_msg, FSTR_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOF(serial_msg);

commit 0539e870de30877a38c78d29a304a97a6068cc80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 27 18:33:32 2021 -0600

    üé® Rename HAL timer elements

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 187776de12..758275d21e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2380,21 +2380,21 @@ void Temperature::init() {
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
     HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_VOLTAGE)
     HAL_ANALOG_SELECT(POWER_MONITOR_VOLTAGE_PIN);
   #endif
 
-  HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
+  HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_2 && !(_EFANOVERLAP(2,0) || _EFANOVERLAP(2,1))
     INIT_E_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
@@ -2961,25 +2961,25 @@ void Temperature::readings_ready() {
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
  *  - Call planner.isr to count down its "ignore" time
  */
 HAL_TEMP_TIMER_ISR() {
-  HAL_timer_isr_prologue(TEMP_TIMER_NUM);
+  HAL_timer_isr_prologue(MF_TIMER_TEMP);
 
   Temperature::isr();
 
-  HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
+  HAL_timer_isr_epilogue(MF_TIMER_TEMP);
 }
 
 #if ENABLED(SLOW_PWM_HEATERS) && !defined(MIN_STATE_TIME)
   #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
 #endif
 
 class SoftPWM {
 public:
   uint8_t count;
   inline bool add(const uint8_t mask, const uint8_t amount) {

commit 6fa278b7418ebdc4f02b49749d34888c67c22024
Author: Anson Liu <ansonl@users.noreply.github.com>
Date:   Sat Nov 27 17:58:05 2021 -0500

    ü©π UM2 extruder cooling fan on PJ6 (#23194)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fc5eb2dc6c..187776de12 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -871,23 +871,35 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
         #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
         RREPEAT_S(1, HOTENDS, _NEXT_FAN)
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
         , REPEAT(HOTENDS,_CFAN) (HOTENDS)
       #endif
     };
 
     uint8_t fanState = 0;
-    HOTEND_LOOP()
-      if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
+    HOTEND_LOOP() {
+      if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE) {
         SBI(fanState, pgm_read_byte(&fanBit[e]));
+        #if MOTHERBOARD == BOARD_ULTIMAIN_2
+          // For the UM2 the head fan is connected to PJ6, which does not have an Arduino PIN definition. So use direct register access.
+          // https://github.com/Ultimaker/Ultimaker2Marlin/blob/master/Marlin/temperature.cpp#L553
+          SBI(DDRJ, 6); SBI(PORTJ, 6);
+        #endif
+      }
+      else {
+        #if MOTHERBOARD == BOARD_ULTIMAIN_2
+          SBI(DDRJ, 6); CBI(PORTJ, 6);
+        #endif
+      }
+    }
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
     #endif

commit a7549aac5c5efc7097d6ebe69b2d46b3e7acbfab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 22 13:21:26 2021 -0500

    üé® Misc. issue review patches

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7afec4408e..fc5eb2dc6c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -586,21 +586,21 @@ volatile bool Temperature::raw_temps_ready = false;
     #if ENABLED(PIDTEMPBED)
       #define B_TERN(T,A,B) ((T) ? (A) : (B))
     #else
       #define B_TERN(T,A,B) (B)
     #endif
     #define GHV(C,B,H) C_TERN(ischamber, C, B_TERN(isbed, B, H))
     #define SHV(V) C_TERN(ischamber, temp_chamber.soft_pwm_amount = V, B_TERN(isbed, temp_bed.soft_pwm_amount = V, temp_hotend[heater_id].soft_pwm_amount = V))
     #define ONHEATINGSTART() C_TERN(ischamber, printerEventLEDs.onChamberHeatingStart(), B_TERN(isbed, printerEventLEDs.onBedHeatingStart(), printerEventLEDs.onHotendHeatingStart()))
     #define ONHEATING(S,C,T) C_TERN(ischamber, printerEventLEDs.onChamberHeating(S,C,T), B_TERN(isbed, printerEventLEDs.onBedHeating(S,C,T), printerEventLEDs.onHotendHeating(S,C,T)))
 
-    #define WATCH_PID BOTH(WATCH_CHAMBER, PIDTEMPCHAMBER) || BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP)
+    #define WATCH_PID DISABLED(NO_WATCH_PID_TUNING) && (BOTH(WATCH_CHAMBER, PIDTEMPCHAMBER) || BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP))
 
     #if WATCH_PID
       #if BOTH(THERMAL_PROTECTION_CHAMBER, PIDTEMPCHAMBER)
         #define C_GTV(T,A,B) ((T) ? (A) : (B))
       #else
         #define C_GTV(T,A,B) (B)
       #endif
       #if BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
         #define B_GTV(T,A,B) ((T) ? (A) : (B))
       #else
@@ -677,22 +677,22 @@ volatile bool Temperature::raw_temps_ready = false;
           if (cycles > 0) {
             const long max_pow = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX);
             bias += (d * (t_high - t_low)) / (t_low + t_high);
             LIMIT(bias, 20, max_pow - 20);
             d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
             SERIAL_ECHOPGM(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
             if (cycles > 2) {
               const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
                           Tu = float(t_low + t_high) * 0.001f,
-                          pf = ischamber ? 0.2f : (isbed ? 0.2f : 0.6f),
-                          df = ischamber ? 1.0f / 3.0f : (isbed ? 1.0f / 3.0f : 1.0f / 8.0f);
+                          pf = (ischamber || isbed) ? 0.2f : 0.6f,
+                          df = (ischamber || isbed) ? 1.0f / 3.0f : 1.0f / 8.0f;
 
               tune_pid.Kp = Ku * pf;
               tune_pid.Ki = tune_pid.Kp * 2.0f / Tu;
               tune_pid.Kd = tune_pid.Kp * Tu * df;
 
               SERIAL_ECHOLNPGM(STR_KU, Ku, STR_TU, Tu);
               if (ischamber || isbed)
                 SERIAL_ECHOLNPGM(" No overshoot");
               else
                 SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
@@ -724,21 +724,21 @@ volatile bool Temperature::raw_temps_ready = false;
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_PID
           if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
-                temp_change_ms = ms + SEC_TO_MS(watch_temp_period);     // - move the expiration timer up
+                temp_change_ms = ms + SEC_TO_MS(watch_temp_period);   // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _temp_error(heater_id, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
               _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds

commit 7110d11c9d8933c8c412c2fabd3b065a5ab97b6e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Nov 23 21:01:53 2021 +0100

    ‚ú® Fan tachometer support (#23086)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ede8aa73ac..7afec4408e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -287,21 +287,21 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if HAS_TEMP_REDUNDANT
   redundant_info_t Temperature::temp_redundant;
 #endif
 
-#if ENABLED(AUTO_POWER_E_FANS)
+#if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed; // = 0
 #endif
@@ -519,22 +519,23 @@ volatile bool Temperature::raw_temps_ready = false;
 #endif
 
 #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #if MILLISECONDS_PREHEAT_TIME > 0
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
-#if HAS_AUTO_FAN
-  millis_t Temperature::next_auto_fan_check_ms = 0;
+#if HAS_FAN_LOGIC
+  constexpr millis_t Temperature::fan_update_interval_ms;
+  millis_t Temperature::fan_update_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
   celsius_t Temperature::singlenozzle_temp[EXTRUDERS];
 #endif
@@ -607,21 +608,21 @@ volatile bool Temperature::raw_temps_ready = false;
       #endif
       #define GTV(C,B,H) C_GTV(ischamber, C, B_GTV(isbed, B, H))
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
-    TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
+    TERN_(HAS_FAN_LOGIC, fan_update_ms = next_temp_ms + fan_update_interval_ms);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
     TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       return;
     }
@@ -652,26 +653,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
 
-        #if HAS_AUTO_FAN
-          if (ELAPSED(ms, next_auto_fan_check_ms)) {
-            checkExtruderAutoFans();
-            next_auto_fan_check_ms = ms + 2500UL;
-          }
-        #endif
+        TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
 
         if (heating && current_temp > target && ELAPSED(ms, t2 + 5000UL)) {
           heating = false;
           SHV((bias - d) >> 1);
           t1 = ms;
           t_high = t1 - t2;
           maxT = target;
         }
 
         if (!heating && current_temp < target && ELAPSED(ms, t1 + 5000UL)) {
@@ -846,34 +842,35 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
       case H_COOLER: return temp_cooler.soft_pwm_amount;
     #endif
     default:
       return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
+
   #if EXTRUDER_AUTO_FAN_SPEED != 255
     #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else
     #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
   #endif
   #if CHAMBER_AUTO_FAN_SPEED != 255
     #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
   #else
     #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
   #endif
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
-  void Temperature::checkExtruderAutoFans() {
+  void Temperature::update_autofans() {
     #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HAS_MULTI_HOTEND
         #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
         RREPEAT_S(1, HOTENDS, _NEXT_FAN)
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
         , REPEAT(HOTENDS,_CFAN) (HOTENDS)
@@ -907,50 +904,57 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
         #if ENABLED(AUTO_POWER_CHAMBER_FAN)
           case CHAMBER_FAN_INDEX:
             chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
             break;
         #endif
         default:
-          #if ENABLED(AUTO_POWER_E_FANS)
+          #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
             autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
           #endif
           break;
       }
 
+      #if BOTH(HAS_FANCHECK, HAS_PWMFANCHECK)
+        #define _AUTOFAN_SPEED() fan_check.is_measuring() ? 255 : EXTRUDER_AUTO_FAN_SPEED
+      #else
+        #define _AUTOFAN_SPEED() 255
+      #endif
+      #define _AUTOFAN_CASE(N) case N: _UPDATE_AUTO_FAN(E##N, fan_on, _AUTOFAN_SPEED()); break
+
       switch (f) {
         #if HAS_AUTO_FAN_0
-          case 0: _UPDATE_AUTO_FAN(E0, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(0);
         #endif
         #if HAS_AUTO_FAN_1
-          case 1: _UPDATE_AUTO_FAN(E1, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(1);
         #endif
         #if HAS_AUTO_FAN_2
-          case 2: _UPDATE_AUTO_FAN(E2, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(2);
         #endif
         #if HAS_AUTO_FAN_3
-          case 3: _UPDATE_AUTO_FAN(E3, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(3);
         #endif
         #if HAS_AUTO_FAN_4
-          case 4: _UPDATE_AUTO_FAN(E4, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(4);
         #endif
         #if HAS_AUTO_FAN_5
-          case 5: _UPDATE_AUTO_FAN(E5, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(5);
         #endif
         #if HAS_AUTO_FAN_6
-          case 6: _UPDATE_AUTO_FAN(E6, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(6);
         #endif
         #if HAS_AUTO_FAN_7
-          case 7: _UPDATE_AUTO_FAN(E7, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+          _AUTOFAN_CASE(7);
         #endif
         #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
           case CHAMBER_FAN_INDEX: _UPDATE_AUTO_FAN(CHAMBER, fan_on, CHAMBER_AUTO_FAN_SPEED); break;
         #endif
       }
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
@@ -1360,34 +1364,28 @@ void Temperature::manage_heater() {
     } // HOTEND_LOOP
 
   #endif // HAS_HOTEND
 
   #if HAS_TEMP_REDUNDANT
     // Make sure measured temperatures are close together
     if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
       _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), F(STR_REDUNDANCY), GET_TEXT_F(MSG_ERR_REDUNDANT_TEMP));
   #endif
 
-  #if HAS_AUTO_FAN
-    if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
-      checkExtruderAutoFans();
-      next_auto_fan_check_ms = ms + 2500UL;
-    }
-  #endif
+  // Manage extruder auto fans and/or read fan tachometers
+  TERN_(HAS_FAN_LOGIC, manage_extruder_fans(ms));
 
-  #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    /**
-     * Dynamically set the volumetric multiplier based
-     * on the delayed Filament Width measurement.
-     */
-    filwidth.update_volumetric();
-  #endif
+  /**
+   * Dynamically set the volumetric multiplier based
+   * on the delayed Filament Width measurement.
+   */
+  TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_volumetric());
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
@@ -3494,20 +3492,23 @@ void Temperature::isr() {
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
     babystep.task();
   #endif
 
+  // Check fan tachometers
+  TERN_(HAS_FANCHECK, fan_check.update_tachometers());
+
   // Poll endstops state, if required
   endstops.poll();
 
   // Periodically call the planner timer service routine
   planner.isr();
 }
 
 #if HAS_TEMP_SENSOR
   /**
    * Print a single heater state in the form:

commit 8ee368b718ea7086522f9d64dc97e45a273d6832
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sun Nov 14 05:55:31 2021 -0600

    ‚ö°Ô∏è Controller Fan software PWM (etc.) (#23102)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 48941532c8..ede8aa73ac 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -34,20 +34,24 @@
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
 #include "printcounter.h"
 
 #if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
+#if ENABLED(USE_CONTROLLER_FAN)
+  #include "../feature/controllerfan.h"
+#endif
+
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "../lcd/e3v2/enhanced/dwin.h"
 #endif
 
@@ -295,20 +299,24 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed; // = 0
 #endif
 
+#if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
+  uint8_t Temperature::soft_pwm_controller_speed;
+#endif
+
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef BOARD_OPENDRAIN_MOSFETS
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
@@ -3014,20 +3022,24 @@ void Temperature::isr() {
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
   #if HAS_COOLER
     static SoftPWM soft_pwm_cooler;
   #endif
 
+  #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
+    static SoftPWM soft_pwm_controller;
+  #endif
+
   #define WRITE_FAN(n, v) WRITE(FAN##n##_PIN, (v) ^ FAN_INVERTING)
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
     #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, HAS_COOLER, FAN_SOFT_PWM)
       constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \
         const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
         WRITE_HEATER_##N(on);                               \
       }while(0)
@@ -3049,20 +3061,24 @@ void Temperature::isr() {
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER, soft_pwm_chamber, temp_chamber);
       #endif
 
       #if HAS_COOLER
         _PWM_MOD(COOLER, soft_pwm_cooler, temp_cooler);
       #endif
 
+      #if BOTH(USE_CONTROLLER_FAN, FAN_SOFT_PWM)
+        WRITE(CONTROLLER_FAN_PIN, soft_pwm_controller.add(pwm_mask, soft_pwm_controller_speed));
+      #endif
+
       #if ENABLED(FAN_SOFT_PWM)
         #define _FAN_PWM(N) do{                                     \
           uint8_t &spcf = soft_pwm_count_fan[N];                    \
           spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
           WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW);               \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
@@ -3125,20 +3141,23 @@ void Temperature::isr() {
         #endif
         #if HAS_FAN5
           if (soft_pwm_count_fan[5] <= pwm_count_tmp) WRITE_FAN(5, LOW);
         #endif
         #if HAS_FAN6
           if (soft_pwm_count_fan[6] <= pwm_count_tmp) WRITE_FAN(6, LOW);
         #endif
         #if HAS_FAN7
           if (soft_pwm_count_fan[7] <= pwm_count_tmp) WRITE_FAN(7, LOW);
         #endif
+        #if ENABLED(USE_CONTROLLER_FAN)
+          if (soft_pwm_controller.count <= pwm_count_tmp) WRITE(CONTROLLER_FAN_PIN, LOW);
+        #endif
       #endif
     }
 
     // SOFT_PWM_SCALE to frequency:
     //
     // 0: 16000000/64/256/128 =   7.6294 Hz
     // 1:                / 64 =  15.2588 Hz
     // 2:                / 32 =  30.5176 Hz
     // 3:                / 16 =  61.0352 Hz
     // 4:                /  8 = 122.0703 Hz

commit 589a6d7f6bbf2254958aa92d8707c51fcbcd8dd3
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Nov 10 11:55:20 2021 -0500

    üö∏ Fix up E3V2 Enhanced (#23100)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cef348c5f9..48941532c8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3724,22 +3724,23 @@ void Temperature::isr() {
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         wait_for_heatup = false;
         #if HAS_DWIN_E3V2_BASIC
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // print timer
           dwin_heat_time = elapsed.value;
+        #else
+          ui.reset_status();
         #endif
-        ui.reset_status();
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
         return true;
       }
 
       return false;
     }
 
     #if ENABLED(WAIT_FOR_HOTEND)
       void Temperature::wait_for_hotend_heating(const uint8_t target_extruder) {
         if (isHeatingHotend(target_extruder)) {

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ‚öóÔ∏è Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5e8f4c9d95..cef348c5f9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -880,25 +880,25 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #if HAS_AUTO_COOLER_FAN
       if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
     #endif
 
-    #define _UPDATE_AUTO_FAN(P,D,A) do{                  \
-      if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)          \
-        analogWrite(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
-      else                                               \
-        WRITE(P##_AUTO_FAN_PIN, D);                      \
+    #define _UPDATE_AUTO_FAN(P,D,A) do{                   \
+      if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)           \
+        set_pwm_duty(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
+      else                                                \
+        WRITE(P##_AUTO_FAN_PIN, D);                       \
     }while(0)
 
     uint8_t fanDone = 0;
     LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
         #if ENABLED(AUTO_POWER_CHAMBER_FAN)
           case CHAMBER_FAN_INDEX:

commit 357fb8d98458883144e29a39e9f4d5c033f803a3
Author: Jason Smith <jason.inet@gmail.com>
Date:   Mon Oct 18 01:11:16 2021 -0700

    üêõ Fix max chamber fan speed (#22977)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4320a530c5..5e8f4c9d95 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1487,22 +1487,22 @@ void Temperature::manage_heater() {
             fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
             fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #elif CHAMBER_FAN_MODE == 3
             fan_chamber_pwm = CHAMBER_FAN_BASE + _MAX((CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target), 0);
           #endif
-          NOMORE(fan_chamber_pwm, 225);
-          set_fan_speed(CHAMBER_FAN_INDEX, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
+          NOMORE(fan_chamber_pwm, 255);
+          set_fan_speed(CHAMBER_FAN_INDEX, fan_chamber_pwm);
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
           if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {

commit ad4a8a68c2125f74124225813fe978c31677b3e5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 18 01:49:35 2021 -0500

    ‚úÖ Warn about dummy thermistors

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3130914451..4320a530c5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2200,36 +2200,36 @@ void Temperature::init() {
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   // Thermistor activation by MCU pin
   #if PIN_EXISTS(TEMP_0_TR_ENABLE)
-    OUT_WRITE(TEMP_0_TR_ENABLE_PIN,
+    OUT_WRITE(TEMP_0_TR_ENABLE_PIN, (
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
-        1
+        HIGH
       #else
-        0
+        LOW
       #endif
-    );
+    ));
   #endif
   #if PIN_EXISTS(TEMP_1_TR_ENABLE)
-    OUT_WRITE(TEMP_1_TR_ENABLE_PIN,
+    OUT_WRITE(TEMP_1_TR_ENABLE_PIN, (
       #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
-        1
+        HIGH
       #else
-        0
+        LOW
       #endif
-    );
+    ));
   #endif
 
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif
   #endif
   #if HAS_HEATER_1

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e0a35787c6..3130914451 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -180,45 +180,45 @@
 
 #if HAS_HOTEND_THERMISTOR
   #define NEXT_TEMPTABLE(N) ,TEMPTABLE_##N
   #define NEXT_TEMPTABLE_LEN(N) ,TEMPTABLE_##N##_LEN
   static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0 REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
   static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
 #endif
 
 Temperature thermalManager;
 
-const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
-           str_t_heating_failed[] PROGMEM = STR_T_HEATING_FAILED;
+PGMSTR(str_t_thermal_runaway, STR_T_THERMAL_RUNAWAY);
+PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
-  #define _BED_PSTR(h) (h) == H_BED ? GET_TEXT(MSG_BED) :
+  #define _BED_FSTR(h) (h) == H_BED ? GET_TEXT_F(MSG_BED) :
 #else
-  #define _BED_PSTR(h)
+  #define _BED_FSTR(h)
 #endif
 #if HAS_HEATED_CHAMBER
-  #define _CHAMBER_PSTR(h) (h) == H_CHAMBER ? GET_TEXT(MSG_CHAMBER) :
+  #define _CHAMBER_FSTR(h) (h) == H_CHAMBER ? GET_TEXT_F(MSG_CHAMBER) :
 #else
-  #define _CHAMBER_PSTR(h)
+  #define _CHAMBER_FSTR(h)
 #endif
 #if HAS_COOLER
-  #define _COOLER_PSTR(h) (h) == H_COOLER ? GET_TEXT(MSG_COOLER) :
+  #define _COOLER_FSTR(h) (h) == H_COOLER ? GET_TEXT_F(MSG_COOLER) :
 #else
-  #define _COOLER_PSTR(h)
+  #define _COOLER_FSTR(h)
 #endif
-#define _E_PSTR(h,N) ((HOTENDS) > N && (h) == N) ? PSTR(LCD_STR_E##N) :
-#define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
+#define _E_FSTR(h,N) ((HOTENDS) > N && (h) == N) ? F(LCD_STR_E##N) :
+#define HEATER_FSTR(h) _BED_FSTR(h) _CHAMBER_FSTR(h) _COOLER_FSTR(h) _E_FSTR(h,1) _E_FSTR(h,2) _E_FSTR(h,3) _E_FSTR(h,4) _E_FSTR(h,5) F(LCD_STR_E0)
 
 //
 // Initialize MAX TC objects/SPI
 //
 #if HAS_MAX_TC
 
   #if HAS_MAXTC_SW_SPI
     // Initialize SoftSPI for non-lib Software SPI; Libraries take care of it themselves.
     template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin>
       SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
@@ -724,24 +724,24 @@ volatile bool Temperature::raw_temps_ready = false;
         // Make sure heating is actually working
         #if WATCH_PID
           if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);     // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
-                _temp_error(heater_id, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+                _temp_error(heater_id, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+              _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
@@ -944,46 +944,46 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
-inline void loud_kill(PGM_P const lcd_msg, const heater_id_t heater_id) {
+inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
   #if USE_BEEPER
     thermalManager.disable_all_heaters();
     for (uint8_t i = 20; i--;) {
       WRITE(BEEPER_PIN, HIGH);
       delay(25);
       watchdog_refresh();
       WRITE(BEEPER_PIN, LOW);
       delay(40);
       watchdog_refresh();
       delay(40);
       watchdog_refresh();
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
-  kill(lcd_msg, HEATER_PSTR(heater_id));
+  kill(lcd_msg, HEATER_FSTR(heater_id));
 }
 
-void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_msg, PGM_P const lcd_msg) {
+void Temperature::_temp_error(const heater_id_t heater_id, FSTR_P const serial_msg, FSTR_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
-    SERIAL_ECHOPGM_P(serial_msg);
+    SERIAL_ECHOF(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
 
     heater_id_t real_heater_id = heater_id;
 
     #if HAS_TEMP_REDUNDANT
       if (heater_id == H_REDUNDANT) {
         SERIAL_ECHOPGM(STR_REDUNDANT); // print redundant and cascade to print target, too.
         real_heater_id = (heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET);
       }
     #endif
@@ -1024,28 +1024,28 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(1);
   #endif
-  _temp_error(heater_id, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
+  _temp_error(heater_id, F(STR_T_MAXTEMP), GET_TEXT_F(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_id_t heater_id) {
   #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(0);
   #endif
-  _temp_error(heater_id, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
+  _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
 
 #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
   bool Temperature::pid_debug_flag; // = 0
 #endif
 
 #if HAS_HOTEND
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
@@ -1287,21 +1287,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
   if (marlin_state == MF_INITIALIZING) return watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
 
   static bool no_reentry = false;  // Prevent recursion
   if (no_reentry) return;
   REMEMBER(mh, no_reentry, true);
 
   #if ENABLED(EMERGENCY_PARSER)
-    if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
+    if (emergency_parser.killed_by_M112) kill(FPSTR(M112_KILL_STR), nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
@@ -1337,33 +1337,33 @@ void Temperature::manage_heater() {
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
             TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
-            _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+            _temp_error((heater_id_t)e, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
           }
         }
       #endif
 
     } // HOTEND_LOOP
 
   #endif // HAS_HOTEND
 
   #if HAS_TEMP_REDUNDANT
     // Make sure measured temperatures are close together
     if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
-      _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
+      _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), F(STR_REDUNDANCY), GET_TEXT_F(MSG_ERR_REDUNDANT_TEMP));
   #endif
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
@@ -1380,21 +1380,21 @@ void Temperature::manage_heater() {
       if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         if (watch_bed.check(degBed()))          // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
           TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
-          _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+          _temp_error(H_BED, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
         }
       }
     #endif // WATCH_BED
 
     #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
       static bool last_pause_state;
@@ -1460,21 +1460,21 @@ void Temperature::manage_heater() {
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (degChamber() > CHAMBER_MAXTEMP) max_temp_error(H_CHAMBER);
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
         if (watch_chamber.check(degChamber()))  // Increased enough? Error below.
           start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
-          _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+          _temp_error(H_CHAMBER, FPSTR(str_t_heating_failed), GET_TEXT_F(MSG_HEATING_FAILED_LCD));
       }
     #endif
 
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
       static bool flag_chamber_excess_heat; // = false;
     #endif
 
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
       static bool flag_chamber_off; // = false
 
@@ -1582,21 +1582,21 @@ void Temperature::manage_heater() {
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
       if (degCooler() > COOLER_MAXTEMP) max_temp_error(H_COOLER);
     #endif
 
     #if WATCH_COOLER
       // Make sure temperature is decreasing
       if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
         if (degCooler() > watch_cooler.target)    // Failed to decrease enough?
-          _temp_error(H_COOLER, GET_TEXT(MSG_COOLING_FAILED), GET_TEXT(MSG_COOLING_FAILED));
+          _temp_error(H_COOLER, GET_TEXT_F(MSG_COOLING_FAILED), GET_TEXT_F(MSG_COOLING_FAILED));
         else
           start_watching_cooler();                 // Start again if the target is still far off
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
     if (cooler.enabled) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
       if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
@@ -2590,21 +2590,21 @@ void Temperature::init() {
 
         if (current >= running_temp - hysteresis_degc) {
           timer = millis() + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(millis(), timer)) break;
         state = TRRunaway;
 
       case TRRunaway:
         TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
-        _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+        _temp_error(heater_id, FPSTR(str_t_thermal_runaway), GET_TEXT_F(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   // Disable autotemp, unpause and reset everything
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
   TERN_(PROBING_HEATERS_OFF, pause_heaters(false));
@@ -3889,21 +3889,21 @@ void Temperature::isr() {
     #endif
     #ifndef MIN_DELTA_SLOPE_TIME_PROBE
       #define MIN_DELTA_SLOPE_TIME_PROBE 600
     #endif
 
     bool Temperature::wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling/*=true*/) {
 
       const bool wants_to_cool = isProbeAboveTemp(target_temp),
                  will_wait = !(wants_to_cool && no_wait_for_cooling);
       if (will_wait)
-        SERIAL_ECHOLNPGM("Waiting for probe to ", (wants_to_cool ? PSTR("cool down") : PSTR("heat up")), " to ", target_temp, " degrees.");
+        SERIAL_ECHOLNPGM("Waiting for probe to ", wants_to_cool ? F("cool down") : F("heat up"), " to ", target_temp, " degrees.");
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       float old_temp = 9999;
       millis_t next_temp_ms = 0, next_delta_check_ms = 0;
       wait_for_heatup = true;
       while (will_wait && wait_for_heatup) {
 

commit d7fede3a6324cd6b1ec91a9c8e248fce8f0d7cf2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:40:01 2021 -0500

    üé® Apply F() to G-code report header

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 40778ef312..e0a35787c6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1720,21 +1720,21 @@ void Temperature::manage_heater() {
         { true, 0, 0, BOARD_PULLUP_RESISTOR_OHMS, BOARD_RESISTANCE_25C_OHMS, 0, 0, BOARD_BETA, 0 },
       #endif
       #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
         { true, 0, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::M305_report(const uint8_t t_index, const bool forReplay/*=true*/) {
-    gcode.report_heading_etc(forReplay, PSTR(STR_USER_THERMISTORS));
+    gcode.report_heading_etc(forReplay, F(STR_USER_THERMISTORS));
     SERIAL_ECHOPGM("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     SERIAL_ECHOF(

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fbf8481c03..40778ef312 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -628,21 +628,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
-    TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT), "Wait for heat up..."));
+    TERN_(HAS_STATUS_MESSAGE, ui.set_status(F("Wait for heat up...")));
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
@@ -689,21 +689,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
               SERIAL_ECHOLNPGM(STR_KU, Ku, STR_TU, Tu);
               if (ischamber || isbed)
                 SERIAL_ECHOLNPGM(" No overshoot");
               else
                 SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
               SERIAL_ECHOLNPGM(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
             }
           }
           SHV((bias + d) >> 1);
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PID_CYCLE), cycles, ncycles));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PID_CYCLE), cycles, ncycles));
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
@@ -3596,25 +3596,25 @@ void Temperature::isr() {
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
     void Temperature::AutoReportTemp::report() { print_heater_states(active_extruder); SERIAL_EOL(); }
   #endif
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
-      ui.status_printf_P(0,
+      ui.status_printf(0,
         #if HAS_MULTI_HOTEND
-          PSTR("E%c " S_FMT), '1' + e
+          F("E%c " S_FMT), '1' + e
         #else
-          PSTR("E1 " S_FMT)
+          F("E1 " S_FMT)
         #endif
         , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
@@ -3737,21 +3737,21 @@ void Temperature::isr() {
         return true;
       }
 
       return false;
     }
 
     #if ENABLED(WAIT_FOR_HOTEND)
       void Temperature::wait_for_hotend_heating(const uint8_t target_extruder) {
         if (isHeatingHotend(target_extruder)) {
           SERIAL_ECHOLNPGM("Wait for hotend heating...");
-          LCD_MESSAGEPGM(MSG_HEATING);
+          LCD_MESSAGE(MSG_HEATING);
           wait_for_hotend(target_extruder);
           ui.reset_status();
         }
       }
     #endif
 
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 
@@ -3867,21 +3867,21 @@ void Temperature::isr() {
         ui.reset_status();
         return true;
       }
 
       return false;
     }
 
     void Temperature::wait_for_bed_heating() {
       if (isHeatingBed()) {
         SERIAL_ECHOLNPGM("Wait for bed heating...");
-        LCD_MESSAGEPGM(MSG_BED_HEATING);
+        LCD_MESSAGE(MSG_BED_HEATING);
         wait_for_bed();
         ui.reset_status();
       }
     }
 
   #endif // HAS_HEATED_BED
 
   #if HAS_TEMP_PROBE
 
     #ifndef MIN_DELTA_SLOPE_DEG_PROBE

commit 520b97083e52efdd47ab434b97823e48d85ade62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:03:07 2021 -0500

    üé® Apply F() to serial macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d59ebe5695..fbf8481c03 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -748,24 +748,24 @@ volatile bool Temperature::raw_temps_ready = false;
         TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
-          PGM_P const estring = GHV(PSTR("chamber"), PSTR("bed"), NUL_STR);
-          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
-          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
-          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
+          FSTR_P const estring = GHV(F("chamber"), F("bed"), FPSTR(NUL_STR));
+          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
+          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
+          say_default_(); SERIAL_ECHOF(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
         #else
           say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
         #endif
 
         auto _set_hotend_pid = [](const uint8_t e, const PID_t &in_pid) {
           #if ENABLED(PIDTEMP)
             PID_PARAM(Kp, e) = in_pid.Kp;
             PID_PARAM(Ki, e) = scalePID_i(in_pid.Ki);
@@ -1730,35 +1730,35 @@ void Temperature::manage_heater() {
     gcode.report_heading_etc(forReplay, PSTR(STR_USER_THERMISTORS));
     SERIAL_ECHOPGM("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
-    SERIAL_ECHOPGM_P(
-      TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
-      TERN_(TEMP_SENSOR_1_IS_CUSTOM, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
-      TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
-      TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
-      TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
-      TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
-      TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
-      TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
-      TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
-      TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
-      TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
-      TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
-      TERN_(TEMP_SENSOR_BOARD_IS_CUSTOM, t_index == CTI_BOARD ? PSTR("BOARD") :)
-      TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? PSTR("REDUNDANT") :)
+    SERIAL_ECHOF(
+      TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? F("HOTEND 0") :)
+      TERN_(TEMP_SENSOR_1_IS_CUSTOM, t_index == CTI_HOTEND_1 ? F("HOTEND 1") :)
+      TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? F("HOTEND 2") :)
+      TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? F("HOTEND 3") :)
+      TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? F("HOTEND 4") :)
+      TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? F("HOTEND 5") :)
+      TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? F("HOTEND 6") :)
+      TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? F("HOTEND 7") :)
+      TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? F("BED") :)
+      TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? F("CHAMBER") :)
+      TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? F("COOLER") :)
+      TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? F("PROBE") :)
+      TERN_(TEMP_SENSOR_BOARD_IS_CUSTOM, t_index == CTI_BOARD ? F("BOARD") :)
+      TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? F("REDUNDANT") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw) {
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6be98e90d4..d59ebe5695 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1095,21 +1095,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
             if (this_hotend) {
               const long e_position = stepper.position(E_AXIS);
               if (e_position > last_e_position) {
                 lpq[lpq_ptr] = e_position - last_e_position;
                 last_e_position = e_position;
               }
               else
                 lpq[lpq_ptr] = 0;
 
               if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-              work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
+              work_pid[ee].Kc = (lpq[lpq_ptr] * planner.mm_per_step[E_AXIS]) * PID_PARAM(Kc, ee);
               pid_output += work_pid[ee].Kc;
             }
           #endif // PID_EXTRUSION_SCALING
           #if ENABLED(PID_FAN_SCALING)
             if (fan_speed[active_extruder] > PID_FAN_SCALING_MIN_SPEED) {
               work_pid[ee].Kf = PID_PARAM(Kf, ee) + (PID_FAN_SCALING_LIN_FACTOR) * fan_speed[active_extruder];
               pid_output += work_pid[ee].Kf;
             }
             //pid_output -= work_pid[ee].Ki;
             //pid_output += work_pid[ee].Ki * work_pid[ee].Kf

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 934f734e9c..6be98e90d4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -387,21 +387,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(fan));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */
     void Temperature::report_fan_speed(const uint8_t fan) {
       if (fan >= FAN_COUNT) return;
       PORT_REDIRECT(SerialMask::All);
-      SERIAL_ECHOLNPAIR("M106 P", fan, " S", fan_speed[fan]);
+      SERIAL_ECHOLNPGM("M106 P", fan, " S", fan_speed[fan]);
     }
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
@@ -669,37 +669,37 @@ volatile bool Temperature::raw_temps_ready = false;
         if (!heating && current_temp < target && ELAPSED(ms, t1 + 5000UL)) {
           heating = true;
           t2 = ms;
           t_low = t2 - t1;
           if (cycles > 0) {
             const long max_pow = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX);
             bias += (d * (t_high - t_low)) / (t_low + t_high);
             LIMIT(bias, 20, max_pow - 20);
             d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
-            SERIAL_ECHOPAIR(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
+            SERIAL_ECHOPGM(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
             if (cycles > 2) {
               const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
                           Tu = float(t_low + t_high) * 0.001f,
                           pf = ischamber ? 0.2f : (isbed ? 0.2f : 0.6f),
                           df = ischamber ? 1.0f / 3.0f : (isbed ? 1.0f / 3.0f : 1.0f / 8.0f);
 
               tune_pid.Kp = Ku * pf;
               tune_pid.Ki = tune_pid.Kp * 2.0f / Tu;
               tune_pid.Kd = tune_pid.Kp * Tu * df;
 
-              SERIAL_ECHOLNPAIR(STR_KU, Ku, STR_TU, Tu);
+              SERIAL_ECHOLNPGM(STR_KU, Ku, STR_TU, Tu);
               if (ischamber || isbed)
                 SERIAL_ECHOLNPGM(" No overshoot");
               else
                 SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
-              SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
+              SERIAL_ECHOLNPGM(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
             }
           }
           SHV((bias + d) >> 1);
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PID_CYCLE), cycles, ncycles));
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
@@ -749,27 +749,27 @@ volatile bool Temperature::raw_temps_ready = false;
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           PGM_P const estring = GHV(PSTR("chamber"), PSTR("bed"), NUL_STR);
-          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
-          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
-          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
+          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
+          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
         #else
-          say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
-          say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
-          say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOLNPGM("Kp ", tune_pid.Kp);
+          say_default_(); SERIAL_ECHOLNPGM("Ki ", tune_pid.Ki);
+          say_default_(); SERIAL_ECHOLNPGM("Kd ", tune_pid.Kd);
         #endif
 
         auto _set_hotend_pid = [](const uint8_t e, const PID_t &in_pid) {
           #if ENABLED(PIDTEMP)
             PID_PARAM(Kp, e) = in_pid.Kp;
             PID_PARAM(Ki, e) = scalePID_i(in_pid.Ki);
             PID_PARAM(Kd, e) = scalePID_d(in_pid.Kd);
             updatePID();
           #else
             UNUSED(e); UNUSED(in_pid);
@@ -989,21 +989,21 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
     #endif
 
     switch (real_heater_id) {
       OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
       OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
       OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
         if (real_heater_id >= 0)
-          SERIAL_ECHOLNPAIR("E", real_heater_id);
+          SERIAL_ECHOLNPGM("E", real_heater_id);
     }
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   watchdog_refresh();
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
@@ -1721,21 +1721,21 @@ void Temperature::manage_heater() {
       #endif
       #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
         { true, 0, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::M305_report(const uint8_t t_index, const bool forReplay/*=true*/) {
     gcode.report_heading_etc(forReplay, PSTR(STR_USER_THERMISTORS));
-    SERIAL_ECHOPAIR("  M305 P", AS_DIGIT(t_index));
+    SERIAL_ECHOPGM("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     SERIAL_ECHOPGM_P(
       TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
@@ -2528,21 +2528,21 @@ void Temperature::init() {
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
         case H_BED:     SERIAL_ECHOPGM("bed"); break;
         case H_CHAMBER: SERIAL_ECHOPGM("chamber"); break;
         default:        SERIAL_ECHO(heater_id);
       }
-      SERIAL_ECHOLNPAIR(
+      SERIAL_ECHOLNPGM(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
     */
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
@@ -2806,33 +2806,33 @@ void Temperature::disable_all_heaters() {
 
     // Handle an error. If there have been more than THERMOCOUPLE_MAX_ERRORS, send an error over serial.
     // Either way, return the TMAX for the thermocouple to trigger a max_temp_error()
     if (max_tc_temp & MAX_TC_ERROR_MASK) {
       max_tc_errors[hindex]++;
 
       if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
         #if HAS_MAX31855
-          SERIAL_ECHOPAIR("MAX31855 Fault: (", max_tc_temp & 0x7, ") >> ");
+          SERIAL_ECHOPGM("MAX31855 Fault: (", max_tc_temp & 0x7, ") >> ");
           if (max_tc_temp & 0x1)
             SERIAL_ECHOLNPGM("Open Circuit");
           else if (max_tc_temp & 0x2)
             SERIAL_ECHOLNPGM("Short to GND");
           else if (max_tc_temp & 0x4)
             SERIAL_ECHOLNPGM("Short to VCC");
         #elif HAS_MAX31865
           const uint8_t fault_31865 = max865ref.readFault();
           max865ref.clearFault();
           if (fault_31865) {
             SERIAL_EOL();
-            SERIAL_ECHOLNPAIR("\nMAX31865 Fault: (", fault_31865, ")  >>");
+            SERIAL_ECHOLNPGM("\nMAX31865 Fault: (", fault_31865, ")  >>");
             if (fault_31865 & MAX31865_FAULT_HIGHTHRESH)
               SERIAL_ECHOLNPGM("RTD High Threshold");
             if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
               SERIAL_ECHOLNPGM("RTD Low Threshold");
             if (fault_31865 & MAX31865_FAULT_REFINLOW)
               SERIAL_ECHOLNPGM("REFIN- > 0.85 x V bias");
             if (fault_31865 & MAX31865_FAULT_REFINHIGH)
               SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
             if (fault_31865 & MAX31865_FAULT_RTDINLOW)
               SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
@@ -3536,21 +3536,21 @@ void Temperature::isr() {
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
       #define SFP 2
     #endif
     SERIAL_CHAR(':');
     SERIAL_PRINT(c, SFP);
     SERIAL_ECHOPGM(" /");
     SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
-      SERIAL_ECHOPAIR(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
+      SERIAL_ECHOPGM(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(H_E0, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
@@ -3569,33 +3569,33 @@ void Temperature::isr() {
     #endif
     #if HAS_TEMP_BOARD
       print_heater_state(H_BOARD, degBoard(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawBoardTemp()));
     #endif
     #if HAS_TEMP_REDUNDANT
       if (include_r) print_heater_state(H_REDUNDANT, degRedundant(), degRedundantTarget() OPTARG(SHOW_TEMP_ADC_VALUES, rawRedundantTemp()));
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
-    SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
+    SERIAL_ECHOPGM(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
-      SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
+      SERIAL_ECHOPGM(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
-      SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
+      SERIAL_ECHOPGM(" C@:", getHeaterPower(H_CHAMBER));
     #endif
     #if HAS_COOLER
-      SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_COOLER));
+      SERIAL_ECHOPGM(" C@:", getHeaterPower(H_COOLER));
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() {
-        SERIAL_ECHOPAIR(" @", e);
+        SERIAL_ECHOPGM(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
     void Temperature::AutoReportTemp::report() { print_heater_states(active_extruder); SERIAL_EOL(); }
   #endif
@@ -3889,21 +3889,21 @@ void Temperature::isr() {
     #endif
     #ifndef MIN_DELTA_SLOPE_TIME_PROBE
       #define MIN_DELTA_SLOPE_TIME_PROBE 600
     #endif
 
     bool Temperature::wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling/*=true*/) {
 
       const bool wants_to_cool = isProbeAboveTemp(target_temp),
                  will_wait = !(wants_to_cool && no_wait_for_cooling);
       if (will_wait)
-        SERIAL_ECHOLNPAIR("Waiting for probe to ", (wants_to_cool ? PSTR("cool down") : PSTR("heat up")), " to ", target_temp, " degrees.");
+        SERIAL_ECHOLNPGM("Waiting for probe to ", (wants_to_cool ? PSTR("cool down") : PSTR("heat up")), " to ", target_temp, " degrees.");
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       float old_temp = 9999;
       millis_t next_temp_ms = 0, next_delta_check_ms = 0;
       wait_for_heatup = true;
       while (will_wait && wait_for_heatup) {
 

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1bb86ed4c7..934f734e9c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -52,20 +52,24 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
+#if HAS_TEMP_SENSOR
+  #include "../gcode/gcode.h"
+#endif
+
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 #define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
 #if HAS_MAX6675 && USE_LIB_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
@@ -1715,27 +1719,23 @@ void Temperature::manage_heater() {
       #if TEMP_SENSOR_BOARD_IS_CUSTOM
         { true, 0, 0, BOARD_PULLUP_RESISTOR_OHMS, BOARD_RESISTANCE_25C_OHMS, 0, 0, BOARD_BETA, 0 },
       #endif
       #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
         { true, 0, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
-  void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
-
-    if (eprom)
-      SERIAL_ECHOPGM("  M305 ");
-    else
-      SERIAL_ECHO_START();
-    SERIAL_CHAR('P', '0' + t_index);
+  void Temperature::M305_report(const uint8_t t_index, const bool forReplay/*=true*/) {
+    gcode.report_heading_etc(forReplay, PSTR(STR_USER_THERMISTORS));
+    SERIAL_ECHOPAIR("  M305 P", AS_DIGIT(t_index));
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     SERIAL_ECHOPGM_P(
       TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
@@ -1787,27 +1787,27 @@ void Temperature::manage_heater() {
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_hotend(const int16_t raw, const uint8_t e) {
-      if (e >= HOTENDS) {
-        SERIAL_ERROR_START();
-        SERIAL_ECHO(e);
-        SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
-        kill();
-        return 0;
-      }
+    if (e >= HOTENDS) {
+      SERIAL_ERROR_START();
+      SERIAL_ECHO(e);
+      SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
+      kill();
+      return 0;
+    }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif TEMP_SENSOR_0_IS_MAX_TC
           #if TEMP_SENSOR_0_IS_MAX31865
             return TERN(LIB_INTERNAL_MAX31865,
               max31865_0.temperature((uint16_t)raw),
               max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
@@ -3483,23 +3483,20 @@ void Temperature::isr() {
   #endif
 
   // Poll endstops state, if required
   endstops.poll();
 
   // Periodically call the planner timer service routine
   planner.isr();
 }
 
 #if HAS_TEMP_SENSOR
-
-  #include "../gcode/gcode.h"
-
   /**
    * Print a single heater state in the form:
    *        Bed: " B:nnn.nn /nnn.nn"
    *    Chamber: " C:nnn.nn /nnn.nn"
    *      Probe: " P:nnn.nn /nnn.nn"
    *     Cooler: " L:nnn.nn /nnn.nn"
    *  Redundant: " R:nnn.nn /nnn.nn"
    *   Extruder: " T0:nnn.nn /nnn.nn"
    *   With ADC: " T0:nnn.nn /nnn.nn (nnn.nn)"
    */

commit 0f61d9e4dd4d4e4f27e5c688ab2c5dbd0f03af84
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Sep 7 02:15:24 2021 -0500

    ‚ú® Ender-3 V2 CrealityUI Enhanced (#21942)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 935de772f4..1bb86ed4c7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -40,20 +40,22 @@
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/e3v2/creality/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "../lcd/e3v2/enhanced/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
@@ -596,44 +598,47 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
+    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(isbed ? PID_BED_START : PID_EXTR_START));
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
+    TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT), "Wait for heat up..."));
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (updateTemperaturesIfReady()) { // temp sample ready
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
@@ -680,32 +685,34 @@ volatile bool Temperature::raw_temps_ready = false;
 
               SERIAL_ECHOLNPAIR(STR_KU, Ku, STR_TU, Tu);
               if (ischamber || isbed)
                 SERIAL_ECHOLNPGM(" No overshoot");
               else
                 SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
               SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
             }
           }
           SHV((bias + d) >> 1);
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PID_CYCLE), cycles, ncycles));
           cycles++;
           minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
+        TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TEMP_TOO_HIGH));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(ischamber ? active_extruder : (isbed ? active_extruder : heater_id));
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
@@ -727,20 +734,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
+        TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_TUNING_TIMEOUT));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           PGM_P const estring = GHV(PSTR("chamber"), PSTR("bed"), NUL_STR);
@@ -780,37 +788,39 @@ volatile bool Temperature::raw_temps_ready = false;
           };
         #endif
 
         // Use the result? (As with "M303 U1")
         if (set_result)
           GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
+        TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       TERN_(HAL_IDLETASK, HAL_idletask());
 
       // Run UI update
-      TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
+      TERN(HAS_DWIN_E3V2_BASIC, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
+    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_PidTuning(PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
@@ -1007,28 +1017,28 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_id_t heater_id) {
-  #if ENABLED(DWIN_CREALITY_LCD) && (HAS_HOTEND || HAS_HEATED_BED)
+  #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(1);
   #endif
   _temp_error(heater_id, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_id_t heater_id) {
-  #if ENABLED(DWIN_CREALITY_LCD) && (HAS_HOTEND || HAS_HEATED_BED)
+  #if HAS_DWIN_E3V2_BASIC && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(0);
   #endif
   _temp_error(heater_id, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
   bool Temperature::pid_debug_flag; // = 0
 #endif
 
 #if HAS_HOTEND
@@ -1322,21 +1332,21 @@ void Temperature::manage_heater() {
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
-            TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
+            TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           }
         }
       #endif
 
     } // HOTEND_LOOP
 
   #endif // HAS_HOTEND
 
   #if HAS_TEMP_REDUNDANT
@@ -1365,21 +1375,21 @@ void Temperature::manage_heater() {
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {              // Time to check the bed?
         if (watch_bed.check(degBed()))          // Increased enough?
           start_watching_bed();                 // If temp reached, turn off elapsed check
         else {
-          TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
+          TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         }
       }
     #endif // WATCH_BED
 
     #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
@@ -2579,21 +2589,21 @@ void Temperature::init() {
         #endif
 
         if (current >= running_temp - hysteresis_degc) {
           timer = millis() + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(millis(), timer)) break;
         state = TRRunaway;
 
       case TRRunaway:
-        TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
+        TERN_(HAS_DWIN_E3V2_BASIC, DWIN_Popup_Temperature(0));
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   // Disable autotemp, unpause and reset everything
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
@@ -3593,21 +3603,21 @@ void Temperature::isr() {
     void Temperature::AutoReportTemp::report() { print_heater_states(active_extruder); SERIAL_EOL(); }
   #endif
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HAS_MULTI_HOTEND
           PSTR("E%c " S_FMT), '1' + e
         #else
-          PSTR("E " S_FMT)
+          PSTR("E1 " S_FMT)
         #endif
         , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
@@ -3713,27 +3723,26 @@ void Temperature::isr() {
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             TERN_(HAS_LCD_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         wait_for_heatup = false;
-        #if ENABLED(DWIN_CREALITY_LCD)
+        #if HAS_DWIN_E3V2_BASIC
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // print timer
           dwin_heat_time = elapsed.value;
-        #else
-          ui.reset_status();
         #endif
+        ui.reset_status();
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
         return true;
       }
 
       return false;
     }
 
     #if ENABLED(WAIT_FOR_HOTEND)
       void Temperature::wait_for_hotend_heating(const uint8_t target_extruder) {
         if (isHeatingHotend(target_extruder)) {

commit 66ded801b734fbb597ab1c1497d347544b3aa05c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Aug 31 15:40:49 2021 +1200

    ‚è™Ô∏è Revert MAX31865 recent changes (#22660)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0475db486c..935de772f4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -56,35 +56,35 @@
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 // MAX TC related macros
 #define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 #define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
-#if HAS_MAX6675 && LIB_USR_MAX6675
+#if HAS_MAX6675 && USE_LIB_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
 
 // LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library.
 // If LIB_MAX31855 is not on the build_flags then raw SPI reads will be used.
-#if HAS_MAX31855 && LIB_USR_MAX31855
+#if HAS_MAX31855 && USE_ADAFRUIT_MAX31855
   #include <Adafruit_MAX31855.h>
   #define HAS_MAX31855_LIBRARY 1
   typedef Adafruit_MAX31855 MAX31855;
 #endif
 
 #if HAS_MAX31865
-  #if LIB_USR_MAX31865
+  #if USE_ADAFRUIT_MAX31865
     #include <Adafruit_MAX31865.h>
     typedef Adafruit_MAX31865 MAX31865;
   #else
     #include "../libs/MAX31865.h"
   #endif
 #endif
 
 #if HAS_MAX6675_LIBRARY || HAS_MAX31855_LIBRARY || HAS_MAX31865
   #define HAS_MAXTC_LIBRARIES 1
 #endif

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 52d0dfb56e..0475db486c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2281,23 +2281,21 @@ void Temperature::init() {
   #if HAS_FAN6
     INIT_FAN_PIN(FAN6_PIN);
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
-  #if HAS_MAXTC_SW_SPI
-    max_tc_spi.init();
-  #endif
+  TERN_(HAS_MAXTC_SW_SPI, max_tc_spi.init());
 
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
@@ -3030,29 +3028,29 @@ void Temperature::isr() {
      */
     if (pwm_count_tmp >= 127) {
       pwm_count_tmp -= 127;
 
       #if HAS_HOTEND
         #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N]);
         REPEAT(HOTENDS, _PWM_MOD_E);
       #endif
 
       #if HAS_HEATED_BED
-        _PWM_MOD(BED,soft_pwm_bed,temp_bed);
+        _PWM_MOD(BED, soft_pwm_bed, temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
-        _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
+        _PWM_MOD(CHAMBER, soft_pwm_chamber, temp_chamber);
       #endif
 
       #if HAS_COOLER
-        _PWM_MOD(COOLER,soft_pwm_cooler,temp_cooler);
+        _PWM_MOD(COOLER, soft_pwm_cooler, temp_cooler);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #define _FAN_PWM(N) do{                                     \
           uint8_t &spcf = soft_pwm_count_fan[N];                    \
           spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
           WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW);               \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);

commit 526b6cdf5b429cf05579bd203a9d72cd057bf0a1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Aug 5 23:24:20 2021 -0500

    üêõ Fix fan index for Singlenozzle, chamber fan
    
    Fixes #22512
    Followup to #19152, #19519

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1e91511f5a..52d0dfb56e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -362,21 +362,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       if (fan != active_extruder) {
         if (fan < EXTRUDERS) singlenozzle_fan_speed[fan] = speed;
         return;
       }
     #endif
 
-    TERN_(SINGLENOZZLE, fan = 0); // Always use fan index 0 with SINGLENOZZLE
+    TERN_(SINGLENOZZLE, if (fan < EXTRUDERS) fan = 0); // Always fan 0 for SINGLENOZZLE E fan
 
     if (fan >= FAN_COUNT) return;
 
     fan_speed[fan] = speed;
     #if REDUNDANT_PART_COOLING_FAN
       if (fan == 0) fan_speed[REDUNDANT_PART_COOLING_FAN] = speed;
     #endif
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(fan));
   }
@@ -1474,21 +1474,21 @@ void Temperature::manage_heater() {
           #elif CHAMBER_FAN_MODE == 1
             fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #elif CHAMBER_FAN_MODE == 3
             fan_chamber_pwm = CHAMBER_FAN_BASE + _MAX((CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target), 0);
           #endif
           NOMORE(fan_chamber_pwm, 225);
-          set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
+          set_fan_speed(CHAMBER_FAN_INDEX, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
           if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {
@@ -1505,21 +1505,21 @@ void Temperature::manage_heater() {
             next_cool_check_ms_2 = 0;
             old_temp = 9999;
           }
           if (flag_chamber_excess_heat && (temp_chamber.target - temp_chamber.celsius >= LOW_EXCESS_HEAT_LIMIT))
             flag_chamber_excess_heat = false;
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
-          set_fan_speed(2, 0);
+          set_fan_speed(CHAMBER_FAN_INDEX, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
           MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
         #endif
       }
     #endif
 
     #if ENABLED(PIDTEMPCHAMBER)
       // PIDTEMPCHAMBER doesn't support a CHAMBER_VENT yet.

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 20b070e712..1e91511f5a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1515,21 +1515,21 @@ void Temperature::manage_heater() {
           set_fan_speed(2, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
           MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
         #endif
       }
     #endif
 
     #if ENABLED(PIDTEMPCHAMBER)
-      // PIDTEMPCHAMBER doens't support a CHAMBER_VENT yet.
+      // PIDTEMPCHAMBER doesn't support a CHAMBER_VENT yet.
       temp_chamber.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
     #else
       if (ELAPSED(ms, next_chamber_check_ms)) {
         next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
         if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
           if (flag_chamber_excess_heat) {
             temp_chamber.soft_pwm_amount = 0;
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);

commit 9bb5b10c0c9cf5a61d2bfb9dfdb6cfe210b6002b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 31 05:32:13 2021 -0500

    üöö Relocate and adjust DWIN E3V2 (#22471)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f8ccc0c067..20b070e712 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -39,21 +39,21 @@
 #if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../lcd/dwin/e3v2/dwin.h"
+  #include "../lcd/e3v2/creality/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 

commit 273ff6fedc4701733464ff33625fba3dbdf1a53c
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jul 18 18:24:27 2021 -0700

    üêõ Ensure Software SPI pins for Max Thermocouple (#22389)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fd2c260fd3..f8ccc0c067 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -100,20 +100,38 @@
 #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && TEMP_SENSOR_0_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
     #define TEMP_SENSOR_0_USES_SW_SPI 1
 #endif
 #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && TEMP_SENSOR_1_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
     #define TEMP_SENSOR_1_USES_SW_SPI 1
 #endif
 
 #if (TEMP_SENSOR_0_USES_SW_SPI || TEMP_SENSOR_1_USES_SW_SPI) && !HAS_MAXTC_LIBRARIES
   #include "../libs/private_spi.h"
   #define HAS_MAXTC_SW_SPI 1
+
+  // Define pins for SPI-based sensors
+  #if TEMP_SENSOR_0_USES_SW_SPI
+    #define SW_SPI_SCK_PIN    TEMP_0_SCK_PIN
+    #define SW_SPI_MISO_PIN   TEMP_0_MISO_PIN
+    #if PIN_EXISTS(TEMP_0_MOSI)
+      #define SW_SPI_MOSI_PIN TEMP_0_MOSI_PIN
+    #endif
+  #else
+    #define SW_SPI_SCK_PIN    TEMP_1_SCK_PIN
+    #define SW_SPI_MISO_PIN   TEMP_1_MISO_PIN
+    #if PIN_EXISTS(TEMP_1_MOSI)
+      #define SW_SPI_MOSI_PIN TEMP_1_MOSI_PIN
+    #endif
+  #endif
+  #ifndef SW_SPI_MOSI_PIN
+    #define SW_SPI_MOSI_PIN   SD_MOSI_PIN
+  #endif
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
@@ -191,21 +209,22 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
 //
 // Initialize MAX TC objects/SPI
 //
 #if HAS_MAX_TC
 
   #if HAS_MAXTC_SW_SPI
     // Initialize SoftSPI for non-lib Software SPI; Libraries take care of it themselves.
     template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin>
       SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
-    SPIclass<TEMP_0_MISO_PIN, TEMP_0_MOSI_PIN, TEMP_0_SCK_PIN> max_tc_spi;
+    SPIclass<SW_SPI_MISO_PIN, SW_SPI_MOSI_PIN, SW_SPI_SCK_PIN> max_tc_spi;
+
   #endif
 
   #define MAXTC_INIT(n, M) \
       MAX##M max##M##_##n = MAX##M( \
         TEMP_##n##_CS_PIN \
         OPTARG(_MAX31865_##n##_SW, TEMP_##n##_MOSI_PIN) \
         OPTARG(TEMP_SENSOR_##n##_USES_SW_SPI, TEMP_##n##_MISO_PIN, TEMP_##n##_SCK_PIN) \
         OPTARG(LARGE_PINMAP, HIGH) \
       )
 

commit 4479b0222bb66dd54f2c60f50a35a9d35f3230dc
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Mon Jul 12 20:57:01 2021 -0700

    üêõ Followup to TEMP_SENSOR_BOARD (#22343, #22344)
    
    Followup to #22279

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4a56ba66e9..fd2c260fd3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -433,21 +433,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if HAS_TEMP_BOARD
   board_info_t Temperature::temp_board; // = { 0 }
   #if ENABLED(THERMAL_PROTECTION_BOARD)
     int16_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
-            Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
+            Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_HI_TEMP;
   #endif
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
@@ -944,21 +944,21 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOPGM_P(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
 
     heater_id_t real_heater_id = heater_id;
 
     #if HAS_TEMP_REDUNDANT
       if (heater_id == H_REDUNDANT) {
         SERIAL_ECHOPGM(STR_REDUNDANT); // print redundant and cascade to print target, too.
-        real_heater_id = (heater_id_t)TEMP_SENSOR_REDUNDANT_TARGET;
+        real_heater_id = (heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET);
       }
     #endif
 
     switch (real_heater_id) {
       OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
       OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
       OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
       OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
       OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
       default:
@@ -1316,21 +1316,21 @@ void Temperature::manage_heater() {
         }
       #endif
 
     } // HOTEND_LOOP
 
   #endif // HAS_HOTEND
 
   #if HAS_TEMP_REDUNDANT
     // Make sure measured temperatures are close together
     if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
-      _temp_error((heater_id_t)TEMP_SENSOR_REDUNDANT_TARGET, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
+      _temp_error((heater_id_t)HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET), PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
   #endif
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
@@ -2008,21 +2008,21 @@ void Temperature::manage_heater() {
  * The watchdog is dependent on this method. If 'raw_temps_ready' stops
  * being set by the interrupt so that this method is not called for over
  * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
 
   watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
   TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
-  TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.raw = READ_MAX_TC(TEMP_SENSOR_REDUNDANT_SOURCE));
+  TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.raw = READ_MAX_TC(HEATER_ID(TEMP_SENSOR_REDUNDANT_SOURCE)));
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.raw));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.raw));
   TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.raw));
@@ -2448,39 +2448,39 @@ void Temperature::init() {
   #if HAS_HEATED_CHAMBER
     while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
     while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
     while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
 
-  #if HAS_TEMP_BOARD
-    while (analog_to_celsius_board(mintemp_raw_BOARD) > BOARD_MINTEMP) mintemp_raw_BOARD += TEMPDIR(BOARD) * (OVERSAMPLENR);
-    while (analog_to_celsius_board(maxtemp_raw_BOARD) < BOARD_MAXTEMP) maxtemp_raw_BOARD -= TEMPDIR(BOARD) * (OVERSAMPLENR);
+  #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
+    while (analog_to_celsius_board(mintemp_raw_BOARD) < BOARD_MINTEMP) mintemp_raw_BOARD += TEMPDIR(BOARD) * (OVERSAMPLENR);
+    while (analog_to_celsius_board(maxtemp_raw_BOARD) > BOARD_MAXTEMP) maxtemp_raw_BOARD -= TEMPDIR(BOARD) * (OVERSAMPLENR);
   #endif
 
   #if HAS_TEMP_REDUNDANT
     temp_redundant.target = &(
       #if REDUNDANT_TEMP_MATCH(TARGET, COOLER) && HAS_TEMP_COOLER
         temp_cooler
       #elif REDUNDANT_TEMP_MATCH(TARGET, PROBE) && HAS_TEMP_PROBE
         temp_probe
       #elif REDUNDANT_TEMP_MATCH(TARGET, BOARD) && HAS_TEMP_BOARD
         temp_board
       #elif REDUNDANT_TEMP_MATCH(TARGET, CHAMBER) && HAS_TEMP_CHAMBER
         temp_chamber
       #elif REDUNDANT_TEMP_MATCH(TARGET, BED) && HAS_TEMP_BED
         temp_bed
       #else
-        temp_hotend[TEMP_SENSOR_REDUNDANT_TARGET]
+        temp_hotend[HEATER_ID(TEMP_SENSOR_REDUNDANT_TARGET)]
       #endif
     );
   #endif
 }
 
 #if HAS_THERMAL_PROTECTION
 
   Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
   /**

commit c0ecc6625ffbe70cf761465ddd5443ac30124cae
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon Jul 12 00:22:08 2021 -0500

    üèóÔ∏è Allow headless Flow Meter (#22234)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0a72b2b467..4a56ba66e9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1601,21 +1601,21 @@ void Temperature::manage_heater() {
       tr_state_machine[RUNAWAY_IND_COOLER].run(temp_cooler.celsius, temp_cooler.target, H_COOLER, THERMAL_PROTECTION_COOLER_PERIOD, THERMAL_PROTECTION_COOLER_HYSTERESIS);
     #endif
 
   #endif // HAS_COOLER
 
   #if ENABLED(LASER_COOLANT_FLOW_METER)
     cooler.flowmeter_task(ms);
     #if ENABLED(FLOWMETER_SAFETY)
       if (cutter.enabled() && cooler.check_flow_too_low()) {
         cutter.disable();
-        ui.flow_fault();
+        TERN_(HAS_DISPLAY, ui.flow_fault());
       }
     #endif
   #endif
 
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 

commit 2f6c8e1176202a014c2a038846cb0403cd2cafe0
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jul 11 18:41:33 2021 -0700

    ‚ú® Add TEMP_SENSOR_BOARD (#22279)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3b3c769866..0a72b2b467 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -51,22 +51,22 @@
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 // MAX TC related macros
-#define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && TEMP_SENSOR_REDUNDANT_SOURCE == (n)))
-#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && TEMP_SENSOR_REDUNDANT_SOURCE == n))
+#define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
+#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && REDUNDANT_TEMP_MATCH(SOURCE, E##n)))
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 // If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
 #if HAS_MAX6675 && LIB_USR_MAX6675
   #include <max6675.h>
   #define HAS_MAX6675_LIBRARY 1
 #endif
 
 // LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library.
 // If LIB_MAX31855 is not on the build_flags then raw SPI reads will be used.
@@ -255,21 +255,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if HAS_TEMP_REDUNDANT
-  redundant_temp_info_t Temperature::temp_redundant;
+  redundant_info_t Temperature::temp_redundant;
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
@@ -429,20 +429,28 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
       cooler_watch_t Temperature::watch_cooler{0};
     #endif
     millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
   #endif
 #endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
+#if HAS_TEMP_BOARD
+  board_info_t Temperature::temp_board; // = { 0 }
+  #if ENABLED(THERMAL_PROTECTION_BOARD)
+    int16_t Temperature::mintemp_raw_BOARD = TEMP_SENSOR_BOARD_RAW_LO_TEMP,
+            Temperature::maxtemp_raw_BOARD = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
+  #endif
+#endif
+
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint16_t Temperature::ADCKey_count = 0;
 #endif
 
@@ -930,28 +938,40 @@ inline void loud_kill(PGM_P const lcd_msg, const heater_id_t heater_id) {
 }
 
 void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOPGM_P(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
-    if (heater_id >= 0)
-      SERIAL_ECHO(heater_id);
-    else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER))
-      SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
-    else if (TERN0(HAS_COOLER, heater_id == H_COOLER))
-      SERIAL_ECHOPGM(STR_COOLER);
-    else
-      SERIAL_ECHOPGM(STR_HEATER_BED);
+
+    heater_id_t real_heater_id = heater_id;
+
+    #if HAS_TEMP_REDUNDANT
+      if (heater_id == H_REDUNDANT) {
+        SERIAL_ECHOPGM(STR_REDUNDANT); // print redundant and cascade to print target, too.
+        real_heater_id = (heater_id_t)TEMP_SENSOR_REDUNDANT_TARGET;
+      }
+    #endif
+
+    switch (real_heater_id) {
+      OPTCODE(HAS_TEMP_COOLER,  case H_COOLER:  SERIAL_ECHOPGM(STR_COOLER);         break)
+      OPTCODE(HAS_TEMP_PROBE,   case H_PROBE:   SERIAL_ECHOPGM(STR_PROBE);          break)
+      OPTCODE(HAS_TEMP_BOARD,   case H_BOARD:   SERIAL_ECHOPGM(STR_MOTHERBOARD);    break)
+      OPTCODE(HAS_TEMP_CHAMBER, case H_CHAMBER: SERIAL_ECHOPGM(STR_HEATER_CHAMBER); break)
+      OPTCODE(HAS_TEMP_BED,     case H_BED:     SERIAL_ECHOPGM(STR_HEATER_BED);     break)
+      default:
+        if (real_heater_id >= 0)
+          SERIAL_ECHOLNPAIR("E", real_heater_id);
+    }
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   watchdog_refresh();
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
@@ -1656,20 +1676,23 @@ void Temperature::manage_heater() {
       #endif
       #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 },
       #endif
       #if TEMP_SENSOR_COOLER_IS_CUSTOM
         { true, 0, 0, COOLER_PULLUP_RESISTOR_OHMS, COOLER_RESISTANCE_25C_OHMS, 0, 0, COOLER_BETA, 0 },
       #endif
       #if TEMP_SENSOR_PROBE_IS_CUSTOM
         { true, 0, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 },
       #endif
+      #if TEMP_SENSOR_BOARD_IS_CUSTOM
+        { true, 0, 0, BOARD_PULLUP_RESISTOR_OHMS, BOARD_RESISTANCE_25C_OHMS, 0, 0, BOARD_BETA, 0 },
+      #endif
       #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
         { true, 0, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
@@ -1691,20 +1714,21 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
       TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
       TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
       TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
       TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
+      TERN_(TEMP_SENSOR_BOARD_IS_CUSTOM, t_index == CTI_BOARD ? PSTR("BOARD") :)
       TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? PSTR("REDUNDANT") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw) {
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
@@ -1926,28 +1950,46 @@ void Temperature::manage_heater() {
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
+#if HAS_TEMP_BOARD
+  // For motherboard temperature measurement.
+  celsius_float_t Temperature::analog_to_celsius_board(const int16_t raw) {
+    #if TEMP_SENSOR_BOARD_IS_CUSTOM
+      return user_thermistor_to_deg_c(CTI_BOARD, raw);
+    #elif TEMP_SENSOR_BOARD_IS_THERMISTOR
+      SCAN_THERMISTOR_TABLE(TEMPTABLE_BOARD, TEMPTABLE_BOARD_LEN);
+    #elif TEMP_SENSOR_BOARD_IS_AD595
+      return TEMP_AD595(raw);
+    #elif TEMP_SENSOR_BOARD_IS_AD8495
+      return TEMP_AD8495(raw);
+    #else
+      UNUSED(raw);
+      return 0;
+    #endif
+  }
+#endif // HAS_TEMP_BOARD
+
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_redundant(const int16_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
-    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && TEMP_SENSOR_REDUNDANT_SOURCE == 0
+    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && REDUNDANT_TEMP_MATCH(SOURCE, E0)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature((uint16_t)raw), raw * 0.25);
-    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && TEMP_SENSOR_REDUNDANT_SOURCE == 1
+    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && REDUNDANT_TEMP_MATCH(SOURCE, E1)
       return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature((uint16_t)raw), raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
@@ -1976,20 +2018,21 @@ void Temperature::updateTemperaturesFromRawValues() {
   TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.raw = READ_MAX_TC(TEMP_SENSOR_REDUNDANT_SOURCE));
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.raw));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.raw));
+  TERN_(HAS_TEMP_BOARD,     temp_board.celsius     = analog_to_celsius_board(temp_board.raw));
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.raw));
 
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
   #if HAS_HOTEND
     static constexpr int8_t temp_dir[] = {
       #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         0
       #else
@@ -2023,37 +2066,42 @@ void Temperature::updateTemperaturesFromRawValues() {
         }
         #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
           else
             consecutive_low_temperature_error[e] = 0;
         #endif
       }
     }
 
   #endif // HAS_HOTEND
 
+  #define TP_CMP(S,A,B) (TEMPDIR(S) < 0 ? ((A)<(B)) : ((A)>(B)))
   #if ENABLED(THERMAL_PROTECTION_BED)
-    #define BEDCMP(A,B) (TEMPDIR(BED) < 0 ? ((A)<(B)) : ((A)>(B)))
-    if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
-    if (temp_bed.target > 0 && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
+    if (TP_CMP(BED, temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
+    if (temp_bed.target > 0 && TP_CMP(BED, mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
   #endif
 
   #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
-    #define CHAMBERCMP(A,B) (TEMPDIR(CHAMBER) < 0 ? ((A)<(B)) : ((A)>(B)))
-    if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
-    if (temp_chamber.target > 0 && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
+    if (TP_CMP(CHAMBER, temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
+    if (temp_chamber.target > 0 && TP_CMP(CHAMBER, mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
   #endif
 
   #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
-    #define COOLERCMP(A,B) (TEMPDIR(COOLER) < 0 ? ((A)<(B)) : ((A)>(B)))
-    if (cutter.unitPower > 0 && COOLERCMP(temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
-    if (COOLERCMP(mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
+    if (cutter.unitPower > 0 && TP_CMP(COOLER, temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
+    if (TP_CMP(COOLER, mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
+  #endif
+
+  #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
+    if (TP_CMP(BOARD, temp_board.raw, maxtemp_raw_BOARD)) max_temp_error(H_BOARD);
+    if (TP_CMP(BOARD, mintemp_raw_BOARD, temp_board.raw)) min_temp_error(H_BOARD);
   #endif
+  #undef TP_CMP
+
 } // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to manage_heater()
  *
  *  - Init (and disable) SPI thermocouples like MAX6675 and MAX31865
  *  - Disable RUMBA JTAG to accommodate a thermocouple extension
  *  - Read-enable thermistors with a read-enable pin
@@ -2268,20 +2316,23 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if HAS_TEMP_ADC_COOLER
     HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
   #endif
   #if HAS_TEMP_ADC_PROBE
     HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
+  #if HAS_TEMP_ADC_BOARD
+    HAL_ANALOG_SELECT(TEMP_BOARD_PIN);
+  #endif
   #if HAS_TEMP_ADC_REDUNDANT
     HAL_ANALOG_SELECT(TEMP_REDUNDANT_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
@@ -2381,44 +2432,52 @@ void Temperature::init() {
       _TEMP_MAX_E(6);
     #endif
     #if _MINMAX_TEST(7, MIN)
       _TEMP_MIN_E(7);
     #endif
     #if _MINMAX_TEST(7, MAX)
       _TEMP_MAX_E(7);
     #endif
   #endif // HAS_HOTEND
 
+  // TODO: combine these into the macros above
   #if HAS_HEATED_BED
     while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
   #endif
 
   #if HAS_HEATED_CHAMBER
     while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
     while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
     while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
 
+  #if HAS_TEMP_BOARD
+    while (analog_to_celsius_board(mintemp_raw_BOARD) > BOARD_MINTEMP) mintemp_raw_BOARD += TEMPDIR(BOARD) * (OVERSAMPLENR);
+    while (analog_to_celsius_board(maxtemp_raw_BOARD) < BOARD_MAXTEMP) maxtemp_raw_BOARD -= TEMPDIR(BOARD) * (OVERSAMPLENR);
+  #endif
+
   #if HAS_TEMP_REDUNDANT
     temp_redundant.target = &(
-      #if TEMP_SENSOR_REDUNDANT_TARGET == -5 && HAS_TEMP_COOLER
+      #if REDUNDANT_TEMP_MATCH(TARGET, COOLER) && HAS_TEMP_COOLER
         temp_cooler
-      #elif TEMP_SENSOR_REDUNDANT_TARGET == -4 && HAS_TEMP_PROBE
+      #elif REDUNDANT_TEMP_MATCH(TARGET, PROBE) && HAS_TEMP_PROBE
         temp_probe
-      #elif TEMP_SENSOR_REDUNDANT_TARGET == -2 && HAS_TEMP_CHAMBER
+      #elif REDUNDANT_TEMP_MATCH(TARGET, BOARD) && HAS_TEMP_BOARD
+        temp_board
+      #elif REDUNDANT_TEMP_MATCH(TARGET, CHAMBER) && HAS_TEMP_CHAMBER
         temp_chamber
-      #elif TEMP_SENSOR_REDUNDANT_TARGET == -1 && HAS_TEMP_BED
+      #elif REDUNDANT_TEMP_MATCH(TARGET, BED) && HAS_TEMP_BED
         temp_bed
       #else
         temp_hotend[TEMP_SENSOR_REDUNDANT_TARGET]
       #endif
     );
   #endif
 }
 
 #if HAS_THERMAL_PROTECTION
 
@@ -2780,20 +2839,21 @@ void Temperature::disable_all_heaters() {
 #endif // HAS_MAX_TC
 
 /**
  * Update raw temperatures
  *
  * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
  * Applies all the accumulators to the current raw temperatures.
  */
 void Temperature::update_raw_temperatures() {
 
+  // TODO: can this be collapsed into a HOTEND_LOOP()?
   #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_0_IS_MAX_TC
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1 && !TEMP_SENSOR_1_IS_MAX_TC
     temp_hotend[1].update();
   #endif
 
   #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_REDUNDANT_IS_MAX_TC
     temp_redundant.update();
@@ -2801,20 +2861,21 @@ void Temperature::update_raw_temperatures() {
 
   TERN_(HAS_TEMP_ADC_2,       temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED,     temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
   TERN_(HAS_TEMP_ADC_PROBE,   temp_probe.update());
+  TERN_(HAS_TEMP_ADC_BOARD,   temp_board.update());
   TERN_(HAS_TEMP_ADC_COOLER,  temp_cooler.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 }
 
 /**
  * Called by the Temperature ISR when all the ADCs have been processed.
  * Reset all the ADC accumulators for another round of updates.
@@ -2827,24 +2888,25 @@ void Temperature::readings_ready() {
     raw_temps_ready = true;
   }
 
   // Filament Sensor - can be read any time since IIR filtering is used
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.reading_ready());
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
   #endif
 
-  TERN_(HAS_HEATED_BED, temp_bed.reset());
-  TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
-  TERN_(HAS_TEMP_PROBE, temp_probe.reset());
-  TERN_(HAS_TEMP_COOLER, temp_cooler.reset());
+  TERN_(HAS_HEATED_BED,     temp_bed.reset());
+  TERN_(HAS_TEMP_CHAMBER,   temp_chamber.reset());
+  TERN_(HAS_TEMP_PROBE,     temp_probe.reset());
+  TERN_(HAS_TEMP_COOLER,    temp_cooler.reset());
+  TERN_(HAS_TEMP_BOARD,     temp_board.reset());
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
@@ -3257,20 +3319,25 @@ void Temperature::isr() {
     #if HAS_TEMP_ADC_COOLER
       case PrepareTemp_COOLER: HAL_START_ADC(TEMP_COOLER_PIN); break;
       case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
     #endif
 
     #if HAS_TEMP_ADC_PROBE
       case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
+    #if HAS_TEMP_ADC_BOARD
+      case PrepareTemp_BOARD: HAL_START_ADC(TEMP_BOARD_PIN); break;
+      case MeasureTemp_BOARD: ACCUMULATE_ADC(temp_board); break;
+    #endif
+
     #if HAS_TEMP_ADC_REDUNDANT
       case PrepareTemp_REDUNDANT: HAL_START_ADC(TEMP_REDUNDANT_PIN); break;
       case MeasureTemp_REDUNDANT: ACCUMULATE_ADC(temp_redundant); break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
@@ -3423,20 +3490,23 @@ void Temperature::isr() {
       #endif
       #if HAS_TEMP_CHAMBER
         case H_CHAMBER: k = 'C'; break;
       #endif
       #if HAS_TEMP_PROBE
         case H_PROBE: k = 'P'; break;
       #endif
       #if HAS_TEMP_COOLER
         case H_COOLER: k = 'L'; break;
       #endif
+      #if HAS_TEMP_BOARD
+        case H_BOARD: k = 'M'; break;
+      #endif
       #if HAS_TEMP_REDUNDANT
         case H_REDUNDANT: k = 'R'; break;
       #endif
     }
     SERIAL_CHAR(' ', k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
@@ -3452,33 +3522,36 @@ void Temperature::isr() {
       SERIAL_ECHOPAIR(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
-      print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
+      print_heater_state(H_E0, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
     #endif
     #if HAS_HEATED_BED
       print_heater_state(H_BED, degBed(), degTargetBed() OPTARG(SHOW_TEMP_ADC_VALUES, rawBedTemp()));
     #endif
     #if HAS_TEMP_CHAMBER
       print_heater_state(H_CHAMBER, degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber()) OPTARG(SHOW_TEMP_ADC_VALUES, rawChamberTemp()));
     #endif
     #if HAS_TEMP_COOLER
       print_heater_state(H_COOLER, degCooler(), TERN0(HAS_COOLER, degTargetCooler()) OPTARG(SHOW_TEMP_ADC_VALUES, rawCoolerTemp()));
     #endif
     #if HAS_TEMP_PROBE
-      print_heater_state(H_PROBE, degProbe(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawProbeTemp()) );
+      print_heater_state(H_PROBE, degProbe(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawProbeTemp()));
+    #endif
+    #if HAS_TEMP_BOARD
+      print_heater_state(H_BOARD, degBoard(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawBoardTemp()));
     #endif
     #if HAS_TEMP_REDUNDANT
       if (include_r) print_heater_state(H_REDUNDANT, degRedundant(), degRedundantTarget() OPTARG(SHOW_TEMP_ADC_VALUES, rawRedundantTemp()));
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));

commit 79405ce2afd2a3d36ecb70274ec7a5355a7765c8
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Thu Jul 8 21:48:11 2021 -0700

    üêõ Fix manage_heaters recursion on servo move (#22313)
    
    Followup to e297748b22

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 83187259ff..3b3c769866 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1229,20 +1229,24 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
   if (marlin_state == MF_INITIALIZING) return watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
 
+  static bool no_reentry = false;  // Prevent recursion
+  if (no_reentry) return;
+  REMEMBER(mh, no_reentry, true);
+
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready

commit b2f0913083d83bd3fd9af1c603d1f4cc1afb64eb
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Tue Jul 6 17:36:41 2021 -0700

    üêõ Redundant Temp Sensor followup (#22196)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9f32ce933b..83187259ff 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -27,20 +27,21 @@
 // Useful when debugging thermocouples
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 #include "../lcd/marlinui.h"
 
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
+#include "printcounter.h"
 
 #if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
@@ -49,138 +50,80 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
-#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && ENABLED(TEMP_SENSOR_REDUNDANT_SOURCE) && TEMP_SENSOR_REDUNDANT_SOURCE == n))
+// MAX TC related macros
+#define TEMP_SENSOR_IS_MAX(n, M) (ENABLED(TEMP_SENSOR_##n##_IS_MAX##M) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX##M) && TEMP_SENSOR_REDUNDANT_SOURCE == (n)))
+#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && TEMP_SENSOR_REDUNDANT_SOURCE == n))
 
-// LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library
-#if LIB_USR_MAX31855
+// LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
+// If LIB_MAX6675 is not on the build_flags then raw SPI reads will be used.
+#if HAS_MAX6675 && LIB_USR_MAX6675
+  #include <max6675.h>
+  #define HAS_MAX6675_LIBRARY 1
+#endif
+
+// LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library.
+// If LIB_MAX31855 is not on the build_flags then raw SPI reads will be used.
+#if HAS_MAX31855 && LIB_USR_MAX31855
   #include <Adafruit_MAX31855.h>
-  #if PIN_EXISTS(MAX31855_MISO) && PIN_EXISTS(MAX31855_SCK)
-    #define MAX31855_USES_SW_SPI 1
-  #endif
-  #if TEMP_SENSOR_IS_MAX(0, MAX31855) && PIN_EXISTS(MAX31855_CS)
-    #define HAS_MAX31855_TEMP 1
-    Adafruit_MAX31855 max31855_0 = Adafruit_MAX31855(MAX31855_CS_PIN
-      #if MAX31855_USES_SW_SPI
-        , MAX31855_MISO_PIN, MAX31855_SCK_PIN  // For software SPI also set MISO/SCK
-      #endif
-      #if ENABLED(LARGE_PINMAP)
-        , HIGH
-      #endif
-    );
-  #endif
-  #if TEMP_SENSOR_IS_MAX(1, MAX31855) && PIN_EXISTS(MAX31855_CS2)
-    #define HAS_MAX31855_TEMP 1
-    Adafruit_MAX31855 max31855_1 = Adafruit_MAX31855(MAX31855_CS2_PIN
-      #if MAX31855_USES_SW_SPI
-        , MAX31855_MISO_PIN, MAX31855_SCK_PIN  // For software SPI also set MISO/SCK
-      #endif
-      #if ENABLED(LARGE_PINMAP)
-        , HIGH
-      #endif
-    );
-  #endif
+  #define HAS_MAX31855_LIBRARY 1
+  typedef Adafruit_MAX31855 MAX31855;
 #endif
 
-// LIB_MAX31865 can be added to the build_flags in platformio.ini to use a user-defined library.
-// If LIB_MAX31865 is not on the build_flags then the Adafruit MAX31865 V1.1.0 library is used.
 #if HAS_MAX31865
-  #include <Adafruit_MAX31865.h>
-  #ifndef MAX31865_MOSI_PIN
-    #define MAX31865_MOSI_PIN SD_MOSI_PIN
-  #endif
-  #if PIN_EXISTS(MAX31865_MISO) && PIN_EXISTS(MAX31865_SCK)
-    #define MAX31865_USES_SW_SPI 1
-  #endif
-  #if TEMP_SENSOR_IS_MAX(0, MAX31865) && PIN_EXISTS(MAX31865_CS)
-    #define HAS_MAX31865_TEMP 1
-      Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
-        #if MAX31865_USES_SW_SPI && PIN_EXISTS(MAX31865_MOSI)
-          , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN  // For software SPI also set MOSI/MISO/SCK
-        #endif
-        #if ENABLED(LARGE_PINMAP)
-          , HIGH
-        #endif
-      );
-  #endif
-  #if TEMP_SENSOR_IS_MAX(1, MAX31865) && PIN_EXISTS(MAX31865_CS2)
-    #define HAS_MAX31865_TEMP 1
-    Adafruit_MAX31865 max31865_1 = Adafruit_MAX31865(MAX31865_CS2_PIN
-      #if MAX31865_USES_SW_SPI && PIN_EXISTS(MAX31865_MOSI)
-        , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN  // For software SPI also set MOSI/MISO/SCK
-      #endif
-      #if ENABLED(LARGE_PINMAP)
-        , HIGH
-      #endif
-    );
+  #if LIB_USR_MAX31865
+    #include <Adafruit_MAX31865.h>
+    typedef Adafruit_MAX31865 MAX31865;
+  #else
+    #include "../libs/MAX31865.h"
   #endif
 #endif
 
-// LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
-#if LIB_USR_MAX6675
-  #include <max6675.h>
-  #if PIN_EXISTS(MAX6675_MISO) && PIN_EXISTS(MAX6675_SCK)
-    #define MAX6675_USES_SW_SPI 1
-  #endif
-  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX6675_CS)
-    #define HAS_MAX6675_TEMP 1
-    MAX6675 max6675_0 = MAX6675(MAX6675_CS_PIN
-      #if MAX6675_USES_SW_SPI
-        , MAX6675_MISO_PIN, MAX6675_SCK_PIN   // For software SPI also set MISO/SCK
-      #endif
-      #if ENABLED(LARGE_PINMAP)
-        , HIGH
-      #endif
-    );
-  #endif
-  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX6675_CS2)
-    #define HAS_MAX6675_TEMP 1
-    MAX6675 max6675_1 = MAX6675(MAX6675_CS2_PIN
-      #if MAX6675_USES_SW_SPI
-        , MAX6675_MISO_PIN, MAX6675_SCK_PIN   // For software SPI also set MISO/SCK
-      #endif
-      #if ENABLED(LARGE_PINMAP)
-        , HIGH
-      #endif
-    );
-  #endif
+#if HAS_MAX6675_LIBRARY || HAS_MAX31855_LIBRARY || HAS_MAX31865
+  #define HAS_MAXTC_LIBRARIES 1
 #endif
 
-#if !HAS_MAX6675_TEMP && !HAS_MAX31855_TEMP && !HAS_MAX31865_TEMP
-  #define NO_THERMO_TEMPS 1
+// If we have a MAX TC with SCK and MISO pins defined, it's either on a separate/dedicated Hardware
+// SPI bus, or some pins for Software SPI. Alternate Hardware SPI buses are not supported yet, so
+// your SPI options are:
+//
+//  1. Only CS pin(s) defined:                  Hardware SPI on the default bus (usually the SD card SPI).
+//  2. CS, MISO, and SCK pins defined:          Software SPI on a separate bus, as defined by MISO, SCK.
+//  3. CS, MISO, and SCK pins w/ FORCE_HW_SPI:  Hardware SPI on the default bus, ignoring MISO, SCK.
+//
+#if TEMP_SENSOR_IS_ANY_MAX_TC(0) && TEMP_SENSOR_0_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
+    #define TEMP_SENSOR_0_USES_SW_SPI 1
 #endif
-
-#if (TEMP_SENSOR_0_IS_MAX_TC || TEMP_SENSOR_1_IS_MAX_TC || TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && PINS_EXIST(MAX6675_SCK, MAX6675_DO) && NO_THERMO_TEMPS
-  #define THERMO_SEPARATE_SPI 1
+#if TEMP_SENSOR_IS_ANY_MAX_TC(1) && TEMP_SENSOR_1_HAS_SPI_PINS && DISABLED(TEMP_SENSOR_FORCE_HW_SPI)
+    #define TEMP_SENSOR_1_USES_SW_SPI 1
 #endif
 
-#if THERMO_SEPARATE_SPI
+#if (TEMP_SENSOR_0_USES_SW_SPI || TEMP_SENSOR_1_USES_SW_SPI) && !HAS_MAXTC_LIBRARIES
   #include "../libs/private_spi.h"
+  #define HAS_MAXTC_SW_SPI 1
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
-#include "printcounter.h"
-
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/e_parser.h"
@@ -239,21 +182,81 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   #define _CHAMBER_PSTR(h)
 #endif
 #if HAS_COOLER
   #define _COOLER_PSTR(h) (h) == H_COOLER ? GET_TEXT(MSG_COOLER) :
 #else
   #define _COOLER_PSTR(h)
 #endif
 #define _E_PSTR(h,N) ((HOTENDS) > N && (h) == N) ? PSTR(LCD_STR_E##N) :
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
-// public:
+//
+// Initialize MAX TC objects/SPI
+//
+#if HAS_MAX_TC
+
+  #if HAS_MAXTC_SW_SPI
+    // Initialize SoftSPI for non-lib Software SPI; Libraries take care of it themselves.
+    template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin>
+      SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
+    SPIclass<TEMP_0_MISO_PIN, TEMP_0_MOSI_PIN, TEMP_0_SCK_PIN> max_tc_spi;
+  #endif
+
+  #define MAXTC_INIT(n, M) \
+      MAX##M max##M##_##n = MAX##M( \
+        TEMP_##n##_CS_PIN \
+        OPTARG(_MAX31865_##n##_SW, TEMP_##n##_MOSI_PIN) \
+        OPTARG(TEMP_SENSOR_##n##_USES_SW_SPI, TEMP_##n##_MISO_PIN, TEMP_##n##_SCK_PIN) \
+        OPTARG(LARGE_PINMAP, HIGH) \
+      )
+
+  #if HAS_MAX6675_LIBRARY
+    #if TEMP_SENSOR_IS_MAX(0, 6675)
+      MAXTC_INIT(0, 6675);
+    #endif
+    #if TEMP_SENSOR_IS_MAX(1, 6675)
+      MAXTC_INIT(1, 6675);
+    #endif
+  #endif
+
+  #if HAS_MAX31855_LIBRARY
+    #if TEMP_SENSOR_IS_MAX(0, 31855)
+      MAXTC_INIT(0, 31855);
+    #endif
+    #if TEMP_SENSOR_IS_MAX(1, 31855)
+      MAXTC_INIT(1, 31855);
+    #endif
+  #endif
+
+  // MAX31865 always uses a library, unlike '55 & 6675
+  #if HAS_MAX31865
+    #define _MAX31865_0_SW TEMP_SENSOR_0_USES_SW_SPI
+    #define _MAX31865_1_SW TEMP_SENSOR_1_USES_SW_SPI
+
+    #if TEMP_SENSOR_IS_MAX(0, 31865)
+      MAXTC_INIT(0, 31865);
+    #endif
+    #if TEMP_SENSOR_IS_MAX(1, 31865)
+      MAXTC_INIT(1, 31865);
+    #endif
+
+    #undef _MAX31865_0_SW
+    #undef _MAX31865_1_SW
+  #endif
+
+  #undef MAXTC_INIT
+
+#endif
+
+/**
+ * public:
+ */
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
   #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
@@ -267,20 +270,39 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed; // = 0
 #endif
 
+// Init fans according to whether they're native PWM or Software PWM
+#ifdef BOARD_OPENDRAIN_MOSFETS
+  #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
+#else
+  #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
+#endif
+#if ENABLED(FAN_SOFT_PWM)
+  #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
+#else
+  #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
+#endif
+#if ENABLED(FAST_PWM_FAN)
+  #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
+#else
+  #define SET_FAST_PWM_FREQ(P) NOOP
+#endif
+#define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
+
+// HAS_FAN does not include CONTROLLER_FAN
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
 
     Temperature::extra_fan_t Temperature::extra_fan_speed[FAN_COUNT];
 
     /**
      * Handle the M106 P<fan> T<speed> command:
@@ -412,21 +434,32 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
-// private:
+#if HAS_ADC_BUTTONS
+  uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
+  uint16_t Temperature::ADCKey_count = 0;
+#endif
+
+#if ENABLED(PID_EXTRUSION_SCALING)
+  int16_t Temperature::lpq_len; // Initialized in settings.cpp
+#endif
+
+/**
+ * private:
+ */
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 
@@ -465,30 +498,24 @@ volatile bool Temperature::raw_temps_ready = false;
   celsius_t Temperature::singlenozzle_temp[EXTRUDERS];
 #endif
 #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
   uint8_t Temperature::singlenozzle_fan_speed[EXTRUDERS];
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused_for_probing;
 #endif
 
-// public:
-
-#if HAS_ADC_BUTTONS
-  uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
-  uint16_t Temperature::ADCKey_count = 0;
-#endif
-
-#if ENABLED(PID_EXTRUSION_SCALING)
-  int16_t Temperature::lpq_len; // Initialized in settings.cpp
-#endif
+/**
+ * public:
+ * Class and Instance Methods
+ */
 
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
@@ -751,43 +778,49 @@ volatile bool Temperature::raw_temps_ready = false;
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
-/**
- * Class and Instance Methods
- */
-
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     #if HAS_COOLER
       case H_COOLER: return temp_cooler.soft_pwm_amount;
     #endif
     default:
       return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
+  #if EXTRUDER_AUTO_FAN_SPEED != 255
+    #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
+  #else
+    #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
+  #endif
+  #if CHAMBER_AUTO_FAN_SPEED != 255
+    #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
+  #else
+    #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
+  #endif
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
     #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HAS_MULTI_HOTEND
         #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
         RREPEAT_S(1, HOTENDS, _NEXT_FAN)
@@ -1661,25 +1694,20 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
       TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? PSTR("REDUNDANT") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw) {
-    //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
-    //  static uint32_t clocks_total = 0;
-    //  static uint32_t calls = 0;
-    //  uint32_t tcnt5 = TCNT5;
-    //#endif
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
       t.pre_calc     = false;
       t.res_25_recip = 1.0f / t.res_25;
       t.res_25_log   = logf(t.res_25);
       t.beta_recip   = 1.0f / t.beta;
       t.sh_alpha     = RECIPROCAL(THERMISTOR_RESISTANCE_NOMINAL_C - (THERMISTOR_ABS_ZERO_C))
@@ -1693,28 +1721,20 @@ void Temperature::manage_heater() {
     const float adc_inverse = (adc_max - adc_raw) - 0.5f,
                 resistance = t.series_res * (adc_raw + 0.5f) / adc_inverse,
                 log_resistance = logf(resistance);
 
     float value = t.sh_alpha;
     value += log_resistance * t.beta_recip;
     if (t.sh_c_coeff != 0)
       value += t.sh_c_coeff * cu(log_resistance);
     value = 1.0f / value;
 
-    //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
-    //  int32_t clocks = TCNT5 - tcnt5;
-    //  if (clocks >= 0) {
-    //    clocks_total += clocks;
-    //    calls++;
-    //  }
-    //#endif
-
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_hotend(const int16_t raw, const uint8_t e) {
       if (e >= HOTENDS) {
@@ -1723,33 +1743,47 @@ void Temperature::manage_heater() {
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif TEMP_SENSOR_0_IS_MAX_TC
-          return TERN(TEMP_SENSOR_0_IS_MAX31865, max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0), raw * 0.25);
+          #if TEMP_SENSOR_0_IS_MAX31865
+            return TERN(LIB_INTERNAL_MAX31865,
+              max31865_0.temperature((uint16_t)raw),
+              max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
+            );
+          #else
+            return raw * 0.25;
+          #endif
         #elif TEMP_SENSOR_0_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_0_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
         #if TEMP_SENSOR_1_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
         #elif TEMP_SENSOR_1_IS_MAX_TC
-          return TERN(TEMP_SENSOR_1_IS_MAX31865, max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1), raw * 0.25);
+          #if TEMP_SENSOR_0_IS_MAX31865
+            return TERN(LIB_INTERNAL_MAX31865,
+              max31865_1.temperature((uint16_t)raw),
+              max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1)
+            );
+          #else
+            return raw * 0.25;
+          #endif
         #elif TEMP_SENSOR_1_IS_AD595
           return TEMP_AD595(raw);
         #elif TEMP_SENSOR_1_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
         #if TEMP_SENSOR_2_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
@@ -1894,23 +1928,23 @@ void Temperature::manage_heater() {
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
 #if HAS_TEMP_REDUNDANT
   // For redundant temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_redundant(const int16_t raw) {
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && TEMP_SENSOR_REDUNDANT_SOURCE == 0
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0), raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature((uint16_t)raw), raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && TEMP_SENSOR_REDUNDANT_SOURCE == 1
-      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1), raw * 0.25);
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature((uint16_t)raw), raw * 0.25);
     #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
@@ -1929,20 +1963,21 @@ void Temperature::manage_heater() {
  * being set by the interrupt so that this method is not called for over
  * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
 
   watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
   TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
   TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.raw = READ_MAX_TC(TEMP_SENSOR_REDUNDANT_SOURCE));
+
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
 
   TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.raw));
   TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.raw));
   TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.raw));
 
@@ -2001,54 +2036,21 @@ void Temperature::updateTemperaturesFromRawValues() {
     #define CHAMBERCMP(A,B) (TEMPDIR(CHAMBER) < 0 ? ((A)<(B)) : ((A)>(B)))
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
     if (temp_chamber.target > 0 && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
   #endif
 
   #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
     #define COOLERCMP(A,B) (TEMPDIR(COOLER) < 0 ? ((A)<(B)) : ((A)>(B)))
     if (cutter.unitPower > 0 && COOLERCMP(temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
     if (COOLERCMP(mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
   #endif
-}
-
-#if THERMO_SEPARATE_SPI
-  template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin> SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
-  SPIclass<MAX6675_DO_PIN, SD_MOSI_PIN, MAX6675_SCK_PIN> max_tc_spi;
-#endif
-
-// Init fans according to whether they're native PWM or Software PWM
-#ifdef BOARD_OPENDRAIN_MOSFETS
-  #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
-#else
-  #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
-#endif
-#if ENABLED(FAN_SOFT_PWM)
-  #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
-#else
-  #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
-#endif
-#if ENABLED(FAST_PWM_FAN)
-  #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
-#else
-  #define SET_FAST_PWM_FREQ(P) NOOP
-#endif
-#define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
-#if EXTRUDER_AUTO_FAN_SPEED != 255
-  #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
-#else
-  #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
-#endif
-#if CHAMBER_AUTO_FAN_SPEED != 255
-  #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
-#else
-  #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
-#endif
+} // Temperature::updateTemperaturesFromRawValues
 
 /**
  * Initialize the temperature manager
  *
  * The manager is implemented by periodic calls to manage_heater()
  *
  *  - Init (and disable) SPI thermocouples like MAX6675 and MAX31865
  *  - Disable RUMBA JTAG to accommodate a thermocouple extension
  *  - Read-enable thermistors with a read-enable pin
  *  - Init HEATER and COOLER pins for OUTPUT in OFF state
@@ -2063,64 +2065,61 @@ void Temperature::updateTemperaturesFromRawValues() {
  */
 void Temperature::init() {
 
   TERN_(PROBING_HEATERS_OFF, paused_for_probing = false);
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   // Init (and disable) SPI thermocouples
-  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX6675_CS)
-    OUT_WRITE(MAX6675_CS_PIN, HIGH);
-  #endif
-  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX6675_CS2)
-    OUT_WRITE(MAX6675_CS2_PIN, HIGH);
-  #endif
-  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX31855_CS)
-    OUT_WRITE(MAX31855_CS_PIN, HIGH);
-  #endif
-  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX31855_CS2)
-    OUT_WRITE(MAX31855_CS2_PIN, HIGH);
-  #endif
-  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX31865_CS)
-    OUT_WRITE(MAX31865_CS_PIN, HIGH);
-  #endif
-  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX31865_CS2)
-    OUT_WRITE(MAX31865_CS2_PIN, HIGH);
-  #endif
-
-  #if HAS_MAX31865_TEMP
-    #if TEMP_SENSOR_IS_MAX(0, MAX31865)
-      max31865_0.begin(MAX31865_2WIRE); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-    #endif
-    #if TEMP_SENSOR_IS_MAX(1, MAX31865)
-      max31865_1.begin(MAX31865_2WIRE);
-    #endif
-  #endif
-
-  #if HAS_MAX31855_TEMP
-    #if TEMP_SENSOR_IS_MAX(0, MAX31855)
-      max31855_0.begin(MAX31855);
-    #endif
-    #if TEMP_SENSOR_IS_MAX(1, MAX31855)
-      max31855_1.begin(MAX31855);
+  #if TEMP_SENSOR_IS_ANY_MAX_TC(0) && PIN_EXISTS(TEMP_0_CS)
+    OUT_WRITE(TEMP_0_CS_PIN, HIGH);
+  #endif
+  #if TEMP_SENSOR_IS_ANY_MAX_TC(1) && PIN_EXISTS(TEMP_1_CS)
+    OUT_WRITE(TEMP_1_CS_PIN, HIGH);
+  #endif
+
+  // Setup objects for library-based polling of MAX TCs
+  #if HAS_MAXTC_LIBRARIES
+    #define _MAX31865_WIRES(n) MAX31865_##n##WIRE
+    #define MAX31865_WIRES(n) _MAX31865_WIRES(n)
+
+    #if TEMP_SENSOR_IS_MAX(0, 6675) && HAS_MAX6675_LIBRARY
+      max6675_0.begin();
+    #elif TEMP_SENSOR_IS_MAX(0, 31855) && HAS_MAX31855_LIBRARY
+      max31855_0.begin();
+    #elif TEMP_SENSOR_IS_MAX(0, 31865)
+      max31865_0.begin(
+        MAX31865_WIRES(MAX31865_SENSOR_WIRES_0) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0)
+      );
+      #if defined(LIB_INTERNAL_MAX31865) && ENABLED(MAX31865_50HZ_FILTER)
+        max31865_0.enable50HzFilter(1);
+      #endif
     #endif
-  #endif
 
-  #if HAS_MAX6675_TEMP
-    #if TEMP_SENSOR_IS_MAX(0, MAX6675)
-      max6675_0.begin(MAX6675);
-    #endif
-    #if TEMP_SENSOR_IS_MAX(1, MAX6675)
-      max6675_1.begin(MAX6675);
+    #if TEMP_SENSOR_IS_MAX(1, 6675) && HAS_MAX6675_LIBRARY
+      max6675_1.begin();
+    #elif TEMP_SENSOR_IS_MAX(1, 31855) && HAS_MAX31855_LIBRARY
+      max31855_1.begin();
+    #elif TEMP_SENSOR_IS_MAX(1, 31865)
+      max31865_1.begin(
+        MAX31865_WIRES(MAX31865_SENSOR_WIRES_1) // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+        OPTARG(LIB_INTERNAL_MAX31865, MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1)
+      );
+      #if defined(LIB_INTERNAL_MAX31865) && ENABLED(MAX31865_50HZ_FILTER)
+        max31865_1.enable50HzFilter(1);
+      #endif
     #endif
+    #undef MAX31865_WIRES
+    #undef _MAX31865_WIRES
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
@@ -2145,21 +2144,20 @@ void Temperature::init() {
     );
   #endif
 
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif
   #endif
-
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
     OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
   #endif
   #if HAS_HEATER_3
     OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
@@ -2212,21 +2210,23 @@ void Temperature::init() {
   #if HAS_FAN6
     INIT_FAN_PIN(FAN6_PIN);
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
-  TERN_(THERMO_SEPARATE_SPI, max_tc_spi.init());
+  #if HAS_MAXTC_SW_SPI
+    max_tc_spi.init();
+  #endif
 
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
@@ -2311,25 +2311,21 @@ void Temperature::init() {
   #if HAS_AUTO_FAN_6 && !(_EFANOVERLAP(6,0) || _EFANOVERLAP(6,1) || _EFANOVERLAP(6,2) || _EFANOVERLAP(6,3) || _EFANOVERLAP(6,4) || _EFANOVERLAP(6,5))
     INIT_E_AUTO_FAN_PIN(E6_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_7 && !(_EFANOVERLAP(7,0) || _EFANOVERLAP(7,1) || _EFANOVERLAP(7,2) || _EFANOVERLAP(7,3) || _EFANOVERLAP(7,4) || _EFANOVERLAP(7,5) || _EFANOVERLAP(7,6))
     INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
-  // Wait for temperature measurement to settle
-  //delay(250);
-
   #if HAS_HOTEND
-
     #define _TEMP_MIN_E(NR) do{ \
       const celsius_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
@@ -2379,21 +2375,20 @@ void Temperature::init() {
     #endif
     #if _MINMAX_TEST(6, MAX)
       _TEMP_MAX_E(6);
     #endif
     #if _MINMAX_TEST(7, MIN)
       _TEMP_MIN_E(7);
     #endif
     #if _MINMAX_TEST(7, MAX)
       _TEMP_MAX_E(7);
     #endif
-
   #endif // HAS_HOTEND
 
   #if HAS_HEATED_BED
     while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
   #endif
 
   #if HAS_HEATED_CHAMBER
     while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
@@ -2513,23 +2508,22 @@ void Temperature::init() {
       case TRRunaway:
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
+  // Disable autotemp, unpause and reset everything
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
-
-  // Unpause and reset everything
   TERN_(PROBING_HEATERS_OFF, pause_heaters(false));
 
   #if HAS_HOTEND
     HOTEND_LOOP() {
       setTargetHotend(0, e);
       temp_hotend[e].soft_pwm_amount = 0;
     }
   #endif
 
   #if HAS_TEMP_HOTEND
@@ -2551,41 +2545,39 @@ void Temperature::disable_all_heaters() {
 
   #if HAS_COOLER
     setTargetCooler(0);
     temp_cooler.soft_pwm_amount = 0;
     WRITE_HEATER_COOLER(LOW);
   #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
-  #include "printcounter.h"
-
   bool Temperature::auto_job_over_threshold() {
     #if HAS_HOTEND
       HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;
     #endif
     return TERN0(HAS_HEATED_BED, degTargetBed() > BED_MINTEMP)
         || TERN0(HAS_HEATED_CHAMBER, degTargetChamber() > CHAMBER_MINTEMP);
   }
 
   void Temperature::auto_job_check_timer(const bool can_start, const bool can_stop) {
     if (auto_job_over_threshold()) {
       if (can_start) startOrResumeJob();
     }
     else if (can_stop) {
       print_job_timer.stop();
       ui.reset_status();
     }
   }
 
-#endif
+#endif // PRINTJOB_TIMER_AUTOSTART
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause_heaters(const bool p) {
     if (p != paused_for_probing) {
       paused_for_probing = p;
       if (p) {
         HOTEND_LOOP() heater_idle[e].expire();    // Timeout immediately
         TERN_(HAS_HEATED_BED, heater_idle[IDLE_INDEX_BED].expire()); // Timeout immediately
       }
@@ -2609,195 +2601,183 @@ void Temperature::disable_all_heaters() {
       singlenozzle_temp[old_tool] = temp_hotend[0].target;
       if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
         setTargetHotend(singlenozzle_temp[new_tool], 0);
         TERN_(AUTOTEMP, planner.autotemp_update());
         set_heating_message(0);
         (void)wait_for_hotend(0, false);  // Wait for heating or cooling
       }
     #endif
   }
 
-#endif
+#endif // SINGLENOZZLE_STANDBY_TEMP || SINGLENOZZLE_STANDBY_FAN
 
 #if HAS_MAX_TC
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 
-  int Temperature::read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex/*=0*/)) {
-    #define MAX6675_HEAT_INTERVAL 250UL
+  /**
+   * @brief Read MAX Thermocouple temperature.
+   *
+   * Reads the thermocouple board via HW or SW SPI, using a library (LIB_USR_x) or raw SPI reads.
+   * Doesn't strictly return a temperature; returns an "ADC Value" (i.e. raw register content).
+   *
+   * @param  hindex  the hotend we're referencing (if MULTI_MAX_TC)
+   * @return         integer representing the board's buffer, to be converted later if needed
+   */
+  int16_t Temperature::read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex/*=0*/)) {
+    #define MAXTC_HEAT_INTERVAL 250UL
 
-    #if HAS_MAX31855_TEMP
-      static uint32_t max_tc_temp = 2000;
-      #define MAX_TC_ERROR_MASK    7
-      #define MAX_TC_DISCARD_BITS 18
-      #define MAX_TC_SPEED_BITS    3        // (_BV(SPR1)) // clock √∑ 64
-    #elif HAS_MAX31865_TEMP
-      static uint16_t max_tc_temp = 2000;   // From datasheet 16 bits D15-D0
-      #define MAX_TC_ERROR_MASK    1        // D0 Bit not used
+    #if HAS_MAX31855
+      #define MAX_TC_ERROR_MASK    7        // D2-0: SCV, SCG, OC
+      #define MAX_TC_DISCARD_BITS 18        // Data D31-18; sign bit D31
+      #define MAX_TC_SPEED_BITS    3        // ~1MHz
+    #elif HAS_MAX31865
+      #define MAX_TC_ERROR_MASK    1        // D0 Bit on fault only
       #define MAX_TC_DISCARD_BITS  1        // Data is in D15-D1
-      #define MAX_TC_SPEED_BITS    3        //  (_BV(SPR1)) // clock √∑ 64
-    #else
-      static uint16_t max_tc_temp = 2000;
-      #define MAX_TC_ERROR_MASK    4
-      #define MAX_TC_DISCARD_BITS  3
-      #define MAX_TC_SPEED_BITS    2        // (_BV(SPR0)) // clock √∑ 16
+      #define MAX_TC_SPEED_BITS    3        // ~1MHz
+    #else // MAX6675
+      #define MAX_TC_ERROR_MASK    3        // D2 only; 1 = open circuit
+      #define MAX_TC_DISCARD_BITS  3        // Data D15-D1
+      #define MAX_TC_SPEED_BITS    2        // ~2MHz
     #endif
 
     #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
-      static celsius_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
+      static int16_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
       #define THERMO_TEMP(I) max_tc_temp_previous[I]
       #define THERMO_SEL(A,B) (hindex ? (B) : (A))
-      #define MAX6675_WRITE(V)     do{ switch (hindex) { case 1:      WRITE(MAX6675_SS2_PIN, V); break; default:      WRITE(MAX6675_SS_PIN, V); } }while(0)
-      #define MAX6675_SET_OUTPUT() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN);    break; default: SET_OUTPUT(MAX6675_SS_PIN);    } }while(0)
+      #define MAXTC_CS_WRITE(V) do{ switch (hindex) { case 1: WRITE(TEMP_1_CS_PIN, V); break; default: WRITE(TEMP_0_CS_PIN, V); } }while(0)
     #else
+      // When we have only 1 max tc, THERMO_SEL will pick the appropriate sensor
+      // variable, and MAXTC_*() macros will be hardcoded to the correct CS pin.
       constexpr uint8_t hindex = 0;
       #define THERMO_TEMP(I) max_tc_temp
-      #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
-        #define THERMO_SEL(A,B) B
-      #else
+      #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
         #define THERMO_SEL(A,B) A
-      #endif
-      #if TEMP_SENSOR_IS_MAX(0, MAX6675)
-        #define MAX6675_WRITE(V)          WRITE(MAX6675_SS_PIN, V)
-        #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS_PIN)
+        #define MAXTC_CS_WRITE(V)  WRITE(TEMP_0_CS_PIN, V)
       #else
-        #define MAX6675_WRITE(V)          WRITE(MAX6675_SS2_PIN, V)
-        #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS2_PIN)
+        #define THERMO_SEL(A,B) B
+        #define MAXTC_CS_WRITE(V)  WRITE(TEMP_1_CS_PIN, V)
       #endif
-
     #endif
 
+    static TERN(HAS_MAX31855, uint32_t, uint16_t) max_tc_temp = THERMO_SEL(
+      TEMP_SENSOR_0_MAX_TC_TMAX,
+      TEMP_SENSOR_1_MAX_TC_TMAX
+    );
+
     static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
+    static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
 
     // Return last-read value between readings
-    static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
     millis_t ms = millis();
-    if (PENDING(ms, next_max_tc_ms[hindex])) return int(THERMO_TEMP(hindex));
-    next_max_tc_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
+    if (PENDING(ms, next_max_tc_ms[hindex]))
+      return (int16_t)THERMO_TEMP(hindex);
 
-    //
-    // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
-    //
-    #if !THERMO_SEPARATE_SPI && NO_THERMO_TEMPS
-      spiBegin();
-      spiInit(MAX_TC_SPEED_BITS);
-    #endif
+    next_max_tc_ms[hindex] = ms + MAXTC_HEAT_INTERVAL;
 
-    #if NO_THERMO_TEMPS
-      MAX6675_WRITE(LOW);  // enable TT_MAX6675
-      DELAY_NS(100);       // Ensure 100ns delay
-    #endif
+    #if !HAS_MAXTC_LIBRARIES
+      max_tc_temp = 0;
 
-    max_tc_temp = 0;
+      #if !HAS_MAXTC_SW_SPI
+        // Initialize SPI using the default Hardware SPI bus.
+        // FIXME: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
+        spiBegin();
+        spiInit(MAX_TC_SPEED_BITS);
+      #endif
+
+      MAXTC_CS_WRITE(LOW);  // enable MAXTC
+      DELAY_NS(100);        // Ensure 100ns delay
 
-    // Read a big-endian temperature value
-    #if NO_THERMO_TEMPS
+      // Read a big-endian temperature value without using a library
       for (uint8_t i = sizeof(max_tc_temp); i--;) {
-        max_tc_temp |= TERN(THERMO_SEPARATE_SPI, max_tc_spi.receive(), spiRec());
+        max_tc_temp |= TERN(HAS_MAXTC_SW_SPI, max_tc_spi.receive(), spiRec());
         if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
       }
-        MAX6675_WRITE(HIGH); // disable TT_MAX6675
-    #endif
 
-    #if HAS_MAX31855_TEMP
-      Adafruit_MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1);
-      max_tc_temp = max855ref.readRaw32();
-    #endif
-
-    #if HAS_MAX31865_TEMP
-      Adafruit_MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1);
-      #if ENABLED(LIB_USR_MAX31865)
-        max_tc_temp = max865ref.readRTD_with_Fault();
+      MAXTC_CS_WRITE(HIGH);  // disable MAXTC
+    #else
+      #if HAS_MAX6675_LIBRARY
+        MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1);
+        max_tc_temp = max6675ref.readRaw16();
       #endif
-    #endif
 
-    #if HAS_MAX6675_TEMP
-      MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1);
-      max_tc_temp = max6675ref.readRaw16();
-    #endif
+      #if HAS_MAX31855_LIBRARY
+        MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1);
+        max_tc_temp = max855ref.readRaw32();
+      #endif
 
-    #if ENABLED(LIB_ADAFRUIT_MAX31865)
-      const uint8_t fault_31865 = max865ref.readFault() & 0x3FU;
+      #if HAS_MAX31865
+        MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1);
+        max_tc_temp = TERN(LIB_INTERNAL_MAX31865, max865ref.readRaw(), max865ref.readRTD_with_Fault());
+      #endif
     #endif
 
-    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
-      && TERN(LIB_ADAFRUIT_MAX31865, fault_31865, (max_tc_temp & MAX_TC_ERROR_MASK))
-    ) {
+    // Handle an error. If there have been more than THERMOCOUPLE_MAX_ERRORS, send an error over serial.
+    // Either way, return the TMAX for the thermocouple to trigger a max_temp_error()
+    if (max_tc_temp & MAX_TC_ERROR_MASK) {
       max_tc_errors[hindex]++;
+
       if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
-        #if MAX_TC_ERROR_MASK == 7
-          SERIAL_ECHOPGM("MAX31855 Fault : (", max_tc_temp & 0x7, ") >> ");
+        #if HAS_MAX31855
+          SERIAL_ECHOPAIR("MAX31855 Fault: (", max_tc_temp & 0x7, ") >> ");
           if (max_tc_temp & 0x1)
             SERIAL_ECHOLNPGM("Open Circuit");
           else if (max_tc_temp & 0x2)
             SERIAL_ECHOLNPGM("Short to GND");
           else if (max_tc_temp & 0x4)
             SERIAL_ECHOLNPGM("Short to VCC");
         #elif HAS_MAX31865
-          #if ENABLED(LIB_USR_MAX31865)
-            // At the present time we do not have the ability to set the MAX31865 HIGH threshold
-            // or thr LOW threshold, so no need to check for them, zero these bits out
-            const uint8_t fault_31865 = max865ref.readFault() & 0x3FU;
-          #endif
+          const uint8_t fault_31865 = max865ref.readFault();
           max865ref.clearFault();
           if (fault_31865) {
             SERIAL_EOL();
-            SERIAL_ECHOLNPAIR("\nMAX31865 Fault :(", fault_31865, ")  >>");
+            SERIAL_ECHOLNPAIR("\nMAX31865 Fault: (", fault_31865, ")  >>");
             if (fault_31865 & MAX31865_FAULT_HIGHTHRESH)
               SERIAL_ECHOLNPGM("RTD High Threshold");
             if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
               SERIAL_ECHOLNPGM("RTD Low Threshold");
             if (fault_31865 & MAX31865_FAULT_REFINLOW)
-              SERIAL_ECHOLNPGM("REFIN- > 0.85 x Bias");
+              SERIAL_ECHOLNPGM("REFIN- > 0.85 x V bias");
             if (fault_31865 & MAX31865_FAULT_REFINHIGH)
-              SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
+              SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
             if (fault_31865 & MAX31865_FAULT_RTDINLOW)
-              SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
+              SERIAL_ECHOLNPGM("REFIN- < 0.85 x V bias (FORCE- open)");
             if (fault_31865 & MAX31865_FAULT_OVUV)
               SERIAL_ECHOLNPGM("Under/Over voltage");
           }
-        #else
-          SERIAL_ECHOLNPGM("MAX6675 Open Circuit");
+        #else // MAX6675
+          SERIAL_ECHOLNPGM("MAX6675 Fault: Open Circuit");
         #endif
 
-        // Thermocouple open
-        max_tc_temp = 4 * THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX);
+        // Set thermocouple above max temperature (TMAX)
+        max_tc_temp = THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX) << (MAX_TC_DISCARD_BITS + 1);
       }
-      else
-        max_tc_temp >>= MAX_TC_DISCARD_BITS;
     }
     else {
-      max_tc_temp >>= MAX_TC_DISCARD_BITS;
-      max_tc_errors[hindex] = 0;
+      max_tc_errors[hindex] = 0; // No error bit, reset error count
     }
 
-    #if HAS_MAX31855
-      if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000; // Support negative temperature
-    #endif
+    max_tc_temp >>= MAX_TC_DISCARD_BITS;
 
-    // Return the RTD resistance for MAX31865 for display in SHOW_TEMP_ADC_VALUES
-    #if HAS_MAX31865_TEMP
-      #if ENABLED(LIB_ADAFRUIT_MAX31865)
-        max_tc_temp = (uint32_t(max865ref.readRTD()) * THERMO_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
-      #elif ENABLED(LIB_USR_MAX31865)
-        max_tc_temp = (uint32_t(max_tc_temp) * THERMO_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
-      #endif
+    #if HAS_MAX31855
+      // Support negative temperature for MAX38155
+      if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000;
     #endif
 
     THERMO_TEMP(hindex) = max_tc_temp;
 
-    return int(max_tc_temp);
+    return (int16_t)max_tc_temp;
   }
 
 #endif // HAS_MAX_TC
 
 /**
  * Update raw temperatures
  *
  * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
  * Applies all the accumulators to the current raw temperatures.
  */
@@ -2808,30 +2788,30 @@ void Temperature::update_raw_temperatures() {
   #endif
 
   #if HAS_TEMP_ADC_1 && !TEMP_SENSOR_1_IS_MAX_TC
     temp_hotend[1].update();
   #endif
 
   #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_REDUNDANT_IS_MAX_TC
     temp_redundant.update();
   #endif
 
-  TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
-  TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
-  TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
-  TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
-  TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
-  TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
-  TERN_(HAS_TEMP_ADC_BED, temp_bed.update());
+  TERN_(HAS_TEMP_ADC_2,       temp_hotend[2].update());
+  TERN_(HAS_TEMP_ADC_3,       temp_hotend[3].update());
+  TERN_(HAS_TEMP_ADC_4,       temp_hotend[4].update());
+  TERN_(HAS_TEMP_ADC_5,       temp_hotend[5].update());
+  TERN_(HAS_TEMP_ADC_6,       temp_hotend[6].update());
+  TERN_(HAS_TEMP_ADC_7,       temp_hotend[7].update());
+  TERN_(HAS_TEMP_ADC_BED,     temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
-  TERN_(HAS_TEMP_ADC_PROBE, temp_probe.update());
-  TERN_(HAS_TEMP_ADC_COOLER, temp_cooler.update());
+  TERN_(HAS_TEMP_ADC_PROBE,   temp_probe.update());
+  TERN_(HAS_TEMP_ADC_COOLER,  temp_cooler.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 }
 
 /**
  * Called by the Temperature ISR when all the ADCs have been processed.
  * Reset all the ADC accumulators for another round of updates.
  */
@@ -3458,21 +3438,21 @@ void Temperature::isr() {
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
       #define SFP 2
     #endif
     SERIAL_CHAR(':');
     SERIAL_PRINT(c, SFP);
     SERIAL_ECHOPGM(" /");
     SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
-      SERIAL_ECHOPAIR(" (", TERN(NO_THERMO_TEMPS, false, k == 'T') ? r : r * RECIPROCAL(OVERSAMPLENR));
+      SERIAL_ECHOPAIR(" (", TERN(HAS_MAXTC_LIBRARIES, k == 'T', false) ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));

commit f944ec3ac6d0f4c4b394e11fe1af7416d52d6b68
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sat Jun 19 11:44:28 2021 -0700

    üêõ Redundant Temp Sensor followup (#22173)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9274d0631e..9f32ce933b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2083,30 +2083,44 @@ void Temperature::init() {
     OUT_WRITE(MAX31855_CS2_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX31865_CS)
     OUT_WRITE(MAX31865_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX31865_CS2)
     OUT_WRITE(MAX31865_CS2_PIN, HIGH);
   #endif
 
   #if HAS_MAX31865_TEMP
-    TERN_(TEMP_SENSOR_IS_MAX(0, MAX31865), max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-    TERN_(TEMP_SENSOR_IS_MAX(1, MAX31865), max31865_1.begin(MAX31865_2WIRE));
+    #if TEMP_SENSOR_IS_MAX(0, MAX31865)
+      max31865_0.begin(MAX31865_2WIRE); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+    #endif
+    #if TEMP_SENSOR_IS_MAX(1, MAX31865)
+      max31865_1.begin(MAX31865_2WIRE);
+    #endif
   #endif
+
   #if HAS_MAX31855_TEMP
-    TERN_(TEMP_SENSOR_IS_MAX(0, MAX31855), max31855_0.begin());
-    TERN_(TEMP_SENSOR_IS_MAX(1, MAX31855), max31855_1.begin());
+    #if TEMP_SENSOR_IS_MAX(0, MAX31855)
+      max31855_0.begin(MAX31855);
+    #endif
+    #if TEMP_SENSOR_IS_MAX(1, MAX31855)
+      max31855_1.begin(MAX31855);
+    #endif
   #endif
+
   #if HAS_MAX6675_TEMP
-    TERN_(TEMP_SENSOR_IS_MAX(0, MAX6675), max6675_0.begin());
-    TERN_(TEMP_SENSOR_IS_MAX(1, MAX6675), max6675_1.begin());
+    #if TEMP_SENSOR_IS_MAX(0, MAX6675)
+      max6675_0.begin(MAX6675);
+    #endif
+    #if TEMP_SENSOR_IS_MAX(1, MAX6675)
+      max6675_1.begin(MAX6675);
+    #endif
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif

commit d436c93f371336df31287be4fefe7b87876bcdb8
Author: ellensp <ellensp@hotmail.com>
Date:   Tue Jun 15 11:45:54 2021 +1200

    ‚ú® Redundant Part Cooling Fan (#21888)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e7d4ece721..9274d0631e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -326,20 +326,23 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
         if (fan < EXTRUDERS) singlenozzle_fan_speed[fan] = speed;
         return;
       }
     #endif
 
     TERN_(SINGLENOZZLE, fan = 0); // Always use fan index 0 with SINGLENOZZLE
 
     if (fan >= FAN_COUNT) return;
 
     fan_speed[fan] = speed;
+    #if REDUNDANT_PART_COOLING_FAN
+      if (fan == 0) fan_speed[REDUNDANT_PART_COOLING_FAN] = speed;
+    #endif
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(fan));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */
     void Temperature::report_fan_speed(const uint8_t fan) {
       if (fan >= FAN_COUNT) return;

commit a3e8bb99e472042c7db0b2d0be8d515ee715cf28
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 13 23:08:46 2021 -0400

    üé® ExtUI "user click" and other tweaks (#22122)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a5922cf553..e7d4ece721 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3614,21 +3614,21 @@ void Temperature::isr() {
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
             next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
-            ui.quick_feedback();
+            TERN_(HAS_LCD_MENU, ui.quick_feedback());
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         wait_for_heatup = false;
         #if ENABLED(DWIN_CREALITY_LCD)
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // print timer
@@ -3748,21 +3748,21 @@ void Temperature::isr() {
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
             next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_BED);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
-            ui.quick_feedback();
+            TERN_(HAS_LCD_MENU, ui.quick_feedback());
           }
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
           first_loop = false;
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) {

commit 629551d9bc10fd10baf8684c6830baf83e6caa9b
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Fri Jun 11 13:51:29 2021 -0700

    ‚ú® More flexible redundant temp sensor (#22085)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e2a1899202..a5922cf553 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -49,38 +49,40 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
+#define TEMP_SENSOR_IS_ANY_MAX_TC(n) (ENABLED(TEMP_SENSOR_##n##_IS_MAX_TC) || (ENABLED(TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && ENABLED(TEMP_SENSOR_REDUNDANT_SOURCE) && TEMP_SENSOR_REDUNDANT_SOURCE == n))
+
 // LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library
 #if LIB_USR_MAX31855
   #include <Adafruit_MAX31855.h>
   #if PIN_EXISTS(MAX31855_MISO) && PIN_EXISTS(MAX31855_SCK)
     #define MAX31855_USES_SW_SPI 1
   #endif
-  #if TEMP_SENSOR_0_IS_MAX31855 && PIN_EXISTS(MAX31855_CS)
+  #if TEMP_SENSOR_IS_MAX(0, MAX31855) && PIN_EXISTS(MAX31855_CS)
     #define HAS_MAX31855_TEMP 1
     Adafruit_MAX31855 max31855_0 = Adafruit_MAX31855(MAX31855_CS_PIN
       #if MAX31855_USES_SW_SPI
         , MAX31855_MISO_PIN, MAX31855_SCK_PIN  // For software SPI also set MISO/SCK
       #endif
       #if ENABLED(LARGE_PINMAP)
         , HIGH
       #endif
     );
   #endif
-  #if TEMP_SENSOR_1_IS_MAX31855 && PIN_EXISTS(MAX31855_CS2)
+  #if TEMP_SENSOR_IS_MAX(1, MAX31855) && PIN_EXISTS(MAX31855_CS2)
     #define HAS_MAX31855_TEMP 1
     Adafruit_MAX31855 max31855_1 = Adafruit_MAX31855(MAX31855_CS2_PIN
       #if MAX31855_USES_SW_SPI
         , MAX31855_MISO_PIN, MAX31855_SCK_PIN  // For software SPI also set MISO/SCK
       #endif
       #if ENABLED(LARGE_PINMAP)
         , HIGH
       #endif
     );
   #endif
@@ -89,79 +91,79 @@
 // LIB_MAX31865 can be added to the build_flags in platformio.ini to use a user-defined library.
 // If LIB_MAX31865 is not on the build_flags then the Adafruit MAX31865 V1.1.0 library is used.
 #if HAS_MAX31865
   #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN SD_MOSI_PIN
   #endif
   #if PIN_EXISTS(MAX31865_MISO) && PIN_EXISTS(MAX31865_SCK)
     #define MAX31865_USES_SW_SPI 1
   #endif
-  #if TEMP_SENSOR_0_IS_MAX31865 && PIN_EXISTS(MAX31865_CS)
+  #if TEMP_SENSOR_IS_MAX(0, MAX31865) && PIN_EXISTS(MAX31865_CS)
     #define HAS_MAX31865_TEMP 1
       Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
         #if MAX31865_USES_SW_SPI && PIN_EXISTS(MAX31865_MOSI)
           , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN  // For software SPI also set MOSI/MISO/SCK
         #endif
         #if ENABLED(LARGE_PINMAP)
           , HIGH
         #endif
       );
   #endif
-  #if TEMP_SENSOR_1_IS_MAX31865 && PIN_EXISTS(MAX31865_CS2)
+  #if TEMP_SENSOR_IS_MAX(1, MAX31865) && PIN_EXISTS(MAX31865_CS2)
     #define HAS_MAX31865_TEMP 1
     Adafruit_MAX31865 max31865_1 = Adafruit_MAX31865(MAX31865_CS2_PIN
       #if MAX31865_USES_SW_SPI && PIN_EXISTS(MAX31865_MOSI)
         , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN  // For software SPI also set MOSI/MISO/SCK
       #endif
       #if ENABLED(LARGE_PINMAP)
         , HIGH
       #endif
     );
   #endif
 #endif
 
 // LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
 #if LIB_USR_MAX6675
   #include <max6675.h>
   #if PIN_EXISTS(MAX6675_MISO) && PIN_EXISTS(MAX6675_SCK)
     #define MAX6675_USES_SW_SPI 1
   #endif
-  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX6675_CS)
+  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX6675_CS)
     #define HAS_MAX6675_TEMP 1
     MAX6675 max6675_0 = MAX6675(MAX6675_CS_PIN
       #if MAX6675_USES_SW_SPI
         , MAX6675_MISO_PIN, MAX6675_SCK_PIN   // For software SPI also set MISO/SCK
       #endif
       #if ENABLED(LARGE_PINMAP)
         , HIGH
       #endif
     );
   #endif
-  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX6675_CS2)
+  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX6675_CS2)
     #define HAS_MAX6675_TEMP 1
     MAX6675 max6675_1 = MAX6675(MAX6675_CS2_PIN
       #if MAX6675_USES_SW_SPI
         , MAX6675_MISO_PIN, MAX6675_SCK_PIN   // For software SPI also set MISO/SCK
       #endif
       #if ENABLED(LARGE_PINMAP)
         , HIGH
       #endif
     );
   #endif
 #endif
 
 #if !HAS_MAX6675_TEMP && !HAS_MAX31855_TEMP && !HAS_MAX31865_TEMP
   #define NO_THERMO_TEMPS 1
 #endif
 
-#if (TEMP_SENSOR_0_IS_MAX_TC || TEMP_SENSOR_1_IS_MAX_TC) && PINS_EXIST(MAX6675_SCK, MAX6675_DO) && NO_THERMO_TEMPS
+#if (TEMP_SENSOR_0_IS_MAX_TC || TEMP_SENSOR_1_IS_MAX_TC || TEMP_SENSOR_REDUNDANT_IS_MAX_TC) && PINS_EXIST(MAX6675_SCK, MAX6675_DO) && NO_THERMO_TEMPS
   #define THERMO_SEPARATE_SPI 1
 #endif
 
 #if THERMO_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
@@ -203,29 +205,24 @@
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if ANY(TEMP_SENSOR_0_IS_THERMISTOR, TEMP_SENSOR_1_IS_THERMISTOR, TEMP_SENSOR_2_IS_THERMISTOR, TEMP_SENSOR_3_IS_THERMISTOR, \
         TEMP_SENSOR_4_IS_THERMISTOR, TEMP_SENSOR_5_IS_THERMISTOR, TEMP_SENSOR_6_IS_THERMISTOR, TEMP_SENSOR_7_IS_THERMISTOR )
   #define HAS_HOTEND_THERMISTOR 1
 #endif
 
 #if HAS_HOTEND_THERMISTOR
-  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    static const temp_entry_t* heater_ttbl_map[2] = { TEMPTABLE_0, TEMPTABLE_1 };
-    static constexpr uint8_t heater_ttbllen_map[2] = { TEMPTABLE_0_LEN, TEMPTABLE_1_LEN };
-  #else
-    #define NEXT_TEMPTABLE(N) ,TEMPTABLE_##N
-    #define NEXT_TEMPTABLE_LEN(N) ,TEMPTABLE_##N##_LEN
-    static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0 REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
-    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
-  #endif
+  #define NEXT_TEMPTABLE(N) ,TEMPTABLE_##N
+  #define NEXT_TEMPTABLE_LEN(N) ,TEMPTABLE_##N##_LEN
+  static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0 REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
+  static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
 #endif
 
 Temperature thermalManager;
 
 const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
            str_t_heating_failed[] PROGMEM = STR_T_HEATING_FAILED;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
@@ -250,27 +247,28 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTENDS];
-  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    temp_info_t Temperature::temp_redundant;
-  #endif
   #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
+#if HAS_TEMP_REDUNDANT
+  redundant_temp_info_t Temperature::temp_redundant;
+#endif
+
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed; // = 0
@@ -1212,22 +1210,26 @@ void Temperature::manage_heater() {
   #endif
 
   if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_0_IS_MAX_TC
       if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_1_IS_MAX_TC
-      if (TERN(TEMP_SENSOR_1_AS_REDUNDANT, degHotendRedundant(), degHotend(1)) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
-      if (TERN(TEMP_SENSOR_1_AS_REDUNDANT, degHotendRedundant(), degHotend(1)) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
+      if (degHotend(1) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
+      if (degHotend(1) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
+    #endif
+    #if TEMP_SENSOR_REDUNDANT_IS_MAX_TC
+      if (degRedundant() > TEMP_SENSOR_REDUNDANT_MAX_TC_TMAX - 1.0) max_temp_error(H_REDUNDANT);
+      if (degRedundant() < TEMP_SENSOR_REDUNDANT_MAX_TC_TMIN + .01) min_temp_error(H_REDUNDANT);
     #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
@@ -1247,30 +1249,30 @@ void Temperature::manage_heater() {
         if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
           if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
             start_watching_hotend(e);               // If temp reached, turn off elapsed check
           else {
             TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           }
         }
       #endif
 
-      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        // Make sure measured temperatures are close together
-        if (ABS(degHotend(0) - degHotendRedundant()) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
-          _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
-      #endif
-
     } // HOTEND_LOOP
 
   #endif // HAS_HOTEND
 
+  #if HAS_TEMP_REDUNDANT
+    // Make sure measured temperatures are close together
+    if (ABS(degRedundantTarget() - degRedundant()) > TEMP_SENSOR_REDUNDANT_MAX_DIFF)
+      _temp_error((heater_id_t)TEMP_SENSOR_REDUNDANT_TARGET, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
+  #endif
+
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     /**
      * Dynamically set the volumetric multiplier based
@@ -1606,27 +1608,30 @@ void Temperature::manage_heater() {
       #if TEMP_SENSOR_6_IS_CUSTOM
         { true, 0, 0, HOTEND6_PULLUP_RESISTOR_OHMS, HOTEND6_RESISTANCE_25C_OHMS, 0, 0, HOTEND6_BETA, 0 },
       #endif
       #if TEMP_SENSOR_7_IS_CUSTOM
         { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
       #endif
       #if TEMP_SENSOR_BED_IS_CUSTOM
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
       #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
-        { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
+        { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 },
       #endif
       #if TEMP_SENSOR_COOLER_IS_CUSTOM
-        { true, 0, 0, COOLER_PULLUP_RESISTOR_OHMS, COOLER_RESISTANCE_25C_OHMS, 0, 0, COOLER_BETA, 0 }
+        { true, 0, 0, COOLER_PULLUP_RESISTOR_OHMS, COOLER_RESISTANCE_25C_OHMS, 0, 0, COOLER_BETA, 0 },
       #endif
       #if TEMP_SENSOR_PROBE_IS_CUSTOM
-        { true, 0, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 }
+        { true, 0, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 },
+      #endif
+      #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
+        { true, 0, 0, REDUNDANT_PULLUP_RESISTOR_OHMS, REDUNDANT_RESISTANCE_25C_OHMS, 0, 0, REDUNDANT_BETA, 0 },
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
     else
@@ -1646,20 +1651,21 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
       TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
       TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
       TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
       TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
+      TERN_(TEMP_SENSOR_REDUNDANT_IS_CUSTOM, t_index == CTI_REDUNDANT ? PSTR("REDUNDANT") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
@@ -1701,21 +1707,21 @@ void Temperature::manage_heater() {
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
   celsius_float_t Temperature::analog_to_celsius_hotend(const int16_t raw, const uint8_t e) {
-      if (e >= HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
+      if (e >= HOTENDS) {
         SERIAL_ERROR_START();
         SERIAL_ECHO(e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
@@ -1879,57 +1885,87 @@ void Temperature::manage_heater() {
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
+#if HAS_TEMP_REDUNDANT
+  // For redundant temperature measurement.
+  celsius_float_t Temperature::analog_to_celsius_redundant(const int16_t raw) {
+    #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
+      return user_thermistor_to_deg_c(CTI_REDUNDANT, raw);
+    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && TEMP_SENSOR_REDUNDANT_SOURCE == 0
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0), raw * 0.25);
+    #elif TEMP_SENSOR_REDUNDANT_IS_MAX_TC && TEMP_SENSOR_REDUNDANT_SOURCE == 1
+      return TERN(TEMP_SENSOR_REDUNDANT_IS_MAX31865, max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1), raw * 0.25);
+    #elif TEMP_SENSOR_REDUNDANT_IS_THERMISTOR
+      SCAN_THERMISTOR_TABLE(TEMPTABLE_REDUNDANT, TEMPTABLE_REDUNDANT_LEN);
+    #elif TEMP_SENSOR_REDUNDANT_IS_AD595
+      return TEMP_AD595(raw);
+    #elif TEMP_SENSOR_REDUNDANT_IS_AD8495
+      return TEMP_AD8495(raw);
+    #else
+      UNUSED(raw);
+      return 0;
+    #endif
+  }
+#endif // HAS_TEMP_REDUNDANT
+
 /**
  * Convert the raw sensor readings into actual Celsius temperatures and
  * validate raw temperatures. Bad readings generate min/maxtemp errors.
  *
  * The raw values are generated entirely in interrupt context, and this
  * method is called from normal context once 'raw_temps_ready' has been
  * set by update_raw_temperatures().
  *
  * The watchdog is dependent on this method. If 'raw_temps_ready' stops
  * being set by the interrupt so that this method is not called for over
  * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
 
   watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
 
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
-  TERN_(TEMP_SENSOR_1_IS_MAX_TC, TERN(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant, temp_hotend[1]).raw = READ_MAX_TC(1));
+  TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
+  TERN_(TEMP_SENSOR_REDUNDANT_IS_MAX_TC, temp_redundant.raw = READ_MAX_TC(TEMP_SENSOR_REDUNDANT_SOURCE));
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
-  TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant.celsius = analog_to_celsius_hotend(temp_redundant.raw, 1));
 
-  TERN_(HAS_HEATED_BED,   temp_bed.celsius     = analog_to_celsius_bed(temp_bed.raw));
-  TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
-  TERN_(HAS_TEMP_COOLER,  temp_cooler.celsius  = analog_to_celsius_cooler(temp_cooler.raw));
-  TERN_(HAS_TEMP_PROBE,   temp_probe.celsius   = analog_to_celsius_probe(temp_probe.raw));
+  TERN_(HAS_HEATED_BED,     temp_bed.celsius       = analog_to_celsius_bed(temp_bed.raw));
+  TERN_(HAS_TEMP_CHAMBER,   temp_chamber.celsius   = analog_to_celsius_chamber(temp_chamber.raw));
+  TERN_(HAS_TEMP_COOLER,    temp_cooler.celsius    = analog_to_celsius_cooler(temp_cooler.raw));
+  TERN_(HAS_TEMP_PROBE,     temp_probe.celsius     = analog_to_celsius_probe(temp_probe.raw));
+  TERN_(HAS_TEMP_REDUNDANT, temp_redundant.celsius = analog_to_celsius_redundant(temp_redundant.raw));
 
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
   #if HAS_HOTEND
-
     static constexpr int8_t temp_dir[] = {
-      TERN(TEMP_SENSOR_0_IS_MAX_TC, 0, TEMPDIR(0))
+      #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
+        0
+      #else
+        TEMPDIR(0)
+      #endif
       #if HAS_MULTI_HOTEND
-        , TERN(TEMP_SENSOR_1_IS_MAX_TC, 0, TEMPDIR(1))
+        #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
+          , 0
+        #else
+          , TEMPDIR(1)
+        #endif
         #if HOTENDS > 2
           #define _TEMPDIR(N) , TEMPDIR(N)
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif
       #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
@@ -2024,67 +2060,79 @@ void Temperature::updateTemperaturesFromRawValues() {
  */
 void Temperature::init() {
 
   TERN_(PROBING_HEATERS_OFF, paused_for_probing = false);
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   // Init (and disable) SPI thermocouples
-  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX6675_CS)
+  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX6675_CS)
     OUT_WRITE(MAX6675_CS_PIN, HIGH);
   #endif
-  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX6675_CS2)
+  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX6675_CS2)
     OUT_WRITE(MAX6675_CS2_PIN, HIGH);
   #endif
-  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX31855_CS)
+  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX31855_CS)
     OUT_WRITE(MAX31855_CS_PIN, HIGH);
   #endif
-  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX31855_CS2)
+  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX31855_CS2)
     OUT_WRITE(MAX31855_CS2_PIN, HIGH);
   #endif
-  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX31865_CS)
+  #if TEMP_SENSOR_IS_MAX(0, MAX6675) && PIN_EXISTS(MAX31865_CS)
     OUT_WRITE(MAX31865_CS_PIN, HIGH);
   #endif
-  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX31865_CS2)
+  #if TEMP_SENSOR_IS_MAX(1, MAX6675) && PIN_EXISTS(MAX31865_CS2)
     OUT_WRITE(MAX31865_CS2_PIN, HIGH);
   #endif
 
   #if HAS_MAX31865_TEMP
-    TERN_(TEMP_SENSOR_0_IS_MAX31865, max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-    TERN_(TEMP_SENSOR_1_IS_MAX31865, max31865_1.begin(MAX31865_2WIRE));
+    TERN_(TEMP_SENSOR_IS_MAX(0, MAX31865), max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+    TERN_(TEMP_SENSOR_IS_MAX(1, MAX31865), max31865_1.begin(MAX31865_2WIRE));
   #endif
   #if HAS_MAX31855_TEMP
-    TERN_(TEMP_SENSOR_0_IS_MAX31855, max31855_0.begin());
-    TERN_(TEMP_SENSOR_1_IS_MAX31855, max31855_1.begin());
+    TERN_(TEMP_SENSOR_IS_MAX(0, MAX31855), max31855_0.begin());
+    TERN_(TEMP_SENSOR_IS_MAX(1, MAX31855), max31855_1.begin());
   #endif
   #if HAS_MAX6675_TEMP
-    TERN_(TEMP_SENSOR_0_IS_MAX6675, max6675_0.begin());
-    TERN_(TEMP_SENSOR_1_IS_MAX6675, max6675_1.begin());
+    TERN_(TEMP_SENSOR_IS_MAX(0, MAX6675), max6675_0.begin());
+    TERN_(TEMP_SENSOR_IS_MAX(1, MAX6675), max6675_1.begin());
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
-    #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
+    #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER) || _AD(REDUNDANT)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   // Thermistor activation by MCU pin
   #if PIN_EXISTS(TEMP_0_TR_ENABLE)
-    OUT_WRITE(TEMP_0_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_0_IS_MAX_TC));
+    OUT_WRITE(TEMP_0_TR_ENABLE_PIN,
+      #if TEMP_SENSOR_IS_ANY_MAX_TC(0)
+        1
+      #else
+        0
+      #endif
+    );
   #endif
   #if PIN_EXISTS(TEMP_1_TR_ENABLE)
-    OUT_WRITE(TEMP_1_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_1_IS_MAX_TC));
+    OUT_WRITE(TEMP_1_TR_ENABLE_PIN,
+      #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
+        1
+      #else
+        0
+      #endif
+    );
   #endif
 
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif
   #endif
 
@@ -2199,20 +2247,23 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if HAS_TEMP_ADC_COOLER
     HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
   #endif
   #if HAS_TEMP_ADC_PROBE
     HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
+  #if HAS_TEMP_ADC_REDUNDANT
+    HAL_ANALOG_SELECT(TEMP_REDUNDANT_PIN);
+  #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
     HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_VOLTAGE)
@@ -2261,21 +2312,21 @@ void Temperature::init() {
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const celsius_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_ ##N## _THERMISTOR_ID && TEMP_SENSOR_ ##N## _THERMISTOR_ID != 998 && TEMP_SENSOR_ ##N## _THERMISTOR_ID != 999 && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_##N > 0 && TEMP_SENSOR_##N != 998 && TEMP_SENSOR_##N != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif
@@ -2328,20 +2379,36 @@ void Temperature::init() {
 
   #if HAS_HEATED_CHAMBER
     while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
     while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
     while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
+
+  #if HAS_TEMP_REDUNDANT
+    temp_redundant.target = &(
+      #if TEMP_SENSOR_REDUNDANT_TARGET == -5 && HAS_TEMP_COOLER
+        temp_cooler
+      #elif TEMP_SENSOR_REDUNDANT_TARGET == -4 && HAS_TEMP_PROBE
+        temp_probe
+      #elif TEMP_SENSOR_REDUNDANT_TARGET == -2 && HAS_TEMP_CHAMBER
+        temp_chamber
+      #elif TEMP_SENSOR_REDUNDANT_TARGET == -1 && HAS_TEMP_BED
+        temp_bed
+      #else
+        temp_hotend[TEMP_SENSOR_REDUNDANT_TARGET]
+      #endif
+    );
+  #endif
 }
 
 #if HAS_THERMAL_PROTECTION
 
   Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
@@ -2366,21 +2433,21 @@ void Temperature::init() {
         case H_CHAMBER: SERIAL_ECHOPGM("chamber"); break;
         default:        SERIAL_ECHO(heater_id);
       }
       SERIAL_ECHOLNPAIR(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
-    //*/
+    */
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
       if (heater_idle[idle_index].timed_out) {
         state = TRInactive;
         running_temp = 0;
       }
       else
     #endif
     {
@@ -2563,26 +2630,26 @@ void Temperature::disable_all_heaters() {
     #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
       static celsius_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
       #define THERMO_TEMP(I) max_tc_temp_previous[I]
       #define THERMO_SEL(A,B) (hindex ? (B) : (A))
       #define MAX6675_WRITE(V)     do{ switch (hindex) { case 1:      WRITE(MAX6675_SS2_PIN, V); break; default:      WRITE(MAX6675_SS_PIN, V); } }while(0)
       #define MAX6675_SET_OUTPUT() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN);    break; default: SET_OUTPUT(MAX6675_SS_PIN);    } }while(0)
     #else
       constexpr uint8_t hindex = 0;
       #define THERMO_TEMP(I) max_tc_temp
-      #if TEMP_SENSOR_1_IS_MAX31865
+      #if TEMP_SENSOR_IS_ANY_MAX_TC(1)
         #define THERMO_SEL(A,B) B
       #else
         #define THERMO_SEL(A,B) A
       #endif
-      #if TEMP_SENSOR_0_IS_MAX6675
+      #if TEMP_SENSOR_IS_MAX(0, MAX6675)
         #define MAX6675_WRITE(V)          WRITE(MAX6675_SS_PIN, V)
         #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS_PIN)
       #else
         #define MAX6675_WRITE(V)          WRITE(MAX6675_SS2_PIN, V)
         #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS2_PIN)
       #endif
 
     #endif
 
     static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
@@ -2716,26 +2783,26 @@ void Temperature::disable_all_heaters() {
  *
  * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
  * Applies all the accumulators to the current raw temperatures.
  */
 void Temperature::update_raw_temperatures() {
 
   #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_0_IS_MAX_TC
     temp_hotend[0].update();
   #endif
 
-  #if HAS_TEMP_ADC_1
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      temp_redundant.update();
-    #elif !TEMP_SENSOR_1_IS_MAX_TC
-      temp_hotend[1].update();
-    #endif
+  #if HAS_TEMP_ADC_1 && !TEMP_SENSOR_1_IS_MAX_TC
+    temp_hotend[1].update();
+  #endif
+
+  #if HAS_TEMP_ADC_REDUNDANT && !TEMP_SENSOR_REDUNDANT_IS_MAX_TC
+    temp_redundant.update();
   #endif
 
   TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED, temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
@@ -2757,27 +2824,27 @@ void Temperature::readings_ready() {
   if (!raw_temps_ready) {
     update_raw_temperatures();
     raw_temps_ready = true;
   }
 
   // Filament Sensor - can be read any time since IIR filtering is used
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.reading_ready());
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
-    TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant.reset());
   #endif
 
   TERN_(HAS_HEATED_BED, temp_bed.reset());
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE, temp_probe.reset());
   TERN_(HAS_TEMP_COOLER, temp_cooler.reset());
+  TERN_(HAS_TEMP_REDUNDANT, temp_redundant.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
@@ -3189,23 +3256,28 @@ void Temperature::isr() {
     #if HAS_TEMP_ADC_COOLER
       case PrepareTemp_COOLER: HAL_START_ADC(TEMP_COOLER_PIN); break;
       case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
     #endif
 
     #if HAS_TEMP_ADC_PROBE
       case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
+    #if HAS_TEMP_ADC_REDUNDANT
+      case PrepareTemp_REDUNDANT: HAL_START_ADC(TEMP_REDUNDANT_PIN); break;
+      case MeasureTemp_REDUNDANT: ACCUMULATE_ADC(temp_redundant); break;
+    #endif
+
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
-      case MeasureTemp_1: ACCUMULATE_ADC(TERN(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant, temp_hotend[1])); break;
+      case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2
       case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
       case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
     #if HAS_TEMP_ADC_3
       case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
       case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
@@ -3325,20 +3397,21 @@ void Temperature::isr() {
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   /**
    * Print a single heater state in the form:
    *        Bed: " B:nnn.nn /nnn.nn"
    *    Chamber: " C:nnn.nn /nnn.nn"
    *      Probe: " P:nnn.nn /nnn.nn"
    *     Cooler: " L:nnn.nn /nnn.nn"
+   *  Redundant: " R:nnn.nn /nnn.nn"
    *   Extruder: " T0:nnn.nn /nnn.nn"
    *   With ADC: " T0:nnn.nn /nnn.nn (nnn.nn)"
    */
   static void print_heater_state(const heater_id_t e, const_celsius_float_t c, const_celsius_float_t t
     OPTARG(SHOW_TEMP_ADC_VALUES, const float r)
   ) {
     char k;
     switch (e) {
       default:
         #if HAS_TEMP_HOTEND
@@ -3349,21 +3422,21 @@ void Temperature::isr() {
       #endif
       #if HAS_TEMP_CHAMBER
         case H_CHAMBER: k = 'C'; break;
       #endif
       #if HAS_TEMP_PROBE
         case H_PROBE: k = 'P'; break;
       #endif
       #if HAS_TEMP_COOLER
         case H_COOLER: k = 'L'; break;
       #endif
-      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      #if HAS_TEMP_REDUNDANT
         case H_REDUNDANT: k = 'R'; break;
       #endif
     }
     SERIAL_CHAR(' ', k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
@@ -3375,40 +3448,40 @@ void Temperature::isr() {
     SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       SERIAL_ECHOPAIR(" (", TERN(NO_THERMO_TEMPS, false, k == 'T') ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
-    OPTARG(TEMP_SENSOR_1_AS_REDUNDANT, const bool include_r/*=false*/)
+    OPTARG(HAS_TEMP_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
-      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        if (include_r) print_heater_state(H_REDUNDANT, degHotendRedundant(), degTargetHotend(0) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTempRedundant()));
-      #endif
     #endif
     #if HAS_HEATED_BED
       print_heater_state(H_BED, degBed(), degTargetBed() OPTARG(SHOW_TEMP_ADC_VALUES, rawBedTemp()));
     #endif
     #if HAS_TEMP_CHAMBER
       print_heater_state(H_CHAMBER, degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber()) OPTARG(SHOW_TEMP_ADC_VALUES, rawChamberTemp()));
     #endif
     #if HAS_TEMP_COOLER
       print_heater_state(H_COOLER, degCooler(), TERN0(HAS_COOLER, degTargetCooler()) OPTARG(SHOW_TEMP_ADC_VALUES, rawCoolerTemp()));
     #endif
     #if HAS_TEMP_PROBE
       print_heater_state(H_PROBE, degProbe(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawProbeTemp()) );
     #endif
+    #if HAS_TEMP_REDUNDANT
+      if (include_r) print_heater_state(H_REDUNDANT, degRedundant(), degRedundantTarget() OPTARG(SHOW_TEMP_ADC_VALUES, rawRedundantTemp()));
+    #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
       SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
     #endif

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 898ffa7d5f..e2a1899202 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3328,25 +3328,22 @@ void Temperature::isr() {
 
   /**
    * Print a single heater state in the form:
    *        Bed: " B:nnn.nn /nnn.nn"
    *    Chamber: " C:nnn.nn /nnn.nn"
    *      Probe: " P:nnn.nn /nnn.nn"
    *     Cooler: " L:nnn.nn /nnn.nn"
    *   Extruder: " T0:nnn.nn /nnn.nn"
    *   With ADC: " T0:nnn.nn /nnn.nn (nnn.nn)"
    */
-  static void print_heater_state(const_celsius_float_t c, const_celsius_float_t t
-    #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      , const float r
-    #endif
-    , const heater_id_t e=INDEX_NONE
+  static void print_heater_state(const heater_id_t e, const_celsius_float_t c, const_celsius_float_t t
+    OPTARG(SHOW_TEMP_ADC_VALUES, const float r)
   ) {
     char k;
     switch (e) {
       default:
         #if HAS_TEMP_HOTEND
           k = 'T'; break;
         #endif
       #if HAS_TEMP_BED
         case H_BED: k = 'B'; break;
       #endif
@@ -3378,78 +3375,42 @@ void Temperature::isr() {
     SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
       SERIAL_ECHOPAIR(" (", TERN(NO_THERMO_TEMPS, false, k == 'T') ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      , const bool include_r/*=false*/
-    #endif
+    OPTARG(TEMP_SENSOR_1_AS_REDUNDANT, const bool include_r/*=false*/)
   ) {
     #if HAS_TEMP_HOTEND
-      print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawHotendTemp(target_extruder)
-        #endif
-      );
+      print_heater_state(H_NONE, degHotend(target_extruder), degTargetHotend(target_extruder) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(target_extruder)));
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        if (include_r) print_heater_state(degHotendRedundant(), degTargetHotend(0)
-          #if ENABLED(SHOW_TEMP_ADC_VALUES)
-            , rawHotendTempRedundant()
-          #endif
-          , H_REDUNDANT
-        );
+        if (include_r) print_heater_state(H_REDUNDANT, degHotendRedundant(), degTargetHotend(0) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTempRedundant()));
       #endif
     #endif
     #if HAS_HEATED_BED
-      print_heater_state(degBed(), degTargetBed()
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawBedTemp()
-        #endif
-        , H_BED
-      );
+      print_heater_state(H_BED, degBed(), degTargetBed() OPTARG(SHOW_TEMP_ADC_VALUES, rawBedTemp()));
     #endif
     #if HAS_TEMP_CHAMBER
-      print_heater_state(degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber())
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawChamberTemp()
-        #endif
-        , H_CHAMBER
-      );
-    #endif // HAS_TEMP_CHAMBER
+      print_heater_state(H_CHAMBER, degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber()) OPTARG(SHOW_TEMP_ADC_VALUES, rawChamberTemp()));
+    #endif
     #if HAS_TEMP_COOLER
-      print_heater_state(degCooler(), TERN0(HAS_COOLER, degTargetCooler())
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawCoolerTemp()
-        #endif
-        , H_COOLER
-      );
-    #endif // HAS_TEMP_COOLER
+      print_heater_state(H_COOLER, degCooler(), TERN0(HAS_COOLER, degTargetCooler()) OPTARG(SHOW_TEMP_ADC_VALUES, rawCoolerTemp()));
+    #endif
     #if HAS_TEMP_PROBE
-      print_heater_state(degProbe(), 0
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawProbeTemp()
-        #endif
-        , H_PROBE
-      );
+      print_heater_state(H_PROBE, degProbe(), 0 OPTARG(SHOW_TEMP_ADC_VALUES, rawProbeTemp()) );
     #endif
     #if HAS_MULTI_HOTEND
-      HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawHotendTemp(e)
-        #endif
-        , (heater_id_t)e
-      );
+      HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
       SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
     #endif
     #if HAS_COOLER
       SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_COOLER));
@@ -3458,24 +3419,21 @@ void Temperature::isr() {
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
-    void Temperature::AutoReportTemp::report() {
-      print_heater_states(active_extruder);
-      SERIAL_EOL();
-    }
+    void Temperature::AutoReportTemp::report() { print_heater_states(active_extruder); SERIAL_EOL(); }
   #endif
 
   #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HAS_MULTI_HOTEND
           PSTR("E%c " S_FMT), '1' + e
         #else
           PSTR("E " S_FMT)
@@ -3488,25 +3446,22 @@ void Temperature::isr() {
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60
     #endif
 
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/
-      #if G26_CLICK_CAN_CANCEL
-        , const bool click_to_cancel/*=false*/
-      #endif
+      OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel/*=false*/)
     ) {
-
       #if ENABLED(AUTOTEMP)
         REMEMBER(1, planner.autotemp_enabled, false);
       #endif
 
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_RESIDENCY_TIME)))
       #else
@@ -3631,23 +3586,21 @@ void Temperature::isr() {
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
       #define MIN_COOLING_SLOPE_DEG_BED 1.00
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_BED
       #define MIN_COOLING_SLOPE_TIME_BED 60
     #endif
 
     bool Temperature::wait_for_bed(const bool no_wait_for_cooling/*=true*/
-      #if G26_CLICK_CAN_CANCEL
-        , const bool click_to_cancel/*=false*/
-      #endif
+      OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel/*=false*/)
     ) {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_BED_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif

commit ff0318c5bd95c6cb18ae9765f1ecb344dc2d6e4e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 21:08:57 2021 -0500

    üé® pause => pause_heaters

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f9ff9e5fa6..898ffa7d5f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2432,21 +2432,21 @@ void Temperature::init() {
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
 
   // Unpause and reset everything
-  TERN_(PROBING_HEATERS_OFF, pause(false));
+  TERN_(PROBING_HEATERS_OFF, pause_heaters(false));
 
   #if HAS_HOTEND
     HOTEND_LOOP() {
       setTargetHotend(0, e);
       temp_hotend[e].soft_pwm_amount = 0;
     }
   #endif
 
   #if HAS_TEMP_HOTEND
     #define DISABLE_HEATER(N) WRITE_HEATER_##N(LOW);
@@ -2491,21 +2491,21 @@ void Temperature::disable_all_heaters() {
     else if (can_stop) {
       print_job_timer.stop();
       ui.reset_status();
     }
   }
 
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
-  void Temperature::pause(const bool p) {
+  void Temperature::pause_heaters(const bool p) {
     if (p != paused_for_probing) {
       paused_for_probing = p;
       if (p) {
         HOTEND_LOOP() heater_idle[e].expire();    // Timeout immediately
         TERN_(HAS_HEATED_BED, heater_idle[IDLE_INDEX_BED].expire()); // Timeout immediately
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }

commit d8c4be375c24f0cda27ff8079b78985e5b8afa97
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 17:56:31 2021 -0500

    üé® Null heating message method

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 03c0195085..f9ff9e5fa6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2519,21 +2519,21 @@ void Temperature::disable_all_heaters() {
   void Temperature::singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool) {
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       singlenozzle_fan_speed[old_tool] = fan_speed[0];
       fan_speed[0] = singlenozzle_fan_speed[new_tool];
     #endif
     #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
       singlenozzle_temp[old_tool] = temp_hotend[0].target;
       if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
         setTargetHotend(singlenozzle_temp[new_tool], 0);
         TERN_(AUTOTEMP, planner.autotemp_update());
-        TERN_(HAS_STATUS_MESSAGE, set_heating_message(0));
+        set_heating_message(0);
         (void)wait_for_hotend(0, false);  // Wait for heating or cooling
       }
     #endif
   }
 
 #endif
 
 #if HAS_MAX_TC
 
   #ifndef THERMOCOUPLE_MAX_ERRORS

commit 390878e78af3a0f07e2a1b2e784fc882e22edbd4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 11 04:01:21 2021 -0500

    :art: Additional utility macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 72d801652f..03c0195085 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -306,21 +306,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     }
 
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
     uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
-    uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128, 128, 128);
+    uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 128);
   #endif
 
   /**
    * Set the print fan speed for a target extruder
    */
   void Temperature::set_fan_speed(uint8_t fan, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)

commit 42a2b5c3ec1c4067113b87ad8c1977018bbb763e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 8 17:34:21 2021 -0500

    Move temp errors calling kill() out of ISR (#21832)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2f1a54e91d..72d801652f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -569,22 +569,21 @@ volatile bool Temperature::raw_temps_ready = false;
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
-      if (raw_temps_ready) { // temp sample ready
-        updateTemperaturesFromRawValues();
+      if (updateTemperaturesIfReady()) { // temp sample ready
 
         // Get the current temperature and constrain it
         current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
 
@@ -1205,23 +1204,21 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
-  if (!raw_temps_ready) return;
-
-  updateTemperaturesFromRawValues(); // also resets the watchdog
+  if (!updateTemperaturesIfReady()) return; // Will also reset the watchdog if temperatures are ready
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_0_IS_MAX_TC
       if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
       if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_1_IS_MAX_TC
       if (TERN(TEMP_SENSOR_1_AS_REDUNDANT, degHotendRedundant(), degHotend(1)) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
       if (TERN(TEMP_SENSOR_1_AS_REDUNDANT, degHotendRedundant(), degHotend(1)) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
     #endif
@@ -1883,43 +1880,102 @@ void Temperature::manage_heater() {
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
 /**
- * Get the raw values into the actual temperatures.
- * The raw values are created in interrupt context,
- * and this function is called from normal context
- * as it would block the stepper routine.
+ * Convert the raw sensor readings into actual Celsius temperatures and
+ * validate raw temperatures. Bad readings generate min/maxtemp errors.
+ *
+ * The raw values are generated entirely in interrupt context, and this
+ * method is called from normal context once 'raw_temps_ready' has been
+ * set by update_raw_temperatures().
+ *
+ * The watchdog is dependent on this method. If 'raw_temps_ready' stops
+ * being set by the interrupt so that this method is not called for over
+ * 4 seconds then something has gone afoul and the machine will be reset.
  */
 void Temperature::updateTemperaturesFromRawValues() {
+
+  watchdog_refresh(); // Reset because raw_temps_ready was set by the interrupt
+
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
   TERN_(TEMP_SENSOR_1_IS_MAX_TC, TERN(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant, temp_hotend[1]).raw = READ_MAX_TC(1));
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
   TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant.celsius = analog_to_celsius_hotend(temp_redundant.raw, 1));
-  TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
+
+  TERN_(HAS_HEATED_BED,   temp_bed.celsius     = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
-  TERN_(HAS_TEMP_COOLER, temp_cooler.celsius = analog_to_celsius_cooler(temp_cooler.raw));
-  TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
+  TERN_(HAS_TEMP_COOLER,  temp_cooler.celsius  = analog_to_celsius_cooler(temp_cooler.raw));
+  TERN_(HAS_TEMP_PROBE,   temp_probe.celsius   = analog_to_celsius_probe(temp_probe.raw));
+
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
-  TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
+  TERN_(HAS_POWER_MONITOR,     power_monitor.capture_values());
 
-  // Reset the watchdog on good temperature measurement
-  watchdog_refresh();
+  #if HAS_HOTEND
+
+    static constexpr int8_t temp_dir[] = {
+      TERN(TEMP_SENSOR_0_IS_MAX_TC, 0, TEMPDIR(0))
+      #if HAS_MULTI_HOTEND
+        , TERN(TEMP_SENSOR_1_IS_MAX_TC, 0, TEMPDIR(1))
+        #if HOTENDS > 2
+          #define _TEMPDIR(N) , TEMPDIR(N)
+          REPEAT_S(2, HOTENDS, _TEMPDIR)
+        #endif
+      #endif
+    };
+
+    LOOP_L_N(e, COUNT(temp_dir)) {
+      const int8_t tdir = temp_dir[e];
+      if (tdir) {
+        const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
+        if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_id_t)e);
 
-  raw_temps_ready = false;
+        const bool heater_on = temp_hotend[e].target > 0;
+        if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
+          #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
+            if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+          #endif
+              min_temp_error((heater_id_t)e);
+        }
+        #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
+          else
+            consecutive_low_temperature_error[e] = 0;
+        #endif
+      }
+    }
+
+  #endif // HAS_HOTEND
+
+  #if ENABLED(THERMAL_PROTECTION_BED)
+    #define BEDCMP(A,B) (TEMPDIR(BED) < 0 ? ((A)<(B)) : ((A)>(B)))
+    if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
+    if (temp_bed.target > 0 && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
+  #endif
+
+  #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
+    #define CHAMBERCMP(A,B) (TEMPDIR(CHAMBER) < 0 ? ((A)<(B)) : ((A)>(B)))
+    if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
+    if (temp_chamber.target > 0 && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
+  #endif
+
+  #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
+    #define COOLERCMP(A,B) (TEMPDIR(COOLER) < 0 ? ((A)<(B)) : ((A)>(B)))
+    if (cutter.unitPower > 0 && COOLERCMP(temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
+    if (COOLERCMP(mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
+  #endif
 }
 
 #if THERMO_SEPARATE_SPI
   template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin> SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
   SPIclass<MAX6675_DO_PIN, SD_MOSI_PIN, MAX6675_SCK_PIN> max_tc_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef BOARD_OPENDRAIN_MOSFETS
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
@@ -2650,20 +2706,23 @@ void Temperature::disable_all_heaters() {
 
     THERMO_TEMP(hindex) = max_tc_temp;
 
     return int(max_tc_temp);
   }
 
 #endif // HAS_MAX_TC
 
 /**
  * Update raw temperatures
+ *
+ * Called by ISR => readings_ready when new temperatures have been set by updateTemperaturesFromRawValues.
+ * Applies all the accumulators to the current raw temperatures.
  */
 void Temperature::update_raw_temperatures() {
 
   #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_0_IS_MAX_TC
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       temp_redundant.update();
@@ -2679,114 +2738,50 @@ void Temperature::update_raw_temperatures() {
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED, temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
   TERN_(HAS_TEMP_ADC_PROBE, temp_probe.update());
   TERN_(HAS_TEMP_ADC_COOLER, temp_cooler.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
-
-  raw_temps_ready = true;
 }
 
+/**
+ * Called by the Temperature ISR when all the ADCs have been processed.
+ * Reset all the ADC accumulators for another round of updates.
+ */
 void Temperature::readings_ready() {
 
-  // Update the raw values if they've been read. Else we could be updating them during reading.
-  if (!raw_temps_ready) update_raw_temperatures();
+  // Update raw values only if they're not already set.
+  if (!raw_temps_ready) {
+    update_raw_temperatures();
+    raw_temps_ready = true;
+  }
 
   // Filament Sensor - can be read any time since IIR filtering is used
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.reading_ready());
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
     TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant.reset());
   #endif
 
   TERN_(HAS_HEATED_BED, temp_bed.reset());
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE, temp_probe.reset());
   TERN_(HAS_TEMP_COOLER, temp_cooler.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
-
-  #if HAS_HOTEND
-
-    static constexpr int8_t temp_dir[] = {
-      TERN(TEMP_SENSOR_0_IS_MAX_TC, 0, TEMPDIR(0))
-      #if HAS_MULTI_HOTEND
-        , TERN(TEMP_SENSOR_1_IS_MAX_TC, 0, TEMPDIR(1))
-        #if HOTENDS > 2
-          #define _TEMPDIR(N) , TEMPDIR(N)
-          REPEAT_S(2, HOTENDS, _TEMPDIR)
-        #endif
-      #endif
-    };
-
-    LOOP_L_N(e, COUNT(temp_dir)) {
-      const int8_t tdir = temp_dir[e];
-      if (tdir) {
-        const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
-        if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_id_t)e);
-
-        const bool heater_on = (temp_hotend[e].target > 0 || TERN0(PIDTEMP, temp_hotend[e].soft_pwm_amount > 0));
-        if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
-          #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
-            if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
-          #endif
-              min_temp_error((heater_id_t)e);
-        }
-        #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
-          else
-            consecutive_low_temperature_error[e] = 0;
-        #endif
-      }
-    }
-
-  #endif // HAS_HOTEND
-
-  #if ENABLED(THERMAL_PROTECTION_BED)
-    #if TEMPDIR(BED) < 0
-      #define BEDCMP(A,B) ((A)<(B))
-    #else
-      #define BEDCMP(A,B) ((A)>(B))
-    #endif
-    const bool bed_on = (temp_bed.target > 0) || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount > 0);
-    if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
-    if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
-  #endif
-
-  #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
-    #if TEMPDIR(CHAMBER) < 0
-      #define CHAMBERCMP(A,B) ((A)<(B))
-    #else
-      #define CHAMBERCMP(A,B) ((A)>(B))
-    #endif
-    const bool chamber_on = (temp_chamber.target > 0);
-    if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
-    if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
-  #endif
-
-  #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
-    #if TEMPDIR(COOLER) < 0
-      #define COOLERCMP(A,B) ((A)<(B))
-    #else
-      #define COOLERCMP(A,B) ((A)>(B))
-    #endif
-    if (cutter.unitPower > 0) {
-      if (COOLERCMP(temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
-    }
-    if (COOLERCMP(mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
-  #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan

commit dc187690109b9f66673bb6675c098af0644d40e1
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun May 2 23:37:54 2021 -0300

    Prevent watchdog reset in setup() (#21776)
    
    Cause `manage_heaters` to only reset the watchdog and return until `setup()` is completed.
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6a04efc302..2f1a54e91d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -413,24 +413,20 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
-#if EARLY_WATCHDOG
-  bool Temperature::inited = false;
-#endif
-
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 
 #if HAS_HOTEND
@@ -1198,25 +1194,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
-
-  #if EARLY_WATCHDOG
-    // If thermal manager is still not running, make sure to at least reset the watchdog!
-    if (!inited) return watchdog_refresh();
-  #endif
+  if (marlin_state == MF_INITIALIZING) return watchdog_refresh(); // If Marlin isn't started, at least reset the watchdog!
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
 
     if (emergency_parser.quickstop_by_M410) {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
@@ -2008,26 +2000,20 @@ void Temperature::init() {
   #endif
   #if HAS_MAX31855_TEMP
     TERN_(TEMP_SENSOR_0_IS_MAX31855, max31855_0.begin());
     TERN_(TEMP_SENSOR_1_IS_MAX31855, max31855_1.begin());
   #endif
   #if HAS_MAX6675_TEMP
     TERN_(TEMP_SENSOR_0_IS_MAX6675, max6675_0.begin());
     TERN_(TEMP_SENSOR_1_IS_MAX6675, max6675_1.begin());
   #endif
 
-  #if EARLY_WATCHDOG
-    // Flag that the thermalManager should be running
-    if (inited) return;
-    inited = true;
-  #endif
-
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   // Thermistor activation by MCU pin
@@ -2202,21 +2188,21 @@ void Temperature::init() {
     INIT_E_AUTO_FAN_PIN(E6_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_7 && !(_EFANOVERLAP(7,0) || _EFANOVERLAP(7,1) || _EFANOVERLAP(7,2) || _EFANOVERLAP(7,3) || _EFANOVERLAP(7,4) || _EFANOVERLAP(7,5) || _EFANOVERLAP(7,6))
     INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
-  delay(250);
+  //delay(250);
 
   #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
       const celsius_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \

commit becdac19ea4559c1e636d55d949a15c50cac7888
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 2 21:32:21 2021 -0500

    Temperature cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cc7aa6c8e1..6a04efc302 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -440,46 +440,46 @@ volatile bool Temperature::raw_temps_ready = false;
                          sensor_heater_2 { TEMP_SENSOR_2_RAW_LO_TEMP, TEMP_SENSOR_2_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_3 { TEMP_SENSOR_3_RAW_LO_TEMP, TEMP_SENSOR_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_5 { TEMP_SENSOR_5_RAW_LO_TEMP, TEMP_SENSOR_5_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_6 { TEMP_SENSOR_6_RAW_LO_TEMP, TEMP_SENSOR_6_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_7 { TEMP_SENSOR_7_RAW_LO_TEMP, TEMP_SENSOR_7_RAW_HI_TEMP, 0, 16383 };
 
   temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5, sensor_heater_6, sensor_heater_7);
 #endif
 
-#ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+#if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
-#ifdef MILLISECONDS_PREHEAT_TIME
+#if MILLISECONDS_PREHEAT_TIME > 0
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
 #if HAS_AUTO_FAN
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
   celsius_t Temperature::singlenozzle_temp[EXTRUDERS];
 #endif
 #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
   uint8_t Temperature::singlenozzle_fan_speed[EXTRUDERS];
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
-  bool Temperature::paused;
+  bool Temperature::paused_for_probing;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint16_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
@@ -1313,24 +1313,24 @@ void Temperature::manage_heater() {
     #endif
 
     #if PAUSE_CHANGE_REQD
       static bool last_pause_state;
     #endif
 
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
-          && TERN1(PAUSE_CHANGE_REQD, paused == last_pause_state)
+          && TERN1(PAUSE_CHANGE_REQD, paused_for_probing == last_pause_state)
         ) break;
         next_bed_check_ms = ms + BED_CHECK_INTERVAL;
-        TERN_(PAUSE_CHANGE_REQD, last_pause_state = paused);
+        TERN_(PAUSE_CHANGE_REQD, last_pause_state = paused_for_probing);
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, heater_idle[IDLE_INDEX_BED].update(ms));
 
       #if HAS_THERMALLY_PROTECTED_BED
         tr_state_machine[RUNAWAY_IND_BED].run(temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
       #endif
 
       #if HEATER_IDLE_HANDLER
         if (heater_idle[IDLE_INDEX_BED].timed_out) {
@@ -1951,23 +1951,44 @@ void Temperature::updateTemperaturesFromRawValues() {
   #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 #if CHAMBER_AUTO_FAN_SPEED != 255
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
+ *
  * The manager is implemented by periodic calls to manage_heater()
+ *
+ *  - Init (and disable) SPI thermocouples like MAX6675 and MAX31865
+ *  - Disable RUMBA JTAG to accommodate a thermocouple extension
+ *  - Read-enable thermistors with a read-enable pin
+ *  - Init HEATER and COOLER pins for OUTPUT in OFF state
+ *  - Init the FAN pins as PWM or OUTPUT
+ *  - Init the SPI interface for SPI thermocouples
+ *  - Init ADC according to the HAL
+ *  - Set thermistor pins to analog inputs according to the HAL
+ *  - Start the Temperature ISR timer
+ *  - Init the AUTO FAN pins as PWM or OUTPUT
+ *  - Wait 250ms for temperatures to settle
+ *  - Init temp_range[], used for catching min/maxtemp
  */
 void Temperature::init() {
+
+  TERN_(PROBING_HEATERS_OFF, paused_for_probing = false);
+
+  #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
+    last_e_position = 0;
+  #endif
+
   // Init (and disable) SPI thermocouples
   #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX6675_CS)
     OUT_WRITE(MAX6675_CS_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX6675_CS2)
     OUT_WRITE(MAX6675_CS2_PIN, HIGH);
   #endif
   #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX31855_CS)
     OUT_WRITE(MAX31855_CS_PIN, HIGH);
   #endif
@@ -2010,24 +2031,20 @@ void Temperature::init() {
   #endif
 
   // Thermistor activation by MCU pin
   #if PIN_EXISTS(TEMP_0_TR_ENABLE)
     OUT_WRITE(TEMP_0_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_0_IS_MAX_TC));
   #endif
   #if PIN_EXISTS(TEMP_1_TR_ENABLE)
     OUT_WRITE(TEMP_1_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_1_IS_MAX_TC));
   #endif
 
-  #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
-    last_e_position = 0;
-  #endif
-
   #if HAS_HEATER_0
     #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif
   #endif
 
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
@@ -2269,69 +2286,22 @@ void Temperature::init() {
 
   #if HAS_HEATED_CHAMBER
     while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
     while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
     while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
-
-  TERN_(PROBING_HEATERS_OFF, paused = false);
 }
 
-#if WATCH_HOTENDS
-  /**
-   * Start Heating Sanity Check for hotends that are below
-   * their target temperature by a configurable margin.
-   * This is called when the temperature is set. (M104, M109)
-   */
-  void Temperature::start_watching_hotend(const uint8_t E_NAME) {
-    const uint8_t ee = HOTEND_INDEX;
-    watch_hotend[ee].restart(degHotend(ee), degTargetHotend(ee));
-  }
-#endif
-
-#if WATCH_BED
-  /**
-   * Start Heating Sanity Check for hotends that are below
-   * their target temperature by a configurable margin.
-   * This is called when the temperature is set. (M140, M190)
-   */
-  void Temperature::start_watching_bed() {
-    watch_bed.restart(degBed(), degTargetBed());
-  }
-#endif
-
-#if WATCH_CHAMBER
-  /**
-   * Start Heating Sanity Check for chamber that is below
-   * its target temperature by a configurable margin.
-   * This is called when the temperature is set. (M141, M191)
-   */
-  void Temperature::start_watching_chamber() {
-    watch_chamber.restart(degChamber(), degTargetChamber());
-  }
-#endif
-
-#if WATCH_COOLER
-  /**
-   * Start Cooling Sanity Check for cooler that is above
-   * its target temperature by a configurable margin.
-   * This is called when the temperature is set. (M143, M193)
-   */
-  void Temperature::start_watching_cooler() {
-    watch_cooler.restart(degCooler(), degTargetCooler());
-  }
-#endif
-
 #if HAS_THERMAL_PROTECTION
 
   Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
@@ -2480,22 +2450,22 @@ void Temperature::disable_all_heaters() {
       print_job_timer.stop();
       ui.reset_status();
     }
   }
 
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
-    if (p != paused) {
-      paused = p;
+    if (p != paused_for_probing) {
+      paused_for_probing = p;
       if (p) {
         HOTEND_LOOP() heater_idle[e].expire();    // Timeout immediately
         TERN_(HAS_HEATED_BED, heater_idle[IDLE_INDEX_BED].expire()); // Timeout immediately
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
@@ -2766,31 +2736,30 @@ void Temperature::readings_ready() {
           #define _TEMPDIR(N) , TEMPDIR(N)
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif
       #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
-        const bool heater_on = (temp_hotend[e].target > 0
-          || TERN0(PIDTEMP, temp_hotend[e].soft_pwm_amount) > 0
-        );
         if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_id_t)e);
+
+        const bool heater_on = (temp_hotend[e].target > 0 || TERN0(PIDTEMP, temp_hotend[e].soft_pwm_amount > 0));
         if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
-          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+          #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
             if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
           #endif
               min_temp_error((heater_id_t)e);
         }
-        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+        #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
           else
             consecutive_low_temperature_error[e] = 0;
         #endif
       }
     }
 
   #endif // HAS_HOTEND
 
   #if ENABLED(THERMAL_PROTECTION_BED)
     #if TEMPDIR(BED) < 0

commit 46eb12da51b50f4fdbd482866e366faee446f3f3
Author: vyacheslav-shubin <shubin-vv@krista.ru>
Date:   Sun May 2 04:28:49 2021 +0300

    ExtUI event for PID tuning start (#21734)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 53d6c14d5b..cc7aa6c8e1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -544,20 +544,22 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
+    TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_STARTED));
+
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());

commit ef9ca61039514efef6e2bf100c4b6b1db8f0316c
Author: ellensp <ellensp@hotmail.com>
Date:   Sat May 1 20:21:18 2021 +1200

    Fix Singlenozzle Standby issues (#21759)
    
    Fixes #21758
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 69f5e9b58e..53d6c14d5b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -459,23 +459,23 @@ volatile bool Temperature::raw_temps_ready = false;
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
   celsius_t Temperature::singlenozzle_temp[EXTRUDERS];
-  #if HAS_FAN
-    uint8_t Temperature::singlenozzle_fan_speed[EXTRUDERS];
-  #endif
+#endif
+#if ENABLED(SINGLENOZZLE_STANDBY_FAN)
+  uint8_t Temperature::singlenozzle_fan_speed[EXTRUDERS];
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
@@ -2493,34 +2493,36 @@ void Temperature::disable_all_heaters() {
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
-#if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
+#if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
 
   void Temperature::singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool) {
-    #if HAS_FAN
+    #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       singlenozzle_fan_speed[old_tool] = fan_speed[0];
       fan_speed[0] = singlenozzle_fan_speed[new_tool];
     #endif
-    singlenozzle_temp[old_tool] = temp_hotend[0].target;
-    if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
-      setTargetHotend(singlenozzle_temp[new_tool], 0);
-      TERN_(AUTOTEMP, planner.autotemp_update());
-      TERN_(HAS_STATUS_MESSAGE, set_heating_message(0));
-      (void)wait_for_hotend(0, false);  // Wait for heating or cooling
-    }
+    #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
+      singlenozzle_temp[old_tool] = temp_hotend[0].target;
+      if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
+        setTargetHotend(singlenozzle_temp[new_tool], 0);
+        TERN_(AUTOTEMP, planner.autotemp_update());
+        TERN_(HAS_STATUS_MESSAGE, set_heating_message(0));
+        (void)wait_for_hotend(0, false);  // Wait for heating or cooling
+      }
+    #endif
   }
 
 #endif
 
 #if HAS_MAX_TC
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 

commit cfdfd167794de13de75d99c161f61a0898549717
Author: David <davidtgbe@hotmail.com>
Date:   Fri Apr 30 08:51:26 2021 +0200

    Fix Thermal Runaway false-alarm in M303, add HeaterWatch::check (#21743)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 462af7f61a..69f5e9b58e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -536,21 +536,21 @@ volatile bool Temperature::raw_temps_ready = false;
         #define C_GTV(T,A,B) (B)
       #endif
       #if BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
         #define B_GTV(T,A,B) ((T) ? (A) : (B))
       #else
         #define B_GTV(T,A,B) (B)
       #endif
       #define GTV(C,B,H) C_GTV(ischamber, C, B_GTV(isbed, B, H))
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
-      const celsius_float_t watch_temp_target = celsius_float_t(target - watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
+      const celsius_float_t watch_temp_target = celsius_float_t(target - (watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1));
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
@@ -1246,27 +1246,27 @@ void Temperature::manage_heater() {
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
-        if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
-          if (degHotend(e) < watch_hotend[e].target) {                          // Failed to increase enough?
+        if (watch_hotend[e].elapsed(ms)) {          // Enabled and time to check?
+          if (watch_hotend[e].check(degHotend(e)))  // Increased enough?
+            start_watching_hotend(e);               // If temp reached, turn off elapsed check
+          else {
             TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           }
-          else                                                                  // Start again if the target is still far off
-            start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(degHotend(0) - degHotendRedundant()) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
           _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
 
     } // HOTEND_LOOP
@@ -1289,27 +1289,27 @@ void Temperature::manage_heater() {
   #endif
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
-      if (watch_bed.elapsed(ms)) {        // Time to check the bed?
-        if (degBed() < watch_bed.target) {                              // Failed to increase enough?
+      if (watch_bed.elapsed(ms)) {              // Time to check the bed?
+        if (watch_bed.check(degBed()))          // Increased enough?
+          start_watching_bed();                 // If temp reached, turn off elapsed check
+        else {
           TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         }
-        else                                                            // Start again if the target is still far off
-          start_watching_bed();
       }
     #endif // WATCH_BED
 
     #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
       static bool last_pause_state;
     #endif
@@ -1370,25 +1370,25 @@ void Temperature::manage_heater() {
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (degChamber() > CHAMBER_MAXTEMP) max_temp_error(H_CHAMBER);
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
-      if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
-        if (degChamber() < watch_chamber.target)    // Failed to increase enough?
-          _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+      if (watch_chamber.elapsed(ms)) {          // Time to check the chamber?
+        if (watch_chamber.check(degChamber()))  // Increased enough? Error below.
+          start_watching_chamber();             // If temp reached, turn off elapsed check.
         else
-          start_watching_chamber();                 // Start again if the target is still far off
+          _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
       }
     #endif
 
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
       static bool flag_chamber_excess_heat; // = false;
     #endif
 
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
       static bool flag_chamber_off; // = false
 

commit 5f9aac2027c241056c83d497054be91c64b086e7
Author: ellensp <ellensp@hotmail.com>
Date:   Tue Apr 27 16:36:39 2021 +1200

    Use temp_info_t for temp_redundant (#21715)
    
    Fixes #21712
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8e2b2d6b91..462af7f61a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -249,21 +249,25 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #define _E_PSTR(h,N) ((HOTENDS) > N && (h) == N) ? PSTR(LCD_STR_E##N) :
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
-  hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
+  hotend_info_t Temperature::temp_hotend[HOTENDS];
+  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+    temp_info_t Temperature::temp_redundant;
+  #endif
+  #define _HMT(N) HEATER_##N##_MAXTEMP,
   const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
@@ -413,25 +417,20 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   bool Temperature::allow_cold_extrude = false;
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
 
-#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-  int16_t Temperature::redundant_temperature_raw = 0;
-  celsius_float_t Temperature::redundant_temperature = 0.0;
-#endif
-
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 
 #if HAS_HOTEND
@@ -1218,26 +1217,26 @@ void Temperature::manage_heater() {
       quickstop_stepper();
     }
   #endif
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if TEMP_SENSOR_0_IS_MAX_TC
-      if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
-      if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
+      if (degHotend(0) > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
+      if (degHotend(0) < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
     #if TEMP_SENSOR_1_IS_MAX_TC
-      if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
-      if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
+      if (TERN(TEMP_SENSOR_1_AS_REDUNDANT, degHotendRedundant(), degHotend(1)) > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
+      if (TERN(TEMP_SENSOR_1_AS_REDUNDANT, degHotendRedundant(), degHotend(1)) < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
     #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
@@ -1259,21 +1258,21 @@ void Temperature::manage_heater() {
             TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           }
           else                                                                  // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
-        if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
+        if (ABS(degHotend(0) - degHotendRedundant()) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
           _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
 
     } // HOTEND_LOOP
 
   #endif // HAS_HOTEND
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
@@ -1661,21 +1660,21 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
-  celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
+  celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
     //#endif
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
@@ -1710,22 +1709,22 @@ void Temperature::manage_heater() {
     //#endif
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
-      if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
+  celsius_float_t Temperature::analog_to_celsius_hotend(const int16_t raw, const uint8_t e) {
+      if (e >= HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
         SERIAL_ECHO(e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
@@ -1819,75 +1818,75 @@ void Temperature::manage_heater() {
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // For bed temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_bed(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_bed(const int16_t raw) {
     #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif TEMP_SENSOR_BED_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
     #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // For chamber temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_chamber(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_chamber(const int16_t raw) {
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif TEMP_SENSOR_CHAMBER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_CHAMBER, TEMPTABLE_CHAMBER_LEN);
     #elif TEMP_SENSOR_CHAMBER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_CHAMBER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_COOLER
   // For cooler temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_cooler(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_cooler(const int16_t raw) {
     #if TEMP_SENSOR_COOLER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_COOLER, raw);
     #elif TEMP_SENSOR_COOLER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_COOLER, TEMPTABLE_COOLER_LEN);
     #elif TEMP_SENSOR_COOLER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_COOLER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_COOLER
 
 #if HAS_TEMP_PROBE
   // For probe temperature measurement.
-  celsius_float_t Temperature::analog_to_celsius_probe(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_probe(const int16_t raw) {
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
     #elif TEMP_SENSOR_PROBE_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_PROBE, TEMPTABLE_PROBE_LEN);
     #elif TEMP_SENSOR_PROBE_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
@@ -1897,29 +1896,29 @@ void Temperature::manage_heater() {
 #endif // HAS_TEMP_PROBE
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
-  TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
+  TERN_(TEMP_SENSOR_1_IS_MAX_TC, TERN(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant, temp_hotend[1]).raw = READ_MAX_TC(1));
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
+  TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant.celsius = analog_to_celsius_hotend(temp_redundant.raw, 1));
   TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_COOLER, temp_cooler.celsius = analog_to_celsius_cooler(temp_cooler.raw));
   TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
-  TERN_(TEMP_SENSOR_1_AS_REDUNDANT, redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1));
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
 
 #if THERMO_SEPARATE_SPI
@@ -2700,21 +2699,21 @@ void Temperature::disable_all_heaters() {
  * Update raw temperatures
  */
 void Temperature::update_raw_temperatures() {
 
   #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_0_IS_MAX_TC
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      redundant_temperature_raw = temp_hotend[1].acc;
+      temp_redundant.update();
     #elif !TEMP_SENSOR_1_IS_MAX_TC
       temp_hotend[1].update();
     #endif
   #endif
 
   TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
@@ -2734,21 +2733,21 @@ void Temperature::update_raw_temperatures() {
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!raw_temps_ready) update_raw_temperatures();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.reading_ready());
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
-    TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_hotend[1].reset());
+    TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant.reset());
   #endif
 
   TERN_(HAS_HEATED_BED, temp_bed.reset());
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE, temp_probe.reset());
   TERN_(HAS_TEMP_COOLER, temp_cooler.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
@@ -3238,21 +3237,21 @@ void Temperature::isr() {
       case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
     #endif
 
     #if HAS_TEMP_ADC_PROBE
       case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
-      case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
+      case MeasureTemp_1: ACCUMULATE_ADC(TERN(TEMP_SENSOR_1_AS_REDUNDANT, temp_redundant, temp_hotend[1])); break;
     #endif
 
     #if HAS_TEMP_ADC_2
       case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
       case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
     #if HAS_TEMP_ADC_3
       case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
       case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
@@ -3436,23 +3435,23 @@ void Temperature::isr() {
       , const bool include_r/*=false*/
     #endif
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(target_extruder)
         #endif
       );
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        if (include_r) print_heater_state(redundant_temperature, degTargetHotend(target_extruder)
+        if (include_r) print_heater_state(degHotendRedundant(), degTargetHotend(0)
           #if ENABLED(SHOW_TEMP_ADC_VALUES)
-            , redundant_temperature_raw
+            , rawHotendTempRedundant()
           #endif
           , H_REDUNDANT
         );
       #endif
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif

commit 46f272b66945e4f2fb6e191b83cebeaa57e496f5
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Apr 23 22:29:15 2021 -0300

    Fix Celsius precision, current temp accessors (#21678)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3c8d55c630..8e2b2d6b91 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -493,21 +493,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
    * temperature to succeed.
    */
   void Temperature::PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
-    float current_temp = 0.0;
+    celsius_float_t current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     PID_t tune_pid = { 0, 0, 0 };
     celsius_float_t maxT = 0, minT = 10000;
 
     const bool isbed = (heater_id == H_BED);
@@ -1661,21 +1661,21 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
-  celsius_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
+  celsius_float_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
     //#endif
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
@@ -1710,21 +1710,21 @@ void Temperature::manage_heater() {
     //#endif
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
-  celsius_t Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
+  celsius_float_t Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
       if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
         SERIAL_ECHO(e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
@@ -1819,75 +1819,75 @@ void Temperature::manage_heater() {
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // For bed temperature measurement.
-  celsius_t Temperature::analog_to_celsius_bed(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_bed(const int raw) {
     #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif TEMP_SENSOR_BED_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
     #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // For chamber temperature measurement.
-  celsius_t Temperature::analog_to_celsius_chamber(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_chamber(const int raw) {
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif TEMP_SENSOR_CHAMBER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_CHAMBER, TEMPTABLE_CHAMBER_LEN);
     #elif TEMP_SENSOR_CHAMBER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_CHAMBER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_COOLER
   // For cooler temperature measurement.
-  celsius_t Temperature::analog_to_celsius_cooler(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_cooler(const int raw) {
     #if TEMP_SENSOR_COOLER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_COOLER, raw);
     #elif TEMP_SENSOR_COOLER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_COOLER, TEMPTABLE_COOLER_LEN);
     #elif TEMP_SENSOR_COOLER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_COOLER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_COOLER
 
 #if HAS_TEMP_PROBE
   // For probe temperature measurement.
-  celsius_t Temperature::analog_to_celsius_probe(const int raw) {
+  celsius_float_t Temperature::analog_to_celsius_probe(const int raw) {
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
     #elif TEMP_SENSOR_PROBE_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_PROBE, TEMPTABLE_PROBE_LEN);
     #elif TEMP_SENSOR_PROBE_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1ad0303abd..3c8d55c630 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -492,21 +492,21 @@ volatile bool Temperature::raw_temps_ready = false;
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
    * temperature to succeed.
    */
-  void Temperature::PID_autotune(const_float_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
+  void Temperature::PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
     float current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     PID_t tune_pid = { 0, 0, 0 };
     celsius_float_t maxT = 0, minT = 10000;
 
@@ -3808,24 +3808,24 @@ void Temperature::isr() {
 
   #if HAS_TEMP_PROBE
 
     #ifndef MIN_DELTA_SLOPE_DEG_PROBE
       #define MIN_DELTA_SLOPE_DEG_PROBE 1.0
     #endif
     #ifndef MIN_DELTA_SLOPE_TIME_PROBE
       #define MIN_DELTA_SLOPE_TIME_PROBE 600
     #endif
 
-    bool Temperature::wait_for_probe(const_float_t target_temp, bool no_wait_for_cooling/*=true*/) {
+    bool Temperature::wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling/*=true*/) {
 
-      const bool wants_to_cool = isProbeAboveTemp(target_temp);
-      const bool will_wait = !(wants_to_cool && no_wait_for_cooling);
+      const bool wants_to_cool = isProbeAboveTemp(target_temp),
+                 will_wait = !(wants_to_cool && no_wait_for_cooling);
       if (will_wait)
         SERIAL_ECHOLNPAIR("Waiting for probe to ", (wants_to_cool ? PSTR("cool down") : PSTR("heat up")), " to ", target_temp, " degrees.");
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       float old_temp = 9999;
       millis_t next_temp_ms = 0, next_delta_check_ms = 0;
       wait_for_heatup = true;

commit 3bddbb1110b6ca13a291de426553839b99cae102
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:06:55 2021 -0500

    Clean up formatting, wrap macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cd93ec1fc8..1ad0303abd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -560,37 +560,37 @@ volatile bool Temperature::raw_temps_ready = false;
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const celsius_float_t start_temp = GHV(temp_chamber.celsius, temp_bed.celsius, temp_hotend[heater_id].celsius);
+      const celsius_float_t start_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current_temp = GHV(temp_chamber.celsius, temp_bed.celsius, temp_hotend[heater_id].celsius);
+        current_temp = GHV(degChamber(), degBed(), degHotend(heater_id));
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();

commit 72e3d2492f2085efe9c5fb0b33d67c24baf8a4bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:14:49 2021 -0500

    Update temperature types

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 08583676da..cd93ec1fc8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -375,34 +375,34 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   int16_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP,
           Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
 #endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     millis_t next_cool_check_ms_2 = 0;
-    float old_temp = 9999;
+    celsius_float_t old_temp = 9999;
     int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
             Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     TERN_(WATCH_CHAMBER, chamber_watch_t Temperature::watch_chamber{0});
     IF_DISABLED(PIDTEMPCHAMBER, millis_t Temperature::next_chamber_check_ms);
   #endif
 #endif
 
 #if HAS_TEMP_COOLER
   cooler_info_t Temperature::temp_cooler; // = { 0 }
   #if HAS_COOLER
     bool flag_cooler_state;
     //bool flag_cooler_excess = false;
-    float previous_temp = 9999;
+    celsius_float_t previous_temp = 9999;
     int16_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,
             Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
     #if WATCH_COOLER
       cooler_watch_t Temperature::watch_cooler{0};
     #endif
     millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
   #endif
 #endif
 
 #if HAS_TEMP_PROBE
@@ -414,22 +414,22 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-  celsius_t Temperature::redundant_temperature_raw = 0;
-  float Temperature::redundant_temperature = 0.0;
+  int16_t Temperature::redundant_temperature_raw = 0;
+  celsius_float_t Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
@@ -501,21 +501,21 @@ volatile bool Temperature::raw_temps_ready = false;
    */
   void Temperature::PID_autotune(const_float_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
     float current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     PID_t tune_pid = { 0, 0, 0 };
-    float maxT = 0, minT = 10000;
+    celsius_float_t maxT = 0, minT = 10000;
 
     const bool isbed = (heater_id == H_BED);
     const bool ischamber = (heater_id == H_CHAMBER);
 
     #if ENABLED(PIDTEMPCHAMBER)
       #define C_TERN(T,A,B) ((T) ? (A) : (B))
     #else
       #define C_TERN(T,A,B) (B)
     #endif
     #if ENABLED(PIDTEMPBED)
@@ -537,44 +537,44 @@ volatile bool Temperature::raw_temps_ready = false;
         #define C_GTV(T,A,B) (B)
       #endif
       #if BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
         #define B_GTV(T,A,B) ((T) ? (A) : (B))
       #else
         #define B_GTV(T,A,B) (B)
       #endif
       #define GTV(C,B,H) C_GTV(ischamber, C, B_GTV(isbed, B, H))
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
-      const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
+      const celsius_float_t watch_temp_target = celsius_float_t(target - watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
-      float next_watch_temp = 0.0;
+      celsius_float_t next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
     if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
     SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = GHV(temp_chamber.celsius, temp_bed.celsius, temp_hotend[heater_id].celsius);
+      const celsius_float_t start_temp = GHV(temp_chamber.celsius, temp_bed.celsius, temp_hotend[heater_id].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
@@ -2331,21 +2331,21 @@ void Temperature::init() {
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
    * @param hysteresis_degc  allowed distance from target
    *
    * TODO: Embed the last 3 parameters during init, if not less optimal
    */
-  void Temperature::tr_state_machine_t::run(const_float_t current, const_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc) {
+  void Temperature::tr_state_machine_t::run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc) {
 
     #if HEATER_IDLE_HANDLER
       // Convert the given heater_id_t to an idle array index
       const IdleIndex idle_index = idle_index_for_id(heater_id);
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
@@ -3366,21 +3366,30 @@ void Temperature::isr() {
   endstops.poll();
 
   // Periodically call the planner timer service routine
   planner.isr();
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
-  static void print_heater_state(const_float_t c, const_float_t t
+  /**
+   * Print a single heater state in the form:
+   *        Bed: " B:nnn.nn /nnn.nn"
+   *    Chamber: " C:nnn.nn /nnn.nn"
+   *      Probe: " P:nnn.nn /nnn.nn"
+   *     Cooler: " L:nnn.nn /nnn.nn"
+   *   Extruder: " T0:nnn.nn /nnn.nn"
+   *   With ADC: " T0:nnn.nn /nnn.nn (nnn.nn)"
+   */
+  static void print_heater_state(const_celsius_float_t c, const_celsius_float_t t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const heater_id_t e=INDEX_NONE
   ) {
     char k;
     switch (e) {
       default:
         #if HAS_TEMP_HOTEND
           k = 'T'; break;
@@ -3550,26 +3559,26 @@ void Temperature::isr() {
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
-        const float start_temp = degHotend(target_extruder);
+        const celsius_float_t start_temp = degHotend(target_extruder);
         printerEventLEDs.onHotendHeatingStart();
       #endif
 
       bool wants_to_cool = false;
-      float target_temp = -1.0, old_temp = 9999.0;
+      celsius_float_t target_temp = -1.0, old_temp = 9999.0;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
       wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
           target_temp = degTargetHotend(target_extruder);
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
@@ -3585,30 +3594,30 @@ void Temperature::isr() {
               SERIAL_ECHO(long((SEC_TO_MS(TEMP_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
-        const float temp = degHotend(target_extruder);
+        const celsius_float_t temp = degHotend(target_extruder);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           // Gradually change LED strip from violet to red as nozzle heats up
           if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0
 
-          const float temp_diff = ABS(target_temp - temp);
+          const celsius_float_t temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_WINDOW)
               residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
@@ -3688,26 +3697,26 @@ void Temperature::isr() {
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
-        const float start_temp = degBed();
+        const celsius_float_t start_temp = degBed();
         printerEventLEDs.onBedHeatingStart();
       #endif
 
       bool wants_to_cool = false;
-      float target_temp = -1, old_temp = 9999;
+      celsius_float_t target_temp = -1, old_temp = 9999;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
       wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetBed()) {
           wants_to_cool = isCoolingBed();
           target_temp = degTargetBed();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
@@ -3723,30 +3732,30 @@ void Temperature::isr() {
               SERIAL_ECHO(long((SEC_TO_MS(TEMP_BED_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
-        const float temp = degBed();
+        const celsius_float_t temp = degBed();
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           // Gradually change LED strip from blue to violet as bed heats up
           if (!wants_to_cool) printerEventLEDs.onBedHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
 
-          const float temp_diff = ABS(target_temp - temp);
+          const celsius_float_t temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_BED_WINDOW)
               residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_BED_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_BED_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
@@ -4014,25 +4023,25 @@ void Temperature::isr() {
               SERIAL_ECHO(long((SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
-        const float current_temp = degCooler();
+        const celsius_float_t current_temp = degCooler();
 
         #if TEMP_COOLER_RESIDENCY_TIME > 0
 
-          const float temp_diff = ABS(target_temp - temp);
+          const celsius_float_t temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_COOLER_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_COOLER_WINDOW)
               residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_COOLER_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }

commit fd99ea09ecb41bc1dfc5e4109e0d6c7de1f87424
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 04:00:39 2021 -0500

    Add fan percent accessors

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 306f5c5886..08583676da 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -308,48 +308,48 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128, 128, 128);
   #endif
 
   /**
    * Set the print fan speed for a target extruder
    */
-  void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
+  void Temperature::set_fan_speed(uint8_t fan, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
-      if (target != active_extruder) {
-        if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
+      if (fan != active_extruder) {
+        if (fan < EXTRUDERS) singlenozzle_fan_speed[fan] = speed;
         return;
       }
     #endif
 
-    TERN_(SINGLENOZZLE, target = 0); // Always use fan index 0 with SINGLENOZZLE
+    TERN_(SINGLENOZZLE, fan = 0); // Always use fan index 0 with SINGLENOZZLE
 
-    if (target >= FAN_COUNT) return;
+    if (fan >= FAN_COUNT) return;
 
-    fan_speed[target] = speed;
+    fan_speed[fan] = speed;
 
-    TERN_(REPORT_FAN_CHANGE, report_fan_speed(target));
+    TERN_(REPORT_FAN_CHANGE, report_fan_speed(fan));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */
-    void Temperature::report_fan_speed(const uint8_t target) {
-      if (target >= FAN_COUNT) return;
+    void Temperature::report_fan_speed(const uint8_t fan) {
+      if (fan >= FAN_COUNT) return;
       PORT_REDIRECT(SerialMask::All);
-      SERIAL_ECHOLNPAIR("M106 P", target, " S", fan_speed[target]);
+      SERIAL_ECHOLNPAIR("M106 P", fan, " S", fan_speed[fan]);
     }
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }

commit 5fb3ee610140c9895be5495d84b6d853514e5e2d
Author: ellensp <ellensp@hotmail.com>
Date:   Tue Apr 13 14:02:21 2021 +1200

    Fix Max Temperature not enforced (#21592)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f0bb81bce7..306f5c5886 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2189,33 +2189,33 @@ void Temperature::init() {
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
-      const celsius_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
+      const celsius_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
-      const celsius_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
+      const celsius_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, (int)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_ ##N## THERMISTOR_ID && TEMP_SENSOR_ ##N## THERMISTOR_ID != 998 && TEMP_SENSOR_ ##N## THERMISTOR_ID != 999 && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_ ##N## _THERMISTOR_ID && TEMP_SENSOR_ ##N## _THERMISTOR_ID != 998 && TEMP_SENSOR_ ##N## _THERMISTOR_ID != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif

commit 7f56538602d5cfeb20da143e896e74c881d94d29
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Apr 13 03:28:13 2021 +0200

    Chamber Fan mode 3 (#21594)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index faa5bb5b10..f0bb81bce7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1399,20 +1399,22 @@ void Temperature::manage_heater() {
         #if ENABLED(CHAMBER_FAN)
           int16_t fan_chamber_pwm;
           #if CHAMBER_FAN_MODE == 0
             fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
             fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
+          #elif CHAMBER_FAN_MODE == 3
+            fan_chamber_pwm = CHAMBER_FAN_BASE + _MAX((CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target), 0);
           #endif
           NOMORE(fan_chamber_pwm, 225);
           set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT

commit 6ab7baa413b520fde11f588e288b391b39bf4cd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 8 15:43:16 2021 -0500

    tick() => isr() to spotlight interrupt-time

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 992681632d..faa5bb5b10 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2828,26 +2828,26 @@ void Temperature::readings_ready() {
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
- *  - Call planner.tick to count down its "ignore" time
+ *  - Call planner.isr to count down its "ignore" time
  */
 HAL_TEMP_TIMER_ISR() {
   HAL_timer_isr_prologue(TEMP_TIMER_NUM);
 
-  Temperature::tick();
+  Temperature::isr();
 
   HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
 }
 
 #if ENABLED(SLOW_PWM_HEATERS) && !defined(MIN_STATE_TIME)
   #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
 #endif
 
 class SoftPWM {
 public:
@@ -2872,21 +2872,21 @@ public:
 
 /**
  * Handle various ~1KHz tasks associated with temperature
  *  - Heater PWM (~1KHz with scaler)
  *  - LCD Button polling (~500Hz)
  *  - Start / Read one ADC sensor
  *  - Advance Babysteps
  *  - Endstop polling
  *  - Planner clean buffer
  */
-void Temperature::tick() {
+void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
 
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
@@ -3356,22 +3356,22 @@ void Temperature::tick() {
   // Additional ~1KHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
     babystep.task();
   #endif
 
   // Poll endstops state, if required
   endstops.poll();
 
-  // Periodically call the planner timer
-  planner.tick();
+  // Periodically call the planner timer service routine
+  planner.isr();
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const_float_t c, const_float_t t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif

commit 235ba926021709e293f33b7229690406761298e4
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Thu Apr 1 19:29:49 2021 -0500

    Followup to Laser Flow Meter (#21498)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 02fe7588d9..992681632d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -28,21 +28,21 @@
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 #include "../lcd/marlinui.h"
 
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
 
-#if HAS_COOLER || HAS_FLOWMETER
+#if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
@@ -1542,21 +1542,21 @@ void Temperature::manage_heater() {
       }
       WRITE_HEATER_COOLER(LOW);
     }
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
       tr_state_machine[RUNAWAY_IND_COOLER].run(temp_cooler.celsius, temp_cooler.target, H_COOLER, THERMAL_PROTECTION_COOLER_PERIOD, THERMAL_PROTECTION_COOLER_HYSTERESIS);
     #endif
 
   #endif // HAS_COOLER
 
-  #if HAS_FLOWMETER
+  #if ENABLED(LASER_COOLANT_FLOW_METER)
     cooler.flowmeter_task(ms);
     #if ENABLED(FLOWMETER_SAFETY)
       if (cutter.enabled() && cooler.check_flow_too_low()) {
         cutter.disable();
         ui.flow_fault();
       }
     #endif
   #endif
 
   UNUSED(ms);

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5a8704d3ba..02fe7588d9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -492,21 +492,21 @@ volatile bool Temperature::raw_temps_ready = false;
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
    * temperature to succeed.
    */
-  void Temperature::PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
+  void Temperature::PID_autotune(const_float_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
     float current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     PID_t tune_pid = { 0, 0, 0 };
     float maxT = 0, minT = 10000;
 
@@ -2329,21 +2329,21 @@ void Temperature::init() {
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
    * @param hysteresis_degc  allowed distance from target
    *
    * TODO: Embed the last 3 parameters during init, if not less optimal
    */
-  void Temperature::tr_state_machine_t::run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc) {
+  void Temperature::tr_state_machine_t::run(const_float_t current, const_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc) {
 
     #if HEATER_IDLE_HANDLER
       // Convert the given heater_id_t to an idle array index
       const IdleIndex idle_index = idle_index_for_id(heater_id);
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
@@ -3364,21 +3364,21 @@ void Temperature::tick() {
   endstops.poll();
 
   // Periodically call the planner timer
   planner.tick();
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
-  static void print_heater_state(const float &c, const float &t
+  static void print_heater_state(const_float_t c, const_float_t t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const heater_id_t e=INDEX_NONE
   ) {
     char k;
     switch (e) {
       default:
         #if HAS_TEMP_HOTEND
           k = 'T'; break;
@@ -3797,21 +3797,21 @@ void Temperature::tick() {
 
   #if HAS_TEMP_PROBE
 
     #ifndef MIN_DELTA_SLOPE_DEG_PROBE
       #define MIN_DELTA_SLOPE_DEG_PROBE 1.0
     #endif
     #ifndef MIN_DELTA_SLOPE_TIME_PROBE
       #define MIN_DELTA_SLOPE_TIME_PROBE 600
     #endif
 
-    bool Temperature::wait_for_probe(const float target_temp, bool no_wait_for_cooling/*=true*/) {
+    bool Temperature::wait_for_probe(const_float_t target_temp, bool no_wait_for_cooling/*=true*/) {
 
       const bool wants_to_cool = isProbeAboveTemp(target_temp);
       const bool will_wait = !(wants_to_cool && no_wait_for_cooling);
       if (will_wait)
         SERIAL_ECHOLNPAIR("Waiting for probe to ", (wants_to_cool ? PSTR("cool down") : PSTR("heat up")), " to ", target_temp, " degrees.");
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 

commit ccdbffbf3f599f0860c643647ce6c40f1eb5a4cd
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon Mar 29 01:41:56 2021 -0500

    Laser Coolant Flow Meter / Safety Shutdown (#21431)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a9b7ab13eb..5a8704d3ba 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -28,37 +28,41 @@
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 #include "../lcd/marlinui.h"
 
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
 
-#if HAS_COOLER
+#if HAS_COOLER || HAS_FLOWMETER
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../feature/host_actions.h"
+#endif
+
 // LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library
 #if LIB_USR_MAX31855
   #include <Adafruit_MAX31855.h>
   #if PIN_EXISTS(MAX31855_MISO) && PIN_EXISTS(MAX31855_SCK)
     #define MAX31855_USES_SW_SPI 1
   #endif
   #if TEMP_SENSOR_0_IS_MAX31855 && PIN_EXISTS(MAX31855_CS)
     #define HAS_MAX31855_TEMP 1
     Adafruit_MAX31855 max31855_0 = Adafruit_MAX31855(MAX31855_CS_PIN
       #if MAX31855_USES_SW_SPI
@@ -1499,21 +1503,21 @@ void Temperature::manage_heater() {
       if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
         if (degCooler() > watch_cooler.target)    // Failed to decrease enough?
           _temp_error(H_COOLER, GET_TEXT(MSG_COOLING_FAILED), GET_TEXT(MSG_COOLING_FAILED));
         else
           start_watching_cooler();                 // Start again if the target is still far off
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
-    if (cooler.is_enabled()) {
+    if (cooler.enabled) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
       if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
       if (ELAPSED(ms, next_cooler_check_ms)) {
         next_cooler_check_ms = ms + COOLER_CHECK_INTERVAL;
         if (temp_cooler.celsius > temp_cooler.target) {
           temp_cooler.soft_pwm_amount = temp_cooler.celsius > temp_cooler.target ? MAX_COOLER_POWER : 0;
           flag_cooler_state = temp_cooler.soft_pwm_amount > 0 ? true : false; // used to allow M106 fan control when cooler is disabled
           #if ENABLED(COOLER_FAN)
             int16_t fan_cooler_pwm = (COOLER_FAN_BASE) + (COOLER_FAN_FACTOR) * ABS(temp_cooler.celsius - temp_cooler.target);
             NOMORE(fan_cooler_pwm, 255);
@@ -1535,22 +1539,33 @@ void Temperature::manage_heater() {
       if (flag_cooler_state) {
         flag_cooler_state = false;
         thermalManager.set_fan_speed(COOLER_FAN_INDEX, 0);
       }
       WRITE_HEATER_COOLER(LOW);
     }
 
     #if ENABLED(THERMAL_PROTECTION_COOLER)
       tr_state_machine[RUNAWAY_IND_COOLER].run(temp_cooler.celsius, temp_cooler.target, H_COOLER, THERMAL_PROTECTION_COOLER_PERIOD, THERMAL_PROTECTION_COOLER_HYSTERESIS);
     #endif
+
   #endif // HAS_COOLER
 
+  #if HAS_FLOWMETER
+    cooler.flowmeter_task(ms);
+    #if ENABLED(FLOWMETER_SAFETY)
+      if (cutter.enabled() && cooler.check_flow_too_low()) {
+        cutter.disable();
+        ui.flow_fault();
+      }
+    #endif
+  #endif
+
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */

commit 30e7e2c2766d7dbbe0144344287994f1969dfadd
Author: Martijn Bosgraaf <drywfiltiarn+github@gmail.com>
Date:   Wed Mar 24 18:21:11 2021 +0100

    Extend M106/M107 for better laser module support (#16082)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index da792db833..a9b7ab13eb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -190,21 +190,21 @@
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_SERVOS
-  #include "./servo.h"
+  #include "servo.h"
 #endif
 
 #if ANY(TEMP_SENSOR_0_IS_THERMISTOR, TEMP_SENSOR_1_IS_THERMISTOR, TEMP_SENSOR_2_IS_THERMISTOR, TEMP_SENSOR_3_IS_THERMISTOR, \
         TEMP_SENSOR_4_IS_THERMISTOR, TEMP_SENSOR_5_IS_THERMISTOR, TEMP_SENSOR_6_IS_THERMISTOR, TEMP_SENSOR_7_IS_THERMISTOR )
   #define HAS_HOTEND_THERMISTOR 1
 #endif
 
 #if HAS_HOTEND_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static const temp_entry_t* heater_ttbl_map[2] = { TEMPTABLE_0, TEMPTABLE_1 };

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6d1f3bd0a3..da792db833 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2488,21 +2488,21 @@ void Temperature::disable_all_heaters() {
 
   void Temperature::singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool) {
     #if HAS_FAN
       singlenozzle_fan_speed[old_tool] = fan_speed[0];
       fan_speed[0] = singlenozzle_fan_speed[new_tool];
     #endif
     singlenozzle_temp[old_tool] = temp_hotend[0].target;
     if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
       setTargetHotend(singlenozzle_temp[new_tool], 0);
       TERN_(AUTOTEMP, planner.autotemp_update());
-      TERN_(HAS_DISPLAY, set_heating_message(0));
+      TERN_(HAS_STATUS_MESSAGE, set_heating_message(0));
       (void)wait_for_hotend(0, false);  // Wait for heating or cooling
     }
   }
 
 #endif
 
 #if HAS_MAX_TC
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
@@ -3485,21 +3485,21 @@ void Temperature::tick() {
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
     void Temperature::AutoReportTemp::report() {
       print_heater_states(active_extruder);
       SERIAL_EOL();
     }
   #endif
 
-  #if HAS_HOTEND && HAS_DISPLAY
+  #if HAS_HOTEND && HAS_STATUS_MESSAGE
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HAS_MULTI_HOTEND
           PSTR("E%c " S_FMT), '1' + e
         #else
           PSTR("E " S_FMT)
         #endif
         , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index dd7a36a82a..6d1f3bd0a3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -246,21 +246,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
-  const uint16_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+  const celsius_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
@@ -361,82 +361,70 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #if WATCH_HOTENDS
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
   Temperature::heater_idle_t Temperature::heater_idle[NR_HEATER_IDLE]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
-  #ifdef BED_MINTEMP
-    int16_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP;
-  #endif
-  #ifdef BED_MAXTEMP
-    int16_t Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
-  #endif
+  int16_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP,
+          Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
 #endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     millis_t next_cool_check_ms_2 = 0;
     float old_temp = 9999;
-    #ifdef CHAMBER_MINTEMP
-      int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP;
-    #endif
-    #ifdef CHAMBER_MAXTEMP
-      int16_t Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
-    #endif
+    int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP,
+            Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     TERN_(WATCH_CHAMBER, chamber_watch_t Temperature::watch_chamber{0});
     IF_DISABLED(PIDTEMPCHAMBER, millis_t Temperature::next_chamber_check_ms);
   #endif
 #endif
 
 #if HAS_TEMP_COOLER
   cooler_info_t Temperature::temp_cooler; // = { 0 }
   #if HAS_COOLER
     bool flag_cooler_state;
     //bool flag_cooler_excess = false;
     float previous_temp = 9999;
-    #ifdef COOLER_MINTEMP
-      int16_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP;
-    #endif
-    #ifdef COOLER_MAXTEMP
-      int16_t Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
-    #endif
+    int16_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP,
+            Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
     #if WATCH_COOLER
       cooler_watch_t Temperature::watch_cooler{0};
     #endif
     millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
   #endif
 #endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
-  int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
+  celsius_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-  uint16_t Temperature::redundant_temperature_raw = 0;
+  celsius_t Temperature::redundant_temperature_raw = 0;
   float Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
@@ -467,21 +455,21 @@ volatile bool Temperature::raw_temps_ready = false;
 #if HAS_AUTO_FAN
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
-  uint16_t Temperature::singlenozzle_temp[EXTRUDERS];
+  celsius_t Temperature::singlenozzle_temp[EXTRUDERS];
   #if HAS_FAN
     uint8_t Temperature::singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
@@ -1559,36 +1547,36 @@ void Temperature::manage_heater() {
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
-#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                            \
-  uint8_t l = 0, r = LEN, m;                                          \
-  for (;;) {                                                          \
-    m = (l + r) >> 1;                                                 \
-    if (!m) return int16_t(pgm_read_word(&TBL[0].celsius));           \
-    if (m == l || m == r) return int16_t(pgm_read_word(&TBL[LEN-1].celsius)); \
-    int16_t v00 = pgm_read_word(&TBL[m-1].value),                     \
-          v10 = pgm_read_word(&TBL[m-0].value);                       \
-         if (raw < v00) r = m;                                        \
-    else if (raw > v10) l = m;                                        \
-    else {                                                            \
-      const int16_t v01 = int16_t(pgm_read_word(&TBL[m-1].celsius)),  \
-                  v11 = int16_t(pgm_read_word(&TBL[m-0].celsius));    \
-      return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00); \
-    }                                                                 \
-  }                                                                   \
+#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                                \
+  uint8_t l = 0, r = LEN, m;                                              \
+  for (;;) {                                                              \
+    m = (l + r) >> 1;                                                     \
+    if (!m) return celsius_t(pgm_read_word(&TBL[0].celsius));             \
+    if (m == l || m == r) return celsius_t(pgm_read_word(&TBL[LEN-1].celsius)); \
+    int16_t v00 = pgm_read_word(&TBL[m-1].value),                         \
+            v10 = pgm_read_word(&TBL[m-0].value);                         \
+         if (raw < v00) r = m;                                            \
+    else if (raw > v10) l = m;                                            \
+    else {                                                                \
+      const celsius_t v01 = celsius_t(pgm_read_word(&TBL[m-1].celsius)),  \
+                      v11 = celsius_t(pgm_read_word(&TBL[m-0].celsius));  \
+      return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);     \
+    }                                                                     \
+  }                                                                       \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
     user_thermistor_t default_user_thermistor[USER_THERMISTORS] = {
       #if TEMP_SENSOR_0_IS_CUSTOM
         { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
@@ -1656,21 +1644,21 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
-  float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
+  celsius_t Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
     //#endif
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
     user_thermistor_t &t = user_thermistor[t_index];
     if (t.pre_calc) { // pre-calculate some variables
@@ -1705,21 +1693,21 @@ void Temperature::manage_heater() {
     //#endif
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
-  float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
+  celsius_t Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
       if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
         SERIAL_ECHO(e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
@@ -1814,75 +1802,75 @@ void Temperature::manage_heater() {
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // For bed temperature measurement.
-  float Temperature::analog_to_celsius_bed(const int raw) {
+  celsius_t Temperature::analog_to_celsius_bed(const int raw) {
     #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif TEMP_SENSOR_BED_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
     #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // For chamber temperature measurement.
-  float Temperature::analog_to_celsius_chamber(const int raw) {
+  celsius_t Temperature::analog_to_celsius_chamber(const int raw) {
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif TEMP_SENSOR_CHAMBER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_CHAMBER, TEMPTABLE_CHAMBER_LEN);
     #elif TEMP_SENSOR_CHAMBER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_CHAMBER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_COOLER
   // For cooler temperature measurement.
-  float Temperature::analog_to_celsius_cooler(const int raw) {
+  celsius_t Temperature::analog_to_celsius_cooler(const int raw) {
     #if TEMP_SENSOR_COOLER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_COOLER, raw);
     #elif TEMP_SENSOR_COOLER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_COOLER, TEMPTABLE_COOLER_LEN);
     #elif TEMP_SENSOR_COOLER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_COOLER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_COOLER
 
 #if HAS_TEMP_PROBE
   // For probe temperature measurement.
-  float Temperature::analog_to_celsius_probe(const int raw) {
+  celsius_t Temperature::analog_to_celsius_probe(const int raw) {
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
     #elif TEMP_SENSOR_PROBE_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_PROBE, TEMPTABLE_PROBE_LEN);
     #elif TEMP_SENSOR_PROBE_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
@@ -2184,27 +2172,27 @@ void Temperature::init() {
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
-      const int16_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, (int16_t)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
+      const celsius_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
-      const int16_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, (int16_t)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
+      const celsius_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
     #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_ ##N## THERMISTOR_ID && TEMP_SENSOR_ ##N## THERMISTOR_ID != 998 && TEMP_SENSOR_ ##N## THERMISTOR_ID != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
@@ -2250,44 +2238,32 @@ void Temperature::init() {
     #if _MINMAX_TEST(7, MIN)
       _TEMP_MIN_E(7);
     #endif
     #if _MINMAX_TEST(7, MAX)
       _TEMP_MAX_E(7);
     #endif
 
   #endif // HAS_HOTEND
 
   #if HAS_HEATED_BED
-    #ifdef BED_MINTEMP
-      while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
-    #endif
-    #ifdef BED_MAXTEMP
-      while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
-    #endif
-  #endif // HAS_HEATED_BED
+    while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
+    while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
+  #endif
 
   #if HAS_HEATED_CHAMBER
-    #ifdef CHAMBER_MINTEMP
-      while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
-    #endif
-    #ifdef CHAMBER_MAXTEMP
-      while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
-    #endif
+    while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
+    while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
   #endif
 
   #if HAS_COOLER
-    #ifdef COOLER_MINTEMP
-      while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
-    #endif
-    #ifdef COOLER_MAXTEMP
-      while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
-    #endif
+    while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
+    while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
   #endif
 
   TERN_(PROBING_HEATERS_OFF, paused = false);
 }
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
@@ -2338,21 +2314,21 @@ void Temperature::init() {
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
    * @param hysteresis_degc  allowed distance from target
    *
    * TODO: Embed the last 3 parameters during init, if not less optimal
    */
-  void Temperature::tr_state_machine_t::run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
+  void Temperature::tr_state_machine_t::run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc) {
 
     #if HEATER_IDLE_HANDLER
       // Convert the given heater_id_t to an idle array index
       const IdleIndex idle_index = idle_index_for_id(heater_id);
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
@@ -2547,21 +2523,21 @@ void Temperature::disable_all_heaters() {
       #define MAX_TC_SPEED_BITS    3        //  (_BV(SPR1)) // clock √∑ 64
     #else
       static uint16_t max_tc_temp = 2000;
       #define MAX_TC_ERROR_MASK    4
       #define MAX_TC_DISCARD_BITS  3
       #define MAX_TC_SPEED_BITS    2        // (_BV(SPR0)) // clock √∑ 16
     #endif
 
     #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
-      static uint16_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
+      static celsius_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
       #define THERMO_TEMP(I) max_tc_temp_previous[I]
       #define THERMO_SEL(A,B) (hindex ? (B) : (A))
       #define MAX6675_WRITE(V)     do{ switch (hindex) { case 1:      WRITE(MAX6675_SS2_PIN, V); break; default:      WRITE(MAX6675_SS_PIN, V); } }while(0)
       #define MAX6675_SET_OUTPUT() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN);    break; default: SET_OUTPUT(MAX6675_SS_PIN);    } }while(0)
     #else
       constexpr uint8_t hindex = 0;
       #define THERMO_TEMP(I) max_tc_temp
       #if TEMP_SENSOR_1_IS_MAX31865
         #define THERMO_SEL(A,B) B
       #else

commit f7aaa2e1c758dae56fb0d3dbb743a1c5c04245d2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:39:05 2021 -0500

    Add typedef extra_fan_t

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 16553193ec..dd7a36a82a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -266,33 +266,40 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed; // = 0
 #endif
 
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
-    uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
 
-    void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
-      switch (tmp_temp) {
+    Temperature::extra_fan_t Temperature::extra_fan_speed[FAN_COUNT];
+
+    /**
+     * Handle the M106 P<fan> T<speed> command:
+     *  T1       = Restore fan speed saved on the last T2
+     *  T2       = Save the fan speed, then set to the last T<3-255> value
+     *  T<3-255> = Set the "extra fan speed"
+     */
+    void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t command_or_speed) {
+      switch (command_or_speed) {
         case 1:
-          set_fan_speed(fan, old_fan_speed[fan]);
+          set_fan_speed(fan, extra_fan_speed[fan].saved);
           break;
         case 2:
-          old_fan_speed[fan] = fan_speed[fan];
-          set_fan_speed(fan, new_fan_speed[fan]);
+          extra_fan_speed[fan].saved = fan_speed[fan];
+          set_fan_speed(fan, extra_fan_speed[fan].speed);
           break;
         default:
-          new_fan_speed[fan] = _MIN(tmp_temp, 255U);
+          extra_fan_speed[fan].speed = _MIN(command_or_speed, 255U);
           break;
       }
     }
 
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
     uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif

commit cfa6c7d45ba72d1a0b26e6308191e008dcd0d9c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:34:10 2021 -0500

    Improve max temp / target

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a000a31de7..16553193ec 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -246,34 +246,35 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
-  const uint16_t Temperature::heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+  const uint16_t Temperature::hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if ENABLED(AUTO_POWER_COOLER_FAN)
   uint8_t Temperature::coolerfan_speed; // = 0
 #endif
+
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
     uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
 
     void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
       switch (tmp_temp) {
         case 1:
@@ -545,21 +546,21 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
-    if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - HOTEND_OVERSHOOT)) {
+    if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - (HOTEND_OVERSHOOT))) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
@@ -1505,21 +1506,21 @@ void Temperature::manage_heater() {
           _temp_error(H_COOLER, GET_TEXT(MSG_COOLING_FAILED), GET_TEXT(MSG_COOLING_FAILED));
         else
           start_watching_cooler();                 // Start again if the target is still far off
       }
     #endif
 
     static bool flag_cooler_state; // = false
 
     if (cooler.is_enabled()) {
       flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
-      if (temp_cooler.target == 0) temp_cooler.target = COOLER_MINTEMP;
+      if (temp_cooler.target == 0) temp_cooler.target = COOLER_MIN_TARGET;
       if (ELAPSED(ms, next_cooler_check_ms)) {
         next_cooler_check_ms = ms + COOLER_CHECK_INTERVAL;
         if (temp_cooler.celsius > temp_cooler.target) {
           temp_cooler.soft_pwm_amount = temp_cooler.celsius > temp_cooler.target ? MAX_COOLER_POWER : 0;
           flag_cooler_state = temp_cooler.soft_pwm_amount > 0 ? true : false; // used to allow M106 fan control when cooler is disabled
           #if ENABLED(COOLER_FAN)
             int16_t fan_cooler_pwm = (COOLER_FAN_BASE) + (COOLER_FAN_FACTOR) * ABS(temp_cooler.celsius - temp_cooler.target);
             NOMORE(fan_cooler_pwm, 255);
             set_fan_speed(COOLER_FAN_INDEX, fan_cooler_pwm); // Set cooler fan pwm
             cooler_fan_flush_ms = ms + 5000;

commit 55c31fbe9a70710c6a209d40b7d0165d081dcdd0
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Mar 9 10:20:37 2021 +0100

    Distinguish serial index from mask (#21287)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a1d5745de4..a000a31de7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -322,21 +322,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(target));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */
     void Temperature::report_fan_speed(const uint8_t target) {
       if (target >= FAN_COUNT) return;
-      PORT_REDIRECT(SERIAL_ALL);
+      PORT_REDIRECT(SerialMask::All);
       SERIAL_ECHOLNPAIR("M106 P", target, " S", fan_speed[target]);
     }
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)

commit b95e548ddbcbc1c088eabc17992d0a06f82ac167
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Mar 6 14:13:28 2021 -0600

    Cooler (for Laser) - M143, M193 (#21255)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index be98972b77..a1d5745de4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -28,20 +28,25 @@
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 #include "../lcd/marlinui.h"
 
 #include "temperature.h"
 #include "endstops.h"
 #include "planner.h"
 
+#if HAS_COOLER
+  #include "../feature/cooler.h"
+  #include "../feature/spindle_laser.h"
+#endif
+
 #if ENABLED(EMERGENCY_PARSER)
   #include "motion.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
@@ -225,42 +230,50 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #if HAS_HEATED_BED
   #define _BED_PSTR(h) (h) == H_BED ? GET_TEXT(MSG_BED) :
 #else
   #define _BED_PSTR(h)
 #endif
 #if HAS_HEATED_CHAMBER
   #define _CHAMBER_PSTR(h) (h) == H_CHAMBER ? GET_TEXT(MSG_CHAMBER) :
 #else
   #define _CHAMBER_PSTR(h)
 #endif
+#if HAS_COOLER
+  #define _COOLER_PSTR(h) (h) == H_COOLER ? GET_TEXT(MSG_COOLER) :
+#else
+  #define _COOLER_PSTR(h)
+#endif
 #define _E_PSTR(h,N) ((HOTENDS) > N && (h) == N) ? PSTR(LCD_STR_E##N) :
-#define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
+#define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _COOLER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
   const uint16_t Temperature::heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
+#if ENABLED(AUTO_POWER_COOLER_FAN)
+  uint8_t Temperature::coolerfan_speed; // = 0
+#endif
 #if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
     uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
 
     void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
       switch (tmp_temp) {
         case 1:
@@ -348,40 +361,56 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
     int16_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
   #endif
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
-#endif // HAS_HEATED_BED
+#endif
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
-    int16_t fan_chamber_pwm;
-    bool flag_chamber_off;
-    bool flag_chamber_excess_heat = false;
     millis_t next_cool_check_ms_2 = 0;
     float old_temp = 9999;
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     #endif
     TERN_(WATCH_CHAMBER, chamber_watch_t Temperature::watch_chamber{0});
     IF_DISABLED(PIDTEMPCHAMBER, millis_t Temperature::next_chamber_check_ms);
-  #endif // HAS_HEATED_CHAMBER
-#endif // HAS_TEMP_CHAMBER
+  #endif
+#endif
+
+#if HAS_TEMP_COOLER
+  cooler_info_t Temperature::temp_cooler; // = { 0 }
+  #if HAS_COOLER
+    bool flag_cooler_state;
+    //bool flag_cooler_excess = false;
+    float previous_temp = 9999;
+    #ifdef COOLER_MINTEMP
+      int16_t Temperature::mintemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_LO_TEMP;
+    #endif
+    #ifdef COOLER_MAXTEMP
+      int16_t Temperature::maxtemp_raw_COOLER = TEMP_SENSOR_COOLER_RAW_HI_TEMP;
+    #endif
+    #if WATCH_COOLER
+      cooler_watch_t Temperature::watch_cooler{0};
+    #endif
+    millis_t Temperature::next_cooler_check_ms, Temperature::cooler_fan_flush_ms;
+  #endif
+#endif
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
@@ -737,20 +766,23 @@ volatile bool Temperature::raw_temps_ready = false;
  */
 
 int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
+    #if HAS_COOLER
+      case H_COOLER: return temp_cooler.soft_pwm_amount;
+    #endif
     default:
       return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
 
   #define CHAMBER_FAN_INDEX HOTENDS
@@ -772,20 +804,25 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
     uint8_t fanState = 0;
     HOTEND_LOOP()
       if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
+    #if HAS_AUTO_COOLER_FAN
+      if (temp_cooler.celsius >= COOLER_AUTO_FAN_TEMPERATURE)
+        SBI(fanState, pgm_read_byte(&fanBit[COOLER_FAN_INDEX]));
+    #endif
+
     #define _UPDATE_AUTO_FAN(P,D,A) do{                  \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)          \
         analogWrite(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                               \
         WRITE(P##_AUTO_FAN_PIN, D);                      \
     }while(0)
 
     uint8_t fanDone = 0;
     LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
@@ -867,20 +904,22 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOPGM_P(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
     if (heater_id >= 0)
       SERIAL_ECHO(heater_id);
     else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER))
       SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
+    else if (TERN0(HAS_COOLER, heater_id == H_COOLER))
+      SERIAL_ECHOPGM(STR_COOLER);
     else
       SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   watchdog_refresh();
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
@@ -1340,25 +1379,32 @@ void Temperature::manage_heater() {
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
           _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
+    #if EITHER(CHAMBER_FAN, CHAMBER_VENT) || DISABLED(PIDTEMPCHAMBER)
+      static bool flag_chamber_excess_heat; // = false;
+    #endif
+
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
+      static bool flag_chamber_off; // = false
+
       if (temp_chamber.target > CHAMBER_MINTEMP) {
         flag_chamber_off = false;
 
         #if ENABLED(CHAMBER_FAN)
+          int16_t fan_chamber_pwm;
           #if CHAMBER_FAN_MODE == 0
             fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
             fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #endif
           NOMORE(fan_chamber_pwm, 225);
@@ -1369,57 +1415,54 @@ void Temperature::manage_heater() {
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
           if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {
             // Open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds if the
             // temperature didn't drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             if (next_cool_check_ms_2 == 0 || ELAPSED(ms, next_cool_check_ms_2)) {
-              if (old_temp - temp_chamber.celsius < float(MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)) flag_chamber_excess_heat = true; //the bed is heating the chamber too much
+              if (temp_chamber.celsius - old_temp > MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)
+                flag_chamber_excess_heat = true; // the bed is heating the chamber too much
               next_cool_check_ms_2 = ms + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER_VENT);
               old_temp = temp_chamber.celsius;
             }
           }
           else {
             next_cool_check_ms_2 = 0;
             old_temp = 9999;
           }
-          if (flag_chamber_excess_heat && (temp_chamber.celsius - temp_chamber.target <= -LOW_EXCESS_HEAT_LIMIT) ) {
+          if (flag_chamber_excess_heat && (temp_chamber.target - temp_chamber.celsius >= LOW_EXCESS_HEAT_LIMIT))
             flag_chamber_excess_heat = false;
-          }
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
           set_fan_speed(2, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
           MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
         #endif
       }
     #endif
 
-
-
-
     #if ENABLED(PIDTEMPCHAMBER)
       // PIDTEMPCHAMBER doens't support a CHAMBER_VENT yet.
       temp_chamber.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
     #else
-    if (ELAPSED(ms, next_chamber_check_ms)) {
-      next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
+      if (ELAPSED(ms, next_chamber_check_ms)) {
+        next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
-      if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
+        if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
           if (flag_chamber_excess_heat) {
             temp_chamber.soft_pwm_amount = 0;
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
             #endif
           }
           else {
             #if ENABLED(CHAMBER_LIMIT_SWITCHING)
               if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
                 temp_chamber.soft_pwm_amount = 0;
@@ -1430,29 +1473,88 @@ void Temperature::manage_heater() {
             #endif
             #if ENABLED(CHAMBER_VENT)
               if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 0);
             #endif
           }
         }
         else {
           temp_chamber.soft_pwm_amount = 0;
           WRITE_HEATER_CHAMBER(LOW);
         }
-
      }
      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
        tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
      #endif
    #endif
 
   #endif // HAS_HEATED_CHAMBER
 
+  #if HAS_COOLER
+
+    #ifndef COOLER_CHECK_INTERVAL
+      #define COOLER_CHECK_INTERVAL 2000UL
+    #endif
+
+    #if ENABLED(THERMAL_PROTECTION_COOLER)
+      if (degCooler() > COOLER_MAXTEMP) max_temp_error(H_COOLER);
+    #endif
+
+    #if WATCH_COOLER
+      // Make sure temperature is decreasing
+      if (watch_cooler.elapsed(ms)) {             // Time to check the cooler?
+        if (degCooler() > watch_cooler.target)    // Failed to decrease enough?
+          _temp_error(H_COOLER, GET_TEXT(MSG_COOLING_FAILED), GET_TEXT(MSG_COOLING_FAILED));
+        else
+          start_watching_cooler();                 // Start again if the target is still far off
+      }
+    #endif
+
+    static bool flag_cooler_state; // = false
+
+    if (cooler.is_enabled()) {
+      flag_cooler_state = true; // used to allow M106 fan control when cooler is disabled
+      if (temp_cooler.target == 0) temp_cooler.target = COOLER_MINTEMP;
+      if (ELAPSED(ms, next_cooler_check_ms)) {
+        next_cooler_check_ms = ms + COOLER_CHECK_INTERVAL;
+        if (temp_cooler.celsius > temp_cooler.target) {
+          temp_cooler.soft_pwm_amount = temp_cooler.celsius > temp_cooler.target ? MAX_COOLER_POWER : 0;
+          flag_cooler_state = temp_cooler.soft_pwm_amount > 0 ? true : false; // used to allow M106 fan control when cooler is disabled
+          #if ENABLED(COOLER_FAN)
+            int16_t fan_cooler_pwm = (COOLER_FAN_BASE) + (COOLER_FAN_FACTOR) * ABS(temp_cooler.celsius - temp_cooler.target);
+            NOMORE(fan_cooler_pwm, 255);
+            set_fan_speed(COOLER_FAN_INDEX, fan_cooler_pwm); // Set cooler fan pwm
+            cooler_fan_flush_ms = ms + 5000;
+          #endif
+        }
+        else {
+          temp_cooler.soft_pwm_amount = 0;
+          #if ENABLED(COOLER_FAN)
+            set_fan_speed(COOLER_FAN_INDEX, temp_cooler.celsius > temp_cooler.target - 2 ? COOLER_FAN_BASE : 0);
+          #endif
+          WRITE_HEATER_COOLER(LOW);
+        }
+      }
+    }
+    else {
+      temp_cooler.soft_pwm_amount = 0;
+      if (flag_cooler_state) {
+        flag_cooler_state = false;
+        thermalManager.set_fan_speed(COOLER_FAN_INDEX, 0);
+      }
+      WRITE_HEATER_COOLER(LOW);
+    }
+
+    #if ENABLED(THERMAL_PROTECTION_COOLER)
+      tr_state_machine[RUNAWAY_IND_COOLER].run(temp_cooler.celsius, temp_cooler.target, H_COOLER, THERMAL_PROTECTION_COOLER_PERIOD, THERMAL_PROTECTION_COOLER_HYSTERESIS);
+    #endif
+  #endif // HAS_COOLER
+
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
@@ -1503,20 +1605,23 @@ void Temperature::manage_heater() {
       #endif
       #if TEMP_SENSOR_7_IS_CUSTOM
         { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
       #endif
       #if TEMP_SENSOR_BED_IS_CUSTOM
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
       #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
       #endif
+      #if TEMP_SENSOR_COOLER_IS_CUSTOM
+        { true, 0, 0, COOLER_PULLUP_RESISTOR_OHMS, COOLER_RESISTANCE_25C_OHMS, 0, 0, COOLER_BETA, 0 }
+      #endif
       #if TEMP_SENSOR_PROBE_IS_CUSTOM
         { true, 0, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 }
       #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
@@ -1536,20 +1641,21 @@ void Temperature::manage_heater() {
       TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
       TERN_(TEMP_SENSOR_1_IS_CUSTOM, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
       TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
       TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
       TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
       TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
       TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
+      TERN_(TEMP_SENSOR_COOLER_IS_CUSTOM, t_index == CTI_COOLER ? PSTR("COOLER") :)
       TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
@@ -1699,59 +1805,74 @@ void Temperature::manage_heater() {
       // Thermistor with conversion table?
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
-  // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
     #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif TEMP_SENSOR_BED_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
     #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
-  // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif TEMP_SENSOR_CHAMBER_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_CHAMBER, TEMPTABLE_CHAMBER_LEN);
     #elif TEMP_SENSOR_CHAMBER_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_CHAMBER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
+#if HAS_TEMP_COOLER
+  // For cooler temperature measurement.
+  float Temperature::analog_to_celsius_cooler(const int raw) {
+    #if TEMP_SENSOR_COOLER_IS_CUSTOM
+      return user_thermistor_to_deg_c(CTI_COOLER, raw);
+    #elif TEMP_SENSOR_COOLER_IS_THERMISTOR
+      SCAN_THERMISTOR_TABLE(TEMPTABLE_COOLER, TEMPTABLE_COOLER_LEN);
+    #elif TEMP_SENSOR_COOLER_IS_AD595
+      return TEMP_AD595(raw);
+    #elif TEMP_SENSOR_COOLER_IS_AD8495
+      return TEMP_AD8495(raw);
+    #else
+      UNUSED(raw);
+      return 0;
+    #endif
+  }
+#endif // HAS_TEMP_COOLER
+
 #if HAS_TEMP_PROBE
-  // Derived from RepRap FiveD extruder::getTemperature()
   // For probe temperature measurement.
   float Temperature::analog_to_celsius_probe(const int raw) {
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
     #elif TEMP_SENSOR_PROBE_IS_THERMISTOR
       SCAN_THERMISTOR_TABLE(TEMPTABLE_PROBE, TEMPTABLE_PROBE_LEN);
     #elif TEMP_SENSOR_PROBE_IS_AD595
       return TEMP_AD595(raw);
     #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
@@ -1769,20 +1890,21 @@ void Temperature::manage_heater() {
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
   TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
   TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
+  TERN_(HAS_TEMP_COOLER, temp_cooler.celsius = analog_to_celsius_cooler(temp_cooler.raw));
   TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
   TERN_(TEMP_SENSOR_1_AS_REDUNDANT, redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1));
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
@@ -1920,20 +2042,24 @@ void Temperature::init() {
       OUT_WRITE_OD(HEATER_BED_PIN, HEATER_BED_INVERTING);
     #else
       OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
     #endif
   #endif
 
   #if HAS_HEATED_CHAMBER
     OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
   #endif
 
+  #if HAS_COOLER
+    OUT_WRITE(COOLER_PIN, COOLER_INVERTING);
+  #endif
+
   #if HAS_FAN0
     INIT_FAN_PIN(FAN_PIN);
   #endif
   #if HAS_FAN1
     INIT_FAN_PIN(FAN1_PIN);
   #endif
   #if HAS_FAN2
     INIT_FAN_PIN(FAN2_PIN);
   #endif
   #if HAS_FAN3
@@ -1994,20 +2120,23 @@ void Temperature::init() {
   #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
   #if HAS_TEMP_ADC_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
+  #if HAS_TEMP_ADC_COOLER
+    HAL_ANALOG_SELECT(TEMP_COOLER_PIN);
+  #endif
   #if HAS_TEMP_ADC_PROBE
     HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
@@ -2130,20 +2259,29 @@ void Temperature::init() {
 
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
     #ifdef CHAMBER_MAXTEMP
       while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
   #endif
 
+  #if HAS_COOLER
+    #ifdef COOLER_MINTEMP
+      while (analog_to_celsius_cooler(mintemp_raw_COOLER) > COOLER_MINTEMP) mintemp_raw_COOLER += TEMPDIR(COOLER) * (OVERSAMPLENR);
+    #endif
+    #ifdef COOLER_MAXTEMP
+      while (analog_to_celsius_cooler(maxtemp_raw_COOLER) < COOLER_MAXTEMP) maxtemp_raw_COOLER -= TEMPDIR(COOLER) * (OVERSAMPLENR);
+    #endif
+  #endif
+
   TERN_(PROBING_HEATERS_OFF, paused = false);
 }
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_hotend(const uint8_t E_NAME) {
@@ -2167,20 +2305,31 @@ void Temperature::init() {
   /**
    * Start Heating Sanity Check for chamber that is below
    * its target temperature by a configurable margin.
    * This is called when the temperature is set. (M141, M191)
    */
   void Temperature::start_watching_chamber() {
     watch_chamber.restart(degChamber(), degTargetChamber());
   }
 #endif
 
+#if WATCH_COOLER
+  /**
+   * Start Cooling Sanity Check for cooler that is above
+   * its target temperature by a configurable margin.
+   * This is called when the temperature is set. (M143, M193)
+   */
+  void Temperature::start_watching_cooler() {
+    watch_cooler.restart(degCooler(), degTargetCooler());
+  }
+#endif
+
 #if HAS_THERMAL_PROTECTION
 
   Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
   /**
    * @brief Thermal Runaway state machine for a single heater
    * @param current          current measured temperature
    * @param target           current target temperature
    * @param heater_id        extruder index
    * @param period_seconds   missed temperature allowed time
@@ -2294,24 +2443,32 @@ void Temperature::disable_all_heaters() {
     setTargetBed(0);
     temp_bed.soft_pwm_amount = 0;
     WRITE_HEATER_BED(LOW);
   #endif
 
   #if HAS_HEATED_CHAMBER
     setTargetChamber(0);
     temp_chamber.soft_pwm_amount = 0;
     WRITE_HEATER_CHAMBER(LOW);
   #endif
+
+  #if HAS_COOLER
+    setTargetCooler(0);
+    temp_cooler.soft_pwm_amount = 0;
+    WRITE_HEATER_COOLER(LOW);
+  #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
+  #include "printcounter.h"
+
   bool Temperature::auto_job_over_threshold() {
     #if HAS_HOTEND
       HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;
     #endif
     return TERN0(HAS_HEATED_BED, degTargetBed() > BED_MINTEMP)
         || TERN0(HAS_HEATED_CHAMBER, degTargetChamber() > CHAMBER_MINTEMP);
   }
 
   void Temperature::auto_job_check_timer(const bool can_start, const bool can_stop) {
     if (auto_job_over_threshold()) {
@@ -2557,20 +2714,21 @@ void Temperature::update_raw_temperatures() {
 
   TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
   TERN_(HAS_TEMP_ADC_BED, temp_bed.update());
   TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
   TERN_(HAS_TEMP_ADC_PROBE, temp_probe.update());
+  TERN_(HAS_TEMP_ADC_COOLER, temp_cooler.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 
   raw_temps_ready = true;
 }
 
 void Temperature::readings_ready() {
 
@@ -2581,20 +2739,21 @@ void Temperature::readings_ready() {
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.reading_ready());
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
     TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_hotend[1].reset());
   #endif
 
   TERN_(HAS_HEATED_BED, temp_bed.reset());
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE, temp_probe.reset());
+  TERN_(HAS_TEMP_COOLER, temp_cooler.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 
   #if HAS_HOTEND
 
     static constexpr int8_t temp_dir[] = {
       TERN(TEMP_SENSOR_0_IS_MAX_TC, 0, TEMPDIR(0))
       #if HAS_MULTI_HOTEND
@@ -2643,20 +2802,32 @@ void Temperature::readings_ready() {
   #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>(B))
     #endif
     const bool chamber_on = (temp_chamber.target > 0);
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
     if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
   #endif
+
+  #if BOTH(HAS_COOLER, THERMAL_PROTECTION_COOLER)
+    #if TEMPDIR(COOLER) < 0
+      #define COOLERCMP(A,B) ((A)<(B))
+    #else
+      #define COOLERCMP(A,B) ((A)>(B))
+    #endif
+    if (cutter.unitPower > 0) {
+      if (COOLERCMP(temp_cooler.raw, maxtemp_raw_COOLER)) max_temp_error(H_COOLER);
+    }
+    if (COOLERCMP(mintemp_raw_COOLER, temp_cooler.raw)) min_temp_error(H_COOLER);
+  #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
@@ -2728,25 +2899,29 @@ void Temperature::tick() {
   #endif
 
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
+  #if HAS_COOLER
+    static SoftPWM soft_pwm_cooler;
+  #endif
+
   #define WRITE_FAN(n, v) WRITE(FAN##n##_PIN, (v) ^ FAN_INVERTING)
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
-    #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, FAN_SOFT_PWM)
+    #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, HAS_COOLER, FAN_SOFT_PWM)
       constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \
         const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
         WRITE_HEATER_##N(on);                               \
       }while(0)
     #endif
 
     /**
      * Standard heater PWM modulation
      */
@@ -2759,20 +2934,24 @@ void Temperature::tick() {
       #endif
 
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
+      #if HAS_COOLER
+        _PWM_MOD(COOLER,soft_pwm_cooler,temp_cooler);
+      #endif
+
       #if ENABLED(FAN_SOFT_PWM)
         #define _FAN_PWM(N) do{                                     \
           uint8_t &spcf = soft_pwm_count_fan[N];                    \
           spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
           WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW);               \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
@@ -2806,20 +2985,24 @@ void Temperature::tick() {
       #endif
 
       #if HAS_HEATED_BED
         _PWM_LOW(BED, soft_pwm_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_LOW(CHAMBER, soft_pwm_chamber);
       #endif
 
+      #if HAS_COOLER
+        _PWM_LOW(COOLER, soft_pwm_cooler);
+      #endif
+
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
           if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(0, LOW);
         #endif
         #if HAS_FAN1
           if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN(1, LOW);
         #endif
         #if HAS_FAN2
           if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN(2, LOW);
         #endif
@@ -2872,35 +3055,43 @@ void Temperature::tick() {
       #endif
 
       #if HAS_HEATED_BED
         _SLOW_PWM(BED, soft_pwm_bed, temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _SLOW_PWM(CHAMBER, soft_pwm_chamber, temp_chamber);
       #endif
 
+      #if HAS_COOLER
+        _SLOW_PWM(COOLER, soft_pwm_cooler, temp_cooler);
+      #endif
+
     } // slow_pwm_count == 0
 
     #if HAS_HOTEND
       #define _PWM_OFF_E(N) _PWM_OFF(N, soft_pwm_hotend[N]);
       REPEAT(HOTENDS, _PWM_OFF_E);
     #endif
 
     #if HAS_HEATED_BED
       _PWM_OFF(BED, soft_pwm_bed);
     #endif
 
     #if HAS_HEATED_CHAMBER
       _PWM_OFF(CHAMBER, soft_pwm_chamber);
     #endif
 
+    #if HAS_COOLER
+      _PWM_OFF(COOLER, soft_pwm_cooler, temp_cooler);
+    #endif
+
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
         pwm_count_tmp = 0;
         #define _PWM_FAN(N) do{                                 \
           soft_pwm_count_fan[N] = soft_pwm_amount_fan[N] >> 1;  \
           WRITE_FAN(N, soft_pwm_count_fan[N] > 0 ? HIGH : LOW); \
         }while(0)
         #if HAS_FAN0
           _PWM_FAN(0);
         #endif
@@ -2966,20 +3157,21 @@ void Temperature::tick() {
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
       #if HAS_HOTEND
         HOTEND_LOOP() soft_pwm_hotend[e].dec();
       #endif
       TERN_(HAS_HEATED_BED, soft_pwm_bed.dec());
       TERN_(HAS_HEATED_CHAMBER, soft_pwm_chamber.dec());
+      TERN_(HAS_COOLER, soft_pwm_cooler.dec());
     }
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
 
@@ -3033,20 +3225,25 @@ void Temperature::tick() {
     #if HAS_TEMP_ADC_BED
       case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
       case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
     #if HAS_TEMP_ADC_CHAMBER
       case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
       case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
+    #if HAS_TEMP_ADC_COOLER
+      case PrepareTemp_COOLER: HAL_START_ADC(TEMP_COOLER_PIN); break;
+      case MeasureTemp_COOLER: ACCUMULATE_ADC(temp_cooler); break;
+    #endif
+
     #if HAS_TEMP_ADC_PROBE
       case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
@@ -3176,36 +3373,38 @@ void Temperature::tick() {
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const heater_id_t e=INDEX_NONE
   ) {
     char k;
     switch (e) {
+      default:
+        #if HAS_TEMP_HOTEND
+          k = 'T'; break;
+        #endif
+      #if HAS_TEMP_BED
+        case H_BED: k = 'B'; break;
+      #endif
       #if HAS_TEMP_CHAMBER
         case H_CHAMBER: k = 'C'; break;
       #endif
       #if HAS_TEMP_PROBE
         case H_PROBE: k = 'P'; break;
       #endif
-      #if HAS_TEMP_HOTEND
-        default: k = 'T'; break;
-        #if HAS_HEATED_BED
-          case H_BED: k = 'B'; break;
-        #endif
-        #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-          case H_REDUNDANT: k = 'R'; break;
-        #endif
-      #elif HAS_HEATED_BED
-        default: k = 'B'; break;
+      #if HAS_TEMP_COOLER
+        case H_COOLER: k = 'L'; break;
+      #endif
+      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+        case H_REDUNDANT: k = 'R'; break;
       #endif
     }
     SERIAL_CHAR(' ', k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
       #define SFP 2
@@ -3244,32 +3443,35 @@ void Temperature::tick() {
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
         , H_BED
       );
     #endif
     #if HAS_TEMP_CHAMBER
-      print_heater_state(degChamber()
-        #if HAS_HEATED_CHAMBER
-          , degTargetChamber()
-        #else
-          , 0
-        #endif
+      print_heater_state(degChamber(), TERN0(HAS_HEATED_CHAMBER, degTargetChamber())
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawChamberTemp()
         #endif
         , H_CHAMBER
       );
-    #endif
+    #endif // HAS_TEMP_CHAMBER
+    #if HAS_TEMP_COOLER
+      print_heater_state(degCooler(), TERN0(HAS_COOLER, degTargetCooler())
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , rawCoolerTemp()
+        #endif
+        , H_COOLER
+      );
+    #endif // HAS_TEMP_COOLER
     #if HAS_TEMP_PROBE
       print_heater_state(degProbe(), 0
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawProbeTemp()
         #endif
         , H_PROBE
       );
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
@@ -3279,20 +3481,23 @@ void Temperature::tick() {
         , (heater_id_t)e
       );
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
       SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
     #endif
+    #if HAS_COOLER
+      SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_COOLER));
+    #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
@@ -3752,11 +3957,110 @@ void Temperature::tick() {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }
 
       return false;
     }
 
   #endif // HAS_HEATED_CHAMBER
 
+  #if HAS_COOLER
+
+    #ifndef MIN_COOLING_SLOPE_DEG_COOLER
+      #define MIN_COOLING_SLOPE_DEG_COOLER 1.50
+    #endif
+    #ifndef MIN_COOLING_SLOPE_TIME_COOLER
+      #define MIN_COOLING_SLOPE_TIME_COOLER 120
+    #endif
+
+    bool Temperature::wait_for_cooler(const bool no_wait_for_cooling/*=true*/) {
+
+      #if TEMP_COOLER_RESIDENCY_TIME > 0
+        millis_t residency_start_ms = 0;
+        bool first_loop = true;
+        // Loop until the temperature has stabilized
+        #define TEMP_COOLER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME)))
+      #else
+        // Loop until the temperature is very close target
+        #define TEMP_COOLER_CONDITIONS (wants_to_cool ? isLaserHeating() : isLaserCooling())
+      #endif
+
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        KEEPALIVE_STATE(NOT_BUSY);
+      #endif
+
+      bool wants_to_cool = false;
+      float target_temp = -1, previous_temp = 9999;
+      millis_t now, next_temp_ms = 0, next_cooling_check_ms = 0;
+      wait_for_heatup = true;
+      do {
+        // Target temperature might be changed during the loop
+        if (target_temp != degTargetCooler()) {
+          wants_to_cool = isLaserHeating();
+          target_temp = degTargetCooler();
+
+          // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
+          if (no_wait_for_cooling && wants_to_cool) break;
+        }
+
+        now = millis();
+        if (ELAPSED(now, next_temp_ms)) { // Print Temp Reading every 1 second while heating up.
+          next_temp_ms = now + 1000UL;
+          print_heater_states(active_extruder);
+          #if TEMP_COOLER_RESIDENCY_TIME > 0
+            SERIAL_ECHOPGM(" W:");
+            if (residency_start_ms)
+              SERIAL_ECHO(long((SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
+            else
+              SERIAL_CHAR('?');
+          #endif
+          SERIAL_EOL();
+        }
+
+        idle();
+        gcode.reset_stepper_timeout(); // Keep steppers powered
+
+        const float current_temp = degCooler();
+
+        #if TEMP_COOLER_RESIDENCY_TIME > 0
+
+          const float temp_diff = ABS(target_temp - temp);
+
+          if (!residency_start_ms) {
+            // Start the TEMP_COOLER_RESIDENCY_TIME timer when we reach target temp for the first time.
+            if (temp_diff < TEMP_COOLER_WINDOW)
+              residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_COOLER_RESIDENCY_TIME) / 3 : 0);
+          }
+          else if (temp_diff > TEMP_COOLER_HYSTERESIS) {
+            // Restart the timer whenever the temperature falls outside the hysteresis.
+            residency_start_ms = now;
+          }
+
+          first_loop = false;
+        #endif // TEMP_COOLER_RESIDENCY_TIME > 0
+
+        if (wants_to_cool) {
+          // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
+          // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
+          if (!next_cooling_check_ms || ELAPSED(now, next_cooling_check_ms)) {
+            if (previous_temp - current_temp < float(MIN_COOLING_SLOPE_DEG_COOLER)) break;
+            next_cooling_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_COOLER);
+            previous_temp = current_temp;
+          }
+        }
+
+      } while (wait_for_heatup && TEMP_COOLER_CONDITIONS);
+
+      // Prevent a wait-forever situation if R is misused i.e. M191 R0
+      if (wait_for_heatup) {
+        wait_for_heatup = false;
+        ui.reset_status();
+        return true;
+      }
+
+      return false;
+    }
+
+  #endif // HAS_COOLER
+
 #endif // HAS_TEMP_SENSOR

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e85e48c2d4..be98972b77 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -657,23 +657,23 @@ volatile bool Temperature::raw_temps_ready = false;
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
           PGM_P const estring = GHV(PSTR("chamber"), PSTR("bed"), NUL_STR);
-          say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
-          say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
-          say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
+          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
+          say_default_(); SERIAL_ECHOPGM_P(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #else
           say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #endif
 
         auto _set_hotend_pid = [](const uint8_t e, const PID_t &in_pid) {
           #if ENABLED(PIDTEMP)
             PID_PARAM(Kp, e) = in_pid.Kp;
             PID_PARAM(Ki, e) = scalePID_i(in_pid.Ki);
@@ -861,21 +861,21 @@ inline void loud_kill(PGM_P const lcd_msg, const heater_id_t heater_id) {
   #endif
   kill(lcd_msg, HEATER_PSTR(heater_id));
 }
 
 void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
-    serialprintPGM(serial_msg);
+    SERIAL_ECHOPGM_P(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
     if (heater_id >= 0)
       SERIAL_ECHO(heater_id);
     else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER))
       SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
     else
       SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
@@ -1525,21 +1525,21 @@ void Temperature::manage_heater() {
       SERIAL_ECHO_START();
     SERIAL_CHAR('P', '0' + t_index);
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
-    serialprintPGM(
+    SERIAL_ECHOPGM_P(
       TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
       TERN_(TEMP_SENSOR_1_IS_CUSTOM, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
       TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
       TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
       TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
       TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
       TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
       TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
       TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
       TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)

commit 735c1b6183739152eeddade4c06c17e3b0de38bc
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Thu Feb 25 06:28:27 2021 -0800

    PROBING_HEATERS_OFF sub-option WAIT_FOR_HOTEND (#20835)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a220386b9e..e85e48c2d4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3440,20 +3440,31 @@ void Temperature::tick() {
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
         return true;
       }
 
       return false;
     }
 
+    #if ENABLED(WAIT_FOR_HOTEND)
+      void Temperature::wait_for_hotend_heating(const uint8_t target_extruder) {
+        if (isHeatingHotend(target_extruder)) {
+          SERIAL_ECHOLNPGM("Wait for hotend heating...");
+          LCD_MESSAGEPGM(MSG_HEATING);
+          wait_for_hotend(target_extruder);
+          ui.reset_status();
+        }
+      }
+    #endif
+
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
       #define MIN_COOLING_SLOPE_DEG_BED 1.00
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_BED
       #define MIN_COOLING_SLOPE_TIME_BED 60
     #endif

commit d167af4c388df18601380a7edcd5bd6d221458c0
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Thu Feb 25 11:35:18 2021 +0100

    Add BOARD_PREINIT (for Longer3D open drain pins) (#21159)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 58b0a965c9..a220386b9e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1786,21 +1786,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 
   raw_temps_ready = false;
 }
 
 #if THERMO_SEPARATE_SPI
   template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin> SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
   SPIclass<MAX6675_DO_PIN, SD_MOSI_PIN, MAX6675_SCK_PIN> max_tc_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
-#ifdef ALFAWISE_UX0
+#ifdef BOARD_OPENDRAIN_MOSFETS
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
@@ -1879,21 +1879,21 @@ void Temperature::init() {
   #endif
   #if PIN_EXISTS(TEMP_1_TR_ENABLE)
     OUT_WRITE(TEMP_1_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_1_IS_MAX_TC));
   #endif
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
-    #ifdef ALFAWISE_UX0
+    #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif
   #endif
 
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
@@ -1909,21 +1909,21 @@ void Temperature::init() {
     OUT_WRITE(HEATER_5_PIN, HEATER_5_INVERTING);
   #endif
   #if HAS_HEATER_6
     OUT_WRITE(HEATER_6_PIN, HEATER_6_INVERTING);
   #endif
   #if HAS_HEATER_7
     OUT_WRITE(HEATER_7_PIN, HEATER_7_INVERTING);
   #endif
 
   #if HAS_HEATED_BED
-    #ifdef ALFAWISE_UX0
+    #ifdef BOARD_OPENDRAIN_MOSFETS
       OUT_WRITE_OD(HEATER_BED_PIN, HEATER_BED_INVERTING);
     #else
       OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
     #endif
   #endif
 
   #if HAS_HEATED_CHAMBER
     OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
   #endif
 

commit a3a10b62f21cfbedfd001746faa46ac55d248b36
Author: Ken Sanislo <ksanislo@users.noreply.github.com>
Date:   Wed Feb 24 16:26:51 2021 -0800

    Chamber Heater PID (#21156)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index edd76df3b7..58b0a965c9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -364,36 +364,29 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     bool flag_chamber_off;
     bool flag_chamber_excess_heat = false;
     millis_t next_cool_check_ms_2 = 0;
     float old_temp = 9999;
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     #endif
-    #if WATCH_CHAMBER
-      chamber_watch_t Temperature::watch_chamber{0};
-    #endif
-    millis_t Temperature::next_chamber_check_ms;
+    TERN_(WATCH_CHAMBER, chamber_watch_t Temperature::watch_chamber{0});
+    IF_DISABLED(PIDTEMPCHAMBER, millis_t Temperature::next_chamber_check_ms);
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
-// Initialized by settings.load()
-#if ENABLED(PIDTEMP)
-  //hotend_pid_t Temperature::pid[HOTENDS];
-#endif
-
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
@@ -478,192 +471,175 @@ volatile bool Temperature::raw_temps_ready = false;
    * temperature to succeed.
    */
   void Temperature::PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
     float current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
-    long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float maxT = 0, minT = 10000;
 
     const bool isbed = (heater_id == H_BED);
+    const bool ischamber = (heater_id == H_CHAMBER);
 
-    #if HAS_PID_FOR_BOTH
-      #define GHV(B,H) (isbed ? (B) : (H))
-      #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater_id].soft_pwm_amount = H; }while(0)
-      #define ONHEATINGSTART() (isbed ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
-      #define ONHEATING(S,C,T) (isbed ? printerEventLEDs.onBedHeating(S,C,T) : printerEventLEDs.onHotendHeating(S,C,T))
-    #elif ENABLED(PIDTEMPBED)
-      #define GHV(B,H) B
-      #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
-      #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
-      #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
+    #if ENABLED(PIDTEMPCHAMBER)
+      #define C_TERN(T,A,B) ((T) ? (A) : (B))
     #else
-      #define GHV(B,H) H
-      #define SHV(B,H) (temp_hotend[heater_id].soft_pwm_amount = H)
-      #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
-      #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
+      #define C_TERN(T,A,B) (B)
     #endif
-    #define WATCH_PID BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP)
+    #if ENABLED(PIDTEMPBED)
+      #define B_TERN(T,A,B) ((T) ? (A) : (B))
+    #else
+      #define B_TERN(T,A,B) (B)
+    #endif
+    #define GHV(C,B,H) C_TERN(ischamber, C, B_TERN(isbed, B, H))
+    #define SHV(V) C_TERN(ischamber, temp_chamber.soft_pwm_amount = V, B_TERN(isbed, temp_bed.soft_pwm_amount = V, temp_hotend[heater_id].soft_pwm_amount = V))
+    #define ONHEATINGSTART() C_TERN(ischamber, printerEventLEDs.onChamberHeatingStart(), B_TERN(isbed, printerEventLEDs.onBedHeatingStart(), printerEventLEDs.onHotendHeatingStart()))
+    #define ONHEATING(S,C,T) C_TERN(ischamber, printerEventLEDs.onChamberHeating(S,C,T), B_TERN(isbed, printerEventLEDs.onBedHeating(S,C,T), printerEventLEDs.onHotendHeating(S,C,T)))
+
+    #define WATCH_PID BOTH(WATCH_CHAMBER, PIDTEMPCHAMBER) || BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP)
 
     #if WATCH_PID
-      #if ALL(THERMAL_PROTECTION_HOTENDS, PIDTEMP, THERMAL_PROTECTION_BED, PIDTEMPBED)
-        #define GTV(B,H) (isbed ? (B) : (H))
-      #elif BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
-        #define GTV(B,H) (H)
+      #if BOTH(THERMAL_PROTECTION_CHAMBER, PIDTEMPCHAMBER)
+        #define C_GTV(T,A,B) ((T) ? (A) : (B))
       #else
-        #define GTV(B,H) (B)
+        #define C_GTV(T,A,B) (B)
       #endif
-      const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
-      const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
-      const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
+      #if BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
+        #define B_GTV(T,A,B) ((T) ? (A) : (B))
+      #else
+        #define B_GTV(T,A,B) (B)
+      #endif
+      #define GTV(C,B,H) C_GTV(ischamber, C, B_GTV(isbed, B, H))
+      const uint16_t watch_temp_period = GTV(WATCH_CHAMBER_TEMP_PERIOD, WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
+      const uint8_t watch_temp_increase = GTV(WATCH_CHAMBER_TEMP_INCREASE, WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
+      const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_CHAMBER_HYSTERESIS, TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
-    if (target > GHV(BED_MAX_TARGET, temp_range[heater_id].maxtemp - HOTEND_OVERSHOOT)) {
+    if (target > GHV(CHAMBER_MAX_TARGET, BED_MAX_TARGET, temp_range[heater_id].maxtemp - HOTEND_OVERSHOOT)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
-    SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
+    long bias = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX) >> 1, d = bias;
+    SHV(bias);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater_id].celsius);
+      const float start_temp = GHV(temp_chamber.celsius, temp_bed.celsius, temp_hotend[heater_id].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current_temp = GHV(temp_bed.celsius, temp_hotend[heater_id].celsius);
+        current_temp = GHV(temp_chamber.celsius, temp_bed.celsius, temp_hotend[heater_id].celsius);
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
-        if (heating && current_temp > target) {
-          if (ELAPSED(ms, t2 + 5000UL)) {
-            heating = false;
-            SHV((bias - d) >> 1, (bias - d) >> 1);
-            t1 = ms;
-            t_high = t1 - t2;
-            maxT = target;
-          }
+        if (heating && current_temp > target && ELAPSED(ms, t2 + 5000UL)) {
+          heating = false;
+          SHV((bias - d) >> 1);
+          t1 = ms;
+          t_high = t1 - t2;
+          maxT = target;
         }
 
-        if (!heating && current_temp < target) {
-          if (ELAPSED(ms, t1 + 5000UL)) {
-            heating = true;
-            t2 = ms;
-            t_low = t2 - t1;
-            if (cycles > 0) {
-              const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
-              bias += (d * (t_high - t_low)) / (t_low + t_high);
-              LIMIT(bias, 20, max_pow - 20);
-              d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
-
-              SERIAL_ECHOPAIR(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
-              if (cycles > 2) {
-                const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
-                            Tu = float(t_low + t_high) * 0.001f,
-                            pf = isbed ? 0.2f : 0.6f,
-                            df = isbed ? 1.0f / 3.0f : 1.0f / 8.0f;
-
-                SERIAL_ECHOPAIR(STR_KU, Ku, STR_TU, Tu);
-                if (isbed) { // Do not remove this otherwise PID autotune won't work right for the bed!
-                  tune_pid.Kp = Ku * 0.2f;
-                  tune_pid.Ki = 2 * tune_pid.Kp / Tu;
-                  tune_pid.Kd = tune_pid.Kp * Tu / 3;
-                  SERIAL_ECHOLNPGM("\n" " No overshoot"); // Works far better for the bed. Classic and some have bad ringing.
-                  SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
-                }
-                else {
-                  tune_pid.Kp = Ku * pf;
-                  tune_pid.Kd = tune_pid.Kp * Tu * df;
-                  tune_pid.Ki = 2 * tune_pid.Kp / Tu;
-                  SERIAL_ECHOLNPGM("\n" STR_CLASSIC_PID);
-                  SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
-                }
-
-                /**
-                tune_pid.Kp = 0.33 * Ku;
-                tune_pid.Ki = tune_pid.Kp / Tu;
-                tune_pid.Kd = tune_pid.Kp * Tu / 3;
-                SERIAL_ECHOLNPGM(" Some overshoot");
-                SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
-                tune_pid.Kp = 0.2 * Ku;
-                tune_pid.Ki = 2 * tune_pid.Kp / Tu;
-                tune_pid.Kd = tune_pid.Kp * Tu / 3;
-                SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd);
-                */
-              }
+        if (!heating && current_temp < target && ELAPSED(ms, t1 + 5000UL)) {
+          heating = true;
+          t2 = ms;
+          t_low = t2 - t1;
+          if (cycles > 0) {
+            const long max_pow = GHV(MAX_CHAMBER_POWER, MAX_BED_POWER, PID_MAX);
+            bias += (d * (t_high - t_low)) / (t_low + t_high);
+            LIMIT(bias, 20, max_pow - 20);
+            d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
+
+            SERIAL_ECHOPAIR(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
+            if (cycles > 2) {
+              const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
+                          Tu = float(t_low + t_high) * 0.001f,
+                          pf = ischamber ? 0.2f : (isbed ? 0.2f : 0.6f),
+                          df = ischamber ? 1.0f / 3.0f : (isbed ? 1.0f / 3.0f : 1.0f / 8.0f);
+
+              tune_pid.Kp = Ku * pf;
+              tune_pid.Ki = tune_pid.Kp * 2.0f / Tu;
+              tune_pid.Kd = tune_pid.Kp * Tu * df;
+
+              SERIAL_ECHOLNPAIR(STR_KU, Ku, STR_TU, Tu);
+              if (ischamber || isbed)
+                SERIAL_ECHOLNPGM(" No overshoot");
+              else
+                SERIAL_ECHOLNPGM(STR_CLASSIC_PID);
+              SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
             }
-            SHV((bias + d) >> 1, (bias + d) >> 1);
-            cycles++;
-            minT = target;
           }
+          SHV((bias + d) >> 1);
+          cycles++;
+          minT = target;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
-          print_heater_states(isbed ? active_extruder : heater_id);
+          print_heater_states(ischamber ? active_extruder : (isbed ? active_extruder : heater_id));
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_PID
-          if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS)) {
+          if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS) || ischamber == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);     // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _temp_error(heater_id, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
@@ -679,57 +655,61 @@ volatile bool Temperature::raw_temps_ready = false;
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
-        #if HAS_PID_FOR_BOTH
-          const char * const estring = GHV(PSTR("bed"), NUL_STR);
+        #if EITHER(PIDTEMPBED, PIDTEMPCHAMBER)
+          PGM_P const estring = GHV(PSTR("chamber"), PSTR("bed"), NUL_STR);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
-        #elif ENABLED(PIDTEMP)
+        #else
           say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
-        #else
-          say_default_(); SERIAL_ECHOLNPAIR("bedKp ", tune_pid.Kp);
-          say_default_(); SERIAL_ECHOLNPAIR("bedKi ", tune_pid.Ki);
-          say_default_(); SERIAL_ECHOLNPAIR("bedKd ", tune_pid.Kd);
         #endif
 
-        #define _SET_BED_PID() do { \
-          temp_bed.pid.Kp = tune_pid.Kp; \
-          temp_bed.pid.Ki = scalePID_i(tune_pid.Ki); \
-          temp_bed.pid.Kd = scalePID_d(tune_pid.Kd); \
-        }while(0)
+        auto _set_hotend_pid = [](const uint8_t e, const PID_t &in_pid) {
+          #if ENABLED(PIDTEMP)
+            PID_PARAM(Kp, e) = in_pid.Kp;
+            PID_PARAM(Ki, e) = scalePID_i(in_pid.Ki);
+            PID_PARAM(Kd, e) = scalePID_d(in_pid.Kd);
+            updatePID();
+          #else
+            UNUSED(e); UNUSED(in_pid);
+          #endif
+        };
 
-        #define _SET_EXTRUDER_PID() do { \
-          PID_PARAM(Kp, heater_id) = tune_pid.Kp; \
-          PID_PARAM(Ki, heater_id) = scalePID_i(tune_pid.Ki); \
-          PID_PARAM(Kd, heater_id) = scalePID_d(tune_pid.Kd); \
-          updatePID(); }while(0)
+        #if ENABLED(PIDTEMPBED)
+          auto _set_bed_pid = [](const PID_t &in_pid) {
+            temp_bed.pid.Kp = in_pid.Kp;
+            temp_bed.pid.Ki = scalePID_i(in_pid.Ki);
+            temp_bed.pid.Kd = scalePID_d(in_pid.Kd);
+          };
+        #endif
+
+        #if ENABLED(PIDTEMPCHAMBER)
+          auto _set_chamber_pid = [](const PID_t &in_pid) {
+            temp_chamber.pid.Kp = in_pid.Kp;
+            temp_chamber.pid.Ki = scalePID_i(in_pid.Ki);
+            temp_chamber.pid.Kd = scalePID_d(in_pid.Kd);
+          };
+        #endif
 
         // Use the result? (As with "M303 U1")
-        if (set_result) {
-          #if HAS_PID_FOR_BOTH
-            if (isbed) _SET_BED_PID(); else _SET_EXTRUDER_PID();
-          #elif ENABLED(PIDTEMP)
-            _SET_EXTRUDER_PID();
-          #else
-            _SET_BED_PID();
-          #endif
-        }
+        if (set_result)
+          GHV(_set_chamber_pid(tune_pid), _set_bed_pid(tune_pid), _set_hotend_pid(heater_id, tune_pid));
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
         goto EXIT_M303;
       }
 
       // Run HAL idle tasks
       TERN_(HAL_IDLETASK, HAL_idletask());
@@ -932,24 +912,25 @@ void Temperature::max_temp_error(const heater_id_t heater_id) {
   _temp_error(heater_id, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_id_t heater_id) {
   #if ENABLED(DWIN_CREALITY_LCD) && (HAS_HOTEND || HAS_HEATED_BED)
     DWIN_Popup_Temperature(0);
   #endif
   _temp_error(heater_id, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
+#if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
+  bool Temperature::pid_debug_flag; // = 0
+#endif
+
 #if HAS_HOTEND
-  #if ENABLED(PID_DEBUG)
-    extern bool pid_debug_flag;
-  #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
@@ -1016,37 +997,32 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder && pid_debug_flag) {
-          SERIAL_ECHO_START();
-          SERIAL_ECHOPAIR(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output);
-          #if DISABLED(PID_OPENLOOP)
-          {
-            SERIAL_ECHOPAIR(
-              STR_PID_DEBUG_PTERM, work_pid[ee].Kp,
-              STR_PID_DEBUG_ITERM, work_pid[ee].Ki,
-              STR_PID_DEBUG_DTERM, work_pid[ee].Kd
+          SERIAL_ECHO_MSG(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output
+            #if DISABLED(PID_OPENLOOP)
+              , STR_PID_DEBUG_PTERM, work_pid[ee].Kp
+              , STR_PID_DEBUG_ITERM, work_pid[ee].Ki
+              , STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
-            );
-          }
-          #endif
-          SERIAL_EOL();
+            #endif
+          );
         }
-      #endif // PID_DEBUG
+      #endif
 
     #else // No PID enabled
 
       const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
       const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
@@ -1092,36 +1068,99 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
         pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_BED_POWER), 0, MAX_BED_POWER);
       }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
+      if (pid_debug_flag) {
+        SERIAL_ECHO_MSG(
+          " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output
+          #if DISABLED(PID_OPENLOOP)
+            , STR_PID_DEBUG_PTERM, work_pid.Kp
+            , STR_PID_DEBUG_ITERM, work_pid.Ki
+            , STR_PID_DEBUG_DTERM, work_pid.Kd
+          #endif
+        );
+      }
+    #endif
+
+    return pid_output;
+  }
+
+#endif // PIDTEMPBED
+
+#if ENABLED(PIDTEMPCHAMBER)
+
+  float Temperature::get_pid_output_chamber() {
+
+    #if DISABLED(PID_OPENLOOP)
+
+      static PID_t work_pid{0};
+      static float temp_iState = 0, temp_dState = 0;
+      static bool pid_reset = true;
+      float pid_output = 0;
+      const float max_power_over_i_gain = float(MAX_CHAMBER_POWER) / temp_chamber.pid.Ki - float(MIN_CHAMBER_POWER),
+                  pid_error = temp_chamber.target - temp_chamber.celsius;
+
+      if (!temp_chamber.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
+        pid_output = 0;
+        pid_reset = true;
+      }
+      else if (pid_error > PID_FUNCTIONAL_RANGE) {
+        pid_output = MAX_CHAMBER_POWER;
+        pid_reset = true;
+      }
+      else {
+        if (pid_reset) {
+          temp_iState = 0.0;
+          work_pid.Kd = 0.0;
+          pid_reset = false;
+        }
+
+        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
+
+        work_pid.Kp = temp_chamber.pid.Kp * pid_error;
+        work_pid.Ki = temp_chamber.pid.Ki * temp_iState;
+        work_pid.Kd = work_pid.Kd + PID_K2 * (temp_chamber.pid.Kd * (temp_dState - temp_chamber.celsius) - work_pid.Kd);
+
+        temp_dState = temp_chamber.celsius;
+
+        pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_CHAMBER_POWER), 0, MAX_CHAMBER_POWER);
+      }
+
+    #else // PID_OPENLOOP
+
+      const float pid_output = constrain(temp_chamber.target, 0, MAX_CHAMBER_POWER);
+
+    #endif // PID_OPENLOOP
+
+    #if ENABLED(PID_CHAMBER_DEBUG)
     {
       SERIAL_ECHO_MSG(
-        " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output,
+        " PID_CHAMBER_DEBUG : Input ", temp_chamber.celsius, " Output ", pid_output
         #if DISABLED(PID_OPENLOOP)
-          STR_PID_DEBUG_PTERM, work_pid.Kp,
-          STR_PID_DEBUG_ITERM, work_pid.Ki,
-          STR_PID_DEBUG_DTERM, work_pid.Kd,
+          , STR_PID_DEBUG_PTERM, work_pid.Kp
+          , STR_PID_DEBUG_ITERM, work_pid.Ki
+          , STR_PID_DEBUG_DTERM, work_pid.Kd
         #endif
       );
     }
     #endif
 
     return pid_output;
   }
 
-#endif // PIDTEMPBED
+#endif // PIDTEMPCHAMBER
 
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
@@ -1356,56 +1395,61 @@ void Temperature::manage_heater() {
           flag_chamber_off = true;
           set_fan_speed(2, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
           MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
         #endif
       }
     #endif
 
+
+
+
+    #if ENABLED(PIDTEMPCHAMBER)
+      // PIDTEMPCHAMBER doens't support a CHAMBER_VENT yet.
+      temp_chamber.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
+    #else
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
-        if (flag_chamber_excess_heat) {
-          temp_chamber.soft_pwm_amount = 0;
-          #if ENABLED(CHAMBER_VENT)
-            if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
-          #endif
+          if (flag_chamber_excess_heat) {
+            temp_chamber.soft_pwm_amount = 0;
+            #if ENABLED(CHAMBER_VENT)
+              if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
+            #endif
+          }
+          else {
+            #if ENABLED(CHAMBER_LIMIT_SWITCHING)
+              if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
+                temp_chamber.soft_pwm_amount = 0;
+              else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
+                temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
+            #else
+              temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? (MAX_CHAMBER_POWER) >> 1 : 0;
+            #endif
+            #if ENABLED(CHAMBER_VENT)
+              if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 0);
+            #endif
+          }
         }
         else {
-          #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-            if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
-              temp_chamber.soft_pwm_amount = 0;
-            else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
-              temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
-          #else
-            temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? (MAX_CHAMBER_POWER) >> 1 : 0;
-          #endif
-          #if ENABLED(CHAMBER_VENT)
-            if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 0);
-          #endif
+          temp_chamber.soft_pwm_amount = 0;
+          WRITE_HEATER_CHAMBER(LOW);
         }
-      }
-      else {
-        temp_chamber.soft_pwm_amount = 0;
-        WRITE_HEATER_CHAMBER(LOW);
-      }
-
-      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
-      #endif
-    }
 
-    // TODO: Implement true PID pwm
-    //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
+     }
+     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+       tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+     #endif
+   #endif
 
   #endif // HAS_HEATED_CHAMBER
 
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**

commit 8707ae23e22d40e7f818cf77e7ec89038fdaacf7
Author: JoAnn Manges <joannmanges@gmail.com>
Date:   Mon Feb 8 20:51:57 2021 -0500

    MAX Thermocouples rework (#20447)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5a4ed16744..edd76df3b7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -40,55 +40,118 @@
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
-#if HAS_MAX31865
-  #include <Adafruit_MAX31865.h>
-  #if TEMP_SENSOR_0_IS_MAX31865 && !defined(MAX31865_CS_PIN) && PIN_EXISTS(MAX6675_SS)
-    #define MAX31865_CS_PIN   MAX6675_SS_PIN
+// LIB_MAX31855 can be added to the build_flags in platformio.ini to use a user-defined library
+#if LIB_USR_MAX31855
+  #include <Adafruit_MAX31855.h>
+  #if PIN_EXISTS(MAX31855_MISO) && PIN_EXISTS(MAX31855_SCK)
+    #define MAX31855_USES_SW_SPI 1
   #endif
-  #if TEMP_SENSOR_1_IS_MAX31865 && !defined(MAX31865_CS2_PIN) && PIN_EXISTS(MAX6675_SS2)
-    #define MAX31865_CS2_PIN  MAX6675_SS2_PIN
+  #if TEMP_SENSOR_0_IS_MAX31855 && PIN_EXISTS(MAX31855_CS)
+    #define HAS_MAX31855_TEMP 1
+    Adafruit_MAX31855 max31855_0 = Adafruit_MAX31855(MAX31855_CS_PIN
+      #if MAX31855_USES_SW_SPI
+        , MAX31855_MISO_PIN, MAX31855_SCK_PIN  // For software SPI also set MISO/SCK
+      #endif
+      #if ENABLED(LARGE_PINMAP)
+        , HIGH
+      #endif
+    );
+  #endif
+  #if TEMP_SENSOR_1_IS_MAX31855 && PIN_EXISTS(MAX31855_CS2)
+    #define HAS_MAX31855_TEMP 1
+    Adafruit_MAX31855 max31855_1 = Adafruit_MAX31855(MAX31855_CS2_PIN
+      #if MAX31855_USES_SW_SPI
+        , MAX31855_MISO_PIN, MAX31855_SCK_PIN  // For software SPI also set MISO/SCK
+      #endif
+      #if ENABLED(LARGE_PINMAP)
+        , HIGH
+      #endif
+    );
   #endif
+#endif
+
+// LIB_MAX31865 can be added to the build_flags in platformio.ini to use a user-defined library.
+// If LIB_MAX31865 is not on the build_flags then the Adafruit MAX31865 V1.1.0 library is used.
+#if HAS_MAX31865
+  #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN SD_MOSI_PIN
   #endif
-  #ifndef MAX31865_MISO_PIN
-    #define MAX31865_MISO_PIN MAX6675_DO_PIN
-  #endif
-  #ifndef MAX31865_SCK_PIN
-    #define MAX31865_SCK_PIN  MAX6675_SCK_PIN
+  #if PIN_EXISTS(MAX31865_MISO) && PIN_EXISTS(MAX31865_SCK)
+    #define MAX31865_USES_SW_SPI 1
   #endif
   #if TEMP_SENSOR_0_IS_MAX31865 && PIN_EXISTS(MAX31865_CS)
     #define HAS_MAX31865_TEMP 1
-    Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
-      #if MAX31865_CS_PIN != MAX6675_SS_PIN
-        , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN // For software SPI also set MOSI/MISO/SCK
-      #endif
-    );
+      Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
+        #if MAX31865_USES_SW_SPI && PIN_EXISTS(MAX31865_MOSI)
+          , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN  // For software SPI also set MOSI/MISO/SCK
+        #endif
+        #if ENABLED(LARGE_PINMAP)
+          , HIGH
+        #endif
+      );
   #endif
   #if TEMP_SENSOR_1_IS_MAX31865 && PIN_EXISTS(MAX31865_CS2)
     #define HAS_MAX31865_TEMP 1
     Adafruit_MAX31865 max31865_1 = Adafruit_MAX31865(MAX31865_CS2_PIN
-      #if MAX31865_CS2_PIN != MAX6675_SS2_PIN
-        , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN // For software SPI also set MOSI/MISO/SCK
+      #if MAX31865_USES_SW_SPI && PIN_EXISTS(MAX31865_MOSI)
+        , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN  // For software SPI also set MOSI/MISO/SCK
+      #endif
+      #if ENABLED(LARGE_PINMAP)
+        , HIGH
+      #endif
+    );
+  #endif
+#endif
+
+// LIB_MAX6675 can be added to the build_flags in platformio.ini to use a user-defined library
+#if LIB_USR_MAX6675
+  #include <max6675.h>
+  #if PIN_EXISTS(MAX6675_MISO) && PIN_EXISTS(MAX6675_SCK)
+    #define MAX6675_USES_SW_SPI 1
+  #endif
+  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX6675_CS)
+    #define HAS_MAX6675_TEMP 1
+    MAX6675 max6675_0 = MAX6675(MAX6675_CS_PIN
+      #if MAX6675_USES_SW_SPI
+        , MAX6675_MISO_PIN, MAX6675_SCK_PIN   // For software SPI also set MISO/SCK
+      #endif
+      #if ENABLED(LARGE_PINMAP)
+        , HIGH
+      #endif
+    );
+  #endif
+  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX6675_CS2)
+    #define HAS_MAX6675_TEMP 1
+    MAX6675 max6675_1 = MAX6675(MAX6675_CS2_PIN
+      #if MAX6675_USES_SW_SPI
+        , MAX6675_MISO_PIN, MAX6675_SCK_PIN   // For software SPI also set MISO/SCK
+      #endif
+      #if ENABLED(LARGE_PINMAP)
+        , HIGH
       #endif
     );
   #endif
 #endif
 
+#if !HAS_MAX6675_TEMP && !HAS_MAX31855_TEMP && !HAS_MAX31865_TEMP
+  #define NO_THERMO_TEMPS 1
+#endif
+
 #if (TEMP_SENSOR_0_IS_MAX_TC || TEMP_SENSOR_1_IS_MAX_TC) && PINS_EXIST(MAX6675_SCK, MAX6675_DO) && NO_THERMO_TEMPS
   #define THERMO_SEPARATE_SPI 1
 #endif
 
 #if THERMO_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
@@ -1711,23 +1774,52 @@ void Temperature::updateTemperaturesFromRawValues() {
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
+  // Init (and disable) SPI thermocouples
+  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX6675_CS)
+    OUT_WRITE(MAX6675_CS_PIN, HIGH);
+  #endif
+  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX6675_CS2)
+    OUT_WRITE(MAX6675_CS2_PIN, HIGH);
+  #endif
+  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX31855_CS)
+    OUT_WRITE(MAX31855_CS_PIN, HIGH);
+  #endif
+  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX31855_CS2)
+    OUT_WRITE(MAX31855_CS2_PIN, HIGH);
+  #endif
+  #if TEMP_SENSOR_0_IS_MAX6675 && PIN_EXISTS(MAX31865_CS)
+    OUT_WRITE(MAX31865_CS_PIN, HIGH);
+  #endif
+  #if TEMP_SENSOR_1_IS_MAX6675 && PIN_EXISTS(MAX31865_CS2)
+    OUT_WRITE(MAX31865_CS2_PIN, HIGH);
+  #endif
 
-  TERN_(TEMP_SENSOR_0_IS_MAX31865, max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-  TERN_(TEMP_SENSOR_1_IS_MAX31865, max31865_1.begin(MAX31865_2WIRE));
+  #if HAS_MAX31865_TEMP
+    TERN_(TEMP_SENSOR_0_IS_MAX31865, max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+    TERN_(TEMP_SENSOR_1_IS_MAX31865, max31865_1.begin(MAX31865_2WIRE));
+  #endif
+  #if HAS_MAX31855_TEMP
+    TERN_(TEMP_SENSOR_0_IS_MAX31855, max31855_0.begin());
+    TERN_(TEMP_SENSOR_1_IS_MAX31855, max31855_1.begin());
+  #endif
+  #if HAS_MAX6675_TEMP
+    TERN_(TEMP_SENSOR_0_IS_MAX6675, max6675_0.begin());
+    TERN_(TEMP_SENSOR_1_IS_MAX6675, max6675_1.begin());
+  #endif
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
@@ -2227,21 +2319,21 @@ void Temperature::disable_all_heaters() {
 
 #if HAS_MAX_TC
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 
   int Temperature::read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex/*=0*/)) {
     #define MAX6675_HEAT_INTERVAL 250UL
 
-    #if HAS_MAX31855
+    #if HAS_MAX31855_TEMP
       static uint32_t max_tc_temp = 2000;
       #define MAX_TC_ERROR_MASK    7
       #define MAX_TC_DISCARD_BITS 18
       #define MAX_TC_SPEED_BITS    3        // (_BV(SPR1)) // clock √∑ 64
     #elif HAS_MAX31865_TEMP
       static uint16_t max_tc_temp = 2000;   // From datasheet 16 bits D15-D0
       #define MAX_TC_ERROR_MASK    1        // D0 Bit not used
       #define MAX_TC_DISCARD_BITS  1        // Data is in D15-D1
       #define MAX_TC_SPEED_BITS    3        //  (_BV(SPR1)) // clock √∑ 64
     #else
@@ -2277,98 +2369,130 @@ void Temperature::disable_all_heaters() {
     #endif
 
     static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
 
     // Return last-read value between readings
     static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
     millis_t ms = millis();
     if (PENDING(ms, next_max_tc_ms[hindex])) return int(THERMO_TEMP(hindex));
     next_max_tc_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
-    #if HAS_MAX31865_TEMP
-      Adafruit_MAX31865 &maxref = THERMO_SEL(max31865_0, max31865_1);
-      const uint16_t max31865_ohms = (uint32_t(maxref.readRTD()) * THERMO_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
-    #endif
-
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
-    #if !THERMO_SEPARATE_SPI
+    #if !THERMO_SEPARATE_SPI && NO_THERMO_TEMPS
       spiBegin();
       spiInit(MAX_TC_SPEED_BITS);
     #endif
 
-    MAX6675_WRITE(LOW); // enable TT_MAX6675
-    DELAY_NS(100);      // Ensure 100ns delay
+    #if NO_THERMO_TEMPS
+      MAX6675_WRITE(LOW);  // enable TT_MAX6675
+      DELAY_NS(100);       // Ensure 100ns delay
+    #endif
 
-    // Read a big-endian temperature value
     max_tc_temp = 0;
-    for (uint8_t i = sizeof(max_tc_temp); i--;) {
-      max_tc_temp |= TERN(THERMO_SEPARATE_SPI, max_tc_spi.receive(), spiRec());
-      if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
-    }
 
-    MAX6675_WRITE(HIGH); // disable TT_MAX6675
+    // Read a big-endian temperature value
+    #if NO_THERMO_TEMPS
+      for (uint8_t i = sizeof(max_tc_temp); i--;) {
+        max_tc_temp |= TERN(THERMO_SEPARATE_SPI, max_tc_spi.receive(), spiRec());
+        if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
+      }
+        MAX6675_WRITE(HIGH); // disable TT_MAX6675
+    #endif
+
+    #if HAS_MAX31855_TEMP
+      Adafruit_MAX31855 &max855ref = THERMO_SEL(max31855_0, max31855_1);
+      max_tc_temp = max855ref.readRaw32();
+    #endif
+
+    #if HAS_MAX31865_TEMP
+      Adafruit_MAX31865 &max865ref = THERMO_SEL(max31865_0, max31865_1);
+      #if ENABLED(LIB_USR_MAX31865)
+        max_tc_temp = max865ref.readRTD_with_Fault();
+      #endif
+    #endif
 
-    const uint8_t fault_31865 = TERN1(HAS_MAX31865_TEMP, maxref.readFault());
+    #if HAS_MAX6675_TEMP
+      MAX6675 &max6675ref = THERMO_SEL(max6675_0, max6675_1);
+      max_tc_temp = max6675ref.readRaw16();
+    #endif
+
+    #if ENABLED(LIB_ADAFRUIT_MAX31865)
+      const uint8_t fault_31865 = max865ref.readFault() & 0x3FU;
+    #endif
 
-    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS) && (max_tc_temp & MAX_TC_ERROR_MASK) && fault_31865) {
+    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
+      && TERN(LIB_ADAFRUIT_MAX31865, fault_31865, (max_tc_temp & MAX_TC_ERROR_MASK))
+    ) {
       max_tc_errors[hindex]++;
       if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
         #if MAX_TC_ERROR_MASK == 7
-          SERIAL_ECHOPGM("MAX31855 ");
-          if (max_tc_temp & 1)
+          SERIAL_ECHOPGM("MAX31855 Fault : (", max_tc_temp & 0x7, ") >> ");
+          if (max_tc_temp & 0x1)
             SERIAL_ECHOLNPGM("Open Circuit");
-          else if (max_tc_temp & 2)
+          else if (max_tc_temp & 0x2)
             SERIAL_ECHOLNPGM("Short to GND");
-          else if (max_tc_temp & 4)
+          else if (max_tc_temp & 0x4)
             SERIAL_ECHOLNPGM("Short to VCC");
-        #elif HAS_MAX31865_TEMP
+        #elif HAS_MAX31865
+          #if ENABLED(LIB_USR_MAX31865)
+            // At the present time we do not have the ability to set the MAX31865 HIGH threshold
+            // or thr LOW threshold, so no need to check for them, zero these bits out
+            const uint8_t fault_31865 = max865ref.readFault() & 0x3FU;
+          #endif
+          max865ref.clearFault();
           if (fault_31865) {
-            maxref.clearFault();
-            SERIAL_ECHOPAIR("MAX31865 Fault :(", fault_31865, ")  >>");
+            SERIAL_EOL();
+            SERIAL_ECHOLNPAIR("\nMAX31865 Fault :(", fault_31865, ")  >>");
             if (fault_31865 & MAX31865_FAULT_HIGHTHRESH)
               SERIAL_ECHOLNPGM("RTD High Threshold");
-            else if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
+            if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
               SERIAL_ECHOLNPGM("RTD Low Threshold");
-            else if (fault_31865 & MAX31865_FAULT_REFINLOW)
+            if (fault_31865 & MAX31865_FAULT_REFINLOW)
               SERIAL_ECHOLNPGM("REFIN- > 0.85 x Bias");
-            else if (fault_31865 & MAX31865_FAULT_REFINHIGH)
+            if (fault_31865 & MAX31865_FAULT_REFINHIGH)
               SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
-            else if (fault_31865 & MAX31865_FAULT_RTDINLOW)
+            if (fault_31865 & MAX31865_FAULT_RTDINLOW)
               SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
-            else if (fault_31865 & MAX31865_FAULT_OVUV)
+            if (fault_31865 & MAX31865_FAULT_OVUV)
               SERIAL_ECHOLNPGM("Under/Over voltage");
           }
         #else
-          SERIAL_ECHOLNPGM("MAX6675");
+          SERIAL_ECHOLNPGM("MAX6675 Open Circuit");
         #endif
 
         // Thermocouple open
         max_tc_temp = 4 * THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX);
       }
       else
         max_tc_temp >>= MAX_TC_DISCARD_BITS;
     }
     else {
       max_tc_temp >>= MAX_TC_DISCARD_BITS;
       max_tc_errors[hindex] = 0;
     }
 
     #if HAS_MAX31855
       if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000; // Support negative temperature
     #endif
 
     // Return the RTD resistance for MAX31865 for display in SHOW_TEMP_ADC_VALUES
-    TERN_(HAS_MAX31865_TEMP, max_tc_temp = max31865_ohms);
+    #if HAS_MAX31865_TEMP
+      #if ENABLED(LIB_ADAFRUIT_MAX31865)
+        max_tc_temp = (uint32_t(max865ref.readRTD()) * THERMO_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
+      #elif ENABLED(LIB_USR_MAX31865)
+        max_tc_temp = (uint32_t(max_tc_temp) * THERMO_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
+      #endif
+    #endif
 
     THERMO_TEMP(hindex) = max_tc_temp;
 
     return int(max_tc_temp);
   }
 
 #endif // HAS_MAX_TC
 
 /**
  * Update raw temperatures
@@ -3040,21 +3164,22 @@ void Temperature::tick() {
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
     #else
       #define SFP 2
     #endif
     SERIAL_CHAR(':');
     SERIAL_PRINT(c, SFP);
     SERIAL_ECHOPGM(" /");
     SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_ECHOPAIR(" (", r * RECIPROCAL(OVERSAMPLENR));
+      // Temperature MAX SPI boards do not have an OVERSAMPLENR defined
+      SERIAL_ECHOPAIR(" (", TERN(NO_THERMO_TEMPS, false, k == 'T') ? r : r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       , const bool include_r/*=false*/
     #endif
   ) {

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f66d60ab15..5a4ed16744 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -821,21 +821,21 @@ inline void loud_kill(PGM_P const lcd_msg, const heater_id_t heater_id) {
 
 void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
     if (heater_id >= 0)
-      SERIAL_ECHO((int)heater_id);
+      SERIAL_ECHO(heater_id);
     else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER))
       SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
     else
       SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
   watchdog_refresh();
 
@@ -1487,21 +1487,21 @@ void Temperature::manage_heater() {
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
   float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
       if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
-        SERIAL_ECHO((int)e);
+        SERIAL_ECHO(e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif TEMP_SENSOR_0_IS_MAX_TC
@@ -2058,21 +2058,21 @@ void Temperature::init() {
       // Convert the given heater_id_t to an idle array index
       const IdleIndex idle_index = idle_index_for_id(heater_id);
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
         case H_BED:     SERIAL_ECHOPGM("bed"); break;
         case H_CHAMBER: SERIAL_ECHOPGM("chamber"); break;
-        default:        SERIAL_ECHO((int)heater_id);
+        default:        SERIAL_ECHO(heater_id);
       }
       SERIAL_ECHOLNPAIR(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
     //*/
 

commit 57e4b82b66e0d98a370e1928a64840d2a9d5f501
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Mon Feb 8 10:36:57 2021 +0800

    Fix: Unsupported use of %f in printf (#21001)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c935323867..f66d60ab15 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3086,29 +3086,29 @@ void Temperature::tick() {
         #if HAS_HEATED_CHAMBER
           , degTargetChamber()
         #else
           , 0
         #endif
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawChamberTemp()
         #endif
         , H_CHAMBER
       );
-    #endif // HAS_TEMP_CHAMBER
+    #endif
     #if HAS_TEMP_PROBE
       print_heater_state(degProbe(), 0
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawProbeTemp()
         #endif
         , H_PROBE
       );
-    #endif // HAS_TEMP_PROBE
+    #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , (heater_id_t)e
       );
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED

commit b35bfeb1c3f1271016227a1d79dcb552e67e3cb9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 7 16:58:06 2021 -0600

    Fix TEMP_0_TR_ENABLE, rename temp conditions (#21016)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f6d22420f2..c935323867 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -40,60 +40,60 @@
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
-#if MAX6675_0_IS_MAX31865 || MAX6675_1_IS_MAX31865
+#if HAS_MAX31865
   #include <Adafruit_MAX31865.h>
-  #if MAX6675_0_IS_MAX31865 && !defined(MAX31865_CS_PIN) && PIN_EXISTS(MAX6675_SS)
+  #if TEMP_SENSOR_0_IS_MAX31865 && !defined(MAX31865_CS_PIN) && PIN_EXISTS(MAX6675_SS)
     #define MAX31865_CS_PIN   MAX6675_SS_PIN
   #endif
-  #if MAX6675_1_IS_MAX31865 && !defined(MAX31865_CS2_PIN) && PIN_EXISTS(MAX6675_SS2)
+  #if TEMP_SENSOR_1_IS_MAX31865 && !defined(MAX31865_CS2_PIN) && PIN_EXISTS(MAX6675_SS2)
     #define MAX31865_CS2_PIN  MAX6675_SS2_PIN
   #endif
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN SD_MOSI_PIN
   #endif
   #ifndef MAX31865_MISO_PIN
     #define MAX31865_MISO_PIN MAX6675_DO_PIN
   #endif
   #ifndef MAX31865_SCK_PIN
     #define MAX31865_SCK_PIN  MAX6675_SCK_PIN
   #endif
-  #if MAX6675_0_IS_MAX31865 && PIN_EXISTS(MAX31865_CS)
-    #define HAS_MAX31865 1
+  #if TEMP_SENSOR_0_IS_MAX31865 && PIN_EXISTS(MAX31865_CS)
+    #define HAS_MAX31865_TEMP 1
     Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
       #if MAX31865_CS_PIN != MAX6675_SS_PIN
         , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN // For software SPI also set MOSI/MISO/SCK
       #endif
     );
   #endif
-  #if MAX6675_1_IS_MAX31865 && PIN_EXISTS(MAX31865_CS2)
-    #define HAS_MAX31865 1
+  #if TEMP_SENSOR_1_IS_MAX31865 && PIN_EXISTS(MAX31865_CS2)
+    #define HAS_MAX31865_TEMP 1
     Adafruit_MAX31865 max31865_1 = Adafruit_MAX31865(MAX31865_CS2_PIN
       #if MAX31865_CS2_PIN != MAX6675_SS2_PIN
         , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN // For software SPI also set MOSI/MISO/SCK
       #endif
     );
   #endif
 #endif
 
-#if EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PINS_EXIST(MAX6675_SCK, MAX6675_DO)
-  #define MAX6675_SEPARATE_SPI 1
+#if (TEMP_SENSOR_0_IS_MAX_TC || TEMP_SENSOR_1_IS_MAX_TC) && PINS_EXIST(MAX6675_SCK, MAX6675_DO) && NO_THERMO_TEMPS
+  #define THERMO_SEPARATE_SPI 1
 #endif
 
-#if MAX6675_SEPARATE_SPI
+#if THERMO_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
@@ -125,34 +125,34 @@
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_SERVOS
   #include "./servo.h"
 #endif
 
-#if ANY(HEATER_0_USES_THERMISTOR, HEATER_1_USES_THERMISTOR, HEATER_2_USES_THERMISTOR, HEATER_3_USES_THERMISTOR, \
-        HEATER_4_USES_THERMISTOR, HEATER_5_USES_THERMISTOR, HEATER_6_USES_THERMISTOR, HEATER_7_USES_THERMISTOR )
+#if ANY(TEMP_SENSOR_0_IS_THERMISTOR, TEMP_SENSOR_1_IS_THERMISTOR, TEMP_SENSOR_2_IS_THERMISTOR, TEMP_SENSOR_3_IS_THERMISTOR, \
+        TEMP_SENSOR_4_IS_THERMISTOR, TEMP_SENSOR_5_IS_THERMISTOR, TEMP_SENSOR_6_IS_THERMISTOR, TEMP_SENSOR_7_IS_THERMISTOR )
   #define HAS_HOTEND_THERMISTOR 1
 #endif
 
 #if HAS_HOTEND_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    static const temp_entry_t* heater_ttbl_map[2] = { HEATER_0_TEMPTABLE, HEATER_1_TEMPTABLE };
-    static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
+    static const temp_entry_t* heater_ttbl_map[2] = { TEMPTABLE_0, TEMPTABLE_1 };
+    static constexpr uint8_t heater_ttbllen_map[2] = { TEMPTABLE_0_LEN, TEMPTABLE_1_LEN };
   #else
-    #define NEXT_TEMPTABLE(N) ,HEATER_##N##_TEMPTABLE
-    #define NEXT_TEMPTABLE_LEN(N) ,HEATER_##N##_TEMPTABLE_LEN
-    static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
-    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
+    #define NEXT_TEMPTABLE(N) ,TEMPTABLE_##N
+    #define NEXT_TEMPTABLE_LEN(N) ,TEMPTABLE_##N##_LEN
+    static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0 REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
+    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
   #endif
 #endif
 
 Temperature thermalManager;
 
 const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
            str_t_heating_failed[] PROGMEM = STR_T_HEATING_FAILED;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
@@ -278,42 +278,42 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
   Temperature::heater_idle_t Temperature::heater_idle[NR_HEATER_IDLE]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
-    int16_t Temperature::mintemp_raw_BED = HEATER_BED_RAW_LO_TEMP;
+    int16_t Temperature::mintemp_raw_BED = TEMP_SENSOR_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
-    int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
+    int16_t Temperature::maxtemp_raw_BED = TEMP_SENSOR_BED_RAW_HI_TEMP;
   #endif
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     int16_t fan_chamber_pwm;
     bool flag_chamber_off;
     bool flag_chamber_excess_heat = false;
     millis_t next_cool_check_ms_2 = 0;
     float old_temp = 9999;
     #ifdef CHAMBER_MINTEMP
-      int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
+      int16_t Temperature::mintemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
-      int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
+      int16_t Temperature::maxtemp_raw_CHAMBER = TEMP_SENSOR_CHAMBER_RAW_HI_TEMP;
     #endif
     #if WATCH_CHAMBER
       chamber_watch_t Temperature::watch_chamber{0};
     #endif
     millis_t Temperature::next_chamber_check_ms;
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
@@ -340,32 +340,32 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   float Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
-#define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) < (HEATER_##N##_RAW_HI_TEMP) ? 1 : -1)
+#define TEMPDIR(N) ((TEMP_SENSOR_##N##_RAW_LO_TEMP) < (TEMP_SENSOR_##N##_RAW_HI_TEMP) ? 1 : -1)
 
 #if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
-  constexpr temp_range_t sensor_heater_0 { HEATER_0_RAW_LO_TEMP, HEATER_0_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_1 { HEATER_1_RAW_LO_TEMP, HEATER_1_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_2 { HEATER_2_RAW_LO_TEMP, HEATER_2_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_3 { HEATER_3_RAW_LO_TEMP, HEATER_3_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_4 { HEATER_4_RAW_LO_TEMP, HEATER_4_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_6 { HEATER_6_RAW_LO_TEMP, HEATER_6_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_7 { HEATER_7_RAW_LO_TEMP, HEATER_7_RAW_HI_TEMP, 0, 16383 };
+  constexpr temp_range_t sensor_heater_0 { TEMP_SENSOR_0_RAW_LO_TEMP, TEMP_SENSOR_0_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_1 { TEMP_SENSOR_1_RAW_LO_TEMP, TEMP_SENSOR_1_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_2 { TEMP_SENSOR_2_RAW_LO_TEMP, TEMP_SENSOR_2_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_3 { TEMP_SENSOR_3_RAW_LO_TEMP, TEMP_SENSOR_3_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_4 { TEMP_SENSOR_4_RAW_LO_TEMP, TEMP_SENSOR_4_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_5 { TEMP_SENSOR_5_RAW_LO_TEMP, TEMP_SENSOR_5_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_6 { TEMP_SENSOR_6_RAW_LO_TEMP, TEMP_SENSOR_6_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_7 { TEMP_SENSOR_7_RAW_LO_TEMP, TEMP_SENSOR_7_RAW_HI_TEMP, 0, 16383 };
 
   temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5, sensor_heater_6, sensor_heater_7);
 #endif
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #ifdef MILLISECONDS_PREHEAT_TIME
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
@@ -1076,27 +1076,27 @@ void Temperature::manage_heater() {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
-    #if HEATER_0_USES_MAX6675
-      if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
-      if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
+    #if TEMP_SENSOR_0_IS_MAX_TC
+      if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, TEMP_SENSOR_0_MAX_TC_TMAX - 1.0)) max_temp_error(H_E0);
+      if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, TEMP_SENSOR_0_MAX_TC_TMIN + .01)) min_temp_error(H_E0);
     #endif
-    #if HEATER_1_USES_MAX6675
-      if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
-      if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
+    #if TEMP_SENSOR_1_IS_MAX_TC
+      if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, TEMP_SENSOR_1_MAX_TC_TMAX - 1.0)) max_temp_error(H_E1);
+      if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, TEMP_SENSOR_1_MAX_TC_TMIN + .01)) min_temp_error(H_E1);
     #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
@@ -1366,80 +1366,84 @@ void Temperature::manage_heater() {
     }                                                                 \
   }                                                                   \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
     user_thermistor_t default_user_thermistor[USER_THERMISTORS] = {
-      #if HEATER_0_USER_THERMISTOR
+      #if TEMP_SENSOR_0_IS_CUSTOM
         { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
       #endif
-      #if HEATER_1_USER_THERMISTOR
+      #if TEMP_SENSOR_1_IS_CUSTOM
         { true, 0, 0, HOTEND1_PULLUP_RESISTOR_OHMS, HOTEND1_RESISTANCE_25C_OHMS, 0, 0, HOTEND1_BETA, 0 },
       #endif
-      #if HEATER_2_USER_THERMISTOR
+      #if TEMP_SENSOR_2_IS_CUSTOM
         { true, 0, 0, HOTEND2_PULLUP_RESISTOR_OHMS, HOTEND2_RESISTANCE_25C_OHMS, 0, 0, HOTEND2_BETA, 0 },
       #endif
-      #if HEATER_3_USER_THERMISTOR
+      #if TEMP_SENSOR_3_IS_CUSTOM
         { true, 0, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
       #endif
-      #if HEATER_4_USER_THERMISTOR
+      #if TEMP_SENSOR_4_IS_CUSTOM
         { true, 0, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
       #endif
-      #if HEATER_5_USER_THERMISTOR
+      #if TEMP_SENSOR_5_IS_CUSTOM
         { true, 0, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
       #endif
-      #if HEATER_6_USER_THERMISTOR
+      #if TEMP_SENSOR_6_IS_CUSTOM
         { true, 0, 0, HOTEND6_PULLUP_RESISTOR_OHMS, HOTEND6_RESISTANCE_25C_OHMS, 0, 0, HOTEND6_BETA, 0 },
       #endif
-      #if HEATER_7_USER_THERMISTOR
+      #if TEMP_SENSOR_7_IS_CUSTOM
         { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
       #endif
-      #if HEATER_BED_USER_THERMISTOR
+      #if TEMP_SENSOR_BED_IS_CUSTOM
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
-      #if HEATER_CHAMBER_USER_THERMISTOR
+      #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
       #endif
+      #if TEMP_SENSOR_PROBE_IS_CUSTOM
+        { true, 0, 0, PROBE_PULLUP_RESISTOR_OHMS, PROBE_RESISTANCE_25C_OHMS, 0, 0, PROBE_BETA, 0 }
+      #endif
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
     else
       SERIAL_ECHO_START();
     SERIAL_CHAR('P', '0' + t_index);
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     serialprintPGM(
-      TERN_(HEATER_0_USER_THERMISTOR, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
-      TERN_(HEATER_1_USER_THERMISTOR, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
-      TERN_(HEATER_2_USER_THERMISTOR, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
-      TERN_(HEATER_3_USER_THERMISTOR, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
-      TERN_(HEATER_4_USER_THERMISTOR, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
-      TERN_(HEATER_5_USER_THERMISTOR, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
-      TERN_(HEATER_6_USER_THERMISTOR, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
-      TERN_(HEATER_7_USER_THERMISTOR, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
-      TERN_(HEATER_BED_USER_THERMISTOR, t_index == CTI_BED ? PSTR("BED") :)
-      TERN_(HEATER_CHAMBER_USER_THERMISTOR, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
+      TERN_(TEMP_SENSOR_0_IS_CUSTOM, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
+      TERN_(TEMP_SENSOR_1_IS_CUSTOM, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
+      TERN_(TEMP_SENSOR_2_IS_CUSTOM, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
+      TERN_(TEMP_SENSOR_3_IS_CUSTOM, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
+      TERN_(TEMP_SENSOR_4_IS_CUSTOM, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
+      TERN_(TEMP_SENSOR_5_IS_CUSTOM, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
+      TERN_(TEMP_SENSOR_6_IS_CUSTOM, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
+      TERN_(TEMP_SENSOR_7_IS_CUSTOM, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
+      TERN_(TEMP_SENSOR_BED_IS_CUSTOM, t_index == CTI_BED ? PSTR("BED") :)
+      TERN_(TEMP_SENSOR_CHAMBER_IS_CUSTOM, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
+      TERN_(TEMP_SENSOR_PROBE_IS_CUSTOM, t_index == CTI_PROBE ? PSTR("PROBE") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
@@ -1491,99 +1495,99 @@ void Temperature::manage_heater() {
       if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
         SERIAL_ECHO((int)e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
-        #if HEATER_0_USER_THERMISTOR
+        #if TEMP_SENSOR_0_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
-        #elif HEATER_0_USES_MAX6675
-          return TERN(MAX6675_0_IS_MAX31865, max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0), raw * 0.25);
-        #elif HEATER_0_USES_AD595
+        #elif TEMP_SENSOR_0_IS_MAX_TC
+          return TERN(TEMP_SENSOR_0_IS_MAX31865, max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0), raw * 0.25);
+        #elif TEMP_SENSOR_0_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_0_USES_AD8495
+        #elif TEMP_SENSOR_0_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
-        #if HEATER_1_USER_THERMISTOR
+        #if TEMP_SENSOR_1_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
-        #elif HEATER_1_USES_MAX6675
-          return TERN(MAX6675_1_IS_MAX31865, max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1), raw * 0.25);
-        #elif HEATER_1_USES_AD595
+        #elif TEMP_SENSOR_1_IS_MAX_TC
+          return TERN(TEMP_SENSOR_1_IS_MAX31865, max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1), raw * 0.25);
+        #elif TEMP_SENSOR_1_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_1_USES_AD8495
+        #elif TEMP_SENSOR_1_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
-        #if HEATER_2_USER_THERMISTOR
+        #if TEMP_SENSOR_2_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
-        #elif HEATER_2_USES_AD595
+        #elif TEMP_SENSOR_2_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_2_USES_AD8495
+        #elif TEMP_SENSOR_2_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 3:
-        #if HEATER_3_USER_THERMISTOR
+        #if TEMP_SENSOR_3_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_3, raw);
-        #elif HEATER_3_USES_AD595
+        #elif TEMP_SENSOR_3_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_3_USES_AD8495
+        #elif TEMP_SENSOR_3_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 4:
-        #if HEATER_4_USER_THERMISTOR
+        #if TEMP_SENSOR_4_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_4, raw);
-        #elif HEATER_4_USES_AD595
+        #elif TEMP_SENSOR_4_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_4_USES_AD8495
+        #elif TEMP_SENSOR_4_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 5:
-        #if HEATER_5_USER_THERMISTOR
+        #if TEMP_SENSOR_5_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_5, raw);
-        #elif HEATER_5_USES_AD595
+        #elif TEMP_SENSOR_5_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_5_USES_AD8495
+        #elif TEMP_SENSOR_5_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 6:
-        #if HEATER_6_USER_THERMISTOR
+        #if TEMP_SENSOR_6_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_6, raw);
-        #elif HEATER_6_USES_AD595
+        #elif TEMP_SENSOR_6_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_6_USES_AD8495
+        #elif TEMP_SENSOR_6_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 7:
-        #if HEATER_7_USER_THERMISTOR
+        #if TEMP_SENSOR_7_IS_CUSTOM
           return user_thermistor_to_deg_c(CTI_HOTEND_7, raw);
-        #elif HEATER_7_USES_AD595
+        #elif TEMP_SENSOR_7_IS_AD595
           return TEMP_AD595(raw);
-        #elif HEATER_7_USES_AD8495
+        #elif TEMP_SENSOR_7_IS_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       default: break;
     }
 
     #if HAS_HOTEND_THERMISTOR
       // Thermistor with conversion table?
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
@@ -1591,101 +1595,101 @@ void Temperature::manage_heater() {
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
-    #if HEATER_BED_USER_THERMISTOR
+    #if TEMP_SENSOR_BED_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_BED, raw);
-    #elif HEATER_BED_USES_THERMISTOR
-      SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
-    #elif HEATER_BED_USES_AD595
+    #elif TEMP_SENSOR_BED_IS_THERMISTOR
+      SCAN_THERMISTOR_TABLE(TEMPTABLE_BED, TEMPTABLE_BED_LEN);
+    #elif TEMP_SENSOR_BED_IS_AD595
       return TEMP_AD595(raw);
-    #elif HEATER_BED_USES_AD8495
+    #elif TEMP_SENSOR_BED_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
-    #if HEATER_CHAMBER_USER_THERMISTOR
+    #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
-    #elif HEATER_CHAMBER_USES_THERMISTOR
-      SCAN_THERMISTOR_TABLE(CHAMBER_TEMPTABLE, CHAMBER_TEMPTABLE_LEN);
-    #elif HEATER_CHAMBER_USES_AD595
+    #elif TEMP_SENSOR_CHAMBER_IS_THERMISTOR
+      SCAN_THERMISTOR_TABLE(TEMPTABLE_CHAMBER, TEMPTABLE_CHAMBER_LEN);
+    #elif TEMP_SENSOR_CHAMBER_IS_AD595
       return TEMP_AD595(raw);
-    #elif HEATER_CHAMBER_USES_AD8495
+    #elif TEMP_SENSOR_CHAMBER_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_PROBE
   // Derived from RepRap FiveD extruder::getTemperature()
   // For probe temperature measurement.
   float Temperature::analog_to_celsius_probe(const int raw) {
-    #if HEATER_PROBE_USER_THERMISTOR
+    #if TEMP_SENSOR_PROBE_IS_CUSTOM
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
-    #elif HEATER_PROBE_USES_THERMISTOR
-      SCAN_THERMISTOR_TABLE(PROBE_TEMPTABLE, PROBE_TEMPTABLE_LEN);
-    #elif HEATER_PROBE_USES_AD595
+    #elif TEMP_SENSOR_PROBE_IS_THERMISTOR
+      SCAN_THERMISTOR_TABLE(TEMPTABLE_PROBE, TEMPTABLE_PROBE_LEN);
+    #elif TEMP_SENSOR_PROBE_IS_AD595
       return TEMP_AD595(raw);
-    #elif HEATER_PROBE_USES_AD8495
+    #elif TEMP_SENSOR_PROBE_IS_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
-  TERN_(HEATER_0_USES_MAX6675, temp_hotend[0].raw = READ_MAX6675(0));
-  TERN_(HEATER_1_USES_MAX6675, temp_hotend[1].raw = READ_MAX6675(1));
+  TERN_(TEMP_SENSOR_0_IS_MAX_TC, temp_hotend[0].raw = READ_MAX_TC(0));
+  TERN_(TEMP_SENSOR_1_IS_MAX_TC, temp_hotend[1].raw = READ_MAX_TC(1));
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
   TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
   TERN_(TEMP_SENSOR_1_AS_REDUNDANT, redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1));
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
 
-#if MAX6675_SEPARATE_SPI
+#if THERMO_SEPARATE_SPI
   template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin> SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
-  SPIclass<MAX6675_DO_PIN, SD_MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
+  SPIclass<MAX6675_DO_PIN, SD_MOSI_PIN, MAX6675_SCK_PIN> max_tc_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef ALFAWISE_UX0
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
@@ -1708,44 +1712,44 @@ void Temperature::updateTemperaturesFromRawValues() {
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
-  TERN_(MAX6675_0_IS_MAX31865, max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-  TERN_(MAX6675_1_IS_MAX31865, max31865_1.begin(MAX31865_2WIRE));
+  TERN_(TEMP_SENSOR_0_IS_MAX31865, max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+  TERN_(TEMP_SENSOR_1_IS_MAX31865, max31865_1.begin(MAX31865_2WIRE));
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
-    #define _AD(N) (HEATER_##N##_USES_AD595 || HEATER_##N##_USES_AD8495)
+    #define _AD(N) (TEMP_SENSOR_##N##_IS_AD595 || TEMP_SENSOR_##N##_IS_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   // Thermistor activation by MCU pin
-  #if PIN_EXISTS(TEMP_0_TR_ENABLE_PIN)
-    OUT_WRITE(TEMP_0_TR_ENABLE_PIN, ENABLED(HEATER_0_USES_MAX6675));
+  #if PIN_EXISTS(TEMP_0_TR_ENABLE)
+    OUT_WRITE(TEMP_0_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_0_IS_MAX_TC));
   #endif
-  #if PIN_EXISTS(TEMP_1_TR_ENABLE_PIN)
-    OUT_WRITE(TEMP_1_TR_ENABLE_PIN, ENABLED(HEATER_1_USES_MAX6675));
+  #if PIN_EXISTS(TEMP_1_TR_ENABLE)
+    OUT_WRITE(TEMP_1_TR_ENABLE_PIN, ENABLED(TEMP_SENSOR_1_IS_MAX_TC));
   #endif
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
     #ifdef ALFAWISE_UX0
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
@@ -1808,21 +1812,21 @@ void Temperature::init() {
   #if HAS_FAN6
     INIT_FAN_PIN(FAN6_PIN);
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
-  TERN_(MAX6675_SEPARATE_SPI, max6675_spi.init());
+  TERN_(THERMO_SEPARATE_SPI, max_tc_spi.init());
 
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
@@ -1907,33 +1911,33 @@ void Temperature::init() {
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
-      const int16_t tmin = _MAX(HEATER_ ##NR## _MINTEMP, TERN(HEATER_##NR##_USER_THERMISTOR, 0, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MINTEMP_IND].celsius))); \
+      const int16_t tmin = _MAX(HEATER_##NR##_MINTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 0, (int16_t)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MINTEMP_IND].celsius))); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
-      const int16_t tmax = _MIN(HEATER_ ##NR## _MAXTEMP, TERN(HEATER_##NR##_USER_THERMISTOR, 2000, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MAXTEMP_IND].celsius) - 1)); \
+      const int16_t tmax = _MIN(HEATER_##NR##_MAXTEMP, TERN(TEMP_SENSOR_##NR##_IS_CUSTOM, 2000, (int16_t)pgm_read_word(&TEMPTABLE_##NR [TEMP_SENSOR_##NR##_MAXTEMP_IND].celsius) - 1)); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #define _MINMAX_TEST(N,M) (HOTENDS > N && THERMISTOR_HEATER_##N && THERMISTOR_HEATER_##N != 998 && THERMISTOR_HEATER_##N != 999 && defined(HEATER_##N##_##M##TEMP))
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && TEMP_SENSOR_ ##N## THERMISTOR_ID && TEMP_SENSOR_ ##N## THERMISTOR_ID != 998 && TEMP_SENSOR_ ##N## THERMISTOR_ID != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
       _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif
@@ -2214,119 +2218,120 @@ void Temperature::disable_all_heaters() {
     if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
       setTargetHotend(singlenozzle_temp[new_tool], 0);
       TERN_(AUTOTEMP, planner.autotemp_update());
       TERN_(HAS_DISPLAY, set_heating_message(0));
       (void)wait_for_hotend(0, false);  // Wait for heating or cooling
     }
   }
 
 #endif
 
-#if HAS_MAX6675
+#if HAS_MAX_TC
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 
-  int Temperature::read_max6675(TERN_(HAS_MULTI_6675, const uint8_t hindex/*=0*/)) {
+  int Temperature::read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex/*=0*/)) {
     #define MAX6675_HEAT_INTERVAL 250UL
 
-    #if MAX6675_0_IS_MAX31855 || MAX6675_1_IS_MAX31855
-      static uint32_t max6675_temp = 2000;
-      #define MAX6675_ERROR_MASK    7
-      #define MAX6675_DISCARD_BITS 18
-      #define MAX6675_SPEED_BITS    3       // (_BV(SPR1)) // clock √∑ 64
-    #elif HAS_MAX31865
-      static uint16_t max6675_temp = 2000;  // From datasheet 16 bits D15-D0
-      #define MAX6675_ERROR_MASK    1       // D0 Bit not used
-      #define MAX6675_DISCARD_BITS  1       // Data is in D15-D1
-      #define MAX6675_SPEED_BITS    3       //  (_BV(SPR1)) // clock √∑ 64
+    #if HAS_MAX31855
+      static uint32_t max_tc_temp = 2000;
+      #define MAX_TC_ERROR_MASK    7
+      #define MAX_TC_DISCARD_BITS 18
+      #define MAX_TC_SPEED_BITS    3        // (_BV(SPR1)) // clock √∑ 64
+    #elif HAS_MAX31865_TEMP
+      static uint16_t max_tc_temp = 2000;   // From datasheet 16 bits D15-D0
+      #define MAX_TC_ERROR_MASK    1        // D0 Bit not used
+      #define MAX_TC_DISCARD_BITS  1        // Data is in D15-D1
+      #define MAX_TC_SPEED_BITS    3        //  (_BV(SPR1)) // clock √∑ 64
     #else
-      static uint16_t max6675_temp = 2000;
-      #define MAX6675_ERROR_MASK    4
-      #define MAX6675_DISCARD_BITS  3
-      #define MAX6675_SPEED_BITS    2       // (_BV(SPR0)) // clock √∑ 16
+      static uint16_t max_tc_temp = 2000;
+      #define MAX_TC_ERROR_MASK    4
+      #define MAX_TC_DISCARD_BITS  3
+      #define MAX_TC_SPEED_BITS    2        // (_BV(SPR0)) // clock √∑ 16
     #endif
 
-    #if HAS_MULTI_6675
+    #if HAS_MULTI_MAX_TC
       // Needed to return the correct temp when this is called between readings
-      static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
-      #define MAX6675_TEMP(I) max6675_temp_previous[I]
-      #define MAX6675_SEL(A,B) (hindex ? (B) : (A))
+      static uint16_t max_tc_temp_previous[MAX_TC_COUNT] = { 0 };
+      #define THERMO_TEMP(I) max_tc_temp_previous[I]
+      #define THERMO_SEL(A,B) (hindex ? (B) : (A))
       #define MAX6675_WRITE(V)     do{ switch (hindex) { case 1:      WRITE(MAX6675_SS2_PIN, V); break; default:      WRITE(MAX6675_SS_PIN, V); } }while(0)
       #define MAX6675_SET_OUTPUT() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN);    break; default: SET_OUTPUT(MAX6675_SS_PIN);    } }while(0)
     #else
       constexpr uint8_t hindex = 0;
-      #define MAX6675_TEMP(I) max6675_temp
-      #if MAX6675_1_IS_MAX31865
-        #define MAX6675_SEL(A,B) B
+      #define THERMO_TEMP(I) max_tc_temp
+      #if TEMP_SENSOR_1_IS_MAX31865
+        #define THERMO_SEL(A,B) B
       #else
-        #define MAX6675_SEL(A,B) A
+        #define THERMO_SEL(A,B) A
       #endif
-      #if HEATER_0_USES_MAX6675
+      #if TEMP_SENSOR_0_IS_MAX6675
         #define MAX6675_WRITE(V)          WRITE(MAX6675_SS_PIN, V)
         #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS_PIN)
       #else
         #define MAX6675_WRITE(V)          WRITE(MAX6675_SS2_PIN, V)
         #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS2_PIN)
       #endif
+
     #endif
 
-    static uint8_t max6675_errors[COUNT_6675] = { 0 };
+    static uint8_t max_tc_errors[MAX_TC_COUNT] = { 0 };
 
     // Return last-read value between readings
-    static millis_t next_max6675_ms[COUNT_6675] = { 0 };
+    static millis_t next_max_tc_ms[MAX_TC_COUNT] = { 0 };
     millis_t ms = millis();
-    if (PENDING(ms, next_max6675_ms[hindex])) return int(MAX6675_TEMP(hindex));
-    next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
+    if (PENDING(ms, next_max_tc_ms[hindex])) return int(THERMO_TEMP(hindex));
+    next_max_tc_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
-    #if HAS_MAX31865
-      Adafruit_MAX31865 &maxref = MAX6675_SEL(max31865_0, max31865_1);
-      const uint16_t max31865_ohms = (uint32_t(maxref.readRTD()) * MAX6675_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
+    #if HAS_MAX31865_TEMP
+      Adafruit_MAX31865 &maxref = THERMO_SEL(max31865_0, max31865_1);
+      const uint16_t max31865_ohms = (uint32_t(maxref.readRTD()) * THERMO_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
     #endif
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
-    #if !MAX6675_SEPARATE_SPI
+    #if !THERMO_SEPARATE_SPI
       spiBegin();
-      spiInit(MAX6675_SPEED_BITS);
+      spiInit(MAX_TC_SPEED_BITS);
     #endif
 
-    MAX6675_WRITE(LOW);  // enable TT_MAX6675
-    DELAY_NS(100);       // Ensure 100ns delay
+    MAX6675_WRITE(LOW); // enable TT_MAX6675
+    DELAY_NS(100);      // Ensure 100ns delay
 
     // Read a big-endian temperature value
-    max6675_temp = 0;
-    for (uint8_t i = sizeof(max6675_temp); i--;) {
-      max6675_temp |= TERN(MAX6675_SEPARATE_SPI, max6675_spi.receive(), spiRec());
-      if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
+    max_tc_temp = 0;
+    for (uint8_t i = sizeof(max_tc_temp); i--;) {
+      max_tc_temp |= TERN(THERMO_SEPARATE_SPI, max_tc_spi.receive(), spiRec());
+      if (i > 0) max_tc_temp <<= 8; // shift left if not the last byte
     }
 
     MAX6675_WRITE(HIGH); // disable TT_MAX6675
 
-    const uint8_t fault_31865 = TERN1(HAS_MAX31865, maxref.readFault());
+    const uint8_t fault_31865 = TERN1(HAS_MAX31865_TEMP, maxref.readFault());
 
-    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS) && (max6675_temp & MAX6675_ERROR_MASK) && fault_31865) {
-      max6675_errors[hindex]++;
-      if (max6675_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
+    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS) && (max_tc_temp & MAX_TC_ERROR_MASK) && fault_31865) {
+      max_tc_errors[hindex]++;
+      if (max_tc_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
-        #if MAX6675_ERROR_MASK == 7
+        #if MAX_TC_ERROR_MASK == 7
           SERIAL_ECHOPGM("MAX31855 ");
-          if (max6675_temp & 1)
+          if (max_tc_temp & 1)
             SERIAL_ECHOLNPGM("Open Circuit");
-          else if (max6675_temp & 2)
+          else if (max_tc_temp & 2)
             SERIAL_ECHOLNPGM("Short to GND");
-          else if (max6675_temp & 4)
+          else if (max_tc_temp & 4)
             SERIAL_ECHOLNPGM("Short to VCC");
-        #elif HAS_MAX31865
+        #elif HAS_MAX31865_TEMP
           if (fault_31865) {
             maxref.clearFault();
             SERIAL_ECHOPAIR("MAX31865 Fault :(", fault_31865, ")  >>");
             if (fault_31865 & MAX31865_FAULT_HIGHTHRESH)
               SERIAL_ECHOLNPGM("RTD High Threshold");
             else if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
               SERIAL_ECHOLNPGM("RTD Low Threshold");
             else if (fault_31865 & MAX31865_FAULT_REFINLOW)
               SERIAL_ECHOLNPGM("REFIN- > 0.85 x Bias");
             else if (fault_31865 & MAX31865_FAULT_REFINHIGH)
@@ -2334,57 +2339,57 @@ void Temperature::disable_all_heaters() {
             else if (fault_31865 & MAX31865_FAULT_RTDINLOW)
               SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
             else if (fault_31865 & MAX31865_FAULT_OVUV)
               SERIAL_ECHOLNPGM("Under/Over voltage");
           }
         #else
           SERIAL_ECHOLNPGM("MAX6675");
         #endif
 
         // Thermocouple open
-        max6675_temp = 4 * MAX6675_SEL(HEATER_0_MAX6675_TMAX, HEATER_1_MAX6675_TMAX);
+        max_tc_temp = 4 * THERMO_SEL(TEMP_SENSOR_0_MAX_TC_TMAX, TEMP_SENSOR_1_MAX_TC_TMAX);
       }
       else
-        max6675_temp >>= MAX6675_DISCARD_BITS;
+        max_tc_temp >>= MAX_TC_DISCARD_BITS;
     }
     else {
-      max6675_temp >>= MAX6675_DISCARD_BITS;
-      max6675_errors[hindex] = 0;
+      max_tc_temp >>= MAX_TC_DISCARD_BITS;
+      max_tc_errors[hindex] = 0;
     }
 
-    #if MAX6675_0_IS_MAX31855 || MAX6675_1_IS_MAX31855
-      if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000; // Support negative temperature
+    #if HAS_MAX31855
+      if (max_tc_temp & 0x00002000) max_tc_temp |= 0xFFFFC000; // Support negative temperature
     #endif
 
     // Return the RTD resistance for MAX31865 for display in SHOW_TEMP_ADC_VALUES
-    TERN_(HAS_MAX31865, max6675_temp = max31865_ohms);
+    TERN_(HAS_MAX31865_TEMP, max_tc_temp = max31865_ohms);
 
-    MAX6675_TEMP(hindex) = max6675_temp;
+    THERMO_TEMP(hindex) = max_tc_temp;
 
-    return int(max6675_temp);
+    return int(max_tc_temp);
   }
 
-#endif // HAS_MAX6675
+#endif // HAS_MAX_TC
 
 /**
  * Update raw temperatures
  */
 void Temperature::update_raw_temperatures() {
 
-  #if HAS_TEMP_ADC_0 && !HEATER_0_USES_MAX6675
+  #if HAS_TEMP_ADC_0 && !TEMP_SENSOR_0_IS_MAX_TC
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = temp_hotend[1].acc;
-    #elif !HEATER_1_USES_MAX6675
+    #elif !TEMP_SENSOR_1_IS_MAX_TC
       temp_hotend[1].update();
     #endif
   #endif
 
   TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
@@ -2416,23 +2421,23 @@ void Temperature::readings_ready() {
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE, temp_probe.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 
   #if HAS_HOTEND
 
     static constexpr int8_t temp_dir[] = {
-      TERN(HEATER_0_USES_MAX6675, 0, TEMPDIR(0))
+      TERN(TEMP_SENSOR_0_IS_MAX_TC, 0, TEMPDIR(0))
       #if HAS_MULTI_HOTEND
-        , TERN(HEATER_1_USES_MAX6675, 0, TEMPDIR(1))
+        , TERN(TEMP_SENSOR_1_IS_MAX_TC, 0, TEMPDIR(1))
         #if HOTENDS > 2
           #define _TEMPDIR(N) , TEMPDIR(N)
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif
       #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {

commit 708ea3d0bb82f067424c75636c28a549aa3d3b06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 23:22:42 2021 -0600

    Use serial shorthand

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b5820e17bf..f6d22420f2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1030,22 +1030,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
       }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
     {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPAIR(
+      SERIAL_ECHO_MSG(
         " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output,
         #if DISABLED(PID_OPENLOOP)
           STR_PID_DEBUG_PTERM, work_pid.Kp,
           STR_PID_DEBUG_ITERM, work_pid.Ki,
           STR_PID_DEBUG_DTERM, work_pid.Kd,
         #endif
       );
     }
     #endif
 

commit 07b4cc145bf6d84245b93f9f72fb0ac0f9d8d380
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 01:11:50 2021 +0100

    Fix AutoReporter implementation (#20959)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c6ed3d3a48..b5820e17bf 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3116,22 +3116,22 @@ void Temperature::tick() {
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
-    Temperature::AutoReportTemp Temperature::auto_reporter;
-    void Temperature::AutoReportTemp::auto_report() {
+    AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
+    void Temperature::AutoReportTemp::report() {
       print_heater_states(active_extruder);
       SERIAL_EOL();
     }
   #endif
 
   #if HAS_HOTEND && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HAS_MULTI_HOTEND

commit 27366197f3380627af365b005702bbe16393a18a
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 00:21:27 2021 +0100

    Serial refactor followup (#20932)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e1fd00dcd6..c6ed3d3a48 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2055,21 +2055,21 @@ void Temperature::init() {
       // Convert the given heater_id_t to an idle array index
       const IdleIndex idle_index = idle_index_for_id(heater_id);
     #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       switch (heater_id) {
         case H_BED:     SERIAL_ECHOPGM("bed"); break;
         case H_CHAMBER: SERIAL_ECHOPGM("chamber"); break;
-        default:        SERIAL_ECHO(heater_id);
+        default:        SERIAL_ECHO((int)heater_id);
       }
       SERIAL_ECHOLNPAIR(
         " ; sizeof(running_temp):", sizeof(running_temp),
         " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
         #if HEATER_IDLE_HANDLER
           , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
         #endif
       );
     //*/
 

commit 9d0e64a725290233d6002017147c578ffd32c504
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 28 20:40:20 2021 -0600

    AutoReport class (Temperature, Cardreader) (#20913)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 139f6b9045..e1fd00dcd6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1269,21 +1269,21 @@ void Temperature::manage_heater() {
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
           if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {
             // Open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds if the
             // temperature didn't drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             if (next_cool_check_ms_2 == 0 || ELAPSED(ms, next_cool_check_ms_2)) {
               if (old_temp - temp_chamber.celsius < float(MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)) flag_chamber_excess_heat = true; //the bed is heating the chamber too much
-              next_cool_check_ms_2 = ms + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER_VENT;
+              next_cool_check_ms_2 = ms + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER_VENT);
               old_temp = temp_chamber.celsius;
             }
           }
           else {
             next_cool_check_ms_2 = 0;
             old_temp = 9999;
           }
           if (flag_chamber_excess_heat && (temp_chamber.celsius - temp_chamber.target <= -LOW_EXCESS_HEAT_LIMIT) ) {
             flag_chamber_excess_heat = false;
           }
@@ -3116,34 +3116,26 @@ void Temperature::tick() {
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
-
-    uint8_t Temperature::auto_report_temp_interval;
-    millis_t Temperature::next_temp_report_ms;
-
-    void Temperature::auto_report_temperatures() {
-      if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
-        next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-        PORT_REDIRECT(SERIAL_ALL);
-        print_heater_states(active_extruder);
-        SERIAL_EOL();
-      }
+    Temperature::AutoReportTemp Temperature::auto_reporter;
+    void Temperature::AutoReportTemp::auto_report() {
+      print_heater_states(active_extruder);
+      SERIAL_EOL();
     }
-
-  #endif // AUTO_REPORT_TEMPERATURES
+  #endif
 
   #if HAS_HOTEND && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HAS_MULTI_HOTEND
           PSTR("E%c " S_FMT), '1' + e
         #else
           PSTR("E " S_FMT)
         #endif
@@ -3245,21 +3237,21 @@ void Temperature::tick() {
           first_loop = false;
 
         #endif
 
         // Prevent a wait-forever situation if R is misused i.e. M109 R0
         if (wants_to_cool) {
           // break after MIN_COOLING_SLOPE_TIME seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
-            next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
+            next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
@@ -3370,21 +3362,21 @@ void Temperature::tick() {
           }
 
         #endif // TEMP_BED_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M190 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_BED seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
-            next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
+            next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_BED);
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
@@ -3454,21 +3446,21 @@ void Temperature::tick() {
         // Break after MIN_DELTA_SLOPE_TIME_PROBE seconds if the temperature
         // did not drop at least MIN_DELTA_SLOPE_DEG_PROBE. This avoids waiting
         // forever as the probe is not actively heated.
         if (!next_delta_check_ms || ELAPSED(now, next_delta_check_ms)) {
           const float temp = degProbe(),
                       delta_temp = old_temp > temp ? old_temp - temp : temp - old_temp;
           if (delta_temp < float(MIN_DELTA_SLOPE_DEG_PROBE)) {
             SERIAL_ECHOLNPGM("Timed out waiting for probe temperature.");
             break;
           }
-          next_delta_check_ms = now + 1000UL * MIN_DELTA_SLOPE_TIME_PROBE;
+          next_delta_check_ms = now + SEC_TO_MS(MIN_DELTA_SLOPE_TIME_PROBE);
           old_temp = temp;
         }
 
         // Loop until the temperature is very close target
         if (!(wants_to_cool ? isProbeAboveTemp(target_temp) : isProbeBelowTemp(target_temp))) {
             SERIAL_ECHOLN(wants_to_cool ? PSTR("Cooldown") : PSTR("Heatup"));
             SERIAL_ECHOLNPGM(" complete, target probe temperature reached.");
             break;
         }
       }
@@ -3559,21 +3551,21 @@ void Temperature::tick() {
 
           first_loop = false;
         #endif // TEMP_CHAMBER_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M191 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_CHAMBER)) break;
-            next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER;
+            next_cool_check_ms = now + SEC_TO_MS(MIN_COOLING_SLOPE_TIME_CHAMBER);
             old_temp = temp;
           }
         }
       } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
 
       if (wait_for_heatup) {
         wait_for_heatup = false;
         ui.reset_status();
         return true;
       }

commit 3f01b222b2b4f77cff66096dd5a18a64828e1fa4
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Thu Jan 28 09:02:06 2021 +0100

    Refactor serial class with templates (#20783)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 589baf7796..139f6b9045 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -246,21 +246,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(target));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder
      */
     void Temperature::report_fan_speed(const uint8_t target) {
       if (target >= FAN_COUNT) return;
-      PORT_REDIRECT(SERIAL_BOTH);
+      PORT_REDIRECT(SERIAL_ALL);
       SERIAL_ECHOLNPAIR("M106 P", target, " S", fan_speed[target]);
     }
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
@@ -3123,21 +3123,21 @@ void Temperature::tick() {
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-        PORT_REDIRECT(SERIAL_BOTH);
+        PORT_REDIRECT(SERIAL_ALL);
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if HAS_HOTEND && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);

commit b8186b50817d33999a414400d82d876da7b40ee9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 25 08:32:58 2021 -0600

    Apply SEC_TO_MS and other fixes

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 00a048736a..589baf7796 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2179,21 +2179,20 @@ void Temperature::disable_all_heaters() {
       if (can_start) startOrResumeJob();
     }
     else if (can_stop) {
       print_job_timer.stop();
       ui.reset_status();
     }
   }
 
 #endif
 
-
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
         HOTEND_LOOP() heater_idle[e].expire();    // Timeout immediately
         TERN_(HAS_HEATED_BED, heater_idle[IDLE_INDEX_BED].expire()); // Timeout immediately
       }
       else {

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c15270f5eb..00a048736a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -20,28 +20,31 @@
  *
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
 // Useful when debugging thermocouples
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
+#include "../MarlinCore.h"
+#include "../HAL/shared/Delay.h"
+#include "../lcd/marlinui.h"
+
 #include "temperature.h"
 #include "endstops.h"
-
-#include "../MarlinCore.h"
 #include "planner.h"
-#include "../HAL/shared/Delay.h"
 
-#include "../lcd/marlinui.h"
+#if ENABLED(EMERGENCY_PARSER)
+  #include "motion.h"
+#endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if MAX6675_0_IS_MAX31865 || MAX6675_1_IS_MAX31865

commit 3f90ecfd77b608908d9a945a79518842f6d4471e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 19 20:58:50 2021 -0600

    Move singlenozzle temp/fan (#20829)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 85222a3463..c15270f5eb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -370,20 +370,27 @@ volatile bool Temperature::raw_temps_ready = false;
 
 #if HAS_AUTO_FAN
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
+#if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
+  uint16_t Temperature::singlenozzle_temp[EXTRUDERS];
+  #if HAS_FAN
+    uint8_t Temperature::singlenozzle_fan_speed[EXTRUDERS];
+  #endif
+#endif
+
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint16_t Temperature::ADCKey_count = 0;
 #endif
@@ -2188,20 +2195,38 @@ void Temperature::disable_all_heaters() {
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
+#if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
+
+  void Temperature::singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool) {
+    #if HAS_FAN
+      singlenozzle_fan_speed[old_tool] = fan_speed[0];
+      fan_speed[0] = singlenozzle_fan_speed[new_tool];
+    #endif
+    singlenozzle_temp[old_tool] = temp_hotend[0].target;
+    if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
+      setTargetHotend(singlenozzle_temp[new_tool], 0);
+      TERN_(AUTOTEMP, planner.autotemp_update());
+      TERN_(HAS_DISPLAY, set_heating_message(0));
+      (void)wait_for_hotend(0, false);  // Wait for heating or cooling
+    }
+  }
+
+#endif
+
 #if HAS_MAX6675
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 
   int Temperature::read_max6675(TERN_(HAS_MULTI_6675, const uint8_t hindex/*=0*/)) {
     #define MAX6675_HEAT_INTERVAL 250UL
 
     #if MAX6675_0_IS_MAX31855 || MAX6675_1_IS_MAX31855

commit f2726399dded441ab751471a8058831636dfaff6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 6 21:32:30 2021 -0600

    Move WRITE_FAN

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 924d796bfc..85222a3463 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2529,20 +2529,22 @@ void Temperature::tick() {
   #endif
 
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
+  #define WRITE_FAN(n, v) WRITE(FAN##n##_PIN, (v) ^ FAN_INVERTING)
+
   #if DISABLED(SLOW_PWM_HEATERS)
 
     #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, FAN_SOFT_PWM)
       constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \
         const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
         WRITE_HEATER_##N(on);                               \
       }while(0)
     #endif
 

commit 1eb592550c905eaefea4ccf16665187e11206a3e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Jan 5 13:18:09 2021 +0100

    Temperature report followup (#20687)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3c10354d02..924d796bfc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1397,22 +1397,21 @@ void Temperature::manage_heater() {
     };
     COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
     else
       SERIAL_ECHO_START();
-    SERIAL_CHAR('P');
-    SERIAL_CHAR('0' + t_index);
+    SERIAL_CHAR('P', '0' + t_index);
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
     SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     serialprintPGM(
       TERN_(HEATER_0_USER_THERMISTOR, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
@@ -2994,29 +2993,33 @@ void Temperature::tick() {
         #if HAS_HEATED_BED
           case H_BED: k = 'B'; break;
         #endif
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           case H_REDUNDANT: k = 'R'; break;
         #endif
       #elif HAS_HEATED_BED
         default: k = 'B'; break;
       #endif
     }
-    SERIAL_CHAR(' ');
-    SERIAL_CHAR(k);
+    SERIAL_CHAR(' ', k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
+    #ifdef SERIAL_FLOAT_PRECISION
+      #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
+    #else
+      #define SFP 2
+    #endif
     SERIAL_CHAR(':');
-    SERIAL_PRINT(c, _MIN(SERIAL_FLOAT_PRECISION, 2));
+    SERIAL_PRINT(c, SFP);
     SERIAL_ECHOPGM(" /");
-    SERIAL_PRINT(t, _MIN(SERIAL_FLOAT_PRECISION, 2));
+    SERIAL_PRINT(t, SFP);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_ECHOPAIR(" (", r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       , const bool include_r/*=false*/

commit dc3cfd0d9dcb874a160289df24bc812757eba3a5
Author: FanDjango <51046875+FanDjango@users.noreply.github.com>
Date:   Tue Jan 5 06:57:58 2021 +0100

    Adjustable precision in M105 temperature report (#20602)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 327f43dc03..3c10354d02 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3000,22 +3000,23 @@ void Temperature::tick() {
       #elif HAS_HEATED_BED
         default: k = 'B'; break;
       #endif
     }
     SERIAL_CHAR(' ');
     SERIAL_CHAR(k);
     #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     SERIAL_CHAR(':');
-    SERIAL_ECHO(c);
-    SERIAL_ECHOPAIR(" /" , t);
+    SERIAL_PRINT(c, _MIN(SERIAL_FLOAT_PRECISION, 2));
+    SERIAL_ECHOPGM(" /");
+    SERIAL_PRINT(t, _MIN(SERIAL_FLOAT_PRECISION, 2));
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_ECHOPAIR(" (", r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       , const bool include_r/*=false*/

commit 2d88bcb67e558f508f37b16b2789fd3e2b1755e9
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sun Jan 3 20:39:15 2021 -0700

    Fix thermal error protection, reporting (#20655)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6f02f3b900..327f43dc03 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -786,23 +786,30 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(PGM_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
   #if USE_BEEPER
+    thermalManager.disable_all_heaters();
     for (uint8_t i = 20; i--;) {
-      WRITE(BEEPER_PIN, HIGH); delay(25);
-      WRITE(BEEPER_PIN, LOW); delay(80);
+      WRITE(BEEPER_PIN, HIGH);
+      delay(25);
+      watchdog_refresh();
+      WRITE(BEEPER_PIN, LOW);
+      delay(40);
+      watchdog_refresh();
+      delay(40);
+      watchdog_refresh();
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
   kill(lcd_msg, HEATER_PSTR(heater_id));
 }
 
 void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
@@ -813,20 +820,21 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
     if (heater_id >= 0)
       SERIAL_ECHO((int)heater_id);
     else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER))
       SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
     else
       SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
+  watchdog_refresh();
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
       case 0:
         expire_ms = ms + BOGUS_TEMPERATURE_GRACE_PERIOD;
         ++killed;
         break;
       case 1:
@@ -916,22 +924,22 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
               }
               else
                 lpq[lpq_ptr] = 0;
 
               if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
               work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
               pid_output += work_pid[ee].Kc;
             }
           #endif // PID_EXTRUSION_SCALING
           #if ENABLED(PID_FAN_SCALING)
-            if (thermalManager.fan_speed[active_extruder] > PID_FAN_SCALING_MIN_SPEED) {
-              work_pid[ee].Kf = PID_PARAM(Kf, ee) + (PID_FAN_SCALING_LIN_FACTOR) * thermalManager.fan_speed[active_extruder];
+            if (fan_speed[active_extruder] > PID_FAN_SCALING_MIN_SPEED) {
+              work_pid[ee].Kf = PID_PARAM(Kf, ee) + (PID_FAN_SCALING_LIN_FACTOR) * fan_speed[active_extruder];
               pid_output += work_pid[ee].Kf;
             }
             //pid_output -= work_pid[ee].Ki;
             //pid_output += work_pid[ee].Ki * work_pid[ee].Kf
           #endif // PID_FAN_SCALING
           LIMIT(pid_output, 0, PID_MAX);
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
@@ -1236,21 +1244,21 @@ void Temperature::manage_heater() {
           #if CHAMBER_FAN_MODE == 0
             fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
             fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #endif
           NOMORE(fan_chamber_pwm, 225);
-          thermalManager.set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
+          set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
           if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {
@@ -1267,21 +1275,21 @@ void Temperature::manage_heater() {
             old_temp = 9999;
           }
           if (flag_chamber_excess_heat && (temp_chamber.celsius - temp_chamber.target <= -LOW_EXCESS_HEAT_LIMIT) ) {
             flag_chamber_excess_heat = false;
           }
         #endif
       }
       else if (!flag_chamber_off) {
         #if ENABLED(CHAMBER_FAN)
           flag_chamber_off = true;
-          thermalManager.set_fan_speed(2, 0);
+          set_fan_speed(2, 0);
         #endif
         #if ENABLED(CHAMBER_VENT)
           flag_chamber_excess_heat = false;
           MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
         #endif
       }
     #endif
 
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
@@ -1348,21 +1356,21 @@ void Temperature::manage_heater() {
       return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00); \
     }                                                                 \
   }                                                                   \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
-    user_thermistor_t user_thermistor[USER_THERMISTORS] = {
+    user_thermistor_t default_user_thermistor[USER_THERMISTORS] = {
       #if HEATER_0_USER_THERMISTOR
         { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
       #endif
       #if HEATER_1_USER_THERMISTOR
         { true, 0, 0, HOTEND1_PULLUP_RESISTOR_OHMS, HOTEND1_RESISTANCE_25C_OHMS, 0, 0, HOTEND1_BETA, 0 },
       #endif
       #if HEATER_2_USER_THERMISTOR
         { true, 0, 0, HOTEND2_PULLUP_RESISTOR_OHMS, HOTEND2_RESISTANCE_25C_OHMS, 0, 0, HOTEND2_BETA, 0 },
       #endif
       #if HEATER_3_USER_THERMISTOR
@@ -1380,21 +1388,21 @@ void Temperature::manage_heater() {
       #if HEATER_7_USER_THERMISTOR
         { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
       #endif
       #if HEATER_BED_USER_THERMISTOR
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
       #if HEATER_CHAMBER_USER_THERMISTOR
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
       #endif
     };
-    COPY(thermalManager.user_thermistor, user_thermistor);
+    COPY(user_thermistor, default_user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
     else
       SERIAL_ECHO_START();
     SERIAL_CHAR('P');
     SERIAL_CHAR('0' + t_index);
@@ -2416,32 +2424,32 @@ void Temperature::readings_ready() {
         }
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           else
             consecutive_low_temperature_error[e] = 0;
         #endif
       }
     }
 
   #endif // HAS_HOTEND
 
-  #if HAS_HEATED_BED
+  #if ENABLED(THERMAL_PROTECTION_BED)
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<(B))
     #else
       #define BEDCMP(A,B) ((A)>(B))
     #endif
     const bool bed_on = (temp_bed.target > 0) || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount > 0);
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
   #endif
 
-  #if HAS_HEATED_CHAMBER
+  #if BOTH(HAS_HEATED_CHAMBER, THERMAL_PROTECTION_CHAMBER)
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>(B))
     #endif
     const bool chamber_on = (temp_chamber.target > 0);
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
     if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
   #endif
 }

commit 4402a0578a9fa5c9743eb5774224ce206c618ce9
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 1 12:56:59 2021 -0800

    Fix CHAMBER_FAN_MODE 0 build (#20621)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fea992f681..6f02f3b900 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1227,21 +1227,21 @@ void Temperature::manage_heater() {
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
       if (temp_chamber.target > CHAMBER_MINTEMP) {
         flag_chamber_off = false;
 
         #if ENABLED(CHAMBER_FAN)
           #if CHAMBER_FAN_MODE == 0
-            fan_chamber_pwm = CHAMBER_FAN_BASE
+            fan_chamber_pwm = CHAMBER_FAN_BASE;
           #elif CHAMBER_FAN_MODE == 1
             fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #endif
           NOMORE(fan_chamber_pwm, 225);
           thermalManager.set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
         #endif

commit c840bbc970c2684c2c9c193ee967c03dd621d99a
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Jan 1 17:31:15 2021 -0300

    Prefix SD SPI pins (SCK, MISO, MOSI, SS) (#20606)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d704ebc85b..fea992f681 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -46,21 +46,21 @@
 
 #if MAX6675_0_IS_MAX31865 || MAX6675_1_IS_MAX31865
   #include <Adafruit_MAX31865.h>
   #if MAX6675_0_IS_MAX31865 && !defined(MAX31865_CS_PIN) && PIN_EXISTS(MAX6675_SS)
     #define MAX31865_CS_PIN   MAX6675_SS_PIN
   #endif
   #if MAX6675_1_IS_MAX31865 && !defined(MAX31865_CS2_PIN) && PIN_EXISTS(MAX6675_SS2)
     #define MAX31865_CS2_PIN  MAX6675_SS2_PIN
   #endif
   #ifndef MAX31865_MOSI_PIN
-    #define MAX31865_MOSI_PIN MOSI_PIN
+    #define MAX31865_MOSI_PIN SD_MOSI_PIN
   #endif
   #ifndef MAX31865_MISO_PIN
     #define MAX31865_MISO_PIN MAX6675_DO_PIN
   #endif
   #ifndef MAX31865_SCK_PIN
     #define MAX31865_SCK_PIN  MAX6675_SCK_PIN
   #endif
   #if MAX6675_0_IS_MAX31865 && PIN_EXISTS(MAX31865_CS)
     #define HAS_MAX31865 1
     Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
@@ -1655,21 +1655,21 @@ void Temperature::updateTemperaturesFromRawValues() {
   TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
 
 #if MAX6675_SEPARATE_SPI
   template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin> SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
-  SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
+  SPIclass<MAX6675_DO_PIN, SD_MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef ALFAWISE_UX0
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)

commit 58eaad703a5e369ab3bf6a1d325b8775d89ede0d
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 22 16:47:52 2020 -0800

    Fix dummy thermistors for Bed, Chamber, Probe (#20247)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d9ce6e151e..d704ebc85b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1832,27 +1832,27 @@ void Temperature::init() {
   #endif
   #if HAS_JOY_ADC_Y
     HAL_ANALOG_SELECT(JOY_Y_PIN);
   #endif
   #if HAS_JOY_ADC_Z
     HAL_ANALOG_SELECT(JOY_Z_PIN);
   #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
-  #if HAS_HEATED_BED
+  #if HAS_TEMP_ADC_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
-  #if HAS_TEMP_CHAMBER
+  #if HAS_TEMP_ADC_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
-  #if HAS_TEMP_PROBE
+  #if HAS_TEMP_ADC_PROBE
     HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
   #if ENABLED(POWER_MONITOR_CURRENT)
     HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
@@ -2348,23 +2348,23 @@ void Temperature::update_raw_temperatures() {
       temp_hotend[1].update();
     #endif
   #endif
 
   TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
-  TERN_(HAS_HEATED_BED, temp_bed.update());
-  TERN_(HAS_TEMP_CHAMBER, temp_chamber.update());
-  TERN_(HAS_TEMP_PROBE, temp_probe.update());
+  TERN_(HAS_TEMP_ADC_BED, temp_bed.update());
+  TERN_(HAS_TEMP_ADC_CHAMBER, temp_chamber.update());
+  TERN_(HAS_TEMP_ADC_PROBE, temp_probe.update());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.update());
   TERN_(HAS_JOY_ADC_Y, joystick.y.update());
   TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 
   raw_temps_ready = true;
 }
 
 void Temperature::readings_ready() {
 
@@ -2815,31 +2815,31 @@ void Temperature::tick() {
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
       case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
       case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
     #endif
 
-    #if HAS_HEATED_BED
+    #if HAS_TEMP_ADC_BED
       case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
       case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
-    #if HAS_TEMP_CHAMBER
+    #if HAS_TEMP_ADC_CHAMBER
       case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
       case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
-    #if HAS_TEMP_PROBE
+    #if HAS_TEMP_ADC_PROBE
       case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
       case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2

commit 615bf2a6f170ddbe4fb393600b743dafb944e9e9
Author: Simone Primarosa <simonepri@outlook.com>
Date:   Sat Nov 21 02:53:04 2020 +0100

    Fix bad SET_FAST_PWM_FREQ calls (#20227)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 19de70b31c..d9ce6e151e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1676,26 +1676,26 @@ void Temperature::updateTemperaturesFromRawValues() {
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
   #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
 #define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
 #if EXTRUDER_AUTO_FAN_SPEED != 255
-  #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
+  #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
 #else
   #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 #if CHAMBER_AUTO_FAN_SPEED != 255
-  #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
+  #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(P); } else SET_OUTPUT(P); }while(0)
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 

commit cb2ec628df4ae2cb79b39aa3d51273927c849340
Author: JoAnn Manges <joannmanges@gmail.com>
Date:   Wed Nov 18 21:12:03 2020 -0800

    Use RTD for MAX31865 reading (#20188)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 167b35cc2b..19de70b31c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2241,24 +2241,21 @@ void Temperature::disable_all_heaters() {
     static uint8_t max6675_errors[COUNT_6675] = { 0 };
 
     // Return last-read value between readings
     static millis_t next_max6675_ms[COUNT_6675] = { 0 };
     millis_t ms = millis();
     if (PENDING(ms, next_max6675_ms[hindex])) return int(MAX6675_TEMP(hindex));
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
     #if HAS_MAX31865
       Adafruit_MAX31865 &maxref = MAX6675_SEL(max31865_0, max31865_1);
-      max6675_temp = int(maxref.temperature(
-        MAX6675_SEL(MAX31865_SENSOR_OHMS_0, MAX31865_SENSOR_OHMS_1),
-        MAX6675_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)
-      ));
+      const uint16_t max31865_ohms = (uint32_t(maxref.readRTD()) * MAX6675_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)) >> 16;
     #endif
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
@@ -2318,20 +2315,23 @@ void Temperature::disable_all_heaters() {
     }
     else {
       max6675_temp >>= MAX6675_DISCARD_BITS;
       max6675_errors[hindex] = 0;
     }
 
     #if MAX6675_0_IS_MAX31855 || MAX6675_1_IS_MAX31855
       if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000; // Support negative temperature
     #endif
 
+    // Return the RTD resistance for MAX31865 for display in SHOW_TEMP_ADC_VALUES
+    TERN_(HAS_MAX31865, max6675_temp = max31865_ohms);
+
     MAX6675_TEMP(hindex) = max6675_temp;
 
     return int(max6675_temp);
   }
 
 #endif // HAS_MAX6675
 
 /**
  * Update raw temperatures
  */

commit f4e9f3654e9be66b5a2234642ccf736a8467dee3
Author: LinFor <linfor@gmail.com>
Date:   Thu Nov 12 01:27:45 2020 +0300

    Fix MAX6675 SPI init, conflicts (#20086)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 22c92fe448..167b35cc2b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1792,36 +1792,21 @@ void Temperature::init() {
   #if HAS_FAN6
     INIT_FAN_PIN(FAN6_PIN);
   #endif
   #if HAS_FAN7
     INIT_FAN_PIN(FAN7_PIN);
   #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
-  #if MAX6675_SEPARATE_SPI
-
-    OUT_WRITE(SCK_PIN, LOW);
-    OUT_WRITE(MOSI_PIN, HIGH);
-    SET_INPUT_PULLUP(MISO_PIN);
-
-    max6675_spi.init();
-
-    OUT_WRITE(SS_PIN, HIGH);
-    OUT_WRITE(MAX6675_SS_PIN, HIGH);
-
-  #endif
-
-  #if HEATER_1_USES_MAX6675
-    OUT_WRITE(MAX6675_SS2_PIN, HIGH);
-  #endif
+  TERN_(MAX6675_SEPARATE_SPI, max6675_spi.init());
 
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
@@ -2270,23 +2255,21 @@ void Temperature::disable_all_heaters() {
     #endif
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
-    MAX6675_SET_OUTPUT();
     MAX6675_WRITE(LOW);  // enable TT_MAX6675
-
     DELAY_NS(100);       // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
       max6675_temp |= TERN(MAX6675_SEPARATE_SPI, max6675_spi.receive(), spiRec());
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     MAX6675_WRITE(HIGH); // disable TT_MAX6675

commit 40d442fde294faedf839e3a80c82cd72c1824ba8
Author: JoAnn Manges <joannmanges@gmail.com>
Date:   Wed Nov 11 16:52:35 2020 -0500

    Fix MAX31865 on SPI (PT100/1000) support (#20074)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b476b35593..22c92fe448 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -37,44 +37,58 @@
 #include "../lcd/marlinui.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
-#if MAX6675_IS_MAX31865
+#if MAX6675_0_IS_MAX31865 || MAX6675_1_IS_MAX31865
   #include <Adafruit_MAX31865.h>
-  #ifndef MAX31865_CS_PIN
-    #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
+  #if MAX6675_0_IS_MAX31865 && !defined(MAX31865_CS_PIN) && PIN_EXISTS(MAX6675_SS)
+    #define MAX31865_CS_PIN   MAX6675_SS_PIN
+  #endif
+  #if MAX6675_1_IS_MAX31865 && !defined(MAX31865_CS2_PIN) && PIN_EXISTS(MAX6675_SS2)
+    #define MAX31865_CS2_PIN  MAX6675_SS2_PIN
   #endif
   #ifndef MAX31865_MOSI_PIN
-    #define MAX31865_MOSI_PIN   MOSI_PIN        //            63
+    #define MAX31865_MOSI_PIN MOSI_PIN
   #endif
   #ifndef MAX31865_MISO_PIN
-    #define MAX31865_MISO_PIN   MAX6675_DO_PIN  //            42
+    #define MAX31865_MISO_PIN MAX6675_DO_PIN
   #endif
   #ifndef MAX31865_SCK_PIN
-    #define MAX31865_SCK_PIN    MAX6675_SCK_PIN //            40
+    #define MAX31865_SCK_PIN  MAX6675_SCK_PIN
+  #endif
+  #if MAX6675_0_IS_MAX31865 && PIN_EXISTS(MAX31865_CS)
+    #define HAS_MAX31865 1
+    Adafruit_MAX31865 max31865_0 = Adafruit_MAX31865(MAX31865_CS_PIN
+      #if MAX31865_CS_PIN != MAX6675_SS_PIN
+        , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN // For software SPI also set MOSI/MISO/SCK
+      #endif
+    );
+  #endif
+  #if MAX6675_1_IS_MAX31865 && PIN_EXISTS(MAX31865_CS2)
+    #define HAS_MAX31865 1
+    Adafruit_MAX31865 max31865_1 = Adafruit_MAX31865(MAX31865_CS2_PIN
+      #if MAX31865_CS2_PIN != MAX6675_SS2_PIN
+        , MAX31865_MOSI_PIN, MAX31865_MISO_PIN, MAX31865_SCK_PIN // For software SPI also set MOSI/MISO/SCK
+      #endif
+    );
   #endif
-  Adafruit_MAX31865 max31865 = Adafruit_MAX31865(MAX31865_CS_PIN
-    #if MAX31865_CS_PIN != MAX6675_SS_PIN
-      , MAX31865_MOSI_PIN           // For software SPI also set MOSI/MISO/SCK
-      , MAX31865_MISO_PIN
-      , MAX31865_SCK_PIN
-    #endif
-  );
 #endif
 
-#define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PINS_EXIST(MAX6675_SCK, MAX6675_DO))
+#if EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PINS_EXIST(MAX6675_SCK, MAX6675_DO)
+  #define MAX6675_SEPARATE_SPI 1
+#endif
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
@@ -1464,39 +1478,33 @@ void Temperature::manage_heater() {
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if HEATER_0_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif HEATER_0_USES_MAX6675
-          return (
-            #if MAX6675_IS_MAX31865
-              max31865.temperature(MAX31865_SENSOR_OHMS, MAX31865_CALIBRATION_OHMS)
-            #else
-              raw * 0.25
-            #endif
-          );
+          return TERN(MAX6675_0_IS_MAX31865, max31865_0.temperature(MAX31865_SENSOR_OHMS_0, MAX31865_CALIBRATION_OHMS_0), raw * 0.25);
         #elif HEATER_0_USES_AD595
           return TEMP_AD595(raw);
         #elif HEATER_0_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
         #if HEATER_1_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
         #elif HEATER_1_USES_MAX6675
-          return raw * 0.25;
+          return TERN(MAX6675_1_IS_MAX31865, max31865_1.temperature(MAX31865_SENSOR_OHMS_1, MAX31865_CALIBRATION_OHMS_1), raw * 0.25);
         #elif HEATER_1_USES_AD595
           return TEMP_AD595(raw);
         #elif HEATER_1_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
         #if HEATER_2_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
@@ -1684,21 +1692,22 @@ void Temperature::updateTemperaturesFromRawValues() {
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
-  TERN_(MAX6675_IS_MAX31865, max31865.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+  TERN_(MAX6675_0_IS_MAX31865, max31865_0.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+  TERN_(MAX6675_1_IS_MAX31865, max31865_1.begin(MAX31865_2WIRE));
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) (HEATER_##N##_USES_AD595 || HEATER_##N##_USES_AD8495)
@@ -2193,146 +2202,154 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // PROBING_HEATERS_OFF
 
 #if HAS_MAX6675
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
   #endif
 
-  int Temperature::read_max6675(
-    #if COUNT_6675 > 1
-      const uint8_t hindex
-    #endif
-  ) {
-    #if COUNT_6675 == 1
-      constexpr uint8_t hindex = 0;
-    #else
-      // Needed to return the correct temp when this is called too soon
-      static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
-    #endif
-
-    static uint8_t max6675_errors[COUNT_6675] = { 0 };
-
+  int Temperature::read_max6675(TERN_(HAS_MULTI_6675, const uint8_t hindex/*=0*/)) {
     #define MAX6675_HEAT_INTERVAL 250UL
 
-    #if MAX6675_IS_MAX31855
+    #if MAX6675_0_IS_MAX31855 || MAX6675_1_IS_MAX31855
       static uint32_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    7
       #define MAX6675_DISCARD_BITS 18
-      #define MAX6675_SPEED_BITS    3  // (_BV(SPR1)) // clock √∑ 64
+      #define MAX6675_SPEED_BITS    3       // (_BV(SPR1)) // clock √∑ 64
+    #elif HAS_MAX31865
+      static uint16_t max6675_temp = 2000;  // From datasheet 16 bits D15-D0
+      #define MAX6675_ERROR_MASK    1       // D0 Bit not used
+      #define MAX6675_DISCARD_BITS  1       // Data is in D15-D1
+      #define MAX6675_SPEED_BITS    3       //  (_BV(SPR1)) // clock √∑ 64
     #else
       static uint16_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    4
       #define MAX6675_DISCARD_BITS  3
-      #define MAX6675_SPEED_BITS    2  // (_BV(SPR0)) // clock √∑ 16
+      #define MAX6675_SPEED_BITS    2       // (_BV(SPR0)) // clock √∑ 16
     #endif
 
+    #if HAS_MULTI_6675
+      // Needed to return the correct temp when this is called between readings
+      static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
+      #define MAX6675_TEMP(I) max6675_temp_previous[I]
+      #define MAX6675_SEL(A,B) (hindex ? (B) : (A))
+      #define MAX6675_WRITE(V)     do{ switch (hindex) { case 1:      WRITE(MAX6675_SS2_PIN, V); break; default:      WRITE(MAX6675_SS_PIN, V); } }while(0)
+      #define MAX6675_SET_OUTPUT() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN);    break; default: SET_OUTPUT(MAX6675_SS_PIN);    } }while(0)
+    #else
+      constexpr uint8_t hindex = 0;
+      #define MAX6675_TEMP(I) max6675_temp
+      #if MAX6675_1_IS_MAX31865
+        #define MAX6675_SEL(A,B) B
+      #else
+        #define MAX6675_SEL(A,B) A
+      #endif
+      #if HEATER_0_USES_MAX6675
+        #define MAX6675_WRITE(V)          WRITE(MAX6675_SS_PIN, V)
+        #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS_PIN)
+      #else
+        #define MAX6675_WRITE(V)          WRITE(MAX6675_SS2_PIN, V)
+        #define MAX6675_SET_OUTPUT() SET_OUTPUT(MAX6675_SS2_PIN)
+      #endif
+    #endif
+
+    static uint8_t max6675_errors[COUNT_6675] = { 0 };
+
     // Return last-read value between readings
     static millis_t next_max6675_ms[COUNT_6675] = { 0 };
     millis_t ms = millis();
-    if (PENDING(ms, next_max6675_ms[hindex]))
-      return int(
-        #if COUNT_6675 == 1
-          max6675_temp
-        #else
-          max6675_temp_previous[hindex] // Need to return the correct previous value
-        #endif
-      );
-
+    if (PENDING(ms, next_max6675_ms[hindex])) return int(MAX6675_TEMP(hindex));
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
-    #if MAX6675_IS_MAX31865
-      max6675_temp = int(max31865.temperature(MAX31865_SENSOR_OHMS, MAX31865_CALIBRATION_OHMS));
+    #if HAS_MAX31865
+      Adafruit_MAX31865 &maxref = MAX6675_SEL(max31865_0, max31865_1);
+      max6675_temp = int(maxref.temperature(
+        MAX6675_SEL(MAX31865_SENSOR_OHMS_0, MAX31865_SENSOR_OHMS_1),
+        MAX6675_SEL(MAX31865_CALIBRATION_OHMS_0, MAX31865_CALIBRATION_OHMS_1)
+      ));
     #endif
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
-    #if COUNT_6675 > 1
-      #define WRITE_MAX6675(V) do{ switch (hindex) { case 1: WRITE(MAX6675_SS2_PIN, V); break; default: WRITE(MAX6675_SS_PIN, V); } }while(0)
-      #define SET_OUTPUT_MAX6675() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN); break; default: SET_OUTPUT(MAX6675_SS_PIN); } }while(0)
-    #elif HEATER_1_USES_MAX6675
-      #define WRITE_MAX6675(V) WRITE(MAX6675_SS2_PIN, V)
-      #define SET_OUTPUT_MAX6675() SET_OUTPUT(MAX6675_SS2_PIN)
-    #else
-      #define WRITE_MAX6675(V) WRITE(MAX6675_SS_PIN, V)
-      #define SET_OUTPUT_MAX6675() SET_OUTPUT(MAX6675_SS_PIN)
-    #endif
-
-    SET_OUTPUT_MAX6675();
-    WRITE_MAX6675(LOW);  // enable TT_MAX6675
+    MAX6675_SET_OUTPUT();
+    MAX6675_WRITE(LOW);  // enable TT_MAX6675
 
     DELAY_NS(100);       // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
-      max6675_temp |= (
-        #if MAX6675_SEPARATE_SPI
-          max6675_spi.receive()
-        #else
-          spiRec()
-        #endif
-      );
+      max6675_temp |= TERN(MAX6675_SEPARATE_SPI, max6675_spi.receive(), spiRec());
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
-    WRITE_MAX6675(HIGH); // disable TT_MAX6675
+    MAX6675_WRITE(HIGH); // disable TT_MAX6675
+
+    const uint8_t fault_31865 = TERN1(HAS_MAX31865, maxref.readFault());
 
-    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS) && (max6675_temp & MAX6675_ERROR_MASK)) {
-      max6675_errors[hindex] += 1;
+    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS) && (max6675_temp & MAX6675_ERROR_MASK) && fault_31865) {
+      max6675_errors[hindex]++;
       if (max6675_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
         #if MAX6675_ERROR_MASK == 7
           SERIAL_ECHOPGM("MAX31855 ");
           if (max6675_temp & 1)
             SERIAL_ECHOLNPGM("Open Circuit");
           else if (max6675_temp & 2)
             SERIAL_ECHOLNPGM("Short to GND");
           else if (max6675_temp & 4)
             SERIAL_ECHOLNPGM("Short to VCC");
+        #elif HAS_MAX31865
+          if (fault_31865) {
+            maxref.clearFault();
+            SERIAL_ECHOPAIR("MAX31865 Fault :(", fault_31865, ")  >>");
+            if (fault_31865 & MAX31865_FAULT_HIGHTHRESH)
+              SERIAL_ECHOLNPGM("RTD High Threshold");
+            else if (fault_31865 & MAX31865_FAULT_LOWTHRESH)
+              SERIAL_ECHOLNPGM("RTD Low Threshold");
+            else if (fault_31865 & MAX31865_FAULT_REFINLOW)
+              SERIAL_ECHOLNPGM("REFIN- > 0.85 x Bias");
+            else if (fault_31865 & MAX31865_FAULT_REFINHIGH)
+              SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
+            else if (fault_31865 & MAX31865_FAULT_RTDINLOW)
+              SERIAL_ECHOLNPGM("REFIN- < 0.85 x Bias - FORCE- open");
+            else if (fault_31865 & MAX31865_FAULT_OVUV)
+              SERIAL_ECHOLNPGM("Under/Over voltage");
+          }
         #else
           SERIAL_ECHOLNPGM("MAX6675");
         #endif
 
         // Thermocouple open
-        max6675_temp = 4 * (
-          #if COUNT_6675 > 1
-            hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
-          #else
-            TERN(HEATER_1_USES_MAX6675, HEATER_1_MAX6675_TMAX, HEATER_0_MAX6675_TMAX)
-          #endif
-        );
+        max6675_temp = 4 * MAX6675_SEL(HEATER_0_MAX6675_TMAX, HEATER_1_MAX6675_TMAX);
       }
       else
         max6675_temp >>= MAX6675_DISCARD_BITS;
     }
     else {
       max6675_temp >>= MAX6675_DISCARD_BITS;
       max6675_errors[hindex] = 0;
     }
 
-    #if ENABLED(MAX6675_IS_MAX31855)
+    #if MAX6675_0_IS_MAX31855 || MAX6675_1_IS_MAX31855
       if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000; // Support negative temperature
     #endif
 
-    #if COUNT_6675 > 1
-      max6675_temp_previous[hindex] = max6675_temp;
-    #endif
+    MAX6675_TEMP(hindex) = max6675_temp;
 
     return int(max6675_temp);
   }
 
 #endif // HAS_MAX6675
 
 /**
  * Update raw temperatures
  */
 void Temperature::update_raw_temperatures() {

commit 59eca253e1518f17e1ffe962ffc6e7bfa0db49a3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Nov 9 01:17:37 2020 -0600

    Simplified temp sensor conditionals

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4eb7216511..b476b35593 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -37,21 +37,21 @@
 #include "../lcd/marlinui.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
-#if ENABLED(MAX6675_IS_MAX31865)
+#if MAX6675_IS_MAX31865
   #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN   MOSI_PIN        //            63
   #endif
   #ifndef MAX31865_MISO_PIN
     #define MAX31865_MISO_PIN   MAX6675_DO_PIN  //            42
   #endif
@@ -107,21 +107,27 @@
   #include "tool_change.h"
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_SERVOS
   #include "./servo.h"
 #endif
-#if HOTEND_USES_THERMISTOR
+
+#if ANY(HEATER_0_USES_THERMISTOR, HEATER_1_USES_THERMISTOR, HEATER_2_USES_THERMISTOR, HEATER_3_USES_THERMISTOR, \
+        HEATER_4_USES_THERMISTOR, HEATER_5_USES_THERMISTOR, HEATER_6_USES_THERMISTOR, HEATER_7_USES_THERMISTOR )
+  #define HAS_HOTEND_THERMISTOR 1
+#endif
+
+#if HAS_HOTEND_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static const temp_entry_t* heater_ttbl_map[2] = { HEATER_0_TEMPTABLE, HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     #define NEXT_TEMPTABLE(N) ,HEATER_##N##_TEMPTABLE
     #define NEXT_TEMPTABLE_LEN(N) ,HEATER_##N##_TEMPTABLE_LEN
     static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
   #endif
 #endif
@@ -1039,25 +1045,25 @@ void Temperature::manage_heater() {
       emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
       quickstop_stepper();
     }
   #endif
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
-    #if ENABLED(HEATER_0_USES_MAX6675)
+    #if HEATER_0_USES_MAX6675
       if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
       if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
     #endif
-    #if ENABLED(HEATER_1_USES_MAX6675)
+    #if HEATER_1_USES_MAX6675
       if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
       if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
     #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
@@ -1329,48 +1335,48 @@ void Temperature::manage_heater() {
     }                                                                 \
   }                                                                   \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
     user_thermistor_t user_thermistor[USER_THERMISTORS] = {
-      #if ENABLED(HEATER_0_USER_THERMISTOR)
+      #if HEATER_0_USER_THERMISTOR
         { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_1_USER_THERMISTOR)
+      #if HEATER_1_USER_THERMISTOR
         { true, 0, 0, HOTEND1_PULLUP_RESISTOR_OHMS, HOTEND1_RESISTANCE_25C_OHMS, 0, 0, HOTEND1_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_2_USER_THERMISTOR)
+      #if HEATER_2_USER_THERMISTOR
         { true, 0, 0, HOTEND2_PULLUP_RESISTOR_OHMS, HOTEND2_RESISTANCE_25C_OHMS, 0, 0, HOTEND2_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_3_USER_THERMISTOR)
+      #if HEATER_3_USER_THERMISTOR
         { true, 0, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_4_USER_THERMISTOR)
+      #if HEATER_4_USER_THERMISTOR
         { true, 0, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_5_USER_THERMISTOR)
+      #if HEATER_5_USER_THERMISTOR
         { true, 0, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_6_USER_THERMISTOR)
+      #if HEATER_6_USER_THERMISTOR
         { true, 0, 0, HOTEND6_PULLUP_RESISTOR_OHMS, HOTEND6_RESISTANCE_25C_OHMS, 0, 0, HOTEND6_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_7_USER_THERMISTOR)
+      #if HEATER_7_USER_THERMISTOR
         { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_BED_USER_THERMISTOR)
+      #if HEATER_BED_USER_THERMISTOR
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
-      #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
+      #if HEATER_CHAMBER_USER_THERMISTOR
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
       #endif
     };
     COPY(thermalManager.user_thermistor, user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
@@ -1455,196 +1461,191 @@ void Temperature::manage_heater() {
       if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
         SERIAL_ECHO((int)e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
-        #if ENABLED(HEATER_0_USER_THERMISTOR)
+        #if HEATER_0_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
-        #elif ENABLED(HEATER_0_USES_MAX6675)
+        #elif HEATER_0_USES_MAX6675
           return (
-            #if ENABLED(MAX6675_IS_MAX31865)
+            #if MAX6675_IS_MAX31865
               max31865.temperature(MAX31865_SENSOR_OHMS, MAX31865_CALIBRATION_OHMS)
             #else
               raw * 0.25
             #endif
           );
-        #elif ENABLED(HEATER_0_USES_AD595)
+        #elif HEATER_0_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_0_USES_AD8495)
+        #elif HEATER_0_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
-        #if ENABLED(HEATER_1_USER_THERMISTOR)
+        #if HEATER_1_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
-        #elif ENABLED(HEATER_1_USES_MAX6675)
+        #elif HEATER_1_USES_MAX6675
           return raw * 0.25;
-        #elif ENABLED(HEATER_1_USES_AD595)
+        #elif HEATER_1_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_1_USES_AD8495)
+        #elif HEATER_1_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 2:
-        #if ENABLED(HEATER_2_USER_THERMISTOR)
+        #if HEATER_2_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
-        #elif ENABLED(HEATER_2_USES_AD595)
+        #elif HEATER_2_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_2_USES_AD8495)
+        #elif HEATER_2_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 3:
-        #if ENABLED(HEATER_3_USER_THERMISTOR)
+        #if HEATER_3_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_3, raw);
-        #elif ENABLED(HEATER_3_USES_AD595)
+        #elif HEATER_3_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_3_USES_AD8495)
+        #elif HEATER_3_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 4:
-        #if ENABLED(HEATER_4_USER_THERMISTOR)
+        #if HEATER_4_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_4, raw);
-        #elif ENABLED(HEATER_4_USES_AD595)
+        #elif HEATER_4_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_4_USES_AD8495)
+        #elif HEATER_4_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 5:
-        #if ENABLED(HEATER_5_USER_THERMISTOR)
+        #if HEATER_5_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_5, raw);
-        #elif ENABLED(HEATER_5_USES_AD595)
+        #elif HEATER_5_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_5_USES_AD8495)
+        #elif HEATER_5_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 6:
-        #if ENABLED(HEATER_6_USER_THERMISTOR)
+        #if HEATER_6_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_6, raw);
-        #elif ENABLED(HEATER_6_USES_AD595)
+        #elif HEATER_6_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_6_USES_AD8495)
+        #elif HEATER_6_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 7:
-        #if ENABLED(HEATER_7_USER_THERMISTOR)
+        #if HEATER_7_USER_THERMISTOR
           return user_thermistor_to_deg_c(CTI_HOTEND_7, raw);
-        #elif ENABLED(HEATER_7_USES_AD595)
+        #elif HEATER_7_USES_AD595
           return TEMP_AD595(raw);
-        #elif ENABLED(HEATER_7_USES_AD8495)
+        #elif HEATER_7_USES_AD8495
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       default: break;
     }
 
-    #if HOTEND_USES_THERMISTOR
+    #if HAS_HOTEND_THERMISTOR
       // Thermistor with conversion table?
       const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
 #endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
-    #if ENABLED(HEATER_BED_USER_THERMISTOR)
+    #if HEATER_BED_USER_THERMISTOR
       return user_thermistor_to_deg_c(CTI_BED, raw);
-    #elif ENABLED(HEATER_BED_USES_THERMISTOR)
+    #elif HEATER_BED_USES_THERMISTOR
       SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
-    #elif ENABLED(HEATER_BED_USES_AD595)
+    #elif HEATER_BED_USES_AD595
       return TEMP_AD595(raw);
-    #elif ENABLED(HEATER_BED_USES_AD8495)
+    #elif HEATER_BED_USES_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
-    #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
+    #if HEATER_CHAMBER_USER_THERMISTOR
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
-    #elif ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
+    #elif HEATER_CHAMBER_USES_THERMISTOR
       SCAN_THERMISTOR_TABLE(CHAMBER_TEMPTABLE, CHAMBER_TEMPTABLE_LEN);
-    #elif ENABLED(HEATER_CHAMBER_USES_AD595)
+    #elif HEATER_CHAMBER_USES_AD595
       return TEMP_AD595(raw);
-    #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
+    #elif HEATER_CHAMBER_USES_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_PROBE
   // Derived from RepRap FiveD extruder::getTemperature()
   // For probe temperature measurement.
   float Temperature::analog_to_celsius_probe(const int raw) {
-    #if ENABLED(PROBE_USER_THERMISTOR)
+    #if HEATER_PROBE_USER_THERMISTOR
       return user_thermistor_to_deg_c(CTI_PROBE, raw);
-    #elif ENABLED(PROBE_USES_THERMISTOR)
+    #elif HEATER_PROBE_USES_THERMISTOR
       SCAN_THERMISTOR_TABLE(PROBE_TEMPTABLE, PROBE_TEMPTABLE_LEN);
-    #elif ENABLED(PROBE_USES_AD595)
+    #elif HEATER_PROBE_USES_AD595
       return TEMP_AD595(raw);
-    #elif ENABLED(PROBE_USES_AD8495)
+    #elif HEATER_PROBE_USES_AD8495
       return TEMP_AD8495(raw);
     #else
       UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_PROBE
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
-  #if ENABLED(HEATER_0_USES_MAX6675)
-    temp_hotend[0].raw = READ_MAX6675(0);
-  #endif
-  #if ENABLED(HEATER_1_USES_MAX6675)
-    temp_hotend[1].raw = READ_MAX6675(1);
-  #endif
+  TERN_(HEATER_0_USES_MAX6675, temp_hotend[0].raw = READ_MAX6675(0));
+  TERN_(HEATER_1_USES_MAX6675, temp_hotend[1].raw = READ_MAX6675(1));
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
-
   TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
   TERN_(TEMP_SENSOR_1_AS_REDUNDANT, redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1));
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
@@ -1693,21 +1694,21 @@ void Temperature::init() {
   TERN_(MAX6675_IS_MAX31865, max31865.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
-    #define _AD(N) ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495)
+    #define _AD(N) (HEATER_##N##_USES_AD595 || HEATER_##N##_USES_AD8495)
     #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   // Thermistor activation by MCU pin
   #if PIN_EXISTS(TEMP_0_TR_ENABLE_PIN)
     OUT_WRITE(TEMP_0_TR_ENABLE_PIN, ENABLED(HEATER_0_USES_MAX6675));
   #endif
@@ -1795,21 +1796,21 @@ void Temperature::init() {
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
     max6675_spi.init();
 
     OUT_WRITE(SS_PIN, HIGH);
     OUT_WRITE(MAX6675_SS_PIN, HIGH);
 
   #endif
 
-  #if ENABLED(HEATER_1_USES_MAX6675)
+  #if HEATER_1_USES_MAX6675
     OUT_WRITE(MAX6675_SS2_PIN, HIGH);
   #endif
 
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
@@ -2208,21 +2209,21 @@ void Temperature::disable_all_heaters() {
       constexpr uint8_t hindex = 0;
     #else
       // Needed to return the correct temp when this is called too soon
       static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
     #endif
 
     static uint8_t max6675_errors[COUNT_6675] = { 0 };
 
     #define MAX6675_HEAT_INTERVAL 250UL
 
-    #if ENABLED(MAX6675_IS_MAX31855)
+    #if MAX6675_IS_MAX31855
       static uint32_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    7
       #define MAX6675_DISCARD_BITS 18
       #define MAX6675_SPEED_BITS    3  // (_BV(SPR1)) // clock √∑ 64
     #else
       static uint16_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    4
       #define MAX6675_DISCARD_BITS  3
       #define MAX6675_SPEED_BITS    2  // (_BV(SPR0)) // clock √∑ 16
     #endif
@@ -2234,36 +2235,36 @@ void Temperature::disable_all_heaters() {
       return int(
         #if COUNT_6675 == 1
           max6675_temp
         #else
           max6675_temp_previous[hindex] // Need to return the correct previous value
         #endif
       );
 
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
-    #if ENABLED(MAX6675_IS_MAX31865)
+    #if MAX6675_IS_MAX31865
       max6675_temp = int(max31865.temperature(MAX31865_SENSOR_OHMS, MAX31865_CALIBRATION_OHMS));
     #endif
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
     #if COUNT_6675 > 1
       #define WRITE_MAX6675(V) do{ switch (hindex) { case 1: WRITE(MAX6675_SS2_PIN, V); break; default: WRITE(MAX6675_SS_PIN, V); } }while(0)
       #define SET_OUTPUT_MAX6675() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN); break; default: SET_OUTPUT(MAX6675_SS_PIN); } }while(0)
-    #elif ENABLED(HEATER_1_USES_MAX6675)
+    #elif HEATER_1_USES_MAX6675
       #define WRITE_MAX6675(V) WRITE(MAX6675_SS2_PIN, V)
       #define SET_OUTPUT_MAX6675() SET_OUTPUT(MAX6675_SS2_PIN)
     #else
       #define WRITE_MAX6675(V) WRITE(MAX6675_SS_PIN, V)
       #define SET_OUTPUT_MAX6675() SET_OUTPUT(MAX6675_SS_PIN)
     #endif
 
     SET_OUTPUT_MAX6675();
     WRITE_MAX6675(LOW);  // enable TT_MAX6675
 
@@ -2329,28 +2330,28 @@ void Temperature::disable_all_heaters() {
     return int(max6675_temp);
   }
 
 #endif // HAS_MAX6675
 
 /**
  * Update raw temperatures
  */
 void Temperature::update_raw_temperatures() {
 
-  #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
+  #if HAS_TEMP_ADC_0 && !HEATER_0_USES_MAX6675
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = temp_hotend[1].acc;
-    #elif DISABLED(HEATER_1_USES_MAX6675)
+    #elif !HEATER_1_USES_MAX6675
       temp_hotend[1].update();
     #endif
   #endif
 
   TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
   TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
   TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
   TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
   TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
   TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());

commit 06bf3ccfb7a19c972e5f40816d49e3860711f976
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 18:28:29 2020 -0600

    Add alternative TERN macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 40f8624efb..4eb7216511 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -261,21 +261,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
     int16_t Temperature::mintemp_raw_BED = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
   #endif
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
-  TERN(PIDTEMPBED,, millis_t Temperature::next_bed_check_ms);
+  IF_DISABLED(PIDTEMPBED, millis_t Temperature::next_bed_check_ms);
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     int16_t fan_chamber_pwm;
     bool flag_chamber_off;
     bool flag_chamber_excess_heat = false;
     millis_t next_cool_check_ms_2 = 0;
     float old_temp = 9999;

commit dcb0f5dc3b70f22fb3d9391525d260dbd2bef9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 17:55:31 2020 -0600

    Temperature 'autostart' => 'auto_job'

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d119a72a64..40f8624efb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2147,30 +2147,30 @@ void Temperature::disable_all_heaters() {
 
   #if HAS_HEATED_CHAMBER
     setTargetChamber(0);
     temp_chamber.soft_pwm_amount = 0;
     WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
-  bool Temperature::over_autostart_threshold() {
+  bool Temperature::auto_job_over_threshold() {
     #if HAS_HOTEND
       HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;
     #endif
     return TERN0(HAS_HEATED_BED, degTargetBed() > BED_MINTEMP)
         || TERN0(HAS_HEATED_CHAMBER, degTargetChamber() > CHAMBER_MINTEMP);
   }
 
-  void Temperature::check_timer_autostart(const bool can_start, const bool can_stop) {
-    if (over_autostart_threshold()) {
+  void Temperature::auto_job_check_timer(const bool can_start, const bool can_stop) {
+    if (auto_job_over_threshold()) {
       if (can_start) startOrResumeJob();
     }
     else if (can_stop) {
       print_job_timer.stop();
       ui.reset_status();
     }
   }
 
 #endif
 

commit 54ec6a0ce2dd5f0a3eecf9d76040fc33cfb95b5d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 29 01:14:02 2020 -0500

    Tweak code formatting

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3468a4c1c5..d119a72a64 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1226,23 +1226,23 @@ void Temperature::manage_heater() {
           thermalManager.set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
-          if( (temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) && !flag_chamber_excess_heat) {
-          // open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds
-          // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
+          if (!flag_chamber_excess_heat && temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) {
+            // Open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds if the
+            // temperature didn't drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             if (next_cool_check_ms_2 == 0 || ELAPSED(ms, next_cool_check_ms_2)) {
               if (old_temp - temp_chamber.celsius < float(MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)) flag_chamber_excess_heat = true; //the bed is heating the chamber too much
               next_cool_check_ms_2 = ms + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER_VENT;
               old_temp = temp_chamber.celsius;
             }
           }
           else {
             next_cool_check_ms_2 = 0;
             old_temp = 9999;
           }

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4b352e738e..3468a4c1c5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -27,21 +27,21 @@
 // Useful when debugging thermocouples
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "planner.h"
 #include "../HAL/shared/Delay.h"
 
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)

commit e370834c35bfc529c4b11441e77e5ce7cdafac67
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 16 18:11:00 2020 -0300

    Handle M410 in the main task (#19752)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9ecbb7c766..4b352e738e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1025,22 +1025,28 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
     if (!inited) return watchdog_refresh();
   #endif
 
-  if (TERN0(EMERGENCY_PARSER, emergency_parser.killed_by_M112))
-    kill(M112_KILL_STR, nullptr, true);
+  #if ENABLED(EMERGENCY_PARSER)
+    if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
+
+    if (emergency_parser.quickstop_by_M410) {
+      emergency_parser.quickstop_by_M410 = false; // quickstop_stepper may call idle so clear this now!
+      quickstop_stepper();
+    }
+  #endif
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
     #if ENABLED(HEATER_0_USES_MAX6675)
       if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
       if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
     #endif

commit a866a758cc0ac671363fdce462dd967e488aa4e4
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Oct 11 22:40:39 2020 -0700

    Allow MAX31865 resistance values configuration (#19695)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f8ff972f80..9ecbb7c766 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1454,21 +1454,21 @@ void Temperature::manage_heater() {
         return 0;
       }
 
     switch (e) {
       case 0:
         #if ENABLED(HEATER_0_USER_THERMISTOR)
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif ENABLED(HEATER_0_USES_MAX6675)
           return (
             #if ENABLED(MAX6675_IS_MAX31865)
-              max31865.temperature(100, 400)  // 100 ohms = PT100 resistance. 400 ohms = calibration resistor
+              max31865.temperature(MAX31865_SENSOR_OHMS, MAX31865_CALIBRATION_OHMS)
             #else
               raw * 0.25
             #endif
           );
         #elif ENABLED(HEATER_0_USES_AD595)
           return TEMP_AD595(raw);
         #elif ENABLED(HEATER_0_USES_AD8495)
           return TEMP_AD8495(raw);
         #else
           break;
@@ -2229,21 +2229,21 @@ void Temperature::disable_all_heaters() {
         #if COUNT_6675 == 1
           max6675_temp
         #else
           max6675_temp_previous[hindex] // Need to return the correct previous value
         #endif
       );
 
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
     #if ENABLED(MAX6675_IS_MAX31865)
-      max6675_temp = int(max31865.temperature(100, 400)); // 100 ohms = PT100 resistance. 400 ohms = calibration resistor
+      max6675_temp = int(max31865.temperature(MAX31865_SENSOR_OHMS, MAX31865_CALIBRATION_OHMS));
     #endif
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 

commit 8e03a4cb938d204793cf27b81b378aee04700950
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 10 01:35:41 2020 -0300

    Keep HAL tasks running during PID Autotune (#19671)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 08adfa8745..f8ff972f80 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -630,20 +630,25 @@ volatile bool Temperature::raw_temps_ready = false;
             _SET_BED_PID();
           #endif
         }
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
         goto EXIT_M303;
       }
+
+      // Run HAL idle tasks
+      TERN_(HAL_IDLETASK, HAL_idletask());
+
+      // Run UI update
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
     wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 

commit 2c6ec0c999759bb137798a5fedc19db1e39c7037
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 6 19:42:03 2020 -0500

    Chamber vent/fan followup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 004c2d1239..08adfa8745 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1198,27 +1198,27 @@ void Temperature::manage_heater() {
     #endif
 
     #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
       if (temp_chamber.target > CHAMBER_MINTEMP) {
         flag_chamber_off = false;
 
         #if ENABLED(CHAMBER_FAN)
           #if CHAMBER_FAN_MODE == 0
             fan_chamber_pwm = CHAMBER_FAN_BASE
           #elif CHAMBER_FAN_MODE == 1
-            fan_chamber_pwm = temp_chamber.celsius > temp_chamber.target ? CHAMBER_FAN_BASE + ((temp_chamber.celsius - temp_chamber.target)  * CHAMBER_FAN_FACTOR ) : 0;
+            fan_chamber_pwm = (temp_chamber.celsius > temp_chamber.target) ? (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * (temp_chamber.celsius - temp_chamber.target) : 0;
           #elif CHAMBER_FAN_MODE == 2
             fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
             if (temp_chamber.soft_pwm_amount)
               fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
           #endif
-          fan_chamber_pwm = _MIN(225, fan_chamber_pwm);
+          NOMORE(fan_chamber_pwm, 225);
           thermalManager.set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
         #endif
 
         #if ENABLED(CHAMBER_VENT)
           #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
           #endif
           #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
             #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
           #endif
@@ -1249,39 +1249,39 @@ void Temperature::manage_heater() {
           flag_chamber_excess_heat = false;
           MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
         #endif
       }
     #endif
 
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
-        if (!flag_chamber_excess_heat){
+        if (flag_chamber_excess_heat) {
+          temp_chamber.soft_pwm_amount = 0;
+          #if ENABLED(CHAMBER_VENT)
+            if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
+          #endif
+        }
+        else {
           #if ENABLED(CHAMBER_LIMIT_SWITCHING)
             if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
               temp_chamber.soft_pwm_amount = 0;
             else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
               temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
           #else
             temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? (MAX_CHAMBER_POWER) >> 1 : 0;
           #endif
           #if ENABLED(CHAMBER_VENT)
             if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 0);
           #endif
         }
-        else {
-          temp_chamber.soft_pwm_amount = 0;
-          #if ENABLED(CHAMBER_VENT)
-            if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
-          #endif
-        }
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
         tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
     }

commit 2c99c1e06f534e6c629dcbfebe2c591c1132a992
Author: ladismrkolj <ladismrkolj@gmail.com>
Date:   Wed Oct 7 01:36:01 2020 +0200

    Add Chamber servo vent, auto fan (#19519)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f589140895..004c2d1239 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -104,20 +104,23 @@
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
+#if HAS_SERVOS
+  #include "./servo.h"
+#endif
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static const temp_entry_t* heater_ttbl_map[2] = { HEATER_0_TEMPTABLE, HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     #define NEXT_TEMPTABLE(N) ,HEATER_##N##_TEMPTABLE
     #define NEXT_TEMPTABLE_LEN(N) ,HEATER_##N##_TEMPTABLE_LEN
     static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
   #endif
@@ -264,20 +267,25 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
   #ifdef BED_MAXTEMP
     int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
   #endif
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   TERN(PIDTEMPBED,, millis_t Temperature::next_bed_check_ms);
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
+    int16_t fan_chamber_pwm;
+    bool flag_chamber_off;
+    bool flag_chamber_excess_heat = false;
+    millis_t next_cool_check_ms_2 = 0;
+    float old_temp = 9999;
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
     #endif
     #if WATCH_CHAMBER
       chamber_watch_t Temperature::watch_chamber{0};
     #endif
     millis_t Temperature::next_chamber_check_ms;
@@ -1182,32 +1190,98 @@ void Temperature::manage_heater() {
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
           _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
+    #if EITHER(CHAMBER_FAN, CHAMBER_VENT)
+      if (temp_chamber.target > CHAMBER_MINTEMP) {
+        flag_chamber_off = false;
+
+        #if ENABLED(CHAMBER_FAN)
+          #if CHAMBER_FAN_MODE == 0
+            fan_chamber_pwm = CHAMBER_FAN_BASE
+          #elif CHAMBER_FAN_MODE == 1
+            fan_chamber_pwm = temp_chamber.celsius > temp_chamber.target ? CHAMBER_FAN_BASE + ((temp_chamber.celsius - temp_chamber.target)  * CHAMBER_FAN_FACTOR ) : 0;
+          #elif CHAMBER_FAN_MODE == 2
+            fan_chamber_pwm = (CHAMBER_FAN_BASE) + (CHAMBER_FAN_FACTOR) * ABS(temp_chamber.celsius - temp_chamber.target);
+            if (temp_chamber.soft_pwm_amount)
+              fan_chamber_pwm += (CHAMBER_FAN_FACTOR) * 2;
+          #endif
+          fan_chamber_pwm = _MIN(225, fan_chamber_pwm);
+          thermalManager.set_fan_speed(2, fan_chamber_pwm); // TODO: instead of fan 2, set to chamber fan
+        #endif
+
+        #if ENABLED(CHAMBER_VENT)
+          #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER_VENT
+            #define MIN_COOLING_SLOPE_TIME_CHAMBER_VENT 20
+          #endif
+          #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
+            #define MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
+          #endif
+          if( (temp_chamber.celsius - temp_chamber.target >= HIGH_EXCESS_HEAT_LIMIT) && !flag_chamber_excess_heat) {
+          // open vent after MIN_COOLING_SLOPE_TIME_CHAMBER_VENT seconds
+          // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER_VENT
+            if (next_cool_check_ms_2 == 0 || ELAPSED(ms, next_cool_check_ms_2)) {
+              if (old_temp - temp_chamber.celsius < float(MIN_COOLING_SLOPE_DEG_CHAMBER_VENT)) flag_chamber_excess_heat = true; //the bed is heating the chamber too much
+              next_cool_check_ms_2 = ms + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER_VENT;
+              old_temp = temp_chamber.celsius;
+            }
+          }
+          else {
+            next_cool_check_ms_2 = 0;
+            old_temp = 9999;
+          }
+          if (flag_chamber_excess_heat && (temp_chamber.celsius - temp_chamber.target <= -LOW_EXCESS_HEAT_LIMIT) ) {
+            flag_chamber_excess_heat = false;
+          }
+        #endif
+      }
+      else if (!flag_chamber_off) {
+        #if ENABLED(CHAMBER_FAN)
+          flag_chamber_off = true;
+          thermalManager.set_fan_speed(2, 0);
+        #endif
+        #if ENABLED(CHAMBER_VENT)
+          flag_chamber_excess_heat = false;
+          MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 90);
+        #endif
+      }
+    #endif
+
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
-        #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-          if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
-            temp_chamber.soft_pwm_amount = 0;
-          else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
-            temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
-        #else
-          temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
-        #endif
+        if (!flag_chamber_excess_heat){
+          #if ENABLED(CHAMBER_LIMIT_SWITCHING)
+            if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
+              temp_chamber.soft_pwm_amount = 0;
+            else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
+              temp_chamber.soft_pwm_amount = (MAX_CHAMBER_POWER) >> 1;
+          #else
+            temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? (MAX_CHAMBER_POWER) >> 1 : 0;
+          #endif
+          #if ENABLED(CHAMBER_VENT)
+            if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, 0);
+          #endif
+        }
+        else {
+          temp_chamber.soft_pwm_amount = 0;
+          #if ENABLED(CHAMBER_VENT)
+            if (!flag_chamber_off) MOVE_SERVO(CHAMBER_VENT_SERVO_NR, temp_chamber.celsius <= temp_chamber.target ? 0 : 90);
+          #endif
+        }
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
         tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
     }
@@ -3358,21 +3432,21 @@ void Temperature::tick() {
     }
 
   #endif // HAS_TEMP_PROBE
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
       #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
-      #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
+      #define MIN_COOLING_SLOPE_TIME_CHAMBER 120
     #endif
 
     bool Temperature::wait_for_chamber(const bool no_wait_for_cooling/*=true*/) {
       #if TEMP_CHAMBER_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CHAMBER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target

commit 79dc8a22976934e0c29495c16626650b87dba4d9
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Sep 22 17:44:17 2020 -0300

    Define <u8,u8,u8>::softSPI (#19419)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d2145bcc80..f589140895 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1560,20 +1560,21 @@ void Temperature::updateTemperaturesFromRawValues() {
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
   TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
 
 #if MAX6675_SEPARATE_SPI
+  template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin> SoftSPI<MisoPin, MosiPin, SckPin> SPIclass<MisoPin, MosiPin, SckPin>::softSPI;
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef ALFAWISE_UX0
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
 #if ENABLED(FAN_SOFT_PWM)

commit 073b7f1e3a77f6d00d58bb144fe3aa96ce3770f3
Author: cosmoderp <36945803+cosmoderp@users.noreply.github.com>
Date:   Thu Sep 17 06:35:04 2020 -0400

    E3 V2 DWIN: Z-Offset, cleanup, versatility (#19384)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e0fa6fa98f..d2145bcc80 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -569,21 +569,21 @@ volatile bool Temperature::raw_temps_ready = false;
               _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
-        TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
+        TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), NUL_STR);
@@ -805,26 +805,30 @@ void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_ms
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_id_t heater_id) {
-  TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(1));
+  #if ENABLED(DWIN_CREALITY_LCD) && (HAS_HOTEND || HAS_HEATED_BED)
+    DWIN_Popup_Temperature(1);
+  #endif
   _temp_error(heater_id, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_id_t heater_id) {
-  TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
+  #if ENABLED(DWIN_CREALITY_LCD) && (HAS_HOTEND || HAS_HEATED_BED)
+    DWIN_Popup_Temperature(0);
+  #endif
   _temp_error(heater_id, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HAS_HOTEND
   #if ENABLED(PID_DEBUG)
     extern bool pid_debug_flag;
   #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
@@ -1048,21 +1052,21 @@ void Temperature::manage_heater() {
         // Check for thermal runaway
         tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
           if (degHotend(e) < watch_hotend[e].target) {                          // Failed to increase enough?
-            TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
+            TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
             _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           }
           else                                                                  // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
@@ -1091,21 +1095,21 @@ void Temperature::manage_heater() {
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target) {                              // Failed to increase enough?
-          TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
+          TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         }
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
     #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
@@ -2016,21 +2020,21 @@ void Temperature::init() {
         #endif
 
         if (current >= running_temp - hysteresis_degc) {
           timer = millis() + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(millis(), timer)) break;
         state = TRRunaway;
 
       case TRRunaway:
-        TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
+        TERN_(DWIN_CREALITY_LCD, DWIN_Popup_Temperature(0));
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
 
@@ -2433,28 +2437,22 @@ void Temperature::tick() {
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
-    #if HAS_HOTEND || HAS_HEATED_BED || HAS_HEATED_CHAMBER
-      constexpr uint8_t pwm_mask =
-        #if ENABLED(SOFT_PWM_DITHER)
-          _BV(SOFT_PWM_SCALE) - 1
-        #else
-          0
-        #endif
-      ;
+    #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, FAN_SOFT_PWM)
+      constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \
         const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
         WRITE_HEATER_##N(on);                               \
       }while(0)
     #endif
 
     /**
      * Standard heater PWM modulation
      */
     if (pwm_count_tmp >= 127) {

commit 979876e958e73e642b51eb655461c92947fe1deb
Author: ellensp <ellensp@hotmail.com>
Date:   Mon Sep 14 16:58:39 2020 +1200

    Improve temperature runaway, idle timeout (#19339)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 06864c6b97..e0fa6fa98f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -245,35 +245,34 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     }
 
   #endif
 
 #endif // HAS_FAN
 
 #if WATCH_HOTENDS
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
-  hotend_idle_t Temperature::hotend_idle[HOTENDS]; // = { { 0 } }
+  Temperature::heater_idle_t Temperature::heater_idle[NR_HEATER_IDLE]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
     int16_t Temperature::mintemp_raw_BED = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
   #endif
   TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
   TERN(PIDTEMPBED,, millis_t Temperature::next_bed_check_ms);
-  TERN_(HEATER_IDLE_HANDLER, hotend_idle_t Temperature::bed_idle); // = { 0 }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
@@ -834,21 +833,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
 
         float pid_output;
 
         if (temp_hotend[ee].target == 0
           || pid_error < -(PID_FUNCTIONAL_RANGE)
-          || TERN0(HEATER_IDLE_HANDLER, hotend_idle[ee].timed_out)
+          || TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out)
         ) {
           pid_output = 0;
           pid_reset[ee] = true;
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
           pid_output = BANG_MAX;
           pid_reset[ee] = true;
         }
         else {
           if (pid_reset[ee]) {
@@ -919,21 +918,21 @@ void Temperature::min_temp_error(const heater_id_t heater_id) {
               #endif
             );
           }
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
-      const bool is_idling = TERN0(HEATER_IDLE_HANDLER, hotend_idle[ee].timed_out);
+      const bool is_idling = TERN0(HEATER_IDLE_HANDLER, heater_idle[ee].timed_out);
       const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
 #endif // HAS_HOTEND
 
 #if ENABLED(PIDTEMPBED)
@@ -1033,29 +1032,28 @@ void Temperature::manage_heater() {
       if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
     #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        if (degHotend(e) > temp_range[e].maxtemp)
-          _temp_error((heater_id_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+        if (degHotend(e) > temp_range[e].maxtemp) max_temp_error((heater_id_t)e);
       #endif
 
-      TERN_(HEATER_IDLE_HANDLER, hotend_idle[e].update(ms));
+      TERN_(HEATER_IDLE_HANDLER, heater_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
-        thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+        tr_state_machine[e].run(temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
           if (degHotend(e) < watch_hotend[e].target) {                          // Failed to increase enough?
             TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
             _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
@@ -1086,22 +1084,21 @@ void Temperature::manage_heater() {
     /**
      * Dynamically set the volumetric multiplier based
      * on the delayed Filament Width measurement.
      */
     filwidth.update_volumetric();
   #endif
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
-      if (degBed() > BED_MAXTEMP)
-        _temp_error(H_BED, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+      if (degBed() > BED_MAXTEMP) max_temp_error(H_BED);
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target) {                              // Failed to increase enough?
           TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         }
         else                                                            // Start again if the target is still far off
@@ -1120,26 +1117,28 @@ void Temperature::manage_heater() {
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
           && TERN1(PAUSE_CHANGE_REQD, paused == last_pause_state)
         ) break;
         next_bed_check_ms = ms + BED_CHECK_INTERVAL;
         TERN_(PAUSE_CHANGE_REQD, last_pause_state = paused);
       #endif
 
-      TERN_(HEATER_IDLE_HANDLER, bed_idle.update(ms));
+      TERN_(HEATER_IDLE_HANDLER, heater_idle[IDLE_INDEX_BED].update(ms));
 
-      TERN_(HAS_THERMALLY_PROTECTED_BED, thermal_runaway_protection(tr_state_machine_bed, temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS));
+      #if HAS_THERMALLY_PROTECTED_BED
+        tr_state_machine[RUNAWAY_IND_BED].run(temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
+      #endif
 
       #if HEATER_IDLE_HANDLER
-        if (bed_idle.timed_out) {
+        if (heater_idle[IDLE_INDEX_BED].timed_out) {
           temp_bed.soft_pwm_amount = 0;
           #if DISABLED(PIDTEMPBED)
             WRITE_HEATER_BED(LOW);
           #endif
         }
         else
       #endif
       {
         #if ENABLED(PIDTEMPBED)
           temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
@@ -1166,22 +1165,21 @@ void Temperature::manage_heater() {
 
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-      if (degChamber() > CHAMBER_MAXTEMP)
-        _temp_error(H_CHAMBER, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+      if (degChamber() > CHAMBER_MAXTEMP) max_temp_error(H_CHAMBER);
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
           _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
@@ -1198,21 +1196,23 @@ void Temperature::manage_heater() {
             temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
         #else
           temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
         #endif
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
-      TERN_(THERMAL_PROTECTION_CHAMBER, thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS));
+      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+        tr_state_machine[RUNAWAY_IND_CHAMBER].run(temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+      #endif
     }
 
     // TODO: Implement true PID pwm
     //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
 
   UNUSED(ms);
 }
 
@@ -1928,101 +1928,106 @@ void Temperature::init() {
    * its target temperature by a configurable margin.
    * This is called when the temperature is set. (M141, M191)
    */
   void Temperature::start_watching_chamber() {
     watch_chamber.restart(degChamber(), degTargetChamber());
   }
 #endif
 
 #if HAS_THERMAL_PROTECTION
 
-  #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-    Temperature::tr_state_machine_t Temperature::tr_state_machine[HOTENDS]; // = { { TRInactive, 0 } };
-  #endif
-  #if HAS_THERMALLY_PROTECTED_BED
-    Temperature::tr_state_machine_t Temperature::tr_state_machine_bed; // = { TRInactive, 0 };
-  #endif
-  #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-    Temperature::tr_state_machine_t Temperature::tr_state_machine_chamber; // = { TRInactive, 0 };
-  #endif
+  Temperature::tr_state_machine_t Temperature::tr_state_machine[NR_HEATER_RUNAWAY]; // = { { TRInactive, 0 } };
 
-  void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
+  /**
+   * @brief Thermal Runaway state machine for a single heater
+   * @param current          current measured temperature
+   * @param target           current target temperature
+   * @param heater_id        extruder index
+   * @param period_seconds   missed temperature allowed time
+   * @param hysteresis_degc  allowed distance from target
+   *
+   * TODO: Embed the last 3 parameters during init, if not less optimal
+   */
+  void Temperature::tr_state_machine_t::run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
-    static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
+    #if HEATER_IDLE_HANDLER
+      // Convert the given heater_id_t to an idle array index
+      const IdleIndex idle_index = idle_index_for_id(heater_id);
+    #endif
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
-      if (heater_id == H_CHAMBER) SERIAL_ECHOPGM("chamber");
-      if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
-      SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
-      if (heater_id >= 0)
-        SERIAL_ECHOPAIR(" ;  Idle Timeout:", hotend_idle[heater_id].timed_out);
-      else
-        SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
-      SERIAL_EOL();
+      switch (heater_id) {
+        case H_BED:     SERIAL_ECHOPGM("bed"); break;
+        case H_CHAMBER: SERIAL_ECHOPGM("chamber"); break;
+        default:        SERIAL_ECHO(heater_id);
+      }
+      SERIAL_ECHOLNPAIR(
+        " ; sizeof(running_temp):", sizeof(running_temp),
+        " ;  State:", state, " ;  Timer:", timer, " ;  Temperature:", current, " ;  Target Temp:", target
+        #if HEATER_IDLE_HANDLER
+          , " ;  Idle Timeout:", heater_idle[idle_index].timed_out
+        #endif
+      );
     //*/
 
-    const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
-
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
-      if ((heater_id >= 0 && hotend_idle[heater_id].timed_out)
-        || TERN0(HAS_HEATED_BED, (heater_id < 0 && bed_idle.timed_out))
-      ) {
-        sm.state = TRInactive;
-        tr_target_temperature[heater_index] = 0;
+      if (heater_idle[idle_index].timed_out) {
+        state = TRInactive;
+        running_temp = 0;
       }
       else
     #endif
     {
       // If the target temperature changes, restart
-      if (tr_target_temperature[heater_index] != target) {
-        tr_target_temperature[heater_index] = target;
-        sm.state = target > 0 ? TRFirstHeating : TRInactive;
+      if (running_temp != target) {
+        running_temp = target;
+        state = target > 0 ? TRFirstHeating : TRInactive;
       }
     }
 
-    switch (sm.state) {
+    switch (state) {
       // Inactive state waits for a target temperature to be set
       case TRInactive: break;
 
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
-        if (current < tr_target_temperature[heater_index]) break;
-        sm.state = TRStable;
+        if (current < running_temp) break;
+        state = TRStable;
 
       // While the temperature is stable watch for a bad temperature
       case TRStable:
 
         #if ENABLED(ADAPTIVE_FAN_SLOWING)
           if (adaptive_fan_slowing && heater_id >= 0) {
             const int fan_index = _MIN(heater_id, FAN_COUNT - 1);
-            if (fan_speed[fan_index] == 0 || current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.25f))
+            if (fan_speed[fan_index] == 0 || current >= running_temp - (hysteresis_degc * 0.25f))
               fan_speed_scaler[fan_index] = 128;
-            else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.3335f))
+            else if (current >= running_temp - (hysteresis_degc * 0.3335f))
               fan_speed_scaler[fan_index] = 96;
-            else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.5f))
+            else if (current >= running_temp - (hysteresis_degc * 0.5f))
               fan_speed_scaler[fan_index] = 64;
-            else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.8f))
+            else if (current >= running_temp - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else
               fan_speed_scaler[fan_index] = 0;
           }
         #endif
 
-        if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
-          sm.timer = millis() + SEC_TO_MS(period_seconds);
+        if (current >= running_temp - hysteresis_degc) {
+          timer = millis() + SEC_TO_MS(period_seconds);
           break;
         }
-        else if (PENDING(millis(), sm.timer)) break;
-        sm.state = TRRunaway;
+        else if (PENDING(millis(), timer)) break;
+        state = TRRunaway;
 
       case TRRunaway:
         TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
@@ -2079,22 +2084,22 @@ void Temperature::disable_all_heaters() {
 
 #endif
 
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
-        HOTEND_LOOP() hotend_idle[e].expire();    // Timeout immediately
-        TERN_(HAS_HEATED_BED, bed_idle.expire()); // Timeout immediately
+        HOTEND_LOOP() heater_idle[e].expire();    // Timeout immediately
+        TERN_(HAS_HEATED_BED, heater_idle[IDLE_INDEX_BED].expire()); // Timeout immediately
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
@@ -2326,23 +2331,21 @@ void Temperature::readings_ready() {
     }
 
   #endif // HAS_HOTEND
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<(B))
     #else
       #define BEDCMP(A,B) ((A)>(B))
     #endif
-    const bool bed_on = temp_bed.target > 0
-      || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount) > 0
-    ;
+    const bool bed_on = (temp_bed.target > 0) || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount > 0);
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
   #endif
 
   #if HAS_HEATED_CHAMBER
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>(B))
     #endif

commit 49ca16c3fb103e8e29f64107ba664aa82917b9f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 13 18:06:14 2020 -0500

    heater_ind_t => heater_id_t

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fbdd1fd6ec..06864c6b97 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -370,47 +370,47 @@ volatile bool Temperature::raw_temps_ready = false;
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
    * temperature to succeed.
    */
-  void Temperature::PID_autotune(const float &target, const heater_ind_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
+  void Temperature::PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result/*=false*/) {
     float current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float maxT = 0, minT = 10000;
 
-    const bool isbed = (heater == H_BED);
+    const bool isbed = (heater_id == H_BED);
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (isbed ? (B) : (H))
-      #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
+      #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater_id].soft_pwm_amount = H; }while(0)
       #define ONHEATINGSTART() (isbed ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
       #define ONHEATING(S,C,T) (isbed ? printerEventLEDs.onBedHeating(S,C,T) : printerEventLEDs.onHotendHeating(S,C,T))
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
-      #define SHV(B,H) (temp_hotend[heater].soft_pwm_amount = H)
+      #define SHV(B,H) (temp_hotend[heater_id].soft_pwm_amount = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
     #define WATCH_PID BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP)
 
     #if WATCH_PID
       #if ALL(THERMAL_PROTECTION_HOTENDS, PIDTEMP, THERMAL_PROTECTION_BED, PIDTEMPBED)
         #define GTV(B,H) (isbed ? (B) : (H))
       #elif BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
         #define GTV(B,H) (H)
@@ -420,51 +420,51 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
-    if (target > GHV(BED_MAX_TARGET, temp_range[heater].maxtemp - HOTEND_OVERSHOOT)) {
+    if (target > GHV(BED_MAX_TARGET, temp_range[heater_id].maxtemp - HOTEND_OVERSHOOT)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
+      const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater_id].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     wait_for_heatup = true; // Can be interrupted with M108
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
+        current_temp = GHV(temp_bed.celsius, temp_hotend[heater_id].celsius);
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
@@ -542,39 +542,39 @@ volatile bool Temperature::raw_temps_ready = false;
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
-          print_heater_states(isbed ? active_extruder : heater);
+          print_heater_states(isbed ? active_extruder : heater_id);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_PID
           if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);     // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
-                _temp_error(heater, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+                _temp_error(heater_id, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+              _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
@@ -601,23 +601,23 @@ volatile bool Temperature::raw_temps_ready = false;
           say_default_(); SERIAL_ECHOLNPAIR("bedKd ", tune_pid.Kd);
         #endif
 
         #define _SET_BED_PID() do { \
           temp_bed.pid.Kp = tune_pid.Kp; \
           temp_bed.pid.Ki = scalePID_i(tune_pid.Ki); \
           temp_bed.pid.Kd = scalePID_d(tune_pid.Kd); \
         }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
-          PID_PARAM(Kp, heater) = tune_pid.Kp; \
-          PID_PARAM(Ki, heater) = scalePID_i(tune_pid.Ki); \
-          PID_PARAM(Kd, heater) = scalePID_d(tune_pid.Kd); \
+          PID_PARAM(Kp, heater_id) = tune_pid.Kp; \
+          PID_PARAM(Ki, heater_id) = scalePID_i(tune_pid.Ki); \
+          PID_PARAM(Kd, heater_id) = scalePID_d(tune_pid.Kd); \
           updatePID(); }while(0)
 
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
             if (isbed) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
@@ -644,21 +644,21 @@ volatile bool Temperature::raw_temps_ready = false;
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
-int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
+int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     default:
       return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
   }
@@ -751,82 +751,82 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
-inline void loud_kill(PGM_P const lcd_msg, const heater_ind_t heater) {
+inline void loud_kill(PGM_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
   #if USE_BEEPER
     for (uint8_t i = 20; i--;) {
       WRITE(BEEPER_PIN, HIGH); delay(25);
       WRITE(BEEPER_PIN, LOW); delay(80);
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
-  kill(lcd_msg, HEATER_PSTR(heater));
+  kill(lcd_msg, HEATER_PSTR(heater_id));
 }
 
-void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
+void Temperature::_temp_error(const heater_id_t heater_id, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
-    if (heater >= 0)
-      SERIAL_ECHO((int)heater);
-    else if (TERN0(HAS_HEATED_CHAMBER, heater == H_CHAMBER))
+    if (heater_id >= 0)
+      SERIAL_ECHO((int)heater_id);
+    else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER))
       SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
     else
       SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
       case 0:
         expire_ms = ms + BOGUS_TEMPERATURE_GRACE_PERIOD;
         ++killed;
         break;
       case 1:
         if (ELAPSED(ms, expire_ms)) ++killed;
         break;
       case 2:
-        loud_kill(lcd_msg, heater);
+        loud_kill(lcd_msg, heater_id);
         ++killed;
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
-    if (!killed) { killed = 1; loud_kill(lcd_msg, heater); }
+    if (!killed) { killed = 1; loud_kill(lcd_msg, heater_id); }
   #endif
 }
 
-void Temperature::max_temp_error(const heater_ind_t heater) {
+void Temperature::max_temp_error(const heater_id_t heater_id) {
   TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(1));
-  _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
+  _temp_error(heater_id, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
-void Temperature::min_temp_error(const heater_ind_t heater) {
+void Temperature::min_temp_error(const heater_id_t heater_id) {
   TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
-  _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
+  _temp_error(heater_id, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HAS_HOTEND
   #if ENABLED(PID_DEBUG)
     extern bool pid_debug_flag;
   #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
@@ -1034,38 +1034,38 @@ void Temperature::manage_heater() {
     #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp)
-          _temp_error((heater_ind_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
+          _temp_error((heater_id_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
       #endif
 
       TERN_(HEATER_IDLE_HANDLER, hotend_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
-        thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+        thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_id_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
           if (degHotend(e) < watch_hotend[e].target) {                          // Failed to increase enough?
             TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
-            _temp_error((heater_ind_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+            _temp_error((heater_id_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           }
           else                                                                  // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
           _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
@@ -1938,21 +1938,21 @@ void Temperature::init() {
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
     Temperature::tr_state_machine_t Temperature::tr_state_machine[HOTENDS]; // = { { TRInactive, 0 } };
   #endif
   #if HAS_THERMALLY_PROTECTED_BED
     Temperature::tr_state_machine_t Temperature::tr_state_machine_bed; // = { TRInactive, 0 };
   #endif
   #if ENABLED(THERMAL_PROTECTION_CHAMBER)
     Temperature::tr_state_machine_t Temperature::tr_state_machine_chamber; // = { TRInactive, 0 };
   #endif
 
-  void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
+  void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       if (heater_id == H_CHAMBER) SERIAL_ECHOPGM("chamber");
       if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
       SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
       if (heater_id >= 0)
@@ -2304,26 +2304,26 @@ void Temperature::readings_ready() {
       #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
         const bool heater_on = (temp_hotend[e].target > 0
           || TERN0(PIDTEMP, temp_hotend[e].soft_pwm_amount) > 0
         );
-        if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
+        if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_id_t)e);
         if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
           #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
             if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
           #endif
-              min_temp_error((heater_ind_t)e);
+              min_temp_error((heater_id_t)e);
         }
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           else
             consecutive_low_temperature_error[e] = 0;
         #endif
       }
     }
 
   #endif // HAS_HOTEND
 
@@ -2876,21 +2876,21 @@ void Temperature::tick() {
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
-    , const heater_ind_t e=INDEX_NONE
+    , const heater_id_t e=INDEX_NONE
   ) {
     char k;
     switch (e) {
       #if HAS_TEMP_CHAMBER
         case H_CHAMBER: k = 'C'; break;
       #endif
       #if HAS_TEMP_PROBE
         case H_PROBE: k = 'P'; break;
       #endif
       #if HAS_TEMP_HOTEND
@@ -2967,35 +2967,35 @@ void Temperature::tick() {
           , rawProbeTemp()
         #endif
         , H_PROBE
       );
     #endif // HAS_TEMP_PROBE
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
-        , (heater_ind_t)e
+        , (heater_id_t)e
       );
     #endif
-    SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_ind_t)target_extruder));
+    SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
       SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
     #endif
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
-        SERIAL_ECHO(getHeaterPower((heater_ind_t)e));
+        SERIAL_ECHO(getHeaterPower((heater_id_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {

commit 1917ed8741ed5c27c6a505c3936050e4f461d075
Author: Neskik <axel.gouverneur@gmail.com>
Date:   Sat Sep 12 05:51:19 2020 +0200

    M872 wait for probe temperature (#19344)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6b22c50a7b..fbdd1fd6ec 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -433,29 +433,29 @@ volatile bool Temperature::raw_temps_ready = false;
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
     TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
-    wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
+    wait_for_heatup = true; // Can be interrupted with M108
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
         current_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
         NOLESS(maxT, current_temp);
@@ -625,20 +625,21 @@ volatile bool Temperature::raw_temps_ready = false;
         }
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
         goto EXIT_M303;
       }
       TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
+    wait_for_heatup = false;
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
@@ -3053,24 +3054,24 @@ void Temperature::tick() {
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degHotend(target_extruder);
         printerEventLEDs.onHotendHeatingStart();
       #endif
 
-      float target_temp = -1.0, old_temp = 9999.0;
       bool wants_to_cool = false;
-      wait_for_heatup = true;
+      float target_temp = -1.0, old_temp = 9999.0;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
           target_temp = degTargetHotend(target_extruder);
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
@@ -3130,31 +3131,33 @@ void Temperature::tick() {
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
+        wait_for_heatup = false;
         #if ENABLED(DWIN_CREALITY_LCD)
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // print timer
           dwin_heat_time = elapsed.value;
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
+        return true;
       }
 
-      return wait_for_heatup;
+      return false;
     }
 
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
       #define MIN_COOLING_SLOPE_DEG_BED 1.00
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_BED
@@ -3169,34 +3172,33 @@ void Temperature::tick() {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_BED_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
-      float target_temp = -1, old_temp = 9999;
-      bool wants_to_cool = false;
-      wait_for_heatup = true;
-      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
-
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
         printerEventLEDs.onBedHeatingStart();
       #endif
 
+      bool wants_to_cool = false;
+      float target_temp = -1, old_temp = 9999;
+      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetBed()) {
           wants_to_cool = isCoolingBed();
           target_temp = degTargetBed();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
@@ -3257,65 +3259,139 @@ void Temperature::tick() {
             ui.quick_feedback();
           }
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
           first_loop = false;
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
-      if (wait_for_heatup) ui.reset_status();
+      if (wait_for_heatup) {
+        wait_for_heatup = false;
+        ui.reset_status();
+        return true;
+      }
 
-      return wait_for_heatup;
+      return false;
     }
 
     void Temperature::wait_for_bed_heating() {
       if (isHeatingBed()) {
         SERIAL_ECHOLNPGM("Wait for bed heating...");
         LCD_MESSAGEPGM(MSG_BED_HEATING);
         wait_for_bed();
         ui.reset_status();
       }
     }
 
   #endif // HAS_HEATED_BED
 
+  #if HAS_TEMP_PROBE
+
+    #ifndef MIN_DELTA_SLOPE_DEG_PROBE
+      #define MIN_DELTA_SLOPE_DEG_PROBE 1.0
+    #endif
+    #ifndef MIN_DELTA_SLOPE_TIME_PROBE
+      #define MIN_DELTA_SLOPE_TIME_PROBE 600
+    #endif
+
+    bool Temperature::wait_for_probe(const float target_temp, bool no_wait_for_cooling/*=true*/) {
+
+      const bool wants_to_cool = isProbeAboveTemp(target_temp);
+      const bool will_wait = !(wants_to_cool && no_wait_for_cooling);
+      if (will_wait)
+        SERIAL_ECHOLNPAIR("Waiting for probe to ", (wants_to_cool ? PSTR("cool down") : PSTR("heat up")), " to ", target_temp, " degrees.");
+
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        KEEPALIVE_STATE(NOT_BUSY);
+      #endif
+
+      float old_temp = 9999;
+      millis_t next_temp_ms = 0, next_delta_check_ms = 0;
+      wait_for_heatup = true;
+      while (will_wait && wait_for_heatup) {
+
+        // Print Temp Reading every 10 seconds while heating up.
+        millis_t now = millis();
+        if (!next_temp_ms || ELAPSED(now, next_temp_ms)) {
+          next_temp_ms = now + 10000UL;
+          print_heater_states(active_extruder);
+          SERIAL_EOL();
+        }
+
+        idle();
+        gcode.reset_stepper_timeout(); // Keep steppers powered
+
+        // Break after MIN_DELTA_SLOPE_TIME_PROBE seconds if the temperature
+        // did not drop at least MIN_DELTA_SLOPE_DEG_PROBE. This avoids waiting
+        // forever as the probe is not actively heated.
+        if (!next_delta_check_ms || ELAPSED(now, next_delta_check_ms)) {
+          const float temp = degProbe(),
+                      delta_temp = old_temp > temp ? old_temp - temp : temp - old_temp;
+          if (delta_temp < float(MIN_DELTA_SLOPE_DEG_PROBE)) {
+            SERIAL_ECHOLNPGM("Timed out waiting for probe temperature.");
+            break;
+          }
+          next_delta_check_ms = now + 1000UL * MIN_DELTA_SLOPE_TIME_PROBE;
+          old_temp = temp;
+        }
+
+        // Loop until the temperature is very close target
+        if (!(wants_to_cool ? isProbeAboveTemp(target_temp) : isProbeBelowTemp(target_temp))) {
+            SERIAL_ECHOLN(wants_to_cool ? PSTR("Cooldown") : PSTR("Heatup"));
+            SERIAL_ECHOLNPGM(" complete, target probe temperature reached.");
+            break;
+        }
+      }
+
+      if (wait_for_heatup) {
+        wait_for_heatup = false;
+        ui.reset_status();
+        return true;
+      }
+      else if (will_wait)
+        SERIAL_ECHOLNPGM("Canceled wait for probe temperature.");
+
+      return false;
+    }
+
+  #endif // HAS_TEMP_PROBE
+
   #if HAS_HEATED_CHAMBER
 
     #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
       #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
       #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
     #endif
 
     bool Temperature::wait_for_chamber(const bool no_wait_for_cooling/*=true*/) {
       #if TEMP_CHAMBER_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CHAMBER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CHAMBER_CONDITIONS (wants_to_cool ? isCoolingChamber() : isHeatingChamber())
       #endif
 
-      float target_temp = -1, old_temp = 9999;
-      bool wants_to_cool = false;
-      wait_for_heatup = true;
-      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
-
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
+      bool wants_to_cool = false;
+      float target_temp = -1, old_temp = 9999;
+      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      wait_for_heatup = true;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetChamber()) {
           wants_to_cool = isCoolingChamber();
           target_temp = degTargetChamber();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
@@ -3360,18 +3436,22 @@ void Temperature::tick() {
           // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_CHAMBER)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER;
             old_temp = temp;
           }
         }
       } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
 
-      if (wait_for_heatup) ui.reset_status();
+      if (wait_for_heatup) {
+        wait_for_heatup = false;
+        ui.reset_status();
+        return true;
+      }
 
-      return wait_for_heatup;
+      return false;
     }
 
   #endif // HAS_HEATED_CHAMBER
 
 #endif // HAS_TEMP_SENSOR

commit a445746a8b6dd752de725eb67d264153c3b393d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 6 21:40:58 2020 -0500

    Clean up LCD conditionals, DWIN

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b162173bc6..6b22c50a7b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -30,21 +30,21 @@
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "planner.h"
 #include "../HAL/shared/Delay.h"
 
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../lcd/dwin/dwin.h"
+  #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example

commit 195d20cef2d7cf08d3a95899df05c9e67cd859da
Author: thordarsen <50306469+thordarsen@users.noreply.github.com>
Date:   Wed Aug 26 06:23:56 2020 -0400

    Fix SINGLENOZZLE fan speed bug (#19152)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 813bcc061b..b162173bc6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -203,23 +203,24 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
    */
   void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
-      target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
+    TERN_(SINGLENOZZLE, target = 0); // Always use fan index 0 with SINGLENOZZLE
+
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;
 
     TERN_(REPORT_FAN_CHANGE, report_fan_speed(target));
   }
 
   #if ENABLED(REPORT_FAN_CHANGE)
     /**
      * Report print fan speed for a target extruder

commit f67ad6fd70bb107ca08ac99af6bcffa2026266d2
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Aug 24 16:54:25 2020 +0200

    Fix auto-power in PID autotune (#19119)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e8be3dbf01..813bcc061b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -428,30 +428,30 @@ volatile bool Temperature::raw_temps_ready = false;
 
     if (target > GHV(BED_MAX_TARGET, temp_range[heater].maxtemp - HOTEND_OVERSHOOT)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
+    TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
-    TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 

commit 7807b613d5c0ff74a26b884c1aaf1b253467c3bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 20 00:08:06 2020 -0500

    Update some comments

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1208e4e995..e8be3dbf01 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -354,21 +354,21 @@ volatile bool Temperature::raw_temps_ready = false;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint16_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
-  int16_t Temperature::lpq_len; // Initialized in configuration_store
+  int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif
 
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to

commit 3426c7fc94beb62dedc85d5f5cd9ac9cac0859b1
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Aug 20 03:11:20 2020 +0200

    Configurable number of M106 fans (#18883)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a217fc9ab8..1208e4e995 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -188,21 +188,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     }
 
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
     uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
-    uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
+    uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128, 128, 128);
   #endif
 
   /**
    * Set the print fan speed for a target extruder
    */
   void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)

commit f205bff2ccdaea55e2dc9e6fa1f98820a9761d42
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Aug 19 09:49:46 2020 +0200

    Fix PSU on for PID autotune (#19066)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1dc480a927..a217fc9ab8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -437,20 +437,21 @@ volatile bool Temperature::raw_temps_ready = false;
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
+    TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
     TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index dfbcd0a15a..1dc480a927 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
 // Useful when debugging thermocouples
 //#define IGNORE_THERMOCOUPLE_ERRORS
 

commit ef90cb7c97b93223ecd3147bc2ce80b6344bf8ff
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 15 01:20:52 2020 -0500

    PLR followup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2e8b0314aa..dfbcd0a15a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2030,21 +2030,21 @@ void Temperature::disable_all_heaters() {
   TERN_(PROBING_HEATERS_OFF, pause(false));
 
   #if HAS_HOTEND
     HOTEND_LOOP() {
       setTargetHotend(0, e);
       temp_hotend[e].soft_pwm_amount = 0;
     }
   #endif
 
   #if HAS_TEMP_HOTEND
-    #define DISABLE_HEATER(N) WRITE_HEATER_##N(LOW)
+    #define DISABLE_HEATER(N) WRITE_HEATER_##N(LOW);
     REPEAT(HOTENDS, DISABLE_HEATER);
   #endif
 
   #if HAS_HEATED_BED
     setTargetBed(0);
     temp_bed.soft_pwm_amount = 0;
     WRITE_HEATER_BED(LOW);
   #endif
 
   #if HAS_HEATED_CHAMBER

commit 76b67d55e2b55317c21c8d24d014887f2c2329eb
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Jul 14 23:14:03 2020 -0700

    Fix some Power Loss Recovery behaviors (#18558)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e62754a301..2e8b0314aa 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2019,47 +2019,43 @@ void Temperature::init() {
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
 
-  #if HAS_HOTEND
-    HOTEND_LOOP() setTargetHotend(0, e);
-  #endif
-  TERN_(HAS_HEATED_BED, setTargetBed(0));
-  TERN_(HAS_HEATED_CHAMBER, setTargetChamber(0));
-
   // Unpause and reset everything
   TERN_(PROBING_HEATERS_OFF, pause(false));
 
-  #define DISABLE_HEATER(N) {           \
-    setTargetHotend(0, N);              \
-    temp_hotend[N].soft_pwm_amount = 0; \
-    WRITE_HEATER_##N(LOW);              \
-  }
+  #if HAS_HOTEND
+    HOTEND_LOOP() {
+      setTargetHotend(0, e);
+      temp_hotend[e].soft_pwm_amount = 0;
+    }
+  #endif
 
   #if HAS_TEMP_HOTEND
+    #define DISABLE_HEATER(N) WRITE_HEATER_##N(LOW)
     REPEAT(HOTENDS, DISABLE_HEATER);
   #endif
 
   #if HAS_HEATED_BED
-    temp_bed.target = 0;
+    setTargetBed(0);
     temp_bed.soft_pwm_amount = 0;
     WRITE_HEATER_BED(LOW);
   #endif
 
   #if HAS_HEATED_CHAMBER
-    temp_chamber.target = 0;
+    setTargetChamber(0);
     temp_chamber.soft_pwm_amount = 0;
     WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
   bool Temperature::over_autostart_threshold() {
     #if HAS_HOTEND
       HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;

commit 55e519a06f47e8c29687ebf2b58cc8117be0afdf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 21:26:09 2020 -0500

    General cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7c10beceeb..e62754a301 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -900,21 +900,24 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder && pid_debug_flag) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output);
           #if DISABLED(PID_OPENLOOP)
           {
-            SERIAL_ECHOPAIR( STR_PID_DEBUG_PTERM, work_pid[ee].Kp, STR_PID_DEBUG_ITERM, work_pid[ee].Ki, STR_PID_DEBUG_DTERM, work_pid[ee].Kd
+            SERIAL_ECHOPAIR(
+              STR_PID_DEBUG_PTERM, work_pid[ee].Kp,
+              STR_PID_DEBUG_ITERM, work_pid[ee].Ki,
+              STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
           }
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 

commit 2d33a9fd7c5485acbcf69c506470a67c870ef113
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 19:30:48 2020 -0500

    Add REPORT_FAN_CHANGE as an option

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 48cf388670..7c10beceeb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -209,32 +209,35 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;
-    report_fan_speed(target);
-  }
 
-  /**
-   * Report print fan speed for a target extruder
-   */
-  void Temperature::report_fan_speed(const uint8_t target) {
-    if (target >= FAN_COUNT) return;
-    PORT_REDIRECT(SERIAL_BOTH);
-    SERIAL_ECHOLNPAIR("M106 P", target, " S", fan_speed[target]);
+    TERN_(REPORT_FAN_CHANGE, report_fan_speed(target));
   }
 
+  #if ENABLED(REPORT_FAN_CHANGE)
+    /**
+     * Report print fan speed for a target extruder
+     */
+    void Temperature::report_fan_speed(const uint8_t target) {
+      if (target >= FAN_COUNT) return;
+      PORT_REDIRECT(SERIAL_BOTH);
+      SERIAL_ECHOLNPAIR("M106 P", target, " S", fan_speed[target]);
+    }
+  #endif
+
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else
           FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }

commit c4dd0082a1a24a6f457488fef3fbf8161e761b46
Author: Axel <ansepulveda@uc.cl>
Date:   Sat Jul 11 01:23:48 2020 -0400

    Option to assist thermocouple debug (#18621)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4d081f39c1..48cf388670 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -17,20 +17,23 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
+// Useful when debugging thermocouples
+//#define IGNORE_THERMOCOUPLE_ERRORS
+
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "planner.h"
 #include "../HAL/shared/Delay.h"
 
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
@@ -1004,28 +1007,29 @@ void Temperature::manage_heater() {
     if (!inited) return watchdog_refresh();
   #endif
 
   if (TERN0(EMERGENCY_PARSER, emergency_parser.killed_by_M112))
     kill(M112_KILL_STR, nullptr, true);
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
-  #if ENABLED(HEATER_0_USES_MAX6675)
-    if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
-    if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
-  #endif
-
-  #if ENABLED(HEATER_1_USES_MAX6675)
-    if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
-    if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
+  #if DISABLED(IGNORE_THERMOCOUPLE_ERRORS)
+    #if ENABLED(HEATER_0_USES_MAX6675)
+      if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
+      if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
+    #endif
+    #if ENABLED(HEATER_1_USES_MAX6675)
+      if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
+      if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
+    #endif
   #endif
 
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp)
           _temp_error((heater_ind_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
@@ -2173,51 +2177,48 @@ void Temperature::disable_all_heaters() {
           max6675_spi.receive()
         #else
           spiRec()
         #endif
       );
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     WRITE_MAX6675(HIGH); // disable TT_MAX6675
 
-    if (max6675_temp & MAX6675_ERROR_MASK) {
+    if (DISABLED(IGNORE_THERMOCOUPLE_ERRORS) && (max6675_temp & MAX6675_ERROR_MASK)) {
       max6675_errors[hindex] += 1;
       if (max6675_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
         SERIAL_ERROR_START();
         SERIAL_ECHOPGM("Temp measurement error! ");
         #if MAX6675_ERROR_MASK == 7
           SERIAL_ECHOPGM("MAX31855 ");
           if (max6675_temp & 1)
             SERIAL_ECHOLNPGM("Open Circuit");
           else if (max6675_temp & 2)
             SERIAL_ECHOLNPGM("Short to GND");
           else if (max6675_temp & 4)
             SERIAL_ECHOLNPGM("Short to VCC");
         #else
           SERIAL_ECHOLNPGM("MAX6675");
         #endif
 
         // Thermocouple open
         max6675_temp = 4 * (
           #if COUNT_6675 > 1
             hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
-          #elif ENABLED(HEATER_1_USES_MAX6675)
-            HEATER_1_MAX6675_TMAX
           #else
-            HEATER_0_MAX6675_TMAX
+            TERN(HEATER_1_USES_MAX6675, HEATER_1_MAX6675_TMAX, HEATER_0_MAX6675_TMAX)
           #endif
         );
       }
-      else {
+      else
         max6675_temp >>= MAX6675_DISCARD_BITS;
-      }
     }
     else {
       max6675_temp >>= MAX6675_DISCARD_BITS;
       max6675_errors[hindex] = 0;
     }
 
     #if ENABLED(MAX6675_IS_MAX31855)
       if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000; // Support negative temperature
     #endif
 

commit c2e0e61fe85967ff4ef4bba7f1f49475f396ed53
Author: ellensp <ellensp@hotmail.com>
Date:   Wed Jul 8 23:28:32 2020 +1200

    Fix User Temp Sensor (1000), reversed Pt100 / Pt1000 (#18590)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d5de826b47..4d081f39c1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1793,27 +1793,27 @@ void Temperature::init() {
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
-      const int16_t tmin = _MAX(HEATER_ ##NR## _MINTEMP, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MINTEMP_IND].celsius)); \
+      const int16_t tmin = _MAX(HEATER_ ##NR## _MINTEMP, TERN(HEATER_##NR##_USER_THERMISTOR, 0, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MINTEMP_IND].celsius))); \
       temp_range[NR].mintemp = tmin; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
-      const int16_t tmax = _MIN(HEATER_ ##NR## _MAXTEMP, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MAXTEMP_IND].celsius) - 1); \
+      const int16_t tmax = _MIN(HEATER_ ##NR## _MAXTEMP, TERN(HEATER_##NR##_USER_THERMISTOR, 2000, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MAXTEMP_IND].celsius) - 1)); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
     #define _MINMAX_TEST(N,M) (HOTENDS > N && THERMISTOR_HEATER_##N && THERMISTOR_HEATER_##N != 998 && THERMISTOR_HEATER_##N != 999 && defined(HEATER_##N##_##M##TEMP))
 
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif

commit 9546847dc1af1d4df4842b99576010890bdaf8b1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 7 01:50:57 2020 -0500

    Temp Residency followup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ff7f69e5c8..d5de826b47 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1806,26 +1806,26 @@ void Temperature::init() {
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const int16_t tmax = _MIN(HEATER_ ##NR## _MAXTEMP, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MAXTEMP_IND].celsius) - 1); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
     #define _MINMAX_TEST(N,M) (HOTENDS > N && THERMISTOR_HEATER_##N && THERMISTOR_HEATER_##N != 998 && THERMISTOR_HEATER_##N != 999 && defined(HEATER_##N##_##M##TEMP))
-  
+
     #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
     #endif
     #if _MINMAX_TEST(0, MAX)
-      _TEMP_MAX_E(0); 
+      _TEMP_MAX_E(0);
     #endif
     #if _MINMAX_TEST(1, MIN)
       _TEMP_MIN_E(1);
     #endif
     #if _MINMAX_TEST(1, MAX)
       _TEMP_MAX_E(1);
     #endif
     #if _MINMAX_TEST(2, MIN)
       _TEMP_MIN_E(2);
     #endif
@@ -3092,21 +3092,21 @@ void Temperature::tick() {
           // Gradually change LED strip from violet to red as nozzle heats up
           if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
-            if (temp_diff < TEMP_WINDOW) {
+            if (temp_diff < TEMP_WINDOW)
               residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
 
         #endif

commit ea8c3a9388f74ab1a05f5261b3373a1682575899
Author: espr14 <espr14@gmail.com>
Date:   Tue Jul 7 01:52:21 2020 +0200

    Reduce 'first loop' temperature residency time (#18421)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1afe5c4e4e..ff7f69e5c8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3093,23 +3093,21 @@ void Temperature::tick() {
           if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_WINDOW) {
-              residency_start_ms = now;
-              if (first_loop) residency_start_ms += SEC_TO_MS(TEMP_RESIDENCY_TIME);
-            }
+              residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
 
         #endif
 
@@ -3220,24 +3218,22 @@ void Temperature::tick() {
           // Gradually change LED strip from blue to violet as bed heats up
           if (!wants_to_cool) printerEventLEDs.onBedHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
-            if (temp_diff < TEMP_BED_WINDOW) {
-              residency_start_ms = now;
-              if (first_loop) residency_start_ms += SEC_TO_MS(TEMP_BED_RESIDENCY_TIME);
-            }
+            if (temp_diff < TEMP_BED_WINDOW)
+              residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_BED_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_BED_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
         #endif // TEMP_BED_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M190 R0
         if (wants_to_cool) {
@@ -3312,21 +3308,21 @@ void Temperature::tick() {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetChamber()) {
           wants_to_cool = isCoolingChamber();
           target_temp = degTargetChamber();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
-        if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
+        if (ELAPSED(now, next_temp_ms)) { // Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_CHAMBER_RESIDENCY_TIME > 0
             SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
               SERIAL_ECHO(long((SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
@@ -3336,24 +3332,22 @@ void Temperature::tick() {
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degChamber();
 
         #if TEMP_CHAMBER_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_CHAMBER_RESIDENCY_TIME timer when we reach target temp for the first time.
-            if (temp_diff < TEMP_CHAMBER_WINDOW) {
-              residency_start_ms = now;
-              if (first_loop) residency_start_ms += SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME);
-            }
+            if (temp_diff < TEMP_CHAMBER_WINDOW)
+              residency_start_ms = now + (first_loop ? SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME) / 3 : 0);
           }
           else if (temp_diff > TEMP_CHAMBER_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
         #endif // TEMP_CHAMBER_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M191 R0

commit 6f14d2d37fbd4c294401243dd2575df1fee9c2bc
Author: J.C. Nelson <32139633+xC0000005@users.noreply.github.com>
Date:   Mon Jul 6 15:08:52 2020 -0700

    Add Lerdge S,X,K (#18302)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6746595ffe..1afe5c4e4e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1591,26 +1591,34 @@ void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495)
-    #if  _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
+    #if _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
+  // Thermistor activation by MCU pin
+  #if PIN_EXISTS(TEMP_0_TR_ENABLE_PIN)
+    OUT_WRITE(TEMP_0_TR_ENABLE_PIN, ENABLED(HEATER_0_USES_MAX6675));
+  #endif
+  #if PIN_EXISTS(TEMP_1_TR_ENABLE_PIN)
+    OUT_WRITE(TEMP_1_TR_ENABLE_PIN, ENABLED(HEATER_1_USES_MAX6675));
+  #endif
+
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
     #ifdef ALFAWISE_UX0
       OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
     #else
       OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
     #endif

commit dc6d8357a681cc99e04c5980c0ac66009c173e85
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 27 23:27:28 2020 -0500

    Reduce string duplication

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 74af973f19..6746595ffe 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1274,22 +1274,22 @@ void Temperature::manage_heater() {
       SERIAL_ECHOPGM("  M305 ");
     else
       SERIAL_ECHO_START();
     SERIAL_CHAR('P');
     SERIAL_CHAR('0' + t_index);
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
-    SERIAL_ECHOPAIR_F(" B", t.beta, 1);
-    SERIAL_ECHOPAIR_F(" C", t.sh_c_coeff, 9);
+    SERIAL_ECHOPAIR_F_P(SP_B_STR, t.beta, 1);
+    SERIAL_ECHOPAIR_F_P(SP_C_STR, t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     serialprintPGM(
       TERN_(HEATER_0_USER_THERMISTOR, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
       TERN_(HEATER_1_USER_THERMISTOR, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
       TERN_(HEATER_2_USER_THERMISTOR, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
       TERN_(HEATER_3_USER_THERMISTOR, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
       TERN_(HEATER_4_USER_THERMISTOR, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
       TERN_(HEATER_5_USER_THERMISTOR, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
       TERN_(HEATER_6_USER_THERMISTOR, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
       TERN_(HEATER_7_USER_THERMISTOR, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)

commit 6df927d3b24c539edd3b7dc6e8717333678c6ff3
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Jul 5 13:04:31 2020 +1200

    Fix thermistors exist-for-reading tests (#18533)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1ca988e5d7..74af973f19 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1797,90 +1797,69 @@ void Temperature::init() {
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       const int16_t tmax = _MIN(HEATER_ ##NR## _MAXTEMP, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MAXTEMP_IND].celsius) - 1); \
       temp_range[NR].maxtemp = tmax; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #if THERMISTOR_HEATER_0
-      #ifdef HEATER_0_MINTEMP
+    #define _MINMAX_TEST(N,M) (HOTENDS > N && THERMISTOR_HEATER_##N && THERMISTOR_HEATER_##N != 998 && THERMISTOR_HEATER_##N != 999 && defined(HEATER_##N##_##M##TEMP))
+  
+    #if _MINMAX_TEST(0, MIN)
       _TEMP_MIN_E(0);
-      #endif
-      #ifdef HEATER_0_MAXTEMP
-        _TEMP_MAX_E(0);
-      #endif
     #endif
-
-    #if HAS_MULTI_HOTEND && THERMISTOR_HEATER_1
-      #ifdef HEATER_1_MINTEMP
-        _TEMP_MIN_E(1);
-      #endif
-      #ifdef HEATER_1_MAXTEMP
-        _TEMP_MAX_E(1);
-      #endif
+    #if _MINMAX_TEST(0, MAX)
+      _TEMP_MAX_E(0); 
     #endif
-
-    #if HOTENDS > 2 && THERMISTOR_HEATER_2
-      #ifdef HEATER_2_MINTEMP
-        _TEMP_MIN_E(2);
-      #endif
-      #ifdef HEATER_2_MAXTEMP
-        _TEMP_MAX_E(2);
-      #endif
+    #if _MINMAX_TEST(1, MIN)
+      _TEMP_MIN_E(1);
     #endif
-
-    #if HOTENDS > 3 && THERMISTOR_HEATER_3
-      #ifdef HEATER_3_MINTEMP
-        _TEMP_MIN_E(3);
-      #endif
-      #ifdef HEATER_3_MAXTEMP
-        _TEMP_MAX_E(3);
-      #endif
+    #if _MINMAX_TEST(1, MAX)
+      _TEMP_MAX_E(1);
     #endif
-
-    #if HOTENDS > 4 && THERMISTOR_HEATER_4
-      #ifdef HEATER_4_MINTEMP
-        _TEMP_MIN_E(4);
-      #endif
-      #ifdef HEATER_4_MAXTEMP
-        _TEMP_MAX_E(4);
-      #endif
+    #if _MINMAX_TEST(2, MIN)
+      _TEMP_MIN_E(2);
     #endif
-
-    #if HOTENDS > 5 && THERMISTOR_HEATER_5
-      #ifdef HEATER_5_MINTEMP
-        _TEMP_MIN_E(5);
-      #endif
-      #ifdef HEATER_5_MAXTEMP
-        _TEMP_MAX_E(5);
-      #endif
+    #if _MINMAX_TEST(2, MAX)
+      _TEMP_MAX_E(2);
     #endif
-
-    #if HOTENDS > 6 && THERMISTOR_HEATER_6
-      #ifdef HEATER_6_MINTEMP
-        _TEMP_MIN_E(6);
-      #endif
-      #ifdef HEATER_6_MAXTEMP
-        _TEMP_MAX_E(6);
-      #endif
+    #if _MINMAX_TEST(3, MIN)
+      _TEMP_MIN_E(3);
     #endif
-
-    #if HOTENDS > 7 && THERMISTOR_HEATER_7
-      #ifdef HEATER_7_MINTEMP
-        _TEMP_MIN_E(7);
-      #endif
-      #ifdef HEATER_7_MAXTEMP
-        _TEMP_MAX_E(7);
-      #endif
+    #if _MINMAX_TEST(3, MAX)
+      _TEMP_MAX_E(3);
+    #endif
+    #if _MINMAX_TEST(4, MIN)
+      _TEMP_MIN_E(4);
+    #endif
+    #if _MINMAX_TEST(4, MAX)
+      _TEMP_MAX_E(4);
+    #endif
+    #if _MINMAX_TEST(5, MIN)
+      _TEMP_MIN_E(5);
+    #endif
+    #if _MINMAX_TEST(5, MAX)
+      _TEMP_MAX_E(5);
+    #endif
+    #if _MINMAX_TEST(6, MIN)
+      _TEMP_MIN_E(6);
+    #endif
+    #if _MINMAX_TEST(6, MAX)
+      _TEMP_MAX_E(6);
+    #endif
+    #if _MINMAX_TEST(7, MIN)
+      _TEMP_MIN_E(7);
+    #endif
+    #if _MINMAX_TEST(7, MAX)
+      _TEMP_MAX_E(7);
     #endif
 
   #endif // HAS_HOTEND
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
     #ifdef BED_MAXTEMP
       while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);

commit c43bbcce152b4d3b4697e1e188d3bcada76a24a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 1 16:27:28 2020 -0500

    Enforce sensor range for temperature target (#18465)
    
    * Mitigate stepper timeout
    
    * Add CHAMBER PWM code
    
    * Structured thermistor tables
    
    * Fix reversed sensor ranges
    
    * Prevent temps outside sensor range

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b95fdbdd86..1ca988e5d7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -103,26 +103,26 @@
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    static const void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
+    static const temp_entry_t* heater_ttbl_map[2] = { HEATER_0_TEMPTABLE, HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     #define NEXT_TEMPTABLE(N) ,HEATER_##N##_TEMPTABLE
     #define NEXT_TEMPTABLE_LEN(N) ,HEATER_##N##_TEMPTABLE_LEN
-    static const void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
+    static const temp_entry_t* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
   #endif
 #endif
 
 Temperature thermalManager;
 
 const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
            str_t_heating_failed[] PROGMEM = STR_T_HEATING_FAILED;
 
 /**
@@ -893,41 +893,43 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder && pid_debug_flag) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output);
           #if DISABLED(PID_OPENLOOP)
+          {
             SERIAL_ECHOPAIR( STR_PID_DEBUG_PTERM, work_pid[ee].Kp, STR_PID_DEBUG_ITERM, work_pid[ee].Ki, STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
+          }
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
       const bool is_idling = TERN0(HEATER_IDLE_HANDLER, hotend_idle[ee].timed_out);
       const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
-#endif // HOTENDS
+#endif // HAS_HOTEND
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
       static PID_t work_pid{0};
       static float temp_iState = 0, temp_dState = 0;
       static bool pid_reset = true;
@@ -1051,21 +1053,21 @@ void Temperature::manage_heater() {
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
           _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
 
     } // HOTEND_LOOP
 
-  #endif // HOTENDS
+  #endif // HAS_HOTEND
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     /**
@@ -1201,36 +1203,36 @@ void Temperature::manage_heater() {
   UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
-#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
-  uint8_t l = 0, r = LEN, m;                                           \
-  for (;;) {                                                           \
-    m = (l + r) >> 1;                                                  \
-    if (!m) return short(pgm_read_word(&TBL[0][1]));                   \
-    if (m == l || m == r) return short(pgm_read_word(&TBL[LEN-1][1])); \
-    short v00 = pgm_read_word(&TBL[m-1][0]),                           \
-          v10 = pgm_read_word(&TBL[m-0][0]);                           \
-         if (raw < v00) r = m;                                         \
-    else if (raw > v10) l = m;                                         \
-    else {                                                             \
-      const short v01 = short(pgm_read_word(&TBL[m-1][1])),            \
-                  v11 = short(pgm_read_word(&TBL[m-0][1]));            \
-      return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);  \
-    }                                                                  \
-  }                                                                    \
+#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                            \
+  uint8_t l = 0, r = LEN, m;                                          \
+  for (;;) {                                                          \
+    m = (l + r) >> 1;                                                 \
+    if (!m) return int16_t(pgm_read_word(&TBL[0].celsius));           \
+    if (m == l || m == r) return int16_t(pgm_read_word(&TBL[LEN-1].celsius)); \
+    int16_t v00 = pgm_read_word(&TBL[m-1].value),                     \
+          v10 = pgm_read_word(&TBL[m-0].value);                       \
+         if (raw < v00) r = m;                                        \
+    else if (raw > v10) l = m;                                        \
+    else {                                                            \
+      const int16_t v01 = int16_t(pgm_read_word(&TBL[m-1].celsius)),  \
+                  v11 = int16_t(pgm_read_word(&TBL[m-0].celsius));    \
+      return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00); \
+    }                                                                 \
+  }                                                                   \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
     user_thermistor_t user_thermistor[USER_THERMISTORS] = {
       #if ENABLED(HEATER_0_USER_THERMISTOR)
         { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
@@ -1445,27 +1447,27 @@ void Temperature::manage_heater() {
         #elif ENABLED(HEATER_7_USES_AD8495)
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       default: break;
     }
 
     #if HOTEND_USES_THERMISTOR
       // Thermistor with conversion table?
-      const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
+      const temp_entry_t(*tt)[] = (temp_entry_t(*)[])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
   }
-#endif // HOTENDS
+#endif // HAS_HOTEND
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
     #if ENABLED(HEATER_BED_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
@@ -1783,94 +1785,105 @@ void Temperature::init() {
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
-      temp_range[NR].mintemp = HEATER_ ##NR## _MINTEMP; \
-      while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < HEATER_ ##NR## _MINTEMP) \
+      const int16_t tmin = _MAX(HEATER_ ##NR## _MINTEMP, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MINTEMP_IND].celsius)); \
+      temp_range[NR].mintemp = tmin; \
+      while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < tmin) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
-      temp_range[NR].maxtemp = HEATER_ ##NR## _MAXTEMP; \
-      while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > HEATER_ ##NR## _MAXTEMP) \
+      const int16_t tmax = _MIN(HEATER_ ##NR## _MAXTEMP, (int16_t)pgm_read_word(&HEATER_ ##NR## _TEMPTABLE[HEATER_ ##NR## _SENSOR_MAXTEMP_IND].celsius) - 1); \
+      temp_range[NR].maxtemp = tmax; \
+      while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > tmax) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
-    #ifdef HEATER_0_MINTEMP
+    #if THERMISTOR_HEATER_0
+      #ifdef HEATER_0_MINTEMP
       _TEMP_MIN_E(0);
+      #endif
+      #ifdef HEATER_0_MAXTEMP
+        _TEMP_MAX_E(0);
+      #endif
     #endif
-    #ifdef HEATER_0_MAXTEMP
-      _TEMP_MAX_E(0);
-    #endif
-    #if HAS_MULTI_HOTEND
+
+    #if HAS_MULTI_HOTEND && THERMISTOR_HEATER_1
       #ifdef HEATER_1_MINTEMP
         _TEMP_MIN_E(1);
       #endif
       #ifdef HEATER_1_MAXTEMP
         _TEMP_MAX_E(1);
       #endif
-      #if HOTENDS > 2
-        #ifdef HEATER_2_MINTEMP
-          _TEMP_MIN_E(2);
-        #endif
-        #ifdef HEATER_2_MAXTEMP
-          _TEMP_MAX_E(2);
-        #endif
-        #if HOTENDS > 3
-          #ifdef HEATER_3_MINTEMP
-            _TEMP_MIN_E(3);
-          #endif
-          #ifdef HEATER_3_MAXTEMP
-            _TEMP_MAX_E(3);
-          #endif
-          #if HOTENDS > 4
-            #ifdef HEATER_4_MINTEMP
-              _TEMP_MIN_E(4);
-            #endif
-            #ifdef HEATER_4_MAXTEMP
-              _TEMP_MAX_E(4);
-            #endif
-            #if HOTENDS > 5
-              #ifdef HEATER_5_MINTEMP
-                _TEMP_MIN_E(5);
-              #endif
-              #ifdef HEATER_5_MAXTEMP
-                _TEMP_MAX_E(5);
-              #endif
-              #if HOTENDS > 6
-                #ifdef HEATER_6_MINTEMP
-                  _TEMP_MIN_E(6);
-                #endif
-                #ifdef HEATER_6_MAXTEMP
-                  _TEMP_MAX_E(6);
-                #endif
-                #if HOTENDS > 7
-                  #ifdef HEATER_7_MINTEMP
-                    _TEMP_MIN_E(7);
-                  #endif
-                  #ifdef HEATER_7_MAXTEMP
-                    _TEMP_MAX_E(7);
-                  #endif
-                #endif // HOTENDS > 7
-              #endif // HOTENDS > 6
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HAS_MULTI_HOTEND
-
-  #endif // HOTENDS
+    #endif
+
+    #if HOTENDS > 2 && THERMISTOR_HEATER_2
+      #ifdef HEATER_2_MINTEMP
+        _TEMP_MIN_E(2);
+      #endif
+      #ifdef HEATER_2_MAXTEMP
+        _TEMP_MAX_E(2);
+      #endif
+    #endif
+
+    #if HOTENDS > 3 && THERMISTOR_HEATER_3
+      #ifdef HEATER_3_MINTEMP
+        _TEMP_MIN_E(3);
+      #endif
+      #ifdef HEATER_3_MAXTEMP
+        _TEMP_MAX_E(3);
+      #endif
+    #endif
+
+    #if HOTENDS > 4 && THERMISTOR_HEATER_4
+      #ifdef HEATER_4_MINTEMP
+        _TEMP_MIN_E(4);
+      #endif
+      #ifdef HEATER_4_MAXTEMP
+        _TEMP_MAX_E(4);
+      #endif
+    #endif
+
+    #if HOTENDS > 5 && THERMISTOR_HEATER_5
+      #ifdef HEATER_5_MINTEMP
+        _TEMP_MIN_E(5);
+      #endif
+      #ifdef HEATER_5_MAXTEMP
+        _TEMP_MAX_E(5);
+      #endif
+    #endif
+
+    #if HOTENDS > 6 && THERMISTOR_HEATER_6
+      #ifdef HEATER_6_MINTEMP
+        _TEMP_MIN_E(6);
+      #endif
+      #ifdef HEATER_6_MAXTEMP
+        _TEMP_MAX_E(6);
+      #endif
+    #endif
+
+    #if HOTENDS > 7 && THERMISTOR_HEATER_7
+      #ifdef HEATER_7_MINTEMP
+        _TEMP_MIN_E(7);
+      #endif
+      #ifdef HEATER_7_MAXTEMP
+        _TEMP_MAX_E(7);
+      #endif
+    #endif
+
+  #endif // HAS_HOTEND
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
     #ifdef BED_MAXTEMP
       while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
   #endif // HAS_HEATED_BED
 
@@ -2312,21 +2325,21 @@ void Temperature::readings_ready() {
           #endif
               min_temp_error((heater_ind_t)e);
         }
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           else
             consecutive_low_temperature_error[e] = 0;
         #endif
       }
     }
 
-  #endif // HOTENDS
+  #endif // HAS_HOTEND
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<(B))
     #else
       #define BEDCMP(A,B) ((A)>(B))
     #endif
     const bool bed_on = temp_bed.target > 0
       || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount) > 0
     ;
@@ -2566,31 +2579,39 @@ void Temperature::tick() {
 
       #if HAS_HOTEND
         #define _SLOW_PWM_E(N) _SLOW_PWM(N, soft_pwm_hotend[N], temp_hotend[N]);
         REPEAT(HOTENDS, _SLOW_PWM_E);
       #endif
 
       #if HAS_HEATED_BED
         _SLOW_PWM(BED, soft_pwm_bed, temp_bed);
       #endif
 
+      #if HAS_HEATED_CHAMBER
+        _SLOW_PWM(CHAMBER, soft_pwm_chamber, temp_chamber);
+      #endif
+
     } // slow_pwm_count == 0
 
     #if HAS_HOTEND
       #define _PWM_OFF_E(N) _PWM_OFF(N, soft_pwm_hotend[N]);
       REPEAT(HOTENDS, _PWM_OFF_E);
     #endif
 
     #if HAS_HEATED_BED
       _PWM_OFF(BED, soft_pwm_bed);
     #endif
 
+    #if HAS_HEATED_CHAMBER
+      _PWM_OFF(CHAMBER, soft_pwm_chamber);
+    #endif
+
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
         pwm_count_tmp = 0;
         #define _PWM_FAN(N) do{                                 \
           soft_pwm_count_fan[N] = soft_pwm_amount_fan[N] >> 1;  \
           WRITE_FAN(N, soft_pwm_count_fan[N] > 0 ? HIGH : LOW); \
         }while(0)
         #if HAS_FAN0
           _PWM_FAN(0);
         #endif
@@ -2655,20 +2676,21 @@ void Temperature::tick() {
     // increment slow_pwm_count only every 64th pwm_count,
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
       #if HAS_HOTEND
         HOTEND_LOOP() soft_pwm_hotend[e].dec();
       #endif
       TERN_(HAS_HEATED_BED, soft_pwm_bed.dec());
+      TERN_(HAS_HEATED_CHAMBER, soft_pwm_chamber.dec());
     }
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
 

commit a907e15ae63b403358d831766d6773c76614702d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 26 18:53:39 2020 -0500

    Allow larger ADC debounce
    
    Reference #17205

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f909476592..b95fdbdd86 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -344,21 +344,21 @@ volatile bool Temperature::raw_temps_ready = false;
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
-  uint8_t Temperature::ADCKey_count = 0;
+  uint16_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 

commit 43a994e0dfdba0e6fda7f2b5cf5db3d622e97435
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 24 20:14:58 2020 -0500

    Fix material preset editing

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9d55867c5b..f909476592 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -144,21 +144,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
-  const int16_t Temperature::heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+  const uint16_t Temperature::heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 

commit 4275466f4930ce554419f5f03f07119b8a9aec04
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 24 19:44:50 2020 -0500

    Fix issues with no hotend / bed / fan (#18395)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 16e29f7b36..9d55867c5b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3121,21 +3121,21 @@ void Temperature::tick() {
             ui.quick_feedback();
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         #if ENABLED(DWIN_CREALITY_LCD)
           HMI_flag.heat_flag = 0;
           duration_t elapsed = print_job_timer.duration();  // print timer
-          heat_time = elapsed.value;
+          dwin_heat_time = elapsed.value;
         #else
           ui.reset_status();
         #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
       }
 
       return wait_for_heatup;
     }
 
   #endif // HAS_TEMP_HOTEND

commit 88e4dffe883036b73c224df8aa45d877e65ff93f
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jun 18 23:05:12 2020 +0200

    Fix PID autotune timeout (#18352)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 23c3d90a3c..16e29f7b36 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -561,21 +561,21 @@ volatile bool Temperature::raw_temps_ready = false;
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
               _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
-      if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
+      if ((ms - _MIN(t1, t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH

commit 424569b4c4bf112a3939724b30bad528a76a2b08
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 18 15:23:03 2020 -0500

    Power monitor and display (#17437)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2b7452a78a..23c3d90a3c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -77,20 +77,24 @@
 #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
+#if HAS_POWER_MONITOR
+  #include "../feature/power_monitor.h"
+#endif
+
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/e_parser.h"
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
@@ -1522,25 +1526,27 @@ void Temperature::manage_heater() {
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
     temp_hotend[1].raw = READ_MAX6675(1);
   #endif
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
+
   TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
   TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
   TERN_(TEMP_SENSOR_1_AS_REDUNDANT, redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1));
   TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
+  TERN_(HAS_POWER_MONITOR, power_monitor.capture_values());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
 
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
@@ -1733,20 +1739,26 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_PROBE
     HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
+  #if ENABLED(POWER_MONITOR_CURRENT)
+    HAL_ANALOG_SELECT(POWER_MONITOR_CURRENT_PIN);
+  #endif
+  #if ENABLED(POWER_MONITOR_VOLTAGE)
+    HAL_ANALOG_SELECT(POWER_MONITOR_VOLTAGE_PIN);
+  #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif
@@ -2753,27 +2765,45 @@ void Temperature::tick() {
     #endif
 
     #if HAS_TEMP_ADC_7
       case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
       case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
-        if (!HAL_ADC_READY())
-          next_sensor_state = adc_sensor_state; // redo this state
-        else
-          filwidth.accumulate(HAL_READ_ADC());
+        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
+        else filwidth.accumulate(HAL_READ_ADC());
       break;
     #endif
 
+    #if ENABLED(POWER_MONITOR_CURRENT)
+      case Prepare_POWER_MONITOR_CURRENT:
+        HAL_START_ADC(POWER_MONITOR_CURRENT_PIN);
+        break;
+      case Measure_POWER_MONITOR_CURRENT:
+        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_current_sample(HAL_READ_ADC());
+        break;
+    #endif
+
+    #if ENABLED(POWER_MONITOR_VOLTAGE)
+      case Prepare_POWER_MONITOR_VOLTAGE:
+        HAL_START_ADC(POWER_MONITOR_VOLTAGE_PIN);
+        break;
+      case Measure_POWER_MONITOR_VOLTAGE:
+        if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; // Redo this state
+        else power_monitor.add_voltage_sample(HAL_READ_ADC());
+        break;
+    #endif
+
     #if HAS_JOY_ADC_X
       case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
       case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
     #endif
 
     #if HAS_JOY_ADC_Y
       case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
       case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
     #endif
 

commit f4c258dc2355fee871bec6e11095c7c4777b160d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 16 01:45:27 2020 -0500

    Creality Ender 3 v2 (#17719)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1fcc849241..2b7452a78a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -25,20 +25,25 @@
  */
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "planner.h"
 #include "../HAL/shared/Delay.h"
 
 #include "../lcd/ultralcd.h"
+
+#if ENABLED(DWIN_CREALITY_LCD)
+  #include "../lcd/dwin/dwin.h"
+#endif
+
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
@@ -553,20 +558,21 @@ volatile bool Temperature::raw_temps_ready = false;
               _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
+        TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), NUL_STR);
@@ -605,21 +611,21 @@ volatile bool Temperature::raw_temps_ready = false;
             _SET_BED_PID();
           #endif
         }
 
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
         TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
         goto EXIT_M303;
       }
-      ui.update();
+      TERN(DWIN_CREALITY_LCD, DWIN_Update(), ui.update());
     }
 
     disable_all_heaters();
 
     TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
 
     TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
     EXIT_M303:
       TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
@@ -787,24 +793,26 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
+  TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(1));
   _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
+  TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
   _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HAS_HOTEND
   #if ENABLED(PID_DEBUG)
     extern bool pid_debug_flag;
   #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
@@ -1022,22 +1030,24 @@ void Temperature::manage_heater() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
-          if (degHotend(e) < watch_hotend[e].target)                            // Failed to increase enough?
+          if (degHotend(e) < watch_hotend[e].target) {                          // Failed to increase enough?
+            TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
             _temp_error((heater_ind_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+          }
           else                                                                  // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
           _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
@@ -1064,22 +1074,24 @@ void Temperature::manage_heater() {
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP)
         _temp_error(H_BED, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
-        if (degBed() < watch_bed.target)                                // Failed to increase enough?
+        if (degBed() < watch_bed.target) {                              // Failed to increase enough?
+          TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
+        }
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
     #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
       #define PAUSE_CHANGE_REQD 1
     #endif
 
     #if PAUSE_CHANGE_REQD
@@ -1974,20 +1986,21 @@ void Temperature::init() {
         #endif
 
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
           sm.timer = millis() + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(millis(), sm.timer)) break;
         sm.state = TRRunaway;
 
       case TRRunaway:
+        TERN_(DWIN_CREALITY_LCD, Popup_Window_Temperature(0));
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   TERN_(AUTOTEMP, planner.autotemp_enabled = false);
 
@@ -3075,21 +3088,27 @@ void Temperature::tick() {
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
-        ui.reset_status();
+        #if ENABLED(DWIN_CREALITY_LCD)
+          HMI_flag.heat_flag = 0;
+          duration_t elapsed = print_job_timer.duration();  // print timer
+          heat_time = elapsed.value;
+        #else
+          ui.reset_status();
+        #endif
         TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
       }
 
       return wait_for_heatup;
     }
 
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 

commit 7628895ac861460bdc6b916e32de8e6a32bb738d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 18 13:58:11 2020 -0500

    Apply misc TERN

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 264d0a9039..1fcc849241 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -893,25 +893,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
-      #if HEATER_IDLE_HANDLER
-        const bool is_idling = hotend_idle[ee].timed_out;
-      #else
-        constexpr bool is_idling = false;
-      #endif
+      const bool is_idling = TERN0(HEATER_IDLE_HANDLER, hotend_idle[ee].timed_out);
       const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
 #endif // HOTENDS
 
 #if ENABLED(PIDTEMPBED)

commit f3bf343c89a1452af92fa7f57f3a4eb2761c77a8
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Tue May 26 04:16:35 2020 +0530

    Report fan speed on change (#18013)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6121a5a0ac..264d0a9039 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -197,20 +197,30 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;
+    report_fan_speed(target);
+  }
+
+  /**
+   * Report print fan speed for a target extruder
+   */
+  void Temperature::report_fan_speed(const uint8_t target) {
+    if (target >= FAN_COUNT) return;
+    PORT_REDIRECT(SERIAL_BOTH);
+    SERIAL_ECHOLNPAIR("M106 P", target, " S", fan_speed[target]);
   }
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else

commit 31eb487da5778f653c771331bcef6b57e3511404
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 22 02:02:03 2020 -0500

    whitespace

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0b073bc16c..6121a5a0ac 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2068,21 +2068,21 @@ void Temperature::disable_all_heaters() {
     #if COUNT_6675 > 1
       const uint8_t hindex
     #endif
   ) {
     #if COUNT_6675 == 1
       constexpr uint8_t hindex = 0;
     #else
       // Needed to return the correct temp when this is called too soon
       static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
     #endif
-    
+
     static uint8_t max6675_errors[COUNT_6675] = { 0 };
 
     #define MAX6675_HEAT_INTERVAL 250UL
 
     #if ENABLED(MAX6675_IS_MAX31855)
       static uint32_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    7
       #define MAX6675_DISCARD_BITS 18
       #define MAX6675_SPEED_BITS    3  // (_BV(SPR1)) // clock √∑ 64
     #else

commit 60bed3434bb7aa51b02978e93dae5985ff24fe3a
Author: Mobilinkd LLC <mobilinkd@gmail.com>
Date:   Wed May 20 15:38:29 2020 -0500

    Ignore spurious MAX31855K / 6675 thermocouple errors (#18039)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f9482aedb2..0b073bc16c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2053,31 +2053,37 @@ void Temperature::disable_all_heaters() {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
         TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
 #if HAS_MAX6675
 
+  #ifndef THERMOCOUPLE_MAX_ERRORS
+    #define THERMOCOUPLE_MAX_ERRORS 15
+  #endif
+
   int Temperature::read_max6675(
     #if COUNT_6675 > 1
       const uint8_t hindex
     #endif
   ) {
     #if COUNT_6675 == 1
       constexpr uint8_t hindex = 0;
     #else
       // Needed to return the correct temp when this is called too soon
       static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
     #endif
+    
+    static uint8_t max6675_errors[COUNT_6675] = { 0 };
 
     #define MAX6675_HEAT_INTERVAL 250UL
 
     #if ENABLED(MAX6675_IS_MAX31855)
       static uint32_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    7
       #define MAX6675_DISCARD_BITS 18
       #define MAX6675_SPEED_BITS    3  // (_BV(SPR1)) // clock √∑ 64
     #else
       static uint16_t max6675_temp = 2000;
@@ -2137,47 +2143,55 @@ void Temperature::disable_all_heaters() {
         #else
           spiRec()
         #endif
       );
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     WRITE_MAX6675(HIGH); // disable TT_MAX6675
 
     if (max6675_temp & MAX6675_ERROR_MASK) {
-      SERIAL_ERROR_START();
-      SERIAL_ECHOPGM("Temp measurement error! ");
-      #if MAX6675_ERROR_MASK == 7
-        SERIAL_ECHOPGM("MAX31855 ");
-        if (max6675_temp & 1)
-          SERIAL_ECHOLNPGM("Open Circuit");
-        else if (max6675_temp & 2)
-          SERIAL_ECHOLNPGM("Short to GND");
-        else if (max6675_temp & 4)
-          SERIAL_ECHOLNPGM("Short to VCC");
-      #else
-        SERIAL_ECHOLNPGM("MAX6675");
-      #endif
-
-      // Thermocouple open
-      max6675_temp = 4 * (
-        #if COUNT_6675 > 1
-          hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
-        #elif ENABLED(HEATER_1_USES_MAX6675)
-          HEATER_1_MAX6675_TMAX
+      max6675_errors[hindex] += 1;
+      if (max6675_errors[hindex] > THERMOCOUPLE_MAX_ERRORS) {
+        SERIAL_ERROR_START();
+        SERIAL_ECHOPGM("Temp measurement error! ");
+        #if MAX6675_ERROR_MASK == 7
+          SERIAL_ECHOPGM("MAX31855 ");
+          if (max6675_temp & 1)
+            SERIAL_ECHOLNPGM("Open Circuit");
+          else if (max6675_temp & 2)
+            SERIAL_ECHOLNPGM("Short to GND");
+          else if (max6675_temp & 4)
+            SERIAL_ECHOLNPGM("Short to VCC");
         #else
-          HEATER_0_MAX6675_TMAX
+          SERIAL_ECHOLNPGM("MAX6675");
         #endif
-      );
+
+        // Thermocouple open
+        max6675_temp = 4 * (
+          #if COUNT_6675 > 1
+            hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
+          #elif ENABLED(HEATER_1_USES_MAX6675)
+            HEATER_1_MAX6675_TMAX
+          #else
+            HEATER_0_MAX6675_TMAX
+          #endif
+        );
+      }
+      else {
+        max6675_temp >>= MAX6675_DISCARD_BITS;
+      }
     }
-    else
+    else {
       max6675_temp >>= MAX6675_DISCARD_BITS;
+      max6675_errors[hindex] = 0;
+    }
 
     #if ENABLED(MAX6675_IS_MAX31855)
       if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000; // Support negative temperature
     #endif
 
     #if COUNT_6675 > 1
       max6675_temp_previous[hindex] = max6675_temp;
     #endif
 
     return int(max6675_temp);

commit 94063e3a873d3e3644d1c363cd4d6eec82de649f
Author: Jason Smith <jason.inet@gmail.com>
Date:   Mon May 18 11:51:32 2020 -0700

    Fix PID + Thermal Protection combos (#18023)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7518e0ef2c..f9482aedb2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -374,29 +374,29 @@ volatile bool Temperature::raw_temps_ready = false;
       #define GHV(B,H) B
       #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
       #define SHV(B,H) (temp_hotend[heater].soft_pwm_amount = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
+    #define WATCH_PID BOTH(WATCH_BED, PIDTEMPBED) || BOTH(WATCH_HOTENDS, PIDTEMP)
 
-    #if WATCH_BED || WATCH_HOTENDS
-      #define HAS_TP_BED BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
-      #if HAS_TP_BED && BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
+    #if WATCH_PID
+      #if ALL(THERMAL_PROTECTION_HOTENDS, PIDTEMP, THERMAL_PROTECTION_BED, PIDTEMPBED)
         #define GTV(B,H) (isbed ? (B) : (H))
-      #elif HAS_TP_BED
-        #define GTV(B,H) (B)
-      #else
+      #elif BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
         #define GTV(B,H) (H)
+      #else
+        #define GTV(B,H) (B)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
@@ -521,21 +521,21 @@ volatile bool Temperature::raw_temps_ready = false;
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
-        #if WATCH_BED || WATCH_HOTENDS
+        #if WATCH_PID
           if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
                 temp_change_ms = ms + SEC_TO_MS(watch_temp_period);     // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _temp_error(heater, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
             }

commit d571a4d389c60d8d8768c769da3369627197cd88
Author: Mathias Rasmussen <mathiasvr@gmail.com>
Date:   Tue May 5 00:23:35 2020 +0200

    Relax bed cooling safety check (#17877)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a456aa8af3..7518e0ef2c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3067,21 +3067,21 @@ void Temperature::tick() {
       }
 
       return wait_for_heatup;
     }
 
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
-      #define MIN_COOLING_SLOPE_DEG_BED 1.50
+      #define MIN_COOLING_SLOPE_DEG_BED 1.00
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_BED
       #define MIN_COOLING_SLOPE_TIME_BED 60
     #endif
 
     bool Temperature::wait_for_bed(const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {

commit 36efe75ad13a8df9f642cde1fe067358d9fa8d25
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Sun May 3 07:32:25 2020 +0200

    Followup for Tool Migration (#17800)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 78f8a19cf6..a456aa8af3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2952,20 +2952,25 @@ void Temperature::tick() {
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60
     #endif
 
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {
+
+      #if ENABLED(AUTOTEMP)
+        REMEMBER(1, planner.autotemp_enabled, false);
+      #endif
+
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 

commit 89b17b54637200838e52ae39a9e4b23f3c2f8d35
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Tue Apr 28 07:21:23 2020 +0200

    Followup fixes for singlenozzle, etc. (#17712)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e55dcb074b..78f8a19cf6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -186,21 +186,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
   #endif
 
   /**
    * Set the print fan speed for a target extruder
    */
   void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
-    #if ENABLED(SINGLENOZZLE)
+    #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;

commit 01c646a892c9cd36baf577ca9be344e3490a7727
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 22:35:25 2020 -0500

    Apply more HAS_HOTEND

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d27a012e45..e55dcb074b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2379,21 +2379,21 @@ void Temperature::tick() {
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
-    #if HOTENDS || HAS_HEATED_BED || HAS_HEATED_CHAMBER
+    #if HAS_HOTEND || HAS_HEATED_BED || HAS_HEATED_CHAMBER
       constexpr uint8_t pwm_mask =
         #if ENABLED(SOFT_PWM_DITHER)
           _BV(SOFT_PWM_SCALE) - 1
         #else
           0
         #endif
       ;
       #define _PWM_MOD(N,S,T) do{                           \
         const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
         WRITE_HEATER_##N(on);                               \
@@ -2924,21 +2924,21 @@ void Temperature::tick() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         PORT_REDIRECT(SERIAL_BOTH);
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
-  #if HOTENDS && HAS_DISPLAY
+  #if HAS_HOTEND && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HAS_MULTI_HOTEND
           PSTR("E%c " S_FMT), '1' + e
         #else
           PSTR("E " S_FMT)
         #endif
         , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );

commit 37176ed2b9c3af5fbb2436d72a090b6d880f921e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 07:53:58 2020 -0500

    Apply maxtemp patch

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a0dec77793..d27a012e45 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -135,20 +135,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
+  const int16_t Temperature::heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 

commit 5507b6073c0215894e9d00f787a64a9b57b16525
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 06:34:53 2020 -0500

    Fix dummy thermistors
    
    Fixes #17422
    
    Co-Authored-By: Moeschus <moeschus@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 761e26f90d..a0dec77793 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2270,36 +2270,36 @@ void Temperature::readings_ready() {
           else
             consecutive_low_temperature_error[e] = 0;
         #endif
       }
     }
 
   #endif // HOTENDS
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
-      #define BEDCMP(A,B) ((A)<=(B))
+      #define BEDCMP(A,B) ((A)<(B))
     #else
-      #define BEDCMP(A,B) ((A)>=(B))
+      #define BEDCMP(A,B) ((A)>(B))
     #endif
     const bool bed_on = temp_bed.target > 0
       || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount) > 0
     ;
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
   #endif
 
   #if HAS_HEATED_CHAMBER
     #if TEMPDIR(CHAMBER) < 0
-      #define CHAMBERCMP(A,B) ((A)<=(B))
+      #define CHAMBERCMP(A,B) ((A)<(B))
     #else
-      #define CHAMBERCMP(A,B) ((A)>=(B))
+      #define CHAMBERCMP(A,B) ((A)>(B))
     #endif
     const bool chamber_on = (temp_chamber.target > 0);
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
     if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *

commit 33217b0dd0e2117905813e3a45632fdc9c66d04f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:48:11 2020 -0500

    Add HOTEND_OVERSHOOT

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 44de7cc40c..761e26f90d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -393,21 +393,21 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
-    if (target > GHV(BED_MAX_TARGET, temp_range[heater].maxtemp - 15)) {
+    if (target > GHV(BED_MAX_TARGET, temp_range[heater].maxtemp - HOTEND_OVERSHOOT)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3b11dcba57..44de7cc40c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -145,21 +145,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
-#if FAN_COUNT > 0
+#if HAS_FAN
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
     uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
 
     void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
       switch (tmp_temp) {
         case 1:
           set_fan_speed(fan, old_fan_speed[fan]);
@@ -212,21 +212,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else
           FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }
     }
 
   #endif
 
-#endif // FAN_COUNT > 0
+#endif // HAS_FAN
 
 #if WATCH_HOTENDS
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
   hotend_idle_t Temperature::hotend_idle[HOTENDS]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
@@ -393,21 +393,21 @@ volatile bool Temperature::raw_temps_ready = false;
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
-    if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
+    if (target > GHV(BED_MAX_TARGET, temp_range[heater].maxtemp - 15)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);

commit 3d45a4bd232c83450c269bb3f0fefa6fc67c788d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:35:20 2020 -0500

    Encapsulate Temperature items

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fc86061ccc..3b11dcba57 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -21,23 +21,24 @@
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
-#include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../HAL/shared/Delay.h"
+
+#include "../lcd/ultralcd.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
@@ -2234,36 +2235,28 @@ void Temperature::readings_ready() {
   TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
   TERN_(HAS_TEMP_PROBE, temp_probe.reset());
 
   TERN_(HAS_JOY_ADC_X, joystick.x.reset());
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 
   #if HAS_HOTEND
 
     static constexpr int8_t temp_dir[] = {
-      #if ENABLED(HEATER_0_USES_MAX6675)
-        0
-      #else
-        TEMPDIR(0)
-      #endif
+      TERN(HEATER_0_USES_MAX6675, 0, TEMPDIR(0))
       #if HAS_MULTI_HOTEND
-        #define _TEMPDIR(N) , TEMPDIR(N)
-        #if ENABLED(HEATER_1_USES_MAX6675)
-          , 0
-        #else
-          _TEMPDIR(1)
-        #endif
+        , TERN(HEATER_1_USES_MAX6675, 0, TEMPDIR(1))
         #if HOTENDS > 2
+          #define _TEMPDIR(N) , TEMPDIR(N)
           REPEAT_S(2, HOTENDS, _TEMPDIR)
-        #endif // HOTENDS > 2
-      #endif // HAS_MULTI_HOTEND
+        #endif
+      #endif
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
         const bool heater_on = (temp_hotend[e].target > 0
           || TERN0(PIDTEMP, temp_hotend[e].soft_pwm_amount) > 0
         );
         if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c72eb6f371..fc86061ccc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -229,29 +229,23 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
     int16_t Temperature::mintemp_raw_BED = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
   #endif
-  #if WATCH_BED
-    bed_watch_t Temperature::watch_bed; // = { 0 }
-  #endif
-  #if DISABLED(PIDTEMPBED)
-    millis_t Temperature::next_bed_check_ms;
-  #endif
-  #if HEATER_IDLE_HANDLER
-    hotend_idle_t Temperature::bed_idle; // = { 0 }
-  #endif
+  TERN_(WATCH_BED, bed_watch_t Temperature::watch_bed); // = { 0 }
+  TERN(PIDTEMPBED,, millis_t Temperature::next_bed_check_ms);
+  TERN_(HEATER_IDLE_HANDLER, hotend_idle_t Temperature::bed_idle); // = { 0 }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
@@ -396,47 +390,41 @@ volatile bool Temperature::raw_temps_ready = false;
         #define GTV(B,H) (H)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
-    #if HAS_AUTO_FAN
-      next_auto_fan_check_ms = next_temp_ms + 2500UL;
-    #endif
+    TERN_(HAS_AUTO_FAN, next_auto_fan_check_ms = next_temp_ms + 2500UL);
 
     if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
-      #endif
+      TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
-    #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
-      adaptive_fan_slowing = false;
-    #endif
+    TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = false);
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
@@ -518,23 +506,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH));
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
@@ -555,23 +541,21 @@ volatile bool Temperature::raw_temps_ready = false;
               _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT));
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), NUL_STR);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
@@ -603,68 +587,56 @@ volatile bool Temperature::raw_temps_ready = false;
         if (set_result) {
           #if HAS_PID_FOR_BOTH
             if (isbed) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
 
-        #if ENABLED(PRINTER_EVENT_LEDS)
-          printerEventLEDs.onPidTuningDone(color);
-        #endif
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onPidTuning(ExtUI::result_t::PID_DONE);
-        #endif
+        TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
+
+        TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
         goto EXIT_M303;
       }
       ui.update();
     }
 
     disable_all_heaters();
 
-    #if ENABLED(PRINTER_EVENT_LEDS)
-      printerEventLEDs.onPidTuningDone(color);
-    #endif
-    #if ENABLED(EXTENSIBLE_UI)
-      ExtUI::onPidTuning(ExtUI::result_t::PID_DONE);
-    #endif
+    TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onPidTuningDone(color));
+
+    TERN_(EXTENSIBLE_UI, ExtUI::onPidTuning(ExtUI::result_t::PID_DONE));
 
     EXIT_M303:
-      #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
-        adaptive_fan_slowing = true;
-      #endif
+      TERN_(NO_FAN_SLOWING_IN_PID_TUNING, adaptive_fan_slowing = true);
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     default:
-      return (0
-        #if HAS_HOTEND
-          + temp_hotend[heater_id].soft_pwm_amount
-        #endif
-      );
+      return TERN0(HAS_HOTEND, temp_hotend[heater_id].soft_pwm_amount);
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
@@ -764,33 +736,30 @@ inline void loud_kill(PGM_P const lcd_msg, const heater_ind_t heater) {
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
   kill(lcd_msg, HEATER_PSTR(heater));
 }
 
 void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
-  if (IsRunning()
-    #if BOGUS_TEMPERATURE_GRACE_PERIOD
-      && killed == 2
-    #endif
-  ) {
+  if (IsRunning() && TERN1(BOGUS_TEMPERATURE_GRACE_PERIOD, killed == 2)) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(STR_STOPPED_HEATER);
-    if (heater >= 0) SERIAL_ECHO((int)heater);
-    #if HAS_HEATED_CHAMBER
-      else if (heater == H_CHAMBER) SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
-    #endif
-    else SERIAL_ECHOPGM(STR_HEATER_BED);
+    if (heater >= 0)
+      SERIAL_ECHO((int)heater);
+    else if (TERN0(HAS_HEATED_CHAMBER, heater == H_CHAMBER))
+      SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
+    else
+      SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
       case 0:
@@ -832,23 +801,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
 
         float pid_output;
 
         if (temp_hotend[ee].target == 0
           || pid_error < -(PID_FUNCTIONAL_RANGE)
-          #if HEATER_IDLE_HANDLER
-            || hotend_idle[ee].timed_out
-          #endif
+          || TERN0(HEATER_IDLE_HANDLER, hotend_idle[ee].timed_out)
         ) {
           pid_output = 0;
           pid_reset[ee] = true;
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
           pid_output = BANG_MAX;
           pid_reset[ee] = true;
         }
         else {
           if (pid_reset[ee]) {
@@ -1008,23 +975,22 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
     if (!inited) return watchdog_refresh();
   #endif
 
-  #if ENABLED(EMERGENCY_PARSER)
-    if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
-  #endif
+  if (TERN0(EMERGENCY_PARSER, emergency_parser.killed_by_M112))
+    kill(M112_KILL_STR, nullptr, true);
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
     if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
@@ -1036,23 +1002,21 @@ void Temperature::manage_heater() {
   millis_t ms = millis();
 
   #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp)
           _temp_error((heater_ind_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
       #endif
 
-      #if HEATER_IDLE_HANDLER
-        hotend_idle[e].update(ms);
-      #endif
+      TERN_(HEATER_IDLE_HANDLER, hotend_idle[e].update(ms));
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
@@ -1099,46 +1063,41 @@ void Temperature::manage_heater() {
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
-    #define PAUSE_CHANGE_REQD BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+    #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+      #define PAUSE_CHANGE_REQD 1
+    #endif
+
     #if PAUSE_CHANGE_REQD
       static bool last_pause_state;
     #endif
 
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
-          #if PAUSE_CHANGE_REQD
-            && paused == last_pause_state
-          #endif
+          && TERN1(PAUSE_CHANGE_REQD, paused == last_pause_state)
         ) break;
         next_bed_check_ms = ms + BED_CHECK_INTERVAL;
-        #if PAUSE_CHANGE_REQD
-          last_pause_state = paused;
-        #endif
+        TERN_(PAUSE_CHANGE_REQD, last_pause_state = paused);
       #endif
 
-      #if HEATER_IDLE_HANDLER
-        bed_idle.update(ms);
-      #endif
+      TERN_(HEATER_IDLE_HANDLER, bed_idle.update(ms));
 
-      #if HAS_THERMALLY_PROTECTED_BED
-        thermal_runaway_protection(tr_state_machine_bed, temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
-      #endif
+      TERN_(HAS_THERMALLY_PROTECTED_BED, thermal_runaway_protection(tr_state_machine_bed, temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS));
 
       #if HEATER_IDLE_HANDLER
         if (bed_idle.timed_out) {
           temp_bed.soft_pwm_amount = 0;
           #if DISABLED(PIDTEMPBED)
             WRITE_HEATER_BED(LOW);
           #endif
         }
         else
       #endif
@@ -1200,23 +1159,21 @@ void Temperature::manage_heater() {
             temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
         #else
           temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
         #endif
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
-      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
-      #endif
+      TERN_(THERMAL_PROTECTION_CHAMBER, thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS));
     }
 
     // TODO: Implement true PID pwm
     //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
 
   UNUSED(ms);
 }
 
@@ -1295,50 +1252,30 @@ void Temperature::manage_heater() {
     SERIAL_CHAR('0' + t_index);
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
     SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F(" B", t.beta, 1);
     SERIAL_ECHOPAIR_F(" C", t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     serialprintPGM(
-      #if ENABLED(HEATER_0_USER_THERMISTOR)
-        t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :
-      #endif
-      #if ENABLED(HEATER_1_USER_THERMISTOR)
-        t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :
-      #endif
-      #if ENABLED(HEATER_2_USER_THERMISTOR)
-        t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :
-      #endif
-      #if ENABLED(HEATER_3_USER_THERMISTOR)
-        t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :
-      #endif
-      #if ENABLED(HEATER_4_USER_THERMISTOR)
-        t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :
-      #endif
-      #if ENABLED(HEATER_5_USER_THERMISTOR)
-        t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :
-      #endif
-      #if ENABLED(HEATER_6_USER_THERMISTOR)
-        t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :
-      #endif
-      #if ENABLED(HEATER_7_USER_THERMISTOR)
-        t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :
-      #endif
-      #if ENABLED(HEATER_BED_USER_THERMISTOR)
-        t_index == CTI_BED ? PSTR("BED") :
-      #endif
-      #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
-        t_index == CTI_CHAMBER ? PSTR("CHAMBER") :
-      #endif
+      TERN_(HEATER_0_USER_THERMISTOR, t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :)
+      TERN_(HEATER_1_USER_THERMISTOR, t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :)
+      TERN_(HEATER_2_USER_THERMISTOR, t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :)
+      TERN_(HEATER_3_USER_THERMISTOR, t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :)
+      TERN_(HEATER_4_USER_THERMISTOR, t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :)
+      TERN_(HEATER_5_USER_THERMISTOR, t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :)
+      TERN_(HEATER_6_USER_THERMISTOR, t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :)
+      TERN_(HEATER_7_USER_THERMISTOR, t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :)
+      TERN_(HEATER_BED_USER_THERMISTOR, t_index == CTI_BED ? PSTR("BED") :)
+      TERN_(HEATER_CHAMBER_USER_THERMISTOR, t_index == CTI_CHAMBER ? PSTR("CHAMBER") :)
       nullptr
     );
     SERIAL_EOL();
   }
 
   float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
@@ -1380,26 +1317,21 @@ void Temperature::manage_heater() {
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 #if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
   float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      if (e > HOTENDS)
-    #else
-      if (e >= HOTENDS)
-    #endif
-      {
+      if (e > HOTENDS - DISABLED(TEMP_SENSOR_1_AS_REDUNDANT)) {
         SERIAL_ERROR_START();
         SERIAL_ECHO((int)e);
         SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if ENABLED(HEATER_0_USER_THERMISTOR)
@@ -1570,35 +1502,25 @@ void Temperature::manage_heater() {
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
     temp_hotend[1].raw = READ_MAX6675(1);
   #endif
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
-  #if HAS_HEATED_BED
-    temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw);
-  #endif
-  #if HAS_TEMP_CHAMBER
-    temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
-  #endif
-  #if HAS_TEMP_PROBE
-    temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw);
-  #endif
-  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
-  #endif
-  #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    filwidth.update_measured_mm();
-  #endif
+  TERN_(HAS_HEATED_BED, temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw));
+  TERN_(HAS_TEMP_CHAMBER, temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw));
+  TERN_(HAS_TEMP_PROBE, temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw));
+  TERN_(TEMP_SENSOR_1_AS_REDUNDANT, redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1));
+  TERN_(FILAMENT_WIDTH_SENSOR, filwidth.update_measured_mm());
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
   raw_temps_ready = false;
 }
 
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
@@ -1630,23 +1552,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
-  #if ENABLED(MAX6675_IS_MAX31865)
-    max31865.begin(MAX31865_2WIRE); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
-  #endif
+  TERN_(MAX6675_IS_MAX31865, max31865.begin(MAX31865_2WIRE)); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495)
@@ -1924,23 +1844,21 @@ void Temperature::init() {
 
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
     #ifdef CHAMBER_MAXTEMP
       while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
   #endif
 
-  #if ENABLED(PROBING_HEATERS_OFF)
-    paused = false;
-  #endif
+  TERN_(PROBING_HEATERS_OFF, paused = false);
 }
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
@@ -1997,23 +1915,21 @@ void Temperature::init() {
       else
         SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
       SERIAL_EOL();
     //*/
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
       if ((heater_id >= 0 && hotend_idle[heater_id].timed_out)
-        #if HAS_HEATED_BED
-          || (heater_id < 0 && bed_idle.timed_out)
-        #endif
+        || TERN0(HAS_HEATED_BED, (heater_id < 0 && bed_idle.timed_out))
       ) {
         sm.state = TRInactive;
         tr_target_temperature[heater_index] = 0;
       }
       else
     #endif
     {
       // If the target temperature changes, restart
       if (tr_target_temperature[heater_index] != target) {
         tr_target_temperature[heater_index] = target;
@@ -2058,40 +1974,30 @@ void Temperature::init() {
 
       case TRRunaway:
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
-  #if ENABLED(AUTOTEMP)
-    planner.autotemp_enabled = false;
-  #endif
+  TERN_(AUTOTEMP, planner.autotemp_enabled = false);
 
   #if HAS_HOTEND
     HOTEND_LOOP() setTargetHotend(0, e);
   #endif
-
-  #if HAS_HEATED_BED
-    setTargetBed(0);
-  #endif
-
-  #if HAS_HEATED_CHAMBER
-    setTargetChamber(0);
-  #endif
+  TERN_(HAS_HEATED_BED, setTargetBed(0));
+  TERN_(HAS_HEATED_CHAMBER, setTargetChamber(0));
 
   // Unpause and reset everything
-  #if ENABLED(PROBING_HEATERS_OFF)
-    pause(false);
-  #endif
+  TERN_(PROBING_HEATERS_OFF, pause(false));
 
   #define DISABLE_HEATER(N) {           \
     setTargetHotend(0, N);              \
     temp_hotend[N].soft_pwm_amount = 0; \
     WRITE_HEATER_##N(LOW);              \
   }
 
   #if HAS_TEMP_HOTEND
     REPEAT(HOTENDS, DISABLE_HEATER);
   #endif
@@ -2108,27 +2014,22 @@ void Temperature::disable_all_heaters() {
     WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
   bool Temperature::over_autostart_threshold() {
     #if HAS_HOTEND
       HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;
     #endif
-    #if HAS_HEATED_BED
-      if (degTargetBed() > BED_MINTEMP) return true;
-    #endif
-    #if HAS_HEATED_CHAMBER
-      if (degTargetChamber() > CHAMBER_MINTEMP) return true;
-    #endif
-    return false;
+    return TERN0(HAS_HEATED_BED, degTargetBed() > BED_MINTEMP)
+        || TERN0(HAS_HEATED_CHAMBER, degTargetChamber() > CHAMBER_MINTEMP);
   }
 
   void Temperature::check_timer_autostart(const bool can_start, const bool can_stop) {
     if (over_autostart_threshold()) {
       if (can_start) startOrResumeJob();
     }
     else if (can_stop) {
       print_job_timer.stop();
       ui.reset_status();
     }
@@ -2136,30 +2037,26 @@ void Temperature::disable_all_heaters() {
 
 #endif
 
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
-        HOTEND_LOOP() hotend_idle[e].expire(); // timeout immediately
-        #if HAS_HEATED_BED
-          bed_idle.expire(); // timeout immediately
-        #endif
+        HOTEND_LOOP() hotend_idle[e].expire();    // Timeout immediately
+        TERN_(HAS_HEATED_BED, bed_idle.expire()); // Timeout immediately
       }
       else {
         HOTEND_LOOP() reset_hotend_idle_timer(e);
-        #if HAS_HEATED_BED
-          reset_bed_idle_timer();
-        #endif
+        TERN_(HAS_HEATED_BED, reset_bed_idle_timer());
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
 #if HAS_MAX6675
 
   int Temperature::read_max6675(
     #if COUNT_6675 > 1
@@ -2296,102 +2193,57 @@ void Temperature::update_raw_temperatures() {
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = temp_hotend[1].acc;
     #elif DISABLED(HEATER_1_USES_MAX6675)
       temp_hotend[1].update();
     #endif
   #endif
 
-  #if HAS_TEMP_ADC_2
-    temp_hotend[2].update();
-  #endif
-  #if HAS_TEMP_ADC_3
-    temp_hotend[3].update();
-  #endif
-  #if HAS_TEMP_ADC_4
-    temp_hotend[4].update();
-  #endif
-  #if HAS_TEMP_ADC_5
-    temp_hotend[5].update();
-  #endif
-  #if HAS_TEMP_ADC_6
-    temp_hotend[6].update();
-  #endif
-  #if HAS_TEMP_ADC_7
-    temp_hotend[7].update();
-  #endif
-
-  #if HAS_HEATED_BED
-    temp_bed.update();
-  #endif
+  TERN_(HAS_TEMP_ADC_2, temp_hotend[2].update());
+  TERN_(HAS_TEMP_ADC_3, temp_hotend[3].update());
+  TERN_(HAS_TEMP_ADC_4, temp_hotend[4].update());
+  TERN_(HAS_TEMP_ADC_5, temp_hotend[5].update());
+  TERN_(HAS_TEMP_ADC_6, temp_hotend[6].update());
+  TERN_(HAS_TEMP_ADC_7, temp_hotend[7].update());
+  TERN_(HAS_HEATED_BED, temp_bed.update());
+  TERN_(HAS_TEMP_CHAMBER, temp_chamber.update());
+  TERN_(HAS_TEMP_PROBE, temp_probe.update());
 
-  #if HAS_TEMP_CHAMBER
-    temp_chamber.update();
-  #endif
-
-  #if HAS_TEMP_PROBE
-    temp_probe.update();
-  #endif
-
-  #if HAS_JOY_ADC_X
-    joystick.x.update();
-  #endif
-  #if HAS_JOY_ADC_Y
-    joystick.y.update();
-  #endif
-  #if HAS_JOY_ADC_Z
-    joystick.z.update();
-  #endif
+  TERN_(HAS_JOY_ADC_X, joystick.x.update());
+  TERN_(HAS_JOY_ADC_Y, joystick.y.update());
+  TERN_(HAS_JOY_ADC_Z, joystick.z.update());
 
   raw_temps_ready = true;
 }
 
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!raw_temps_ready) update_raw_temperatures();
 
   // Filament Sensor - can be read any time since IIR filtering is used
-  #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    filwidth.reading_ready();
-  #endif
+  TERN_(FILAMENT_WIDTH_SENSOR, filwidth.reading_ready());
 
   #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      temp_hotend[1].reset();
-    #endif
+    TERN_(TEMP_SENSOR_1_AS_REDUNDANT, temp_hotend[1].reset());
   #endif
 
-  #if HAS_HEATED_BED
-    temp_bed.reset();
-  #endif
+  TERN_(HAS_HEATED_BED, temp_bed.reset());
+  TERN_(HAS_TEMP_CHAMBER, temp_chamber.reset());
+  TERN_(HAS_TEMP_PROBE, temp_probe.reset());
 
-  #if HAS_TEMP_CHAMBER
-    temp_chamber.reset();
-  #endif
-
-  #if HAS_TEMP_PROBE
-    temp_probe.reset();
-  #endif
-
-  #if HAS_JOY_ADC_X
-    joystick.x.reset();
-  #endif
-  #if HAS_JOY_ADC_Y
-    joystick.y.reset();
-  #endif
-  #if HAS_JOY_ADC_Z
-    joystick.z.reset();
-  #endif
+  TERN_(HAS_JOY_ADC_X, joystick.x.reset());
+  TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
+  TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 
   #if HAS_HOTEND
 
     static constexpr int8_t temp_dir[] = {
       #if ENABLED(HEATER_0_USES_MAX6675)
         0
       #else
         TEMPDIR(0)
       #endif
       #if HAS_MULTI_HOTEND
@@ -2405,23 +2257,21 @@ void Temperature::readings_ready() {
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif // HOTENDS > 2
       #endif // HAS_MULTI_HOTEND
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
         const bool heater_on = (temp_hotend[e].target > 0
-          #if ENABLED(PIDTEMP)
-            || temp_hotend[e].soft_pwm_amount > 0
-          #endif
+          || TERN0(PIDTEMP, temp_hotend[e].soft_pwm_amount) > 0
         );
         if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
         if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
           #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
             if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
           #endif
               min_temp_error((heater_ind_t)e);
         }
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           else
@@ -2431,24 +2281,22 @@ void Temperature::readings_ready() {
     }
 
   #endif // HOTENDS
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<=(B))
     #else
       #define BEDCMP(A,B) ((A)>=(B))
     #endif
-    const bool bed_on = (temp_bed.target > 0)
-      #if ENABLED(PIDTEMPBED)
-        || (temp_bed.soft_pwm_amount > 0)
-      #endif
+    const bool bed_on = temp_bed.target > 0
+      || TERN0(PIDTEMPBED, temp_bed.soft_pwm_amount) > 0
     ;
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
   #endif
 
   #if HAS_HEATED_CHAMBER
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<=(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>=(B))
@@ -2767,24 +2615,22 @@ void Temperature::tick() {
 
     // increment slow_pwm_count only every 64th pwm_count,
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
       #if HAS_HOTEND
         HOTEND_LOOP() soft_pwm_hotend[e].dec();
       #endif
-      #if HAS_HEATED_BED
-        soft_pwm_bed.dec();
-      #endif
-    } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
+      TERN_(HAS_HEATED_BED, soft_pwm_bed.dec());
+    }
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
 
   /**
@@ -3211,23 +3057,21 @@ void Temperature::tick() {
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         ui.reset_status();
-        #if ENABLED(PRINTER_EVENT_LEDS)
-          printerEventLEDs.onHeatingDone();
-        #endif
+        TERN_(PRINTER_EVENT_LEDS, printerEventLEDs.onHeatingDone());
       }
 
       return wait_for_heatup;
     }
 
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED

commit 000ec9fc139413c7702e8e295a29a21f6a6226e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 20 09:43:15 2020 -0500

    Ensure language.h include order
    
    See #17604

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0ca7535ec7..c72eb6f371 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -23,21 +23,20 @@
 /**
  * temperature.cpp - temperature control
  */
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
-#include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 650cda51f3..0ca7535ec7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -133,21 +133,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 #endif
 #define _E_PSTR(h,N) ((HOTENDS) > N && (h) == N) ? PSTR(LCD_STR_E##N) :
 #define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
-#if HOTENDS
+#if HAS_HOTEND
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
@@ -291,21 +291,21 @@ const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
 
 volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) < (HEATER_##N##_RAW_HI_TEMP) ? 1 : -1)
 
-#if HOTENDS
+#if HAS_HOTEND
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
   constexpr temp_range_t sensor_heater_0 { HEATER_0_RAW_LO_TEMP, HEATER_0_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_1 { HEATER_1_RAW_LO_TEMP, HEATER_1_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_2 { HEATER_2_RAW_LO_TEMP, HEATER_2_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_3 { HEATER_3_RAW_LO_TEMP, HEATER_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { HEATER_4_RAW_LO_TEMP, HEATER_4_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_6 { HEATER_6_RAW_LO_TEMP, HEATER_6_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_7 { HEATER_7_RAW_LO_TEMP, HEATER_7_RAW_HI_TEMP, 0, 16383 };
 
@@ -648,38 +648,38 @@ volatile bool Temperature::raw_temps_ready = false;
 int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     default:
       return (0
-        #if HOTENDS
+        #if HAS_HOTEND
           + temp_hotend[heater_id].soft_pwm_amount
         #endif
       );
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
     #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
         RREPEAT_S(1, HOTENDS, _NEXT_FAN)
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
         , REPEAT(HOTENDS,_CFAN) (HOTENDS)
       #endif
     };
 
     uint8_t fanState = 0;
@@ -814,21 +814,21 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 }
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
-#if HOTENDS
+#if HAS_HOTEND
   #if ENABLED(PID_DEBUG)
     extern bool pid_debug_flag;
   #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
@@ -1029,21 +1029,21 @@ void Temperature::manage_heater() {
     if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
     if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   millis_t ms = millis();
 
-  #if HOTENDS
+  #if HAS_HOTEND
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp)
           _temp_error((heater_ind_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
       #endif
 
       #if HEATER_IDLE_HANDLER
         hotend_idle[e].update(ms);
       #endif
@@ -1377,21 +1377,21 @@ void Temperature::manage_heater() {
     //    clocks_total += clocks;
     //    calls++;
     //  }
     //#endif
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
-#if HOTENDS
+#if HAS_HOTEND
   // Derived from RepRap FiveD extruder::getTemperature()
   // For hot end temperature measurement.
   float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       if (e > HOTENDS)
     #else
       if (e >= HOTENDS)
     #endif
       {
         SERIAL_ERROR_START();
@@ -1568,21 +1568,21 @@ void Temperature::manage_heater() {
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
     temp_hotend[1].raw = READ_MAX6675(1);
   #endif
-  #if HOTENDS
+  #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
   #if HAS_HEATED_BED
     temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
     temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if HAS_TEMP_PROBE
     temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw);
@@ -1829,40 +1829,40 @@ void Temperature::init() {
   #if HAS_AUTO_FAN_7 && !(_EFANOVERLAP(7,0) || _EFANOVERLAP(7,1) || _EFANOVERLAP(7,2) || _EFANOVERLAP(7,3) || _EFANOVERLAP(7,4) || _EFANOVERLAP(7,5) || _EFANOVERLAP(7,6))
     INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
-  #if HOTENDS
+  #if HAS_HOTEND
 
     #define _TEMP_MIN_E(NR) do{ \
       temp_range[NR].mintemp = HEATER_ ##NR## _MINTEMP; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < HEATER_ ##NR## _MINTEMP) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       temp_range[NR].maxtemp = HEATER_ ##NR## _MAXTEMP; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > HEATER_ ##NR## _MAXTEMP) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
     #ifdef HEATER_0_MINTEMP
       _TEMP_MIN_E(0);
     #endif
     #ifdef HEATER_0_MAXTEMP
       _TEMP_MAX_E(0);
     #endif
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       #ifdef HEATER_1_MINTEMP
         _TEMP_MIN_E(1);
       #endif
       #ifdef HEATER_1_MAXTEMP
         _TEMP_MAX_E(1);
       #endif
       #if HOTENDS > 2
         #ifdef HEATER_2_MINTEMP
           _TEMP_MIN_E(2);
         #endif
@@ -1903,21 +1903,21 @@ void Temperature::init() {
                   #endif
                   #ifdef HEATER_7_MAXTEMP
                     _TEMP_MAX_E(7);
                   #endif
                 #endif // HOTENDS > 7
               #endif // HOTENDS > 6
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
+    #endif // HAS_MULTI_HOTEND
 
   #endif // HOTENDS
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
     #ifdef BED_MAXTEMP
       while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
@@ -2063,21 +2063,21 @@ void Temperature::init() {
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif
 
-  #if HOTENDS
+  #if HAS_HOTEND
     HOTEND_LOOP() setTargetHotend(0, e);
   #endif
 
   #if HAS_HEATED_BED
     setTargetBed(0);
   #endif
 
   #if HAS_HEATED_CHAMBER
     setTargetChamber(0);
   #endif
@@ -2106,21 +2106,21 @@ void Temperature::disable_all_heaters() {
   #if HAS_HEATED_CHAMBER
     temp_chamber.target = 0;
     temp_chamber.soft_pwm_amount = 0;
     WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
   bool Temperature::over_autostart_threshold() {
-    #if HOTENDS
+    #if HAS_HOTEND
       HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;
     #endif
     #if HAS_HEATED_BED
       if (degTargetBed() > BED_MINTEMP) return true;
     #endif
     #if HAS_HEATED_CHAMBER
       if (degTargetChamber() > CHAMBER_MINTEMP) return true;
     #endif
     return false;
   }
@@ -2351,21 +2351,21 @@ void Temperature::update_raw_temperatures() {
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!raw_temps_ready) update_raw_temperatures();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filwidth.reading_ready();
   #endif
 
-  #if HOTENDS
+  #if HAS_HOTEND
     HOTEND_LOOP() temp_hotend[e].reset();
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       temp_hotend[1].reset();
     #endif
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.reset();
   #endif
 
@@ -2380,39 +2380,39 @@ void Temperature::readings_ready() {
   #if HAS_JOY_ADC_X
     joystick.x.reset();
   #endif
   #if HAS_JOY_ADC_Y
     joystick.y.reset();
   #endif
   #if HAS_JOY_ADC_Z
     joystick.z.reset();
   #endif
 
-  #if HOTENDS
+  #if HAS_HOTEND
 
     static constexpr int8_t temp_dir[] = {
       #if ENABLED(HEATER_0_USES_MAX6675)
         0
       #else
         TEMPDIR(0)
       #endif
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         #define _TEMPDIR(N) , TEMPDIR(N)
         #if ENABLED(HEATER_1_USES_MAX6675)
           , 0
         #else
           _TEMPDIR(1)
         #endif
         #if HOTENDS > 2
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
+      #endif // HAS_MULTI_HOTEND
     };
 
     LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
         const bool heater_on = (temp_hotend[e].target > 0
           #if ENABLED(PIDTEMP)
             || temp_hotend[e].soft_pwm_amount > 0
           #endif
@@ -2524,21 +2524,21 @@ void Temperature::tick() {
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
 
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;
   #endif
 
-  #if HOTENDS
+  #if HAS_HOTEND
     static SoftPWM soft_pwm_hotend[HOTENDS];
   #endif
 
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
@@ -2558,21 +2558,21 @@ void Temperature::tick() {
         WRITE_HEATER_##N(on);                               \
       }while(0)
     #endif
 
     /**
      * Standard heater PWM modulation
      */
     if (pwm_count_tmp >= 127) {
       pwm_count_tmp -= 127;
 
-      #if HOTENDS
+      #if HAS_HOTEND
         #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N]);
         REPEAT(HOTENDS, _PWM_MOD_E);
       #endif
 
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
@@ -2605,21 +2605,21 @@ void Temperature::tick() {
         #if HAS_FAN6
           _FAN_PWM(6);
         #endif
         #if HAS_FAN7
           _FAN_PWM(7);
         #endif
       #endif
     }
     else {
       #define _PWM_LOW(N,S) do{ if (S.count <= pwm_count_tmp) WRITE_HEATER_##N(LOW); }while(0)
-      #if HOTENDS
+      #if HAS_HOTEND
         #define _PWM_LOW_E(N) _PWM_LOW(N, soft_pwm_hotend[N]);
         REPEAT(HOTENDS, _PWM_LOW_E);
       #endif
 
       #if HAS_HEATED_BED
         _PWM_LOW(BED, soft_pwm_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_LOW(CHAMBER, soft_pwm_chamber);
@@ -2671,32 +2671,32 @@ void Temperature::tick() {
      * For relay-driven heaters
      */
     #define _SLOW_SET(NR,PWM,V) do{ if (PWM.ready(V)) WRITE_HEATER_##NR(V); }while(0)
     #define _SLOW_PWM(NR,PWM,SRC) do{ PWM.count = SRC.soft_pwm_amount; _SLOW_SET(NR,PWM,(PWM.count > 0)); }while(0)
     #define _PWM_OFF(NR,PWM) do{ if (PWM.count < slow_pwm_count) _SLOW_SET(NR,PWM,0); }while(0)
 
     static uint8_t slow_pwm_count = 0;
 
     if (slow_pwm_count == 0) {
 
-      #if HOTENDS
+      #if HAS_HOTEND
         #define _SLOW_PWM_E(N) _SLOW_PWM(N, soft_pwm_hotend[N], temp_hotend[N]);
         REPEAT(HOTENDS, _SLOW_PWM_E);
       #endif
 
       #if HAS_HEATED_BED
         _SLOW_PWM(BED, soft_pwm_bed, temp_bed);
       #endif
 
     } // slow_pwm_count == 0
 
-    #if HOTENDS
+    #if HAS_HOTEND
       #define _PWM_OFF_E(N) _PWM_OFF(N, soft_pwm_hotend[N]);
       REPEAT(HOTENDS, _PWM_OFF_E);
     #endif
 
     #if HAS_HEATED_BED
       _PWM_OFF(BED, soft_pwm_bed);
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
@@ -2765,21 +2765,21 @@ void Temperature::tick() {
     // 4:                /  8 = 122.0703 Hz
     // 5:                /  4 = 244.1406 Hz
     pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
 
     // increment slow_pwm_count only every 64th pwm_count,
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
-      #if HOTENDS
+      #if HAS_HOTEND
         HOTEND_LOOP() soft_pwm_hotend[e].dec();
       #endif
       #if HAS_HEATED_BED
         soft_pwm_bed.dec();
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
 
   //
@@ -2983,21 +2983,21 @@ void Temperature::tick() {
         #endif
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           case H_REDUNDANT: k = 'R'; break;
         #endif
       #elif HAS_HEATED_BED
         default: k = 'B'; break;
       #endif
     }
     SERIAL_CHAR(' ');
     SERIAL_CHAR(k);
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     SERIAL_CHAR(':');
     SERIAL_ECHO(c);
     SERIAL_ECHOPAIR(" /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_ECHOPAIR(" (", r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
@@ -3045,36 +3045,36 @@ void Temperature::tick() {
       );
     #endif // HAS_TEMP_CHAMBER
     #if HAS_TEMP_PROBE
       print_heater_state(degProbe(), 0
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawProbeTemp()
         #endif
         , H_PROBE
       );
     #endif // HAS_TEMP_PROBE
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , (heater_ind_t)e
       );
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_ind_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
       SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
     #endif
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower((heater_ind_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
@@ -3089,21 +3089,21 @@ void Temperature::tick() {
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if HOTENDS && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
-        #if HOTENDS > 1
+        #if HAS_MULTI_HOTEND
           PSTR("E%c " S_FMT), '1' + e
         #else
           PSTR("E " S_FMT)
         #endif
         , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );
     }
   #endif
 
   #if HAS_TEMP_HOTEND

commit 07c9dc414219af67ebf016f1e2f1b4e683c4a3b1
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 11 11:03:04 2020 -0500

    Make pid_debug_flag match declaration in M303.cpp
    
    Get it right this time!

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 899cd2dd76..650cda51f3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -816,21 +816,21 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HOTENDS
   #if ENABLED(PID_DEBUG)
-    extern bool PID_debug_flag;
+    extern bool pid_debug_flag;
   #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
@@ -899,21 +899,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
-        if (ee == active_extruder && PID_debug_flag) {
+        if (ee == active_extruder && pid_debug_flag) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output);
           #if DISABLED(PID_OPENLOOP)
             SERIAL_ECHOPAIR( STR_PID_DEBUG_PTERM, work_pid[ee].Kp, STR_PID_DEBUG_ITERM, work_pid[ee].Ki, STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
           #endif
           SERIAL_EOL();

commit a65198882f04622546ebf73903f7618f1eccd92a
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 11 10:25:19 2020 -0500

    Make declaration of PID_debug_flag match M303.cpp

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f9f311635e..899cd2dd76 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -816,21 +816,21 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HOTENDS
   #if ENABLED(PID_DEBUG)
-    extern bool PID_Debug_Flag;
+    extern bool PID_debug_flag;
   #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
@@ -899,21 +899,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
-        if (ee == active_extruder && PID_Debug_Flag) {
+        if (ee == active_extruder && PID_debug_flag) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output);
           #if DISABLED(PID_OPENLOOP)
             SERIAL_ECHOPAIR( STR_PID_DEBUG_PTERM, work_pid[ee].Kp, STR_PID_DEBUG_ITERM, work_pid[ee].Ki, STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
           #endif
           SERIAL_EOL();

commit 0e06aaa2bc5c58e018fcdd466ae8836ac0c38e13
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 3 19:49:45 2020 -0500

    Add millis helper macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index af2f1a10e8..f9f311635e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -392,21 +392,21 @@ volatile bool Temperature::raw_temps_ready = false;
       #if HAS_TP_BED && BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
         #define GTV(B,H) (isbed ? (B) : (H))
       #elif HAS_TP_BED
         #define GTV(B,H) (B)
       #else
         #define GTV(B,H) (H)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
-      millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
+      millis_t temp_change_ms = next_temp_ms + SEC_TO_MS(watch_temp_period);
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
@@ -539,21 +539,21 @@ volatile bool Temperature::raw_temps_ready = false;
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_BED || WATCH_HOTENDS
           if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS)) {
             if (!heated) {                                            // If not yet reached target...
               if (current_temp > next_watch_temp) {                   // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
-                temp_change_ms = ms + watch_temp_period * 1000UL;     // - move the expiration timer up
+                temp_change_ms = ms + SEC_TO_MS(watch_temp_period);     // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _temp_error(heater, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
               _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
@@ -2044,21 +2044,21 @@ void Temperature::init() {
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.5f))
               fan_speed_scaler[fan_index] = 64;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else
               fan_speed_scaler[fan_index] = 0;
           }
         #endif
 
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
-          sm.timer = millis() + period_seconds * 1000UL;
+          sm.timer = millis() + SEC_TO_MS(period_seconds);
           break;
         }
         else if (PENDING(millis(), sm.timer)) break;
         sm.state = TRRunaway;
 
       case TRRunaway:
         _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
@@ -3117,21 +3117,21 @@ void Temperature::tick() {
 
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
-        #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
+        #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
@@ -3153,21 +3153,21 @@ void Temperature::tick() {
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { // Print temp & remaining time every 1s while waiting
           next_temp_ms = now + 1000UL;
           print_heater_states(target_extruder);
           #if TEMP_RESIDENCY_TIME > 0
             SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
-              SERIAL_ECHO(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+              SERIAL_ECHO(long((SEC_TO_MS(TEMP_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degHotend(target_extruder);
@@ -3178,21 +3178,21 @@ void Temperature::tick() {
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_WINDOW) {
               residency_start_ms = now;
-              if (first_loop) residency_start_ms += (TEMP_RESIDENCY_TIME) * 1000UL;
+              if (first_loop) residency_start_ms += SEC_TO_MS(TEMP_RESIDENCY_TIME);
             }
           }
           else if (temp_diff > TEMP_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
 
         #endif
@@ -3240,21 +3240,21 @@ void Temperature::tick() {
 
     bool Temperature::wait_for_bed(const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
-        #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
+        #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_BED_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       float target_temp = -1, old_temp = 9999;
       bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
@@ -3277,21 +3277,21 @@ void Temperature::tick() {
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_BED_RESIDENCY_TIME > 0
             SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
-              SERIAL_ECHO(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+              SERIAL_ECHO(long((SEC_TO_MS(TEMP_BED_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degBed();
@@ -3302,21 +3302,21 @@ void Temperature::tick() {
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_BED_WINDOW) {
               residency_start_ms = now;
-              if (first_loop) residency_start_ms += (TEMP_BED_RESIDENCY_TIME) * 1000UL;
+              if (first_loop) residency_start_ms += SEC_TO_MS(TEMP_BED_RESIDENCY_TIME);
             }
           }
           else if (temp_diff > TEMP_BED_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
         #endif // TEMP_BED_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M190 R0
@@ -3366,21 +3366,21 @@ void Temperature::tick() {
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
       #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
     #endif
 
     bool Temperature::wait_for_chamber(const bool no_wait_for_cooling/*=true*/) {
       #if TEMP_CHAMBER_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         bool first_loop = true;
         // Loop until the temperature has stabilized
-        #define TEMP_CHAMBER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL))
+        #define TEMP_CHAMBER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME)))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CHAMBER_CONDITIONS (wants_to_cool ? isCoolingChamber() : isHeatingChamber())
       #endif
 
       float target_temp = -1, old_temp = 9999;
       bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
@@ -3398,41 +3398,41 @@ void Temperature::tick() {
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_CHAMBER_RESIDENCY_TIME > 0
             SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
-              SERIAL_ECHO(long((((TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+              SERIAL_ECHO(long((SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degChamber();
 
         #if TEMP_CHAMBER_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_CHAMBER_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_CHAMBER_WINDOW) {
               residency_start_ms = now;
-              if (first_loop) residency_start_ms += (TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL;
+              if (first_loop) residency_start_ms += SEC_TO_MS(TEMP_CHAMBER_RESIDENCY_TIME);
             }
           }
           else if (temp_diff > TEMP_CHAMBER_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
           first_loop = false;
         #endif // TEMP_CHAMBER_RESIDENCY_TIME > 0
 

commit 62e8c2dd871f62d80122fe919d065ee3a3e5d520
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 23:50:08 2020 -0500

    Fix up 'system' includes

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 42c79fdd19..af2f1a10e8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -30,21 +30,21 @@
 #include "../MarlinCore.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
-  #include "Adafruit_MAX31865.h"
+  #include <Adafruit_MAX31865.h>
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN   MOSI_PIN        //            63
   #endif
   #ifndef MAX31865_MISO_PIN
     #define MAX31865_MISO_PIN   MAX6675_DO_PIN  //            42
   #endif
   #ifndef MAX31865_SCK_PIN

commit 514afddeb4b3a7ede9ff481504aae69219a95f68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 18:53:58 2020 -0500

    Minor code cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4018c7586c..42c79fdd19 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -535,36 +535,28 @@ volatile bool Temperature::raw_temps_ready = false;
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_BED || WATCH_HOTENDS
-          if (
-            #if WATCH_BED && WATCH_HOTENDS
-              true
-            #elif WATCH_HOTENDS
-              !isbed
-            #else
-              isbed
-            #endif
-          ) {
-            if (!heated) {                                          // If not yet reached target...
-              if (current_temp > next_watch_temp) {                      // Over the watch temp?
-                next_watch_temp = current_temp + watch_temp_increase;    // - set the next temp to watch for
-                temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
-                if (current_temp > watch_temp_target) heated = true;     // - Flag if target temperature reached
+          if (BOTH(WATCH_BED, WATCH_HOTENDS) || isbed == DISABLED(WATCH_HOTENDS)) {
+            if (!heated) {                                            // If not yet reached target...
+              if (current_temp > next_watch_temp) {                   // Over the watch temp?
+                next_watch_temp = current_temp + watch_temp_increase; // - set the next temp to watch for
+                temp_change_ms = ms + watch_temp_period * 1000UL;     // - move the expiration timer up
+                if (current_temp > watch_temp_target) heated = true;  // - Flag if target temperature reached
               }
-              else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
+              else if (ELAPSED(ms, temp_change_ms))                   // Watch timer expired
                 _temp_error(heater, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
               _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE

commit d83ad6f321af6511d35e0396776f557195fcba9f
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Tue Mar 31 13:22:04 2020 -0600

    Improve / fix FTDI EVE Touch UI (#17338)
    
    - Fix timeout and debugging string
    - Fix check for whether `LCD_TIMEOUT_TO_STATUS` is valid
    - Fix incorrect debugging message
    - Make capitalization of callbacks consistent.
    - Allow Touch UI to use hardware SPI on Einsy boards
    - Move print stats to About Printer page.
    - More generic about screen with GPL license.
    - Add missing handler for power loss event
    - Less code duplication on status screen and main/advanced menu; more legible
    - Reorganize advanced and main menu to add more features
    - Hide home Z button when using Z_SAFE_HOMING
    - Fix compilation errors when certain features enabled
    - Fix missing labels in UI
    - Improve color scheme
    - Add new preheat menus
    - Fix incorrect rendering of Marlin logo on boot
    - Add Level X Axis and Auto calibrate buttons

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4e49fcfa24..4018c7586c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -404,21 +404,21 @@ volatile bool Temperature::raw_temps_ready = false;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
       SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::OnPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
+        ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
       #endif
       return;
     }
 
     SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
@@ -520,21 +520,21 @@ volatile bool Temperature::raw_temps_ready = false;
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::OnPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
+          ExtUI::onPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
         #endif
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
@@ -565,21 +565,21 @@ volatile bool Temperature::raw_temps_ready = false;
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::OnPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT);
+          ExtUI::onPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT);
         #endif
         SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), NUL_STR);
@@ -616,35 +616,35 @@ volatile bool Temperature::raw_temps_ready = false;
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onPidTuningDone(color);
         #endif
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::OnPidTuning(ExtUI::result_t::PID_DONE);
+          ExtUI::onPidTuning(ExtUI::result_t::PID_DONE);
         #endif
 
         goto EXIT_M303;
       }
       ui.update();
     }
 
     disable_all_heaters();
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       printerEventLEDs.onPidTuningDone(color);
     #endif
     #if ENABLED(EXTENSIBLE_UI)
-      ExtUI::OnPidTuning(ExtUI::result_t::PID_DONE);
+      ExtUI::onPidTuning(ExtUI::result_t::PID_DONE);
     #endif
 
     EXIT_M303:
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         adaptive_fan_slowing = true;
       #endif
       return;
   }
 
 #endif // HAS_PID_HEATING

commit 1986e1cdf851579958dc1fb245486cb2099582dc
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Mar 24 19:38:09 2020 -0500

    Allow PID_DEBUG to be turned on and off (#17284)
    
    M303 D will now toggle activation of PID_DEBUG output.   This allows the debug capability to be built into the firmware, but turned on and off as needed.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f16a3af046..4e49fcfa24 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -823,20 +823,23 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HOTENDS
+  #if ENABLED(PID_DEBUG)
+    extern bool PID_Debug_Flag;
+  #endif
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
@@ -904,38 +907,29 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
-        if (ee == active_extruder) {
+        if (ee == active_extruder && PID_Debug_Flag) {
           SERIAL_ECHO_START();
-          SERIAL_ECHOPAIR(
-            STR_PID_DEBUG, ee,
-            STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
-            STR_PID_DEBUG_OUTPUT, pid_output
-          );
+          SERIAL_ECHOPAIR(STR_PID_DEBUG, ee, STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius, STR_PID_DEBUG_OUTPUT, pid_output);
           #if DISABLED(PID_OPENLOOP)
-          {
-            SERIAL_ECHOPAIR(
-              STR_PID_DEBUG_PTERM, work_pid[ee].Kp,
-              STR_PID_DEBUG_ITERM, work_pid[ee].Ki,
-              STR_PID_DEBUG_DTERM, work_pid[ee].Kd
+            SERIAL_ECHOPAIR( STR_PID_DEBUG_PTERM, work_pid[ee].Kp, STR_PID_DEBUG_ITERM, work_pid[ee].Ki, STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
-          }
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
       #if HEATER_IDLE_HANDLER
         const bool is_idling = hotend_idle[ee].timed_out;
       #else

commit 095a1123c191db46040688daba4b4505d4615d6e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 14 18:47:44 2020 -0500

    Add a global machine state

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d0b1ddf0a3..f16a3af046 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -758,21 +758,21 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(PGM_P const lcd_msg, const heater_ind_t heater) {
-  Running = false;
+  marlin_state = MF_KILLED;
   #if USE_BEEPER
     for (uint8_t i = 20; i--;) {
       WRITE(BEEPER_PIN, HIGH); delay(25);
       WRITE(BEEPER_PIN, LOW); delay(80);
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
   kill(lcd_msg, HEATER_PSTR(heater));
 }
 
@@ -1996,21 +1996,21 @@ void Temperature::init() {
   #if ENABLED(THERMAL_PROTECTION_CHAMBER)
     Temperature::tr_state_machine_t Temperature::tr_state_machine_chamber; // = { TRInactive, 0 };
   #endif
 
   void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
       SERIAL_ECHO_START();
-      SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
+      SERIAL_ECHOPGM("Thermal Runaway Running. Heater ID: ");
       if (heater_id == H_CHAMBER) SERIAL_ECHOPGM("chamber");
       if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
       SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
       if (heater_id >= 0)
         SERIAL_ECHOPAIR(" ;  Idle Timeout:", hotend_idle[heater_id].timed_out);
       else
         SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
       SERIAL_EOL();
     //*/
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e15d42db6a..d0b1ddf0a3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -701,21 +701,21 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                  \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)          \
         analogWrite(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                               \
         WRITE(P##_AUTO_FAN_PIN, D);                      \
     }while(0)
 
     uint8_t fanDone = 0;
-    for (uint8_t f = 0; f < COUNT(fanBit); f++) {
+    LOOP_L_N(f, COUNT(fanBit)) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
         #if ENABLED(AUTO_POWER_CHAMBER_FAN)
           case CHAMBER_FAN_INDEX:
             chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
             break;
         #endif
         default:
@@ -2415,21 +2415,21 @@ void Temperature::readings_ready() {
           , 0
         #else
           _TEMPDIR(1)
         #endif
         #if HOTENDS > 2
           REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
     };
 
-    for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
+    LOOP_L_N(e, COUNT(temp_dir)) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
         const bool heater_on = (temp_hotend[e].target > 0
           #if ENABLED(PIDTEMP)
             || temp_hotend[e].soft_pwm_amount > 0
           #endif
         );
         if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
         if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c6caa0a2c9..e15d42db6a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -26,21 +26,21 @@
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 #if ENABLED(EXTENSIBLE_UI)
-  #include "../lcd/extensible_ui/ui_api.h"
+  #include "../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include "Adafruit_MAX31865.h"
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN   MOSI_PIN        //            63
   #endif
@@ -73,21 +73,21 @@
   #include "../feature/babystep.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
-  #include "../feature/emergency_parser.h"
+  #include "../feature/e_parser.h"
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
 

commit b579f5dc998b07c731e44041a0602fea39e15981
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 7 22:34:33 2020 -0600

    Move 'last_pause_state' closer to usage

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 75f25f7f7e..c6caa0a2c9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1023,24 +1023,20 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
     if (!inited) return watchdog_refresh();
   #endif
 
-  #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
-    static bool last_pause_state;
-  #endif
-
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
   #endif
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
@@ -1118,30 +1114,35 @@ void Temperature::manage_heater() {
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
+    #define PAUSE_CHANGE_REQD BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+    #if PAUSE_CHANGE_REQD
+      static bool last_pause_state;
+    #endif
+
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
-          #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+          #if PAUSE_CHANGE_REQD
             && paused == last_pause_state
           #endif
         ) break;
         next_bed_check_ms = ms + BED_CHECK_INTERVAL;
-        #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+        #if PAUSE_CHANGE_REQD
           last_pause_state = paused;
         #endif
       #endif
 
       #if HEATER_IDLE_HANDLER
         bed_idle.update(ms);
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
         thermal_runaway_protection(tr_state_machine_bed, temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);

commit 7709261ea9f73d60006b5ab1ae488086908d0e79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 4 12:50:43 2020 -0600

    Move shared code to wait_for_bed_heating

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 73a91049da..75f25f7f7e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3354,20 +3354,29 @@ void Temperature::tick() {
           first_loop = false;
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
       return wait_for_heatup;
     }
 
+    void Temperature::wait_for_bed_heating() {
+      if (isHeatingBed()) {
+        SERIAL_ECHOLNPGM("Wait for bed heating...");
+        LCD_MESSAGEPGM(MSG_BED_HEATING);
+        wait_for_bed();
+        ui.reset_status();
+      }
+    }
+
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
       #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
       #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
     #endif

commit cc822bf70fd4683a00fcf5c3ea5b5e6a62a0d10b
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Mar 1 19:19:02 2020 -0800

    Fix some 8 extruders issues, GTR build (#17043)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c9547b3e9f..73a91049da 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -94,25 +94,27 @@
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
+    static const void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
-    static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
-    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
+    #define NEXT_TEMPTABLE(N) ,HEATER_##N##_TEMPTABLE
+    #define NEXT_TEMPTABLE_LEN(N) ,HEATER_##N##_TEMPTABLE_LEN
+    static const void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE));
+    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
   #endif
 #endif
 
 Temperature thermalManager;
 
 const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
            str_t_heating_failed[] PROGMEM = STR_T_HEATING_FAILED;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code

commit 39c34e4992c274943b35918d6ed9d66508bbb88a
Author: ManuelMcLure <manuel@mclure.org>
Date:   Fri Feb 28 21:28:17 2020 -0800

    Use ADC resolution in AD595/8495 calculation (#17018)
    
    Fixes thermocouple reading on LP1768 (which uses 12-bit resolution).

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 20a08240cd..c9547b3e9f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1225,22 +1225,22 @@ void Temperature::manage_heater() {
     }
 
     // TODO: Implement true PID pwm
     //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
 
   UNUSED(ms);
 }
 
-#define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
-#define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
+#define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
+#define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
   uint8_t l = 0, r = LEN, m;                                           \
   for (;;) {                                                           \
     m = (l + r) >> 1;                                                  \
     if (!m) return short(pgm_read_word(&TBL[0][1]));                   \

commit 4f557235279c0db03bdf6f0d35256d163b7d412a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 07:47:40 2020 -0600

    RUMBA has 3 E plugs

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7cee5fb1ea..20a08240cd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1653,24 +1653,23 @@ void Temperature::init() {
     max31865.begin(MAX31865_2WIRE); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
   #endif
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
+    // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     #define _AD(N) ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495)
-    #if  _AD(0) || _AD(1) || _AD(2) /* RUMBA has 3 E plugs // || _AD(3) || _AD(4) || _AD(5) || _AD(6) || _AD(7) */ \
-      || _AD(BED) || _AD(CHAMBER)
-      // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
+    #if  _AD(0) || _AD(1) || _AD(2) || _AD(BED) || _AD(CHAMBER)
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index de64c28c85..7cee5fb1ea 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -104,20 +104,23 @@
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
   #endif
 #endif
 
 Temperature thermalManager;
 
+const char str_t_thermal_runaway[] PROGMEM = STR_T_THERMAL_RUNAWAY,
+           str_t_heating_failed[] PROGMEM = STR_T_HEATING_FAILED;
+
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
   #define _BED_PSTR(h) (h) == H_BED ? GET_TEXT(MSG_BED) :
 #else
   #define _BED_PSTR(h)
 #endif
@@ -397,28 +400,28 @@ volatile bool Temperature::raw_temps_ready = false;
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
-      SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
+      SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
       #if ENABLED(EXTENSIBLE_UI)
         ExtUI::OnPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
       #endif
       return;
     }
 
-    SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
+    SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
@@ -465,41 +468,41 @@ volatile bool Temperature::raw_temps_ready = false;
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               LIMIT(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
-              SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, minT, MSG_T_MAX, maxT);
+              SERIAL_ECHOPAIR(STR_BIAS, bias, STR_D_COLON, d, STR_T_MIN, minT, STR_T_MAX, maxT);
               if (cycles > 2) {
                 const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
                             Tu = float(t_low + t_high) * 0.001f,
                             pf = isbed ? 0.2f : 0.6f,
                             df = isbed ? 1.0f / 3.0f : 1.0f / 8.0f;
 
-                SERIAL_ECHOPAIR(MSG_KU, Ku, MSG_TU, Tu);
+                SERIAL_ECHOPAIR(STR_KU, Ku, STR_TU, Tu);
                 if (isbed) { // Do not remove this otherwise PID autotune won't work right for the bed!
                   tune_pid.Kp = Ku * 0.2f;
                   tune_pid.Ki = 2 * tune_pid.Kp / Tu;
                   tune_pid.Kd = tune_pid.Kp * Tu / 3;
                   SERIAL_ECHOLNPGM("\n" " No overshoot"); // Works far better for the bed. Classic and some have bad ringing.
-                  SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
+                  SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
                 }
                 else {
                   tune_pid.Kp = Ku * pf;
                   tune_pid.Kd = tune_pid.Kp * Tu * df;
                   tune_pid.Ki = 2 * tune_pid.Kp / Tu;
-                  SERIAL_ECHOLNPGM("\n" MSG_CLASSIC_PID);
-                  SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
+                  SERIAL_ECHOLNPGM("\n" STR_CLASSIC_PID);
+                  SERIAL_ECHOLNPAIR(STR_KP, tune_pid.Kp, STR_KI, tune_pid.Ki, STR_KD, tune_pid.Kd);
                 }
 
                 /**
                 tune_pid.Kp = 0.33 * Ku;
                 tune_pid.Ki = tune_pid.Kp / Tu;
                 tune_pid.Kd = tune_pid.Kp * Tu / 3;
                 SERIAL_ECHOLNPGM(" Some overshoot");
                 SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
                 tune_pid.Kp = 0.2 * Ku;
                 tune_pid.Ki = 2 * tune_pid.Kp / Tu;
@@ -513,21 +516,21 @@ volatile bool Temperature::raw_temps_ready = false;
             minT = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
-        SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
+        SERIAL_ECHOLNPGM(STR_PID_TEMP_TOO_HIGH);
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::OnPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
         #endif
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
@@ -546,42 +549,42 @@ volatile bool Temperature::raw_temps_ready = false;
               isbed
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current_temp > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
-                _temp_error(heater, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
+                _temp_error(heater, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
+              _temp_error(heater, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::OnPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT);
         #endif
-        SERIAL_ECHOLNPGM(MSG_PID_TIMEOUT);
+        SERIAL_ECHOLNPGM(STR_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
-        SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_FINISHED);
+        SERIAL_ECHOLNPGM(STR_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), NUL_STR);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #elif ENABLED(PIDTEMP)
           say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
@@ -775,26 +778,26 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 
   static uint8_t killed = 0;
 
   if (IsRunning()
     #if BOGUS_TEMPERATURE_GRACE_PERIOD
       && killed == 2
     #endif
   ) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
-    SERIAL_ECHOPGM(MSG_STOPPED_HEATER);
+    SERIAL_ECHOPGM(STR_STOPPED_HEATER);
     if (heater >= 0) SERIAL_ECHO((int)heater);
     #if HAS_HEATED_CHAMBER
-      else if (heater == H_CHAMBER) SERIAL_ECHOPGM(MSG_HEATER_CHAMBER);
+      else if (heater == H_CHAMBER) SERIAL_ECHOPGM(STR_HEATER_CHAMBER);
     #endif
-    else SERIAL_ECHOPGM(MSG_HEATER_BED);
+    else SERIAL_ECHOPGM(STR_HEATER_BED);
     SERIAL_EOL();
   }
 
   disable_all_heaters(); // always disable (even for bogus temp)
 
   #if BOGUS_TEMPERATURE_GRACE_PERIOD
     const millis_t ms = millis();
     static millis_t expire_ms;
     switch (killed) {
       case 0:
@@ -810,25 +813,25 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
-  _temp_error(heater, PSTR(MSG_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
+  _temp_error(heater, PSTR(STR_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
-  _temp_error(heater, PSTR(MSG_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
+  _temp_error(heater, PSTR(STR_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HOTENDS
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
@@ -902,32 +905,32 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
         if (ee == active_extruder) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(
-            MSG_PID_DEBUG, ee,
-            MSG_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
-            MSG_PID_DEBUG_OUTPUT, pid_output
+            STR_PID_DEBUG, ee,
+            STR_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
+            STR_PID_DEBUG_OUTPUT, pid_output
           );
           #if DISABLED(PID_OPENLOOP)
           {
             SERIAL_ECHOPAIR(
-              MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
-              MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
-              MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
+              STR_PID_DEBUG_PTERM, work_pid[ee].Kp,
+              STR_PID_DEBUG_ITERM, work_pid[ee].Ki,
+              STR_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
-                , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
+                , STR_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
           }
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
@@ -989,23 +992,23 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
     {
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPAIR(
         " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output,
         #if DISABLED(PID_OPENLOOP)
-          MSG_PID_DEBUG_PTERM, work_pid.Kp,
-          MSG_PID_DEBUG_ITERM, work_pid.Ki,
-          MSG_PID_DEBUG_DTERM, work_pid.Kd,
+          STR_PID_DEBUG_PTERM, work_pid.Kp,
+          STR_PID_DEBUG_ITERM, work_pid.Ki,
+          STR_PID_DEBUG_DTERM, work_pid.Kd,
         #endif
       );
     }
     #endif
 
     return pid_output;
   }
 
 #endif // PIDTEMPBED
 
@@ -1047,48 +1050,48 @@ void Temperature::manage_heater() {
     if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   millis_t ms = millis();
 
   #if HOTENDS
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp)
-          _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
+          _temp_error((heater_ind_t)e, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
       #endif
 
       #if HEATER_IDLE_HANDLER
         hotend_idle[e].update(ms);
       #endif
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
           if (degHotend(e) < watch_hotend[e].target)                            // Failed to increase enough?
-            _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
+            _temp_error((heater_ind_t)e, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
           else                                                                  // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
-          _temp_error(H_E0, PSTR(MSG_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
+          _temp_error(H_E0, PSTR(STR_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
 
     } // HOTEND_LOOP
 
   #endif // HOTENDS
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
@@ -1100,28 +1103,28 @@ void Temperature::manage_heater() {
      * Dynamically set the volumetric multiplier based
      * on the delayed Filament Width measurement.
      */
     filwidth.update_volumetric();
   #endif
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP)
-        _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
+        _temp_error(H_BED, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
-          _temp_error(H_BED, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
+          _temp_error(H_BED, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
           #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
@@ -1178,28 +1181,28 @@ void Temperature::manage_heater() {
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (degChamber() > CHAMBER_MAXTEMP)
-        _temp_error(H_CHAMBER, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
+        _temp_error(H_CHAMBER, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
-          _temp_error(H_CHAMBER, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
+          _temp_error(H_CHAMBER, str_t_heating_failed, GET_TEXT(MSG_HEATING_FAILED_LCD));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
         #if ENABLED(CHAMBER_LIMIT_SWITCHING)
@@ -1397,21 +1400,21 @@ void Temperature::manage_heater() {
   // For hot end temperature measurement.
   float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       if (e > HOTENDS)
     #else
       if (e >= HOTENDS)
     #endif
       {
         SERIAL_ERROR_START();
         SERIAL_ECHO((int)e);
-        SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
+        SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER_NUM);
         kill();
         return 0;
       }
 
     switch (e) {
       case 0:
         #if ENABLED(HEATER_0_USER_THERMISTOR)
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif ENABLED(HEATER_0_USES_MAX6675)
           return (
@@ -2060,21 +2063,21 @@ void Temperature::init() {
         #endif
 
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
           sm.timer = millis() + period_seconds * 1000UL;
           break;
         }
         else if (PENDING(millis(), sm.timer)) break;
         sm.state = TRRunaway;
 
       case TRRunaway:
-        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
+        _temp_error(heater_id, str_t_thermal_runaway, GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif

commit 4360142bd10d4750cb4e2502b43bd22be6b424f3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 15 22:37:16 2020 -0600

    Defer updated ADC

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5bed31b1a1..de64c28c85 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2791,222 +2791,168 @@ void Temperature::tick() {
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
 
   /**
-   * On each call to the ISR one sensor is Sampled and
-   * the next sensor is Prepared.
+   * One sensor is sampled on every other call of the ISR.
+   * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
-   * Sensors are read 16 (OVERSAMPLENR) times and the
-   * final reading takes the average.
+   * On each Prepare pass, ADC is started for a sensor pin.
+   * On the next pass, the ADC value is read and accumulated.
    *
-   * Extra do-nothing passes may exist when there are
-   * only a few sensors. This is set by MIN_ADC_ISR_LOOPS.
-   *
-   * The timing of this ISR gives ADCs 0.9765ms to charge up.
+   * This gives each ADC 0.9765ms to charge up.
    */
-  #define ACCUMULATE_ADC(obj) do{           \
-    if (HAL_ADC_READY())                    \
-      obj.sample(HAL_READ_ADC());           \
-    else                                    \
-      next_sensor_state = adc_sensor_state; \
+  #define ACCUMULATE_ADC(obj) do{ \
+    if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
+    else obj.sample(HAL_READ_ADC()); \
   }while(0)
 
-  #define NEXT_ENUM(A) (typeof(A))(int(A) + 1)
-  #define NEXT_ADC_STATE(N) ((N) >= SensorsReady ? StartSampling : NEXT_ENUM(N))
-
-  // Assume the machine will go on to the next state
-  ADCSensorState next_sensor_state = NEXT_ADC_STATE(adc_sensor_state);
-
-  switch (adc_sensor_state) {
-
-    default: break;
-
-    #if HAS_TEMP_ADC_0
-      case MeasureTemp_0:       ACCUMULATE_ADC(temp_hotend[0]); break;
-    #endif
-    #if HAS_HEATED_BED
-      case MeasureTemp_BED:     ACCUMULATE_ADC(temp_bed); break;
-    #endif
-    #if HAS_TEMP_CHAMBER
-      case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
-    #endif
-    #if HAS_TEMP_PROBE
-      case MeasureTemp_PROBE:   ACCUMULATE_ADC(temp_probe); break;
-    #endif
-    #if HAS_TEMP_ADC_1
-      case MeasureTemp_1:       ACCUMULATE_ADC(temp_hotend[1]); break;
-    #endif
-    #if HAS_TEMP_ADC_2
-      case MeasureTemp_2:       ACCUMULATE_ADC(temp_hotend[2]); break;
-    #endif
-    #if HAS_TEMP_ADC_3
-      case MeasureTemp_3:       ACCUMULATE_ADC(temp_hotend[3]); break;
-    #endif
-    #if HAS_TEMP_ADC_4
-      case MeasureTemp_4:       ACCUMULATE_ADC(temp_hotend[4]); break;
-    #endif
-    #if HAS_TEMP_ADC_5
-      case MeasureTemp_5:       ACCUMULATE_ADC(temp_hotend[5]); break;
-    #endif
-    #if HAS_TEMP_ADC_6
-      case MeasureTemp_6:       ACCUMULATE_ADC(temp_hotend[6]); break;
-    #endif
-    #if HAS_TEMP_ADC_7
-      case MeasureTemp_7:       ACCUMULATE_ADC(temp_hotend[7]); break;
-    #endif
-
-    #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Measure_FILWIDTH:
-        if (HAL_ADC_READY())
-          filwidth.accumulate(HAL_READ_ADC());
-        else
-          next_sensor_state = adc_sensor_state; // redo this state
-      break;
-    #endif
-
-    #if HAS_JOY_ADC_X
-      case MeasureJoy_X:        ACCUMULATE_ADC(joystick.x); break;
-    #endif
-    #if HAS_JOY_ADC_Y
-      case MeasureJoy_Y:        ACCUMULATE_ADC(joystick.y); break;
-    #endif
-    #if HAS_JOY_ADC_Z
-      case MeasureJoy_Z:        ACCUMULATE_ADC(joystick.z); break;
-    #endif
-
-    #if HAS_ADC_BUTTONS
-      #ifndef ADC_BUTTON_DEBOUNCE_DELAY
-        #define ADC_BUTTON_DEBOUNCE_DELAY 16
-      #endif
-      case Measure_ADC_KEY: {
-        if (HAL_ADC_READY()) {
-          if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
-            raw_ADCKey_value = HAL_READ_ADC();
-            if (raw_ADCKey_value <= (HAL_ADC_RANGE) * 900UL / 1024UL) {
-              NOMORE(current_ADCKey_raw, raw_ADCKey_value);
-              ADCKey_count++;
-            }
-            else { // ADC Key release
-              if (ADCKey_count > 0) {
-                if (ADCKey_pressed) {
-                  ADCKey_count = 0;
-                  current_ADCKey_raw = HAL_ADC_RANGE;
-                }
-                else
-                  ADCKey_count++;
-              }
-              else
-                ADCKey_pressed = false;
-            }
-            if (ADCKey_count == ADC_BUTTON_DEBOUNCE_DELAY) ADCKey_pressed = true;
-          }
-        }
-        else
-          next_sensor_state = adc_sensor_state; // redo this state
-
-      } break;
-
-    #endif // HAS_ADC_BUTTONS
-
-  } // switch(adc_sensor_state)
-
-  // Go to the next state (may be unchanged)
-  adc_sensor_state = next_sensor_state;
-
-  // Assume that the state advances
-  next_sensor_state = NEXT_ADC_STATE(adc_sensor_state);
+  ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
-    default: break;
-
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
       static uint8_t delay_count = 0;
       if (extra_loops > 0) {
         if (delay_count == 0) delay_count = extra_loops;  // Init this delay
         if (--delay_count)                                // While delaying...
           next_sensor_state = SensorsReady;               // retain this state (else, next state will be 0)
-        break;                                            // No fallthru
+        break;
       }
       else {
-        adc_sensor_state = StartSampling;                 // Fall through to count up oversamples
-        next_sensor_state = NEXT_ENUM(StartSampling);     // and possibly send the final readings.
+        adc_sensor_state = StartSampling;                 // Fall-through to start sampling
+        next_sensor_state = (ADCSensorState)(int(StartSampling) + 1);
       }
     }
-    // fallthru
 
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
-      if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1 / (16000000 / 64 / 256) = 164ms.
+      if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
         temp_count = 0;
         readings_ready();
       }
-      adc_sensor_state = NEXT_ENUM(StartSampling);        // Do one Prepare phase before exiting
-      next_sensor_state = NEXT_ENUM(adc_sensor_state);    // Also update the next state
-      // fallthru
+      break;
 
     #if HAS_TEMP_ADC_0
-      case PrepareTemp_0:       HAL_START_ADC(TEMP_0_PIN); break;
+      case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
+      case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
     #endif
+
     #if HAS_HEATED_BED
-      case PrepareTemp_BED:     HAL_START_ADC(TEMP_BED_PIN); break;
+      case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
+      case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
+
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
+      case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
+
     #if HAS_TEMP_PROBE
-      case PrepareTemp_PROBE:   HAL_START_ADC(TEMP_PROBE_PIN); break;
+      case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
+      case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
     #endif
+
     #if HAS_TEMP_ADC_1
-      case PrepareTemp_1:       HAL_START_ADC(TEMP_1_PIN); break;
+      case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
+      case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
+
     #if HAS_TEMP_ADC_2
-      case PrepareTemp_2:       HAL_START_ADC(TEMP_2_PIN); break;
+      case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
+      case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
+
     #if HAS_TEMP_ADC_3
-      case PrepareTemp_3:       HAL_START_ADC(TEMP_3_PIN); break;
+      case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
+      case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
     #endif
+
     #if HAS_TEMP_ADC_4
-      case PrepareTemp_4:       HAL_START_ADC(TEMP_4_PIN); break;
+      case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
+      case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
     #endif
+
     #if HAS_TEMP_ADC_5
-      case PrepareTemp_5:       HAL_START_ADC(TEMP_5_PIN); break;
+      case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
+      case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
+
     #if HAS_TEMP_ADC_6
-      case PrepareTemp_6:       HAL_START_ADC(TEMP_6_PIN); break;
+      case PrepareTemp_6: HAL_START_ADC(TEMP_6_PIN); break;
+      case MeasureTemp_6: ACCUMULATE_ADC(temp_hotend[6]); break;
     #endif
+
     #if HAS_TEMP_ADC_7
-      case PrepareTemp_7:       HAL_START_ADC(TEMP_7_PIN); break;
+      case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
+      case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
     #endif
+
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Prepare_FILWIDTH:    HAL_START_ADC(FILWIDTH_PIN); break;
+      case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
+      case Measure_FILWIDTH:
+        if (!HAL_ADC_READY())
+          next_sensor_state = adc_sensor_state; // redo this state
+        else
+          filwidth.accumulate(HAL_READ_ADC());
+      break;
     #endif
+
     #if HAS_JOY_ADC_X
-      case PrepareJoy_X:        HAL_START_ADC(JOY_X_PIN); break;
+      case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
+      case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
     #endif
+
     #if HAS_JOY_ADC_Y
-      case PrepareJoy_Y:        HAL_START_ADC(JOY_Y_PIN); break;
+      case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
+      case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
     #endif
+
     #if HAS_JOY_ADC_Z
-      case PrepareJoy_Z:        HAL_START_ADC(JOY_Z_PIN); break;
+      case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
+      case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
     #endif
+
     #if HAS_ADC_BUTTONS
-      case Prepare_ADC_KEY:     HAL_START_ADC(ADC_KEYPAD_PIN); break;
-    #endif
+      #ifndef ADC_BUTTON_DEBOUNCE_DELAY
+        #define ADC_BUTTON_DEBOUNCE_DELAY 16
+      #endif
+      case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
+      case Measure_ADC_KEY:
+        if (!HAL_ADC_READY())
+          next_sensor_state = adc_sensor_state; // redo this state
+        else if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
+          raw_ADCKey_value = HAL_READ_ADC();
+          if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
+            NOMORE(current_ADCKey_raw, raw_ADCKey_value);
+            ADCKey_count++;
+          }
+          else { //ADC Key release
+            if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
+            if (ADCKey_pressed) {
+              ADCKey_count = 0;
+              current_ADCKey_raw = HAL_ADC_RANGE;
+            }
+          }
+        }
+        if (ADCKey_count == ADC_BUTTON_DEBOUNCE_DELAY) ADCKey_pressed = true;
+        break;
+    #endif // HAS_ADC_BUTTONS
+
+    case StartupDelay: break;
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 

commit 64a81f887a3b9fd471484dba784e11bdba88ffbb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 15 21:42:28 2020 -0600

    EXPERIMENTAL integrated BABYSTEPPING (#16829)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a422912742..5bed31b1a1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -62,21 +62,21 @@
 #define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PINS_EXIST(MAX6675_SCK, MAX6675_DO))
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
-#if ENABLED(BABYSTEPPING)
+#if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
@@ -3003,21 +3003,21 @@ void Temperature::tick() {
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 
-  #if ENABLED(BABYSTEPPING)
+  #if ENABLED(BABYSTEPPING) && DISABLED(INTEGRATED_BABYSTEPPING)
     babystep.task();
   #endif
 
   // Poll endstops state, if required
   endstops.poll();
 
   // Periodically call the planner timer
   planner.tick();
 }
 

commit 64b96f390867700834641b01bbb37a40867a7bef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 15 19:10:46 2020 -0600

    Double ADC read frequency (#16864)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cfb7990010..a422912742 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2791,168 +2791,222 @@ void Temperature::tick() {
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
 
   /**
-   * One sensor is sampled on every other call of the ISR.
-   * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
+   * On each call to the ISR one sensor is Sampled and
+   * the next sensor is Prepared.
    *
-   * On each Prepare pass, ADC is started for a sensor pin.
-   * On the next pass, the ADC value is read and accumulated.
+   * Sensors are read 16 (OVERSAMPLENR) times and the
+   * final reading takes the average.
    *
-   * This gives each ADC 0.9765ms to charge up.
+   * Extra do-nothing passes may exist when there are
+   * only a few sensors. This is set by MIN_ADC_ISR_LOOPS.
+   *
+   * The timing of this ISR gives ADCs 0.9765ms to charge up.
    */
-  #define ACCUMULATE_ADC(obj) do{ \
-    if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
-    else obj.sample(HAL_READ_ADC()); \
+  #define ACCUMULATE_ADC(obj) do{           \
+    if (HAL_ADC_READY())                    \
+      obj.sample(HAL_READ_ADC());           \
+    else                                    \
+      next_sensor_state = adc_sensor_state; \
   }while(0)
 
-  ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
+  #define NEXT_ENUM(A) (typeof(A))(int(A) + 1)
+  #define NEXT_ADC_STATE(N) ((N) >= SensorsReady ? StartSampling : NEXT_ENUM(N))
+
+  // Assume the machine will go on to the next state
+  ADCSensorState next_sensor_state = NEXT_ADC_STATE(adc_sensor_state);
+
+  switch (adc_sensor_state) {
+
+    default: break;
+
+    #if HAS_TEMP_ADC_0
+      case MeasureTemp_0:       ACCUMULATE_ADC(temp_hotend[0]); break;
+    #endif
+    #if HAS_HEATED_BED
+      case MeasureTemp_BED:     ACCUMULATE_ADC(temp_bed); break;
+    #endif
+    #if HAS_TEMP_CHAMBER
+      case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
+    #endif
+    #if HAS_TEMP_PROBE
+      case MeasureTemp_PROBE:   ACCUMULATE_ADC(temp_probe); break;
+    #endif
+    #if HAS_TEMP_ADC_1
+      case MeasureTemp_1:       ACCUMULATE_ADC(temp_hotend[1]); break;
+    #endif
+    #if HAS_TEMP_ADC_2
+      case MeasureTemp_2:       ACCUMULATE_ADC(temp_hotend[2]); break;
+    #endif
+    #if HAS_TEMP_ADC_3
+      case MeasureTemp_3:       ACCUMULATE_ADC(temp_hotend[3]); break;
+    #endif
+    #if HAS_TEMP_ADC_4
+      case MeasureTemp_4:       ACCUMULATE_ADC(temp_hotend[4]); break;
+    #endif
+    #if HAS_TEMP_ADC_5
+      case MeasureTemp_5:       ACCUMULATE_ADC(temp_hotend[5]); break;
+    #endif
+    #if HAS_TEMP_ADC_6
+      case MeasureTemp_6:       ACCUMULATE_ADC(temp_hotend[6]); break;
+    #endif
+    #if HAS_TEMP_ADC_7
+      case MeasureTemp_7:       ACCUMULATE_ADC(temp_hotend[7]); break;
+    #endif
+
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      case Measure_FILWIDTH:
+        if (HAL_ADC_READY())
+          filwidth.accumulate(HAL_READ_ADC());
+        else
+          next_sensor_state = adc_sensor_state; // redo this state
+      break;
+    #endif
+
+    #if HAS_JOY_ADC_X
+      case MeasureJoy_X:        ACCUMULATE_ADC(joystick.x); break;
+    #endif
+    #if HAS_JOY_ADC_Y
+      case MeasureJoy_Y:        ACCUMULATE_ADC(joystick.y); break;
+    #endif
+    #if HAS_JOY_ADC_Z
+      case MeasureJoy_Z:        ACCUMULATE_ADC(joystick.z); break;
+    #endif
+
+    #if HAS_ADC_BUTTONS
+      #ifndef ADC_BUTTON_DEBOUNCE_DELAY
+        #define ADC_BUTTON_DEBOUNCE_DELAY 16
+      #endif
+      case Measure_ADC_KEY: {
+        if (HAL_ADC_READY()) {
+          if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
+            raw_ADCKey_value = HAL_READ_ADC();
+            if (raw_ADCKey_value <= (HAL_ADC_RANGE) * 900UL / 1024UL) {
+              NOMORE(current_ADCKey_raw, raw_ADCKey_value);
+              ADCKey_count++;
+            }
+            else { // ADC Key release
+              if (ADCKey_count > 0) {
+                if (ADCKey_pressed) {
+                  ADCKey_count = 0;
+                  current_ADCKey_raw = HAL_ADC_RANGE;
+                }
+                else
+                  ADCKey_count++;
+              }
+              else
+                ADCKey_pressed = false;
+            }
+            if (ADCKey_count == ADC_BUTTON_DEBOUNCE_DELAY) ADCKey_pressed = true;
+          }
+        }
+        else
+          next_sensor_state = adc_sensor_state; // redo this state
+
+      } break;
+
+    #endif // HAS_ADC_BUTTONS
+
+  } // switch(adc_sensor_state)
+
+  // Go to the next state (may be unchanged)
+  adc_sensor_state = next_sensor_state;
+
+  // Assume that the state advances
+  next_sensor_state = NEXT_ADC_STATE(adc_sensor_state);
 
   switch (adc_sensor_state) {
 
+    default: break;
+
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
       static uint8_t delay_count = 0;
       if (extra_loops > 0) {
         if (delay_count == 0) delay_count = extra_loops;  // Init this delay
         if (--delay_count)                                // While delaying...
           next_sensor_state = SensorsReady;               // retain this state (else, next state will be 0)
-        break;
+        break;                                            // No fallthru
       }
       else {
-        adc_sensor_state = StartSampling;                 // Fall-through to start sampling
-        next_sensor_state = (ADCSensorState)(int(StartSampling) + 1);
+        adc_sensor_state = StartSampling;                 // Fall through to count up oversamples
+        next_sensor_state = NEXT_ENUM(StartSampling);     // and possibly send the final readings.
       }
     }
+    // fallthru
 
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
-      if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
+      if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1 / (16000000 / 64 / 256) = 164ms.
         temp_count = 0;
         readings_ready();
       }
-      break;
+      adc_sensor_state = NEXT_ENUM(StartSampling);        // Do one Prepare phase before exiting
+      next_sensor_state = NEXT_ENUM(adc_sensor_state);    // Also update the next state
+      // fallthru
 
     #if HAS_TEMP_ADC_0
-      case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
-      case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
+      case PrepareTemp_0:       HAL_START_ADC(TEMP_0_PIN); break;
     #endif
-
     #if HAS_HEATED_BED
-      case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
-      case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
+      case PrepareTemp_BED:     HAL_START_ADC(TEMP_BED_PIN); break;
     #endif
-
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
-      case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
-
     #if HAS_TEMP_PROBE
-      case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
-      case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
+      case PrepareTemp_PROBE:   HAL_START_ADC(TEMP_PROBE_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_1
-      case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
-      case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
+      case PrepareTemp_1:       HAL_START_ADC(TEMP_1_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_2
-      case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
-      case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
+      case PrepareTemp_2:       HAL_START_ADC(TEMP_2_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_3
-      case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
-      case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
+      case PrepareTemp_3:       HAL_START_ADC(TEMP_3_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_4
-      case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
-      case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
+      case PrepareTemp_4:       HAL_START_ADC(TEMP_4_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_5
-      case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
-      case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
+      case PrepareTemp_5:       HAL_START_ADC(TEMP_5_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_6
-      case PrepareTemp_6: HAL_START_ADC(TEMP_6_PIN); break;
-      case MeasureTemp_6: ACCUMULATE_ADC(temp_hotend[6]); break;
+      case PrepareTemp_6:       HAL_START_ADC(TEMP_6_PIN); break;
     #endif
-
     #if HAS_TEMP_ADC_7
-      case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
-      case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
+      case PrepareTemp_7:       HAL_START_ADC(TEMP_7_PIN); break;
     #endif
-
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
-      case Measure_FILWIDTH:
-        if (!HAL_ADC_READY())
-          next_sensor_state = adc_sensor_state; // redo this state
-        else
-          filwidth.accumulate(HAL_READ_ADC());
-      break;
+      case Prepare_FILWIDTH:    HAL_START_ADC(FILWIDTH_PIN); break;
     #endif
-
     #if HAS_JOY_ADC_X
-      case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
-      case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
+      case PrepareJoy_X:        HAL_START_ADC(JOY_X_PIN); break;
     #endif
-
     #if HAS_JOY_ADC_Y
-      case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
-      case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
+      case PrepareJoy_Y:        HAL_START_ADC(JOY_Y_PIN); break;
     #endif
-
     #if HAS_JOY_ADC_Z
-      case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
-      case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
+      case PrepareJoy_Z:        HAL_START_ADC(JOY_Z_PIN); break;
     #endif
-
     #if HAS_ADC_BUTTONS
-      #ifndef ADC_BUTTON_DEBOUNCE_DELAY
-        #define ADC_BUTTON_DEBOUNCE_DELAY 16
-      #endif
-      case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
-      case Measure_ADC_KEY:
-        if (!HAL_ADC_READY())
-          next_sensor_state = adc_sensor_state; // redo this state
-        else if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
-          raw_ADCKey_value = HAL_READ_ADC();
-          if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
-            NOMORE(current_ADCKey_raw, raw_ADCKey_value);
-            ADCKey_count++;
-          }
-          else { //ADC Key release
-            if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
-            if (ADCKey_pressed) {
-              ADCKey_count = 0;
-              current_ADCKey_raw = HAL_ADC_RANGE;
-            }
-          }
-        }
-        if (ADCKey_count == ADC_BUTTON_DEBOUNCE_DELAY) ADCKey_pressed = true;
-        break;
-    #endif // HAS_ADC_BUTTONS
-
-    case StartupDelay: break;
+      case Prepare_ADC_KEY:     HAL_START_ADC(ADC_KEYPAD_PIN); break;
+    #endif
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 

commit 0b984519c30f453fdb5b4efb8008a07c69688824
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 14 05:14:37 2020 -0600

    Clean up stepper and babystep (#16857)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f07f943213..cfb7990010 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -58,29 +58,26 @@
     #endif
   );
 #endif
 
 #define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PINS_EXIST(MAX6675_SCK, MAX6675_DO))
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
-#if EITHER(BABYSTEPPING, PID_EXTRUSION_SCALING)
+#if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "../feature/babystep.h"
-  #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
-    #include "../gcode/gcode.h"
-  #endif
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"

commit 0268c1d02c33e6568aa579cfb9e4058603cbcb3c
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Tue Feb 4 01:24:11 2020 -0600

    STM32duino - Use SDIO for onboard SD (#16756)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 16635b39bd..f07f943213 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -52,21 +52,21 @@
   #endif
   Adafruit_MAX31865 max31865 = Adafruit_MAX31865(MAX31865_CS_PIN
     #if MAX31865_CS_PIN != MAX6675_SS_PIN
       , MAX31865_MOSI_PIN           // For software SPI also set MOSI/MISO/SCK
       , MAX31865_MISO_PIN
       , MAX31865_SCK_PIN
     #endif
   );
 #endif
 
-#define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PIN_EXISTS(MAX6675_SCK, MAX6675_DO))
+#define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PINS_EXIST(MAX6675_SCK, MAX6675_DO))
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if EITHER(BABYSTEPPING, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 81068c7f7b..16635b39bd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit ee6003be8705da8a096780f433199299898af6bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 23:07:12 2020 -0600

    Revert breaking change to _FAN_PWM macro

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9919c4e35c..81068c7f7b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2584,23 +2584,24 @@ void Temperature::tick() {
 
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
-        #define _FAN_PWM(N) do{ \
-          const uint8_t spcf = (soft_pwm_count_fan[N] & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
-          WRITE_FAN(N, (spcf > pwm_mask)); \
+        #define _FAN_PWM(N) do{                                     \
+          uint8_t &spcf = soft_pwm_count_fan[N];                    \
+          spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
+          WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW);               \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif

commit 4716dac8742e536dde12773b579407fb1ae1cb66
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 21:00:53 2020 -0600

    Apply REPEAT, RREPEAT, and loop macros (#16757)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6dc831f715..9919c4e35c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -672,39 +672,22 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
 
 #if HAS_AUTO_FAN
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
     #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HOTENDS > 1
-        , REPEAT2(1,_EFAN,1) 1
-        #if HOTENDS > 2
-          , REPEAT2(2,_EFAN,2) 2
-          #if HOTENDS > 3
-            , REPEAT2(3,_EFAN,3) 3
-            #if HOTENDS > 4
-              , REPEAT2(4,_EFAN,4) 4
-              #if HOTENDS > 5
-                , REPEAT2(5,_EFAN,5) 5
-                #if HOTENDS > 6
-                  , REPEAT2(6,_EFAN,6) 6
-                  #if HOTENDS > 7
-                    , REPEAT2(7,_EFAN,7) 7
-                  #endif
-                #endif
-              #endif
-            #endif
-          #endif
-        #endif
+        #define _NEXT_FAN(N) , REPEAT2(N,_EFAN,N) N
+        RREPEAT_S(1, HOTENDS, _NEXT_FAN)
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
         , REPEAT(HOTENDS,_CFAN) (HOTENDS)
       #endif
     };
 
     uint8_t fanState = 0;
     HOTEND_LOOP()
       if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
@@ -2109,24 +2092,24 @@ void Temperature::disable_all_heaters() {
 
   #if HAS_HEATED_CHAMBER
     setTargetChamber(0);
   #endif
 
   // Unpause and reset everything
   #if ENABLED(PROBING_HEATERS_OFF)
     pause(false);
   #endif
 
-  #define DISABLE_HEATER(NR) { \
-    setTargetHotend(0, NR); \
-    temp_hotend[NR].soft_pwm_amount = 0; \
-    WRITE_HEATER_ ##NR (LOW); \
+  #define DISABLE_HEATER(N) {           \
+    setTargetHotend(0, N);              \
+    temp_hotend[N].soft_pwm_amount = 0; \
+    WRITE_HEATER_##N(LOW);              \
   }
 
   #if HAS_TEMP_HOTEND
     REPEAT(HOTENDS, DISABLE_HEATER);
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.target = 0;
     temp_bed.soft_pwm_amount = 0;
     WRITE_HEATER_BED(LOW);

commit 0e72c315a0be49e98758d9744ac0117b0904b7e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 17:05:42 2020 -0600

    Minor string storage optimization

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4b00b095c2..6dc831f715 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1319,21 +1319,21 @@ void Temperature::manage_heater() {
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
     else
       SERIAL_ECHO_START();
     SERIAL_CHAR('P');
     SERIAL_CHAR('0' + t_index);
 
     const user_thermistor_t &t = user_thermistor[t_index];
 
     SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
-    SERIAL_ECHOPAIR_F(" T", t.res_25, 1);
+    SERIAL_ECHOPAIR_F_P(SP_T_STR, t.res_25, 1);
     SERIAL_ECHOPAIR_F(" B", t.beta, 1);
     SERIAL_ECHOPAIR_F(" C", t.sh_c_coeff, 9);
     SERIAL_ECHOPGM(" ; ");
     serialprintPGM(
       #if ENABLED(HEATER_0_USER_THERMISTOR)
         t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :
       #endif
       #if ENABLED(HEATER_1_USER_THERMISTOR)
         t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :
       #endif

commit 22556a7bbf8cad71fe2d4afaa9cd0ca14eaf6952
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 15:18:01 2020 -0600

    More 8-extruder fixups

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 24cd138c5d..4b00b095c2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2324,39 +2324,40 @@ void Temperature::update_raw_temperatures() {
   #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = temp_hotend[1].acc;
     #elif DISABLED(HEATER_1_USES_MAX6675)
       temp_hotend[1].update();
     #endif
-    #if HAS_TEMP_ADC_2
-      temp_hotend[2].update();
-      #if HAS_TEMP_ADC_3
-        temp_hotend[3].update();
-        #if HAS_TEMP_ADC_4
-          temp_hotend[4].update();
-          #if HAS_TEMP_ADC_5
-            temp_hotend[5].update();
-            #if HAS_TEMP_ADC_6
-              temp_hotend[6].update();
-              #if HAS_TEMP_ADC_7
-                temp_hotend[7].update();
-              #endif // HAS_TEMP_ADC_7
-            #endif // HAS_TEMP_ADC_6
-          #endif // HAS_TEMP_ADC_5
-        #endif // HAS_TEMP_ADC_4
-      #endif // HAS_TEMP_ADC_3
-    #endif // HAS_TEMP_ADC_2
-  #endif // HAS_TEMP_ADC_1
+  #endif
+
+  #if HAS_TEMP_ADC_2
+    temp_hotend[2].update();
+  #endif
+  #if HAS_TEMP_ADC_3
+    temp_hotend[3].update();
+  #endif
+  #if HAS_TEMP_ADC_4
+    temp_hotend[4].update();
+  #endif
+  #if HAS_TEMP_ADC_5
+    temp_hotend[5].update();
+  #endif
+  #if HAS_TEMP_ADC_6
+    temp_hotend[6].update();
+  #endif
+  #if HAS_TEMP_ADC_7
+    temp_hotend[7].update();
+  #endif
 
   #if HAS_HEATED_BED
     temp_bed.update();
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.update();
   #endif
 
   #if HAS_TEMP_PROBE

commit c3cab37d7eec97f871ad73d07a3abfa616bbd35c
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Feb 1 02:51:57 2020 -0800

    Fix Temperature::over_autostart_threshold (#16749)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d90a2123d1..24cd138c5d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2136,21 +2136,21 @@ void Temperature::disable_all_heaters() {
     temp_chamber.target = 0;
     temp_chamber.soft_pwm_amount = 0;
     WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
   bool Temperature::over_autostart_threshold() {
     #if HOTENDS
-      HOTEND_LOOP() if (degTargetHotend(e) < (EXTRUDE_MINTEMP) / 2) return true;
+      HOTEND_LOOP() if (degTargetHotend(e) > (EXTRUDE_MINTEMP) / 2) return true;
     #endif
     #if HAS_HEATED_BED
       if (degTargetBed() > BED_MINTEMP) return true;
     #endif
     #if HAS_HEATED_CHAMBER
       if (degTargetChamber() > CHAMBER_MINTEMP) return true;
     #endif
     return false;
   }
 

commit 43d3463d5d612a300789bdc7a845eb2e8a37786d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 03:50:26 2020 -0600

    Misc cleanup, whitespace

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 702f82e770..d90a2123d1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2601,23 +2601,22 @@ void Temperature::tick() {
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #define _FAN_PWM(N) do{ \
-          uint8_t &spcf = soft_pwm_count_fan[N]; \
-          spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
-          WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW); \
+          const uint8_t spcf = (soft_pwm_count_fan[N] & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
+          WRITE_FAN(N, (spcf > pwm_mask)); \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif

commit 9a8de23858b3ec1b19542db4fd6c5e5419e6ee98
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 31 21:08:37 2020 -0800

    Consistent M112 with Emergency Parser (#16747)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 61ed04aaea..702f82e770 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1043,21 +1043,21 @@ void Temperature::manage_heater() {
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
     if (!inited) return watchdog_refresh();
   #endif
 
   #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
-    if (emergency_parser.killed_by_M112) kill();
+    if (emergency_parser.killed_by_M112) kill(M112_KILL_STR, nullptr, true);
   #endif
 
   if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
     if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif

commit 9caf5c05e7e408c7192e689e4ed5fe2735bb2995
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:43 2020 -0600

    Refactor heater watch, job timer auto-start (#16725)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 559b3d5a1e..61ed04aaea 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -213,57 +213,57 @@ Temperature thermalManager;
         else
           FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }
     }
 
   #endif
 
 #endif // FAN_COUNT > 0
 
 #if WATCH_HOTENDS
-  heater_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
+  hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
-  heater_idle_t Temperature::hotend_idle[HOTENDS]; // = { { 0 } }
+  hotend_idle_t Temperature::hotend_idle[HOTENDS]; // = { { 0 } }
 #endif
 
 #if HAS_HEATED_BED
   bed_info_t Temperature::temp_bed; // = { 0 }
   // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
     int16_t Temperature::mintemp_raw_BED = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
   #endif
   #if WATCH_BED
-    heater_watch_t Temperature::watch_bed; // = { 0 }
+    bed_watch_t Temperature::watch_bed; // = { 0 }
   #endif
   #if DISABLED(PIDTEMPBED)
     millis_t Temperature::next_bed_check_ms;
   #endif
   #if HEATER_IDLE_HANDLER
-    heater_idle_t Temperature::bed_idle; // = { 0 }
+    hotend_idle_t Temperature::bed_idle; // = { 0 }
   #endif
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
     #endif
     #if WATCH_CHAMBER
-      heater_watch_t Temperature::watch_chamber{0};
+      chamber_watch_t Temperature::watch_chamber{0};
     #endif
     millis_t Temperature::next_chamber_check_ms;
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 #if HAS_TEMP_PROBE
   probe_info_t Temperature::temp_probe; // = { 0 }
 #endif
 
 // Initialized by settings.load()
@@ -1967,58 +1967,43 @@ void Temperature::init() {
 }
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
-    if (degTargetHotend(ee) && degHotend(ee) < degTargetHotend(ee) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
-      watch_hotend[ee].target = degHotend(ee) + WATCH_TEMP_INCREASE;
-      watch_hotend[ee].next_ms = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
-    }
-    else
-      watch_hotend[ee].next_ms = 0;
+    watch_hotend[ee].restart(degHotend(ee), degTargetHotend(ee));
   }
 #endif
 
 #if WATCH_BED
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M140, M190)
    */
   void Temperature::start_watching_bed() {
-    if (degTargetBed() && degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
-      watch_bed.target = degBed() + WATCH_BED_TEMP_INCREASE;
-      watch_bed.next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
-    }
-    else
-      watch_bed.next_ms = 0;
+    watch_bed.restart(degBed(), degTargetBed());
   }
 #endif
 
 #if WATCH_CHAMBER
   /**
    * Start Heating Sanity Check for chamber that is below
    * its target temperature by a configurable margin.
    * This is called when the temperature is set. (M141, M191)
    */
   void Temperature::start_watching_chamber() {
-    if (degChamber() < degTargetChamber() - (WATCH_CHAMBER_TEMP_INCREASE + TEMP_CHAMBER_HYSTERESIS + 1)) {
-      watch_chamber.target = degChamber() + WATCH_CHAMBER_TEMP_INCREASE;
-      watch_chamber.next_ms = millis() + (WATCH_CHAMBER_TEMP_PERIOD) * 1000UL;
-    }
-    else
-      watch_chamber.next_ms = 0;
+    watch_chamber.restart(degChamber(), degTargetChamber());
   }
 #endif
 
 #if HAS_THERMAL_PROTECTION
 
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
     Temperature::tr_state_machine_t Temperature::tr_state_machine[HOTENDS]; // = { { TRInactive, 0 } };
   #endif
   #if HAS_THERMALLY_PROTECTED_BED
     Temperature::tr_state_machine_t Temperature::tr_state_machine_bed; // = { TRInactive, 0 };
@@ -2147,33 +2132,61 @@ void Temperature::disable_all_heaters() {
     WRITE_HEATER_BED(LOW);
   #endif
 
   #if HAS_HEATED_CHAMBER
     temp_chamber.target = 0;
     temp_chamber.soft_pwm_amount = 0;
     WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
+#if ENABLED(PRINTJOB_TIMER_AUTOSTART)
+
+  bool Temperature::over_autostart_threshold() {
+    #if HOTENDS
+      HOTEND_LOOP() if (degTargetHotend(e) < (EXTRUDE_MINTEMP) / 2) return true;
+    #endif
+    #if HAS_HEATED_BED
+      if (degTargetBed() > BED_MINTEMP) return true;
+    #endif
+    #if HAS_HEATED_CHAMBER
+      if (degTargetChamber() > CHAMBER_MINTEMP) return true;
+    #endif
+    return false;
+  }
+
+  void Temperature::check_timer_autostart(const bool can_start, const bool can_stop) {
+    if (over_autostart_threshold()) {
+      if (can_start) startOrResumeJob();
+    }
+    else if (can_stop) {
+      print_job_timer.stop();
+      ui.reset_status();
+    }
+  }
+
+#endif
+
+
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
         HOTEND_LOOP() hotend_idle[e].expire(); // timeout immediately
         #if HAS_HEATED_BED
           bed_idle.expire(); // timeout immediately
         #endif
       }
       else {
-        HOTEND_LOOP() reset_heater_idle_timer(e);
+        HOTEND_LOOP() reset_hotend_idle_timer(e);
         #if HAS_HEATED_BED
           reset_bed_idle_timer();
         #endif
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
 #if HAS_MAX6675

commit 56cd747c8be868b21619001aeebbecd3827a7e93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 26 17:39:45 2020 -0600

    Rename some temperature members

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index eba7afd81a..559b3d5a1e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -280,21 +280,21 @@ Temperature thermalManager;
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   uint16_t Temperature::redundant_temperature_raw = 0;
   float Temperature::redundant_temperature = 0.0;
 #endif
 
-volatile bool Temperature::temp_meas_ready = false;
+volatile bool Temperature::raw_temps_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) < (HEATER_##N##_RAW_HI_TEMP) ? 1 : -1)
 
 #if HOTENDS
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
@@ -428,21 +428,21 @@ volatile bool Temperature::temp_meas_ready = false;
 
     #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
       adaptive_fan_slowing = false;
     #endif
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
-      if (temp_meas_ready) { // temp sample ready
+      if (raw_temps_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
         current_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
         NOLESS(maxT, current_temp);
         NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current_temp, target);
         #endif
@@ -1046,21 +1046,21 @@ void Temperature::manage_heater() {
   #endif
 
   #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
-  if (!temp_meas_ready) return;
+  if (!raw_temps_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
     if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
@@ -1083,24 +1083,24 @@ void Temperature::manage_heater() {
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
-        if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
-          if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
+        if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) {  // Time to check this extruder?
+          if (degHotend(e) < watch_hotend[e].target)                            // Failed to increase enough?
             _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
-          else                                                                 // Start again if the target is still far off
+          else                                                                  // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
           _temp_error(H_E0, PSTR(MSG_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
 
@@ -1618,21 +1618,21 @@ void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filwidth.update_measured_mm();
   #endif
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
-  temp_meas_ready = false;
+  raw_temps_ready = false;
 }
 
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef ALFAWISE_UX0
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
@@ -2297,23 +2297,23 @@ void Temperature::disable_all_heaters() {
     #if COUNT_6675 > 1
       max6675_temp_previous[hindex] = max6675_temp;
     #endif
 
     return int(max6675_temp);
   }
 
 #endif // HAS_MAX6675
 
 /**
- * Get raw temperatures
+ * Update raw temperatures
  */
-void Temperature::set_current_temp_raw() {
+void Temperature::update_raw_temperatures() {
 
   #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = temp_hotend[1].acc;
     #elif DISABLED(HEATER_1_USES_MAX6675)
       temp_hotend[1].update();
@@ -2353,27 +2353,27 @@ void Temperature::set_current_temp_raw() {
   #if HAS_JOY_ADC_X
     joystick.x.update();
   #endif
   #if HAS_JOY_ADC_Y
     joystick.y.update();
   #endif
   #if HAS_JOY_ADC_Z
     joystick.z.update();
   #endif
 
-  temp_meas_ready = true;
+  raw_temps_ready = true;
 }
 
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
-  if (!temp_meas_ready) set_current_temp_raw();
+  if (!raw_temps_ready) update_raw_temperatures();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filwidth.reading_ready();
   #endif
 
   #if HOTENDS
     HOTEND_LOOP() temp_hotend[e].reset();
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       temp_hotend[1].reset();

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b0b57873ce..eba7afd81a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -296,23 +296,25 @@ volatile bool Temperature::temp_meas_ready = false;
 
 #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) < (HEATER_##N##_RAW_HI_TEMP) ? 1 : -1)
 
 #if HOTENDS
   // Init mintemp and maxtemp with extreme values to prevent false errors during startup
   constexpr temp_range_t sensor_heater_0 { HEATER_0_RAW_LO_TEMP, HEATER_0_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_1 { HEATER_1_RAW_LO_TEMP, HEATER_1_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_2 { HEATER_2_RAW_LO_TEMP, HEATER_2_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_3 { HEATER_3_RAW_LO_TEMP, HEATER_3_RAW_HI_TEMP, 0, 16383 },
                          sensor_heater_4 { HEATER_4_RAW_LO_TEMP, HEATER_4_RAW_HI_TEMP, 0, 16383 },
-                         sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 };
+                         sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_6 { HEATER_6_RAW_LO_TEMP, HEATER_6_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_7 { HEATER_7_RAW_LO_TEMP, HEATER_7_RAW_HI_TEMP, 0, 16383 };
 
-  temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5);
+  temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5, sensor_heater_6, sensor_heater_7);
 #endif
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #ifdef MILLISECONDS_PREHEAT_TIME
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
@@ -679,20 +681,26 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
       #if HOTENDS > 1
         , REPEAT2(1,_EFAN,1) 1
         #if HOTENDS > 2
           , REPEAT2(2,_EFAN,2) 2
           #if HOTENDS > 3
             , REPEAT2(3,_EFAN,3) 3
             #if HOTENDS > 4
               , REPEAT2(4,_EFAN,4) 4
               #if HOTENDS > 5
                 , REPEAT2(5,_EFAN,5) 5
+                #if HOTENDS > 6
+                  , REPEAT2(6,_EFAN,6) 6
+                  #if HOTENDS > 7
+                    , REPEAT2(7,_EFAN,7) 7
+                  #endif
+                #endif
               #endif
             #endif
           #endif
         #endif
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
         , REPEAT(HOTENDS,_CFAN) (HOTENDS)
       #endif
     };
@@ -744,20 +752,26 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
         #endif
         #if HAS_AUTO_FAN_3
           case 3: _UPDATE_AUTO_FAN(E3, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_4
           case 4: _UPDATE_AUTO_FAN(E4, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_5
           case 5: _UPDATE_AUTO_FAN(E5, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
+        #if HAS_AUTO_FAN_6
+          case 6: _UPDATE_AUTO_FAN(E6, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+        #endif
+        #if HAS_AUTO_FAN_7
+          case 7: _UPDATE_AUTO_FAN(E7, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
+        #endif
         #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
           case CHAMBER_FAN_INDEX: _UPDATE_AUTO_FAN(CHAMBER, fan_on, CHAMBER_AUTO_FAN_SPEED); break;
         #endif
       }
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
@@ -886,30 +900,28 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
                 last_e_position = e_position;
               }
               else
                 lpq[lpq_ptr] = 0;
 
               if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
               work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
               pid_output += work_pid[ee].Kc;
             }
           #endif // PID_EXTRUSION_SCALING
-
           #if ENABLED(PID_FAN_SCALING)
             if (thermalManager.fan_speed[active_extruder] > PID_FAN_SCALING_MIN_SPEED) {
               work_pid[ee].Kf = PID_PARAM(Kf, ee) + (PID_FAN_SCALING_LIN_FACTOR) * thermalManager.fan_speed[active_extruder];
               pid_output += work_pid[ee].Kf;
             }
             //pid_output -= work_pid[ee].Ki;
             //pid_output += work_pid[ee].Ki * work_pid[ee].Kf
           #endif // PID_FAN_SCALING
-
           LIMIT(pid_output, 0, PID_MAX);
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
@@ -1279,20 +1291,26 @@ void Temperature::manage_heater() {
       #endif
       #if ENABLED(HEATER_3_USER_THERMISTOR)
         { true, 0, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
       #endif
       #if ENABLED(HEATER_4_USER_THERMISTOR)
         { true, 0, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
       #endif
       #if ENABLED(HEATER_5_USER_THERMISTOR)
         { true, 0, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
       #endif
+      #if ENABLED(HEATER_6_USER_THERMISTOR)
+        { true, 0, 0, HOTEND6_PULLUP_RESISTOR_OHMS, HOTEND6_RESISTANCE_25C_OHMS, 0, 0, HOTEND6_BETA, 0 },
+      #endif
+      #if ENABLED(HEATER_7_USER_THERMISTOR)
+        { true, 0, 0, HOTEND7_PULLUP_RESISTOR_OHMS, HOTEND7_RESISTANCE_25C_OHMS, 0, 0, HOTEND7_BETA, 0 },
+      #endif
       #if ENABLED(HEATER_BED_USER_THERMISTOR)
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
       #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
       #endif
     };
     COPY(thermalManager.user_thermistor, user_thermistor);
   }
 
@@ -1324,20 +1342,26 @@ void Temperature::manage_heater() {
       #endif
       #if ENABLED(HEATER_3_USER_THERMISTOR)
         t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :
       #endif
       #if ENABLED(HEATER_4_USER_THERMISTOR)
         t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :
       #endif
       #if ENABLED(HEATER_5_USER_THERMISTOR)
         t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :
       #endif
+      #if ENABLED(HEATER_6_USER_THERMISTOR)
+        t_index == CTI_HOTEND_6 ? PSTR("HOTEND 6") :
+      #endif
+      #if ENABLED(HEATER_7_USER_THERMISTOR)
+        t_index == CTI_HOTEND_7 ? PSTR("HOTEND 7") :
+      #endif
       #if ENABLED(HEATER_BED_USER_THERMISTOR)
         t_index == CTI_BED ? PSTR("BED") :
       #endif
       #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
         t_index == CTI_CHAMBER ? PSTR("CHAMBER") :
       #endif
       nullptr
     );
     SERIAL_EOL();
   }
@@ -1469,20 +1493,40 @@ void Temperature::manage_heater() {
       case 5:
         #if ENABLED(HEATER_5_USER_THERMISTOR)
           return user_thermistor_to_deg_c(CTI_HOTEND_5, raw);
         #elif ENABLED(HEATER_5_USES_AD595)
           return TEMP_AD595(raw);
         #elif ENABLED(HEATER_5_USES_AD8495)
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
+      case 6:
+        #if ENABLED(HEATER_6_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_6, raw);
+        #elif ENABLED(HEATER_6_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_6_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      case 7:
+        #if ENABLED(HEATER_7_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_7, raw);
+        #elif ENABLED(HEATER_7_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_7_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
       default: break;
     }
 
     #if HOTEND_USES_THERMISTOR
       // Thermistor with conversion table?
       const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
       SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
     #endif
 
     return 0;
@@ -1626,22 +1670,23 @@ void Temperature::init() {
     max31865.begin(MAX31865_2WIRE); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
   #endif
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
-    #define _AD(N) (ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495))
-    #if _AD(0) || _AD(1) || _AD(2) || _AD(3) || _AD(4) || _AD(5) || _AD(BED) || _AD(CHAMBER)
+    #define _AD(N) ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495)
+    #if  _AD(0) || _AD(1) || _AD(2) /* RUMBA has 3 E plugs // || _AD(3) || _AD(4) || _AD(5) || _AD(6) || _AD(7) */ \
+      || _AD(BED) || _AD(CHAMBER)
       // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
@@ -1661,20 +1706,26 @@ void Temperature::init() {
   #endif
   #if HAS_HEATER_3
     OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
     OUT_WRITE(HEATER_4_PIN, HEATER_4_INVERTING);
   #endif
   #if HAS_HEATER_5
     OUT_WRITE(HEATER_5_PIN, HEATER_5_INVERTING);
   #endif
+  #if HAS_HEATER_6
+    OUT_WRITE(HEATER_6_PIN, HEATER_6_INVERTING);
+  #endif
+  #if HAS_HEATER_7
+    OUT_WRITE(HEATER_7_PIN, HEATER_7_INVERTING);
+  #endif
 
   #if HAS_HEATED_BED
     #ifdef ALFAWISE_UX0
       OUT_WRITE_OD(HEATER_BED_PIN, HEATER_BED_INVERTING);
     #else
       OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
     #endif
   #endif
 
   #if HAS_HEATED_CHAMBER
@@ -1683,20 +1734,35 @@ void Temperature::init() {
 
   #if HAS_FAN0
     INIT_FAN_PIN(FAN_PIN);
   #endif
   #if HAS_FAN1
     INIT_FAN_PIN(FAN1_PIN);
   #endif
   #if HAS_FAN2
     INIT_FAN_PIN(FAN2_PIN);
   #endif
+  #if HAS_FAN3
+    INIT_FAN_PIN(FAN3_PIN);
+  #endif
+  #if HAS_FAN4
+    INIT_FAN_PIN(FAN4_PIN);
+  #endif
+  #if HAS_FAN5
+    INIT_FAN_PIN(FAN5_PIN);
+  #endif
+  #if HAS_FAN6
+    INIT_FAN_PIN(FAN6_PIN);
+  #endif
+  #if HAS_FAN7
+    INIT_FAN_PIN(FAN7_PIN);
+  #endif
   #if ENABLED(USE_CONTROLLER_FAN)
     INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
   #if MAX6675_SEPARATE_SPI
 
     OUT_WRITE(SCK_PIN, LOW);
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
@@ -1724,20 +1790,26 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_ADC_3
     HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_ADC_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_ADC_5
     HAL_ANALOG_SELECT(TEMP_5_PIN);
   #endif
+  #if HAS_TEMP_ADC_6
+    HAL_ANALOG_SELECT(TEMP_6_PIN);
+  #endif
+  #if HAS_TEMP_ADC_7
+    HAL_ANALOG_SELECT(TEMP_7_PIN);
+  #endif
   #if HAS_JOY_ADC_X
     HAL_ANALOG_SELECT(JOY_X_PIN);
   #endif
   #if HAS_JOY_ADC_Y
     HAL_ANALOG_SELECT(JOY_Y_PIN);
   #endif
   #if HAS_JOY_ADC_Z
     HAL_ANALOG_SELECT(JOY_Z_PIN);
   #endif
   #if HAS_JOY_ADC_EN
@@ -1773,20 +1845,26 @@ void Temperature::init() {
   #endif
   #if HAS_AUTO_FAN_3 && !(_EFANOVERLAP(3,0) || _EFANOVERLAP(3,1) || _EFANOVERLAP(3,2))
     INIT_E_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_4 && !(_EFANOVERLAP(4,0) || _EFANOVERLAP(4,1) || _EFANOVERLAP(4,2) || _EFANOVERLAP(4,3))
     INIT_E_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_5 && !(_EFANOVERLAP(5,0) || _EFANOVERLAP(5,1) || _EFANOVERLAP(5,2) || _EFANOVERLAP(5,3) || _EFANOVERLAP(5,4))
     INIT_E_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
   #endif
+  #if HAS_AUTO_FAN_6 && !(_EFANOVERLAP(6,0) || _EFANOVERLAP(6,1) || _EFANOVERLAP(6,2) || _EFANOVERLAP(6,3) || _EFANOVERLAP(6,4) || _EFANOVERLAP(6,5))
+    INIT_E_AUTO_FAN_PIN(E6_AUTO_FAN_PIN);
+  #endif
+  #if HAS_AUTO_FAN_7 && !(_EFANOVERLAP(7,0) || _EFANOVERLAP(7,1) || _EFANOVERLAP(7,2) || _EFANOVERLAP(7,3) || _EFANOVERLAP(7,4) || _EFANOVERLAP(7,5) || _EFANOVERLAP(7,6))
+    INIT_E_AUTO_FAN_PIN(E7_AUTO_FAN_PIN);
+  #endif
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HOTENDS
 
     #define _TEMP_MIN_E(NR) do{ \
@@ -1834,20 +1912,36 @@ void Temperature::init() {
             #ifdef HEATER_4_MAXTEMP
               _TEMP_MAX_E(4);
             #endif
             #if HOTENDS > 5
               #ifdef HEATER_5_MINTEMP
                 _TEMP_MIN_E(5);
               #endif
               #ifdef HEATER_5_MAXTEMP
                 _TEMP_MAX_E(5);
               #endif
+              #if HOTENDS > 6
+                #ifdef HEATER_6_MINTEMP
+                  _TEMP_MIN_E(6);
+                #endif
+                #ifdef HEATER_6_MAXTEMP
+                  _TEMP_MAX_E(6);
+                #endif
+                #if HOTENDS > 7
+                  #ifdef HEATER_7_MINTEMP
+                    _TEMP_MIN_E(7);
+                  #endif
+                  #ifdef HEATER_7_MAXTEMP
+                    _TEMP_MAX_E(7);
+                  #endif
+                #endif // HOTENDS > 7
+              #endif // HOTENDS > 6
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
   #endif // HOTENDS
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
@@ -2225,20 +2319,26 @@ void Temperature::set_current_temp_raw() {
       temp_hotend[1].update();
     #endif
     #if HAS_TEMP_ADC_2
       temp_hotend[2].update();
       #if HAS_TEMP_ADC_3
         temp_hotend[3].update();
         #if HAS_TEMP_ADC_4
           temp_hotend[4].update();
           #if HAS_TEMP_ADC_5
             temp_hotend[5].update();
+            #if HAS_TEMP_ADC_6
+              temp_hotend[6].update();
+              #if HAS_TEMP_ADC_7
+                temp_hotend[7].update();
+              #endif // HAS_TEMP_ADC_7
+            #endif // HAS_TEMP_ADC_6
           #endif // HAS_TEMP_ADC_5
         #endif // HAS_TEMP_ADC_4
       #endif // HAS_TEMP_ADC_3
     #endif // HAS_TEMP_ADC_2
   #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
     temp_bed.update();
   #endif
 
@@ -2501,20 +2601,35 @@ void Temperature::tick() {
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif
+        #if HAS_FAN3
+          _FAN_PWM(3);
+        #endif
+        #if HAS_FAN4
+          _FAN_PWM(4);
+        #endif
+        #if HAS_FAN5
+          _FAN_PWM(5);
+        #endif
+        #if HAS_FAN6
+          _FAN_PWM(6);
+        #endif
+        #if HAS_FAN7
+          _FAN_PWM(7);
+        #endif
       #endif
     }
     else {
       #define _PWM_LOW(N,S) do{ if (S.count <= pwm_count_tmp) WRITE_HEATER_##N(LOW); }while(0)
       #if HOTENDS
         #define _PWM_LOW_E(N) _PWM_LOW(N, soft_pwm_hotend[N]);
         REPEAT(HOTENDS, _PWM_LOW_E);
       #endif
 
       #if HAS_HEATED_BED
@@ -2528,20 +2643,35 @@ void Temperature::tick() {
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
           if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(0, LOW);
         #endif
         #if HAS_FAN1
           if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN(1, LOW);
         #endif
         #if HAS_FAN2
           if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN(2, LOW);
         #endif
+        #if HAS_FAN3
+          if (soft_pwm_count_fan[3] <= pwm_count_tmp) WRITE_FAN(3, LOW);
+        #endif
+        #if HAS_FAN4
+          if (soft_pwm_count_fan[4] <= pwm_count_tmp) WRITE_FAN(4, LOW);
+        #endif
+        #if HAS_FAN5
+          if (soft_pwm_count_fan[5] <= pwm_count_tmp) WRITE_FAN(5, LOW);
+        #endif
+        #if HAS_FAN6
+          if (soft_pwm_count_fan[6] <= pwm_count_tmp) WRITE_FAN(6, LOW);
+        #endif
+        #if HAS_FAN7
+          if (soft_pwm_count_fan[7] <= pwm_count_tmp) WRITE_FAN(7, LOW);
+        #endif
       #endif
     }
 
     // SOFT_PWM_SCALE to frequency:
     //
     // 0: 16000000/64/256/128 =   7.6294 Hz
     // 1:                / 64 =  15.2588 Hz
     // 2:                / 32 =  30.5176 Hz
     // 3:                / 16 =  61.0352 Hz
     // 4:                /  8 = 122.0703 Hz
@@ -2592,30 +2722,60 @@ void Temperature::tick() {
         }while(0)
         #if HAS_FAN0
           _PWM_FAN(0);
         #endif
         #if HAS_FAN1
           _PWM_FAN(1);
         #endif
         #if HAS_FAN2
           _PWM_FAN(2);
         #endif
+        #if HAS_FAN3
+          _FAN_PWM(3);
+        #endif
+        #if HAS_FAN4
+          _FAN_PWM(4);
+        #endif
+        #if HAS_FAN5
+          _FAN_PWM(5);
+        #endif
+        #if HAS_FAN6
+          _FAN_PWM(6);
+        #endif
+        #if HAS_FAN7
+          _FAN_PWM(7);
+        #endif
       }
       #if HAS_FAN0
         if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(0, LOW);
       #endif
       #if HAS_FAN1
         if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN(1, LOW);
       #endif
       #if HAS_FAN2
         if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN(2, LOW);
       #endif
+      #if HAS_FAN3
+        if (soft_pwm_count_fan[3] <= pwm_count_tmp) WRITE_FAN(3, LOW);
+      #endif
+      #if HAS_FAN4
+        if (soft_pwm_count_fan[4] <= pwm_count_tmp) WRITE_FAN(4, LOW);
+      #endif
+      #if HAS_FAN5
+        if (soft_pwm_count_fan[5] <= pwm_count_tmp) WRITE_FAN(5, LOW);
+      #endif
+      #if HAS_FAN6
+        if (soft_pwm_count_fan[6] <= pwm_count_tmp) WRITE_FAN(6, LOW);
+      #endif
+      #if HAS_FAN7
+        if (soft_pwm_count_fan[7] <= pwm_count_tmp) WRITE_FAN(7, LOW);
+      #endif
     #endif // FAN_SOFT_PWM
 
     // SOFT_PWM_SCALE to frequency:
     //
     // 0: 16000000/64/256/128 =   7.6294 Hz
     // 1:                / 64 =  15.2588 Hz
     // 2:                / 32 =  30.5176 Hz
     // 3:                / 16 =  61.0352 Hz
     // 4:                /  8 = 122.0703 Hz
     // 5:                /  4 = 244.1406 Hz
@@ -2723,20 +2883,30 @@ void Temperature::tick() {
     #if HAS_TEMP_ADC_4
       case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
       case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
     #endif
 
     #if HAS_TEMP_ADC_5
       case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
       case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
 
+    #if HAS_TEMP_ADC_6
+      case PrepareTemp_6: HAL_START_ADC(TEMP_6_PIN); break;
+      case MeasureTemp_6: ACCUMULATE_ADC(temp_hotend[6]); break;
+    #endif
+
+    #if HAS_TEMP_ADC_7
+      case PrepareTemp_7: HAL_START_ADC(TEMP_7_PIN); break;
+      case MeasureTemp_7: ACCUMULATE_ADC(temp_hotend[7]); break;
+    #endif
+
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else
           filwidth.accumulate(HAL_READ_ADC());
       break;
     #endif
 

commit a338dce83f6f3b3348a8422ad8acd7b81cc1cefe
Author: tompe-proj <59094873+tompe-proj@users.noreply.github.com>
Date:   Sat Jan 18 00:16:45 2020 +0100

    PINDA v2 temperature sensor / compensation (#16293)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b110afb85a..b0b57873ce 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -255,20 +255,24 @@ Temperature thermalManager;
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
     #endif
     #if WATCH_CHAMBER
       heater_watch_t Temperature::watch_chamber{0};
     #endif
     millis_t Temperature::next_chamber_check_ms;
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
+#if HAS_TEMP_PROBE
+  probe_info_t Temperature::temp_probe; // = { 0 }
+#endif
+
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   //hotend_pid_t Temperature::pid[HOTENDS];
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
@@ -647,25 +651,25 @@ volatile bool Temperature::temp_meas_ready = false;
 
 int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   switch (heater_id) {
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
     default:
-      #if HOTENDS
-        return temp_hotend[heater_id].soft_pwm_amount;
-      #else
-        return 0;
-      #endif
+      return (0
+        #if HOTENDS
+          + temp_hotend[heater_id].soft_pwm_amount
+        #endif
+      );
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
@@ -1391,21 +1395,21 @@ void Temperature::manage_heater() {
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       if (e > HOTENDS)
     #else
       if (e >= HOTENDS)
     #endif
       {
         SERIAL_ERROR_START();
         SERIAL_ECHO((int)e);
         SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
         kill();
-        return 0.0;
+        return 0;
       }
 
     switch (e) {
       case 0:
         #if ENABLED(HEATER_0_USER_THERMISTOR)
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif ENABLED(HEATER_0_USES_MAX6675)
           return (
             #if ENABLED(MAX6675_IS_MAX31865)
               max31865.temperature(100, 400)  // 100 ohms = PT100 resistance. 400 ohms = calibration resistor
@@ -1491,43 +1495,64 @@ void Temperature::manage_heater() {
   float Temperature::analog_to_celsius_bed(const int raw) {
     #if ENABLED(HEATER_BED_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_BED_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
+      UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
     #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(CHAMBER_TEMPTABLE, CHAMBER_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_CHAMBER_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
+      UNUSED(raw);
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
+#if HAS_TEMP_PROBE
+  // Derived from RepRap FiveD extruder::getTemperature()
+  // For probe temperature measurement.
+  float Temperature::analog_to_celsius_probe(const int raw) {
+    #if ENABLED(PROBE_USER_THERMISTOR)
+      return user_thermistor_to_deg_c(CTI_PROBE, raw);
+    #elif ENABLED(PROBE_USES_THERMISTOR)
+      SCAN_THERMISTOR_TABLE(PROBE_TEMPTABLE, PROBE_TEMPTABLE_LEN);
+    #elif ENABLED(PROBE_USES_AD595)
+      return TEMP_AD595(raw);
+    #elif ENABLED(PROBE_USES_AD8495)
+      return TEMP_AD8495(raw);
+    #else
+      UNUSED(raw);
+      return 0;
+    #endif
+  }
+#endif // HAS_TEMP_PROBE
+
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
@@ -1536,20 +1561,23 @@ void Temperature::updateTemperaturesFromRawValues() {
   #endif
   #if HOTENDS
     HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #endif
   #if HAS_HEATED_BED
     temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
     temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
+  #if HAS_TEMP_PROBE
+    temp_probe.celsius = analog_to_celsius_probe(temp_probe.raw);
+  #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filwidth.update_measured_mm();
   #endif
 
   // Reset the watchdog on good temperature measurement
   watchdog_refresh();
 
@@ -1714,20 +1742,23 @@ void Temperature::init() {
   #endif
   #if HAS_JOY_ADC_EN
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
   #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
+  #if HAS_TEMP_PROBE
+    HAL_ANALOG_SELECT(TEMP_PROBE_PIN);
+  #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
@@ -2208,20 +2239,24 @@ void Temperature::set_current_temp_raw() {
   #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
     temp_bed.update();
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.update();
   #endif
 
+  #if HAS_TEMP_PROBE
+    temp_probe.update();
+  #endif
+
   #if HAS_JOY_ADC_X
     joystick.x.update();
   #endif
   #if HAS_JOY_ADC_Y
     joystick.y.update();
   #endif
   #if HAS_JOY_ADC_Z
     joystick.z.update();
   #endif
 
@@ -2246,20 +2281,24 @@ void Temperature::readings_ready() {
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.reset();
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.reset();
   #endif
 
+  #if HAS_TEMP_PROBE
+    temp_probe.reset();
+  #endif
+
   #if HAS_JOY_ADC_X
     joystick.x.reset();
   #endif
   #if HAS_JOY_ADC_Y
     joystick.y.reset();
   #endif
   #if HAS_JOY_ADC_Z
     joystick.z.reset();
   #endif
 
@@ -2654,20 +2693,25 @@ void Temperature::tick() {
     #if HAS_HEATED_BED
       case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
       case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
       case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
+    #if HAS_TEMP_PROBE
+      case PrepareTemp_PROBE: HAL_START_ADC(TEMP_PROBE_PIN); break;
+      case MeasureTemp_PROBE: ACCUMULATE_ADC(temp_probe); break;
+    #endif
+
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
       case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2
       case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
       case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
@@ -2767,20 +2811,23 @@ void Temperature::tick() {
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const heater_ind_t e=INDEX_NONE
   ) {
     char k;
     switch (e) {
       #if HAS_TEMP_CHAMBER
         case H_CHAMBER: k = 'C'; break;
       #endif
+      #if HAS_TEMP_PROBE
+        case H_PROBE: k = 'P'; break;
+      #endif
       #if HAS_TEMP_HOTEND
         default: k = 'T'; break;
         #if HAS_HEATED_BED
           case H_BED: k = 'B'; break;
         #endif
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           case H_REDUNDANT: k = 'R'; break;
         #endif
       #elif HAS_HEATED_BED
         default: k = 'B'; break;
@@ -2835,20 +2882,28 @@ void Temperature::tick() {
           , degTargetChamber()
         #else
           , 0
         #endif
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawChamberTemp()
         #endif
         , H_CHAMBER
       );
     #endif // HAS_TEMP_CHAMBER
+    #if HAS_TEMP_PROBE
+      print_heater_state(degProbe(), 0
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , rawProbeTemp()
+        #endif
+        , H_PROBE
+      );
+    #endif // HAS_TEMP_PROBE
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , (heater_ind_t)e
       );
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_ind_t)target_extruder));
     #if HAS_HEATED_BED

commit c305c2cc6bb71283bf675e92c120aa99ceb030b5
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Jan 14 23:55:26 2020 -0800

    Fix some warnings, Melzi pins

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1ff818bd2b..b110afb85a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2905,38 +2905,39 @@ void Temperature::tick() {
       #define MIN_COOLING_SLOPE_TIME 60
     #endif
 
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
+        bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degHotend(target_extruder);
         printerEventLEDs.onHotendHeatingStart();
       #endif
 
       float target_temp = -1.0, old_temp = 9999.0;
-      bool wants_to_cool = false, first_loop = true;
+      bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
           target_temp = degTargetHotend(target_extruder);
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
@@ -2975,42 +2976,42 @@ void Temperature::tick() {
             if (temp_diff < TEMP_WINDOW) {
               residency_start_ms = now;
               if (first_loop) residency_start_ms += (TEMP_RESIDENCY_TIME) * 1000UL;
             }
           }
           else if (temp_diff > TEMP_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
+          first_loop = false;
+
         #endif
 
         // Prevent a wait-forever situation if R is misused i.e. M109 R0
         if (wants_to_cool) {
           // break after MIN_COOLING_SLOPE_TIME seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
-        first_loop = false;
-
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         ui.reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onHeatingDone();
         #endif
       }
 
       return wait_for_heatup;
@@ -3144,29 +3145,30 @@ void Temperature::tick() {
     #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
       #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
       #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
     #endif
 
     bool Temperature::wait_for_chamber(const bool no_wait_for_cooling/*=true*/) {
       #if TEMP_CHAMBER_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
+        bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_CHAMBER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CHAMBER_CONDITIONS (wants_to_cool ? isCoolingChamber() : isHeatingChamber())
       #endif
 
       float target_temp = -1, old_temp = 9999;
-      bool wants_to_cool = false, first_loop = true;
+      bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetChamber()) {
@@ -3205,35 +3207,33 @@ void Temperature::tick() {
             if (temp_diff < TEMP_CHAMBER_WINDOW) {
               residency_start_ms = now;
               if (first_loop) residency_start_ms += (TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL;
             }
           }
           else if (temp_diff > TEMP_CHAMBER_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
+          first_loop = false;
         #endif // TEMP_CHAMBER_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M191 R0
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_CHAMBER)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER;
             old_temp = temp;
           }
         }
-
-        first_loop = false;
-
       } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
       return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_CHAMBER
 
 #endif // HAS_TEMP_SENSOR

commit 2d7f94cae1d7d69665813ceff33ba834a182f8f7
Author: Dennis <16547088+soligen2010@users.noreply.github.com>
Date:   Wed Jan 15 19:06:03 2020 -0500

    Adjustable ADC debounce delay (#16264)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 056847fb34..1ff818bd2b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2705,41 +2705,44 @@ void Temperature::tick() {
       case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
       case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
     #endif
 
     #if HAS_JOY_ADC_Z
       case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
       case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
     #endif
 
     #if HAS_ADC_BUTTONS
+      #ifndef ADC_BUTTON_DEBOUNCE_DELAY
+        #define ADC_BUTTON_DEBOUNCE_DELAY 16
+      #endif
       case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
-        else if (ADCKey_count < 16) {
+        else if (ADCKey_count < ADC_BUTTON_DEBOUNCE_DELAY) {
           raw_ADCKey_value = HAL_READ_ADC();
           if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
           else { //ADC Key release
             if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
             if (ADCKey_pressed) {
               ADCKey_count = 0;
               current_ADCKey_raw = HAL_ADC_RANGE;
             }
           }
         }
-        if (ADCKey_count == 16) ADCKey_pressed = true;
+        if (ADCKey_count == ADC_BUTTON_DEBOUNCE_DELAY) ADCKey_pressed = true;
         break;
-    #endif // ADC_KEYPAD
+    #endif // HAS_ADC_BUTTONS
 
     case StartupDelay: break;
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks

commit e593da1c23a4759f6591826f815a504f0272e21a
Author: George Fu <nailao_5918@163.com>
Date:   Sat Jan 4 11:00:44 2020 +0800

    Update and fix DGUS (#16317)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 93b15310a3..056847fb34 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -25,20 +25,23 @@
  */
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../MarlinCore.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../lcd/extensible_ui/ui_api.h"
+#endif
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include "Adafruit_MAX31865.h"
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
     #define MAX31865_MOSI_PIN   MOSI_PIN        //            63
   #endif
   #ifndef MAX31865_MISO_PIN
@@ -392,20 +395,23 @@ volatile bool Temperature::temp_meas_ready = false;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
       SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::OnPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
+      #endif
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
@@ -505,20 +511,23 @@ volatile bool Temperature::temp_meas_ready = false;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::OnPidTuning(ExtUI::result_t::PID_TEMP_TOO_HIGH);
+        #endif
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
@@ -547,20 +556,23 @@ volatile bool Temperature::temp_meas_ready = false;
               _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::OnPidTuning(ExtUI::result_t::PID_TUNING_TIMEOUT);
+        #endif
         SERIAL_ECHOLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), NUL_STR);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
@@ -595,31 +607,37 @@ volatile bool Temperature::temp_meas_ready = false;
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onPidTuningDone(color);
         #endif
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::OnPidTuning(ExtUI::result_t::PID_DONE);
+        #endif
 
         goto EXIT_M303;
       }
       ui.update();
     }
 
     disable_all_heaters();
 
     #if ENABLED(PRINTER_EVENT_LEDS)
       printerEventLEDs.onPidTuningDone(color);
     #endif
+    #if ENABLED(EXTENSIBLE_UI)
+      ExtUI::OnPidTuning(ExtUI::result_t::PID_DONE);
+    #endif
 
     EXIT_M303:
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         adaptive_fan_slowing = true;
       #endif
       return;
   }
 
 #endif // HAS_PID_HEATING
 

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index daaa008bf9..93b15310a3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -20,21 +20,21 @@
  *
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
 #include "temperature.h"
 #include "endstops.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include "Adafruit_MAX31865.h"
   #ifndef MAX31865_CS_PIN
     #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif

commit 5a98c83eef09daf5f59e08c8518827861eb92e21
Author: Bob <bob808@users.noreply.github.com>
Date:   Wed Nov 27 09:45:03 2019 +0200

    Use MAX6675 SPI pins for MAX31865 over SPI pins (#16024)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9c9037bd57..daaa008bf9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -29,33 +29,33 @@
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 
 #if ENABLED(MAX6675_IS_MAX31865)
   #include "Adafruit_MAX31865.h"
   #ifndef MAX31865_CS_PIN
-    #define MAX31865_CS_PIN     CS_PIN      // HW:49   SW:65    for example
+    #define MAX31865_CS_PIN     MAX6675_SS_PIN  // HW:49   SW:65    for example
   #endif
   #ifndef MAX31865_MOSI_PIN
-    #define MAX31865_MOSI_PIN   MOSI_PIN    //            63
+    #define MAX31865_MOSI_PIN   MOSI_PIN        //            63
   #endif
   #ifndef MAX31865_MISO_PIN
-    #define MAX31865_MISO_PIN   MISO_PIN    //            42
+    #define MAX31865_MISO_PIN   MAX6675_DO_PIN  //            42
   #endif
   #ifndef MAX31865_SCK_PIN
-    #define MAX31865_SCK_PIN    SCK_PIN     //            40
+    #define MAX31865_SCK_PIN    MAX6675_SCK_PIN //            40
   #endif
   Adafruit_MAX31865 max31865 = Adafruit_MAX31865(MAX31865_CS_PIN
-    #if MAX31865_CS_PIN != CS_PIN
+    #if MAX31865_CS_PIN != MAX6675_SS_PIN
       , MAX31865_MOSI_PIN           // For software SPI also set MOSI/MISO/SCK
       , MAX31865_MISO_PIN
       , MAX31865_SCK_PIN
     #endif
   );
 #endif
 
 #define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PIN_EXISTS(MAX6675_SCK, MAX6675_DO))
 
 #if MAX6675_SEPARATE_SPI

commit ff6518c0a891b5de5ef8d1aacff8be6228fe1104
Author: haschtl <haschtl@protonmail.com>
Date:   Tue Nov 26 10:34:43 2019 +0100

    Add PID_FAN_SCALING option (#15585)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 57c8b76671..9c9037bd57 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -865,20 +865,29 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
               }
               else
                 lpq[lpq_ptr] = 0;
 
               if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
               work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
               pid_output += work_pid[ee].Kc;
             }
           #endif // PID_EXTRUSION_SCALING
 
+          #if ENABLED(PID_FAN_SCALING)
+            if (thermalManager.fan_speed[active_extruder] > PID_FAN_SCALING_MIN_SPEED) {
+              work_pid[ee].Kf = PID_PARAM(Kf, ee) + (PID_FAN_SCALING_LIN_FACTOR) * thermalManager.fan_speed[active_extruder];
+              pid_output += work_pid[ee].Kf;
+            }
+            //pid_output -= work_pid[ee].Ki;
+            //pid_output += work_pid[ee].Ki * work_pid[ee].Kf
+          #endif // PID_FAN_SCALING
+
           LIMIT(pid_output, 0, PID_MAX);
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 

commit 751cd1f53306cdbdd98e108af144201a6624a14b
Author: Bob <bob808@users.noreply.github.com>
Date:   Thu Nov 21 11:15:10 2019 +0200

    MAX31865 temperature sensor (#15930)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f48ce8e572..57c8b76671 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -26,20 +26,43 @@
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 
+#if ENABLED(MAX6675_IS_MAX31865)
+  #include "Adafruit_MAX31865.h"
+  #ifndef MAX31865_CS_PIN
+    #define MAX31865_CS_PIN     CS_PIN      // HW:49   SW:65    for example
+  #endif
+  #ifndef MAX31865_MOSI_PIN
+    #define MAX31865_MOSI_PIN   MOSI_PIN    //            63
+  #endif
+  #ifndef MAX31865_MISO_PIN
+    #define MAX31865_MISO_PIN   MISO_PIN    //            42
+  #endif
+  #ifndef MAX31865_SCK_PIN
+    #define MAX31865_SCK_PIN    SCK_PIN     //            40
+  #endif
+  Adafruit_MAX31865 max31865 = Adafruit_MAX31865(MAX31865_CS_PIN
+    #if MAX31865_CS_PIN != CS_PIN
+      , MAX31865_MOSI_PIN           // For software SPI also set MOSI/MISO/SCK
+      , MAX31865_MISO_PIN
+      , MAX31865_SCK_PIN
+    #endif
+  );
+#endif
+
 #define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PIN_EXISTS(MAX6675_SCK, MAX6675_DO))
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if EITHER(BABYSTEPPING, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
@@ -1349,21 +1372,27 @@ void Temperature::manage_heater() {
         SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
         kill();
         return 0.0;
       }
 
     switch (e) {
       case 0:
         #if ENABLED(HEATER_0_USER_THERMISTOR)
           return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
         #elif ENABLED(HEATER_0_USES_MAX6675)
-          return raw * 0.25;
+          return (
+            #if ENABLED(MAX6675_IS_MAX31865)
+              max31865.temperature(100, 400)  // 100 ohms = PT100 resistance. 400 ohms = calibration resistor
+            #else
+              raw * 0.25
+            #endif
+          );
         #elif ENABLED(HEATER_0_USES_AD595)
           return TEMP_AD595(raw);
         #elif ENABLED(HEATER_0_USES_AD8495)
           return TEMP_AD8495(raw);
         #else
           break;
         #endif
       case 1:
         #if ENABLED(HEATER_1_USER_THERMISTOR)
           return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
@@ -1531,20 +1560,24 @@ void Temperature::updateTemperaturesFromRawValues() {
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
+  #if ENABLED(MAX6675_IS_MAX31865)
+    max31865.begin(MAX31865_2WIRE); // MAX31865_2WIRE, MAX31865_3WIRE, MAX31865_4WIRE
+  #endif
+
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
     #define _AD(N) (ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495))
     #if _AD(0) || _AD(1) || _AD(2) || _AD(3) || _AD(4) || _AD(5) || _AD(BED) || _AD(CHAMBER)
       // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
@@ -2026,20 +2059,24 @@ void Temperature::disable_all_heaters() {
       return int(
         #if COUNT_6675 == 1
           max6675_temp
         #else
           max6675_temp_previous[hindex] // Need to return the correct previous value
         #endif
       );
 
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
+    #if ENABLED(MAX6675_IS_MAX31865)
+      max6675_temp = int(max31865.temperature(100, 400)); // 100 ohms = PT100 resistance. 400 ohms = calibration resistor
+    #endif
+
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
     #if COUNT_6675 > 1
       #define WRITE_MAX6675(V) do{ switch (hindex) { case 1: WRITE(MAX6675_SS2_PIN, V); break; default: WRITE(MAX6675_SS_PIN, V); } }while(0)

commit ac71cdc265374717c067102b2bc22af002c86ee3
Author: Lino Barreca <linobarreca@hotmail.com>
Date:   Wed Nov 13 02:23:02 2019 +0100

    New HardwareTimer for STM32 5.7.0 (#15655)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9f0f05263b..f48ce8e572 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2283,21 +2283,21 @@ void Temperature::readings_ready() {
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
  *  - Call planner.tick to count down its "ignore" time
  */
 HAL_TEMP_TIMER_ISR() {
   HAL_timer_isr_prologue(TEMP_TIMER_NUM);
 
-  Temperature::isr();
+  Temperature::tick();
 
   HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
 }
 
 #if ENABLED(SLOW_PWM_HEATERS) && !defined(MIN_STATE_TIME)
   #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
 #endif
 
 class SoftPWM {
 public:
@@ -2313,25 +2313,35 @@ public:
       const bool rdy = !state_timer_heater;
       if (rdy && state_heater != v) {
         state_heater = v;
         state_timer_heater = MIN_STATE_TIME;
       }
       return rdy;
     }
   #endif
 };
 
-void Temperature::isr() {
+/**
+ * Handle various ~1KHz tasks associated with temperature
+ *  - Heater PWM (~1KHz with scaler)
+ *  - LCD Button polling (~500Hz)
+ *  - Start / Read one ADC sensor
+ *  - Advance Babysteps
+ *  - Endstop polling
+ *  - Planner clean buffer
+ */
+void Temperature::tick() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
+
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;
   #endif
 
   #if HOTENDS
     static SoftPWM soft_pwm_hotend[HOTENDS];

commit 776632c503540c3bd2061b1b0812c091b3a4f6b4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 9 17:59:04 2019 -0600

    Add and apply REPEAT macro (#15829)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 447dc96a63..9f0f05263b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -621,45 +621,45 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   }
 }
 
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
 
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
-    #define _EFAN(A,B) _EFANOVERLAP(A,B) ? B :
+    #define _EFAN(B,A) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HOTENDS > 1
-        , _EFAN(1,0) 1
-      #endif
-      #if HOTENDS > 2
-        , _EFAN(2,0) _EFAN(2,1) 2
-      #endif
-      #if HOTENDS > 3
-        , _EFAN(3,0) _EFAN(3,1) _EFAN(3,2) 3
-      #endif
-      #if HOTENDS > 4
-        , _EFAN(4,0) _EFAN(4,1) _EFAN(4,2) _EFAN(4,3) 4
-      #endif
-      #if HOTENDS > 5
-        , _EFAN(5,0) _EFAN(5,1) _EFAN(5,2) _EFAN(5,3) _EFAN(5,4) 5
+        , REPEAT2(1,_EFAN,1) 1
+        #if HOTENDS > 2
+          , REPEAT2(2,_EFAN,2) 2
+          #if HOTENDS > 3
+            , REPEAT2(3,_EFAN,3) 3
+            #if HOTENDS > 4
+              , REPEAT2(4,_EFAN,4) 4
+              #if HOTENDS > 5
+                , REPEAT2(5,_EFAN,5) 5
+              #endif
+            #endif
+          #endif
+        #endif
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
-        , _CFAN(0) _CFAN(1) _CFAN(2) _CFAN(3) _CFAN(4) _CFAN(5) 6
+        , REPEAT(HOTENDS,_CFAN) (HOTENDS)
       #endif
     };
-    uint8_t fanState = 0;
 
+    uint8_t fanState = 0;
     HOTEND_LOOP()
       if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                  \
@@ -1946,36 +1946,21 @@ void Temperature::disable_all_heaters() {
     pause(false);
   #endif
 
   #define DISABLE_HEATER(NR) { \
     setTargetHotend(0, NR); \
     temp_hotend[NR].soft_pwm_amount = 0; \
     WRITE_HEATER_ ##NR (LOW); \
   }
 
   #if HAS_TEMP_HOTEND
-    DISABLE_HEATER(0);
-    #if HOTENDS > 1
-      DISABLE_HEATER(1);
-      #if HOTENDS > 2
-        DISABLE_HEATER(2);
-        #if HOTENDS > 3
-          DISABLE_HEATER(3);
-          #if HOTENDS > 4
-            DISABLE_HEATER(4);
-            #if HOTENDS > 5
-              DISABLE_HEATER(5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
+    REPEAT(HOTENDS, DISABLE_HEATER);
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.target = 0;
     temp_bed.soft_pwm_amount = 0;
     WRITE_HEATER_BED(LOW);
   #endif
 
   #if HAS_HEATED_CHAMBER
     temp_chamber.target = 0;
@@ -2216,36 +2201,28 @@ void Temperature::readings_ready() {
 
   #if HOTENDS
 
     static constexpr int8_t temp_dir[] = {
       #if ENABLED(HEATER_0_USES_MAX6675)
         0
       #else
         TEMPDIR(0)
       #endif
       #if HOTENDS > 1
+        #define _TEMPDIR(N) , TEMPDIR(N)
         #if ENABLED(HEATER_1_USES_MAX6675)
           , 0
         #else
-          , TEMPDIR(1)
+          _TEMPDIR(1)
         #endif
         #if HOTENDS > 2
-          , TEMPDIR(2)
-          #if HOTENDS > 3
-            , TEMPDIR(3)
-            #if HOTENDS > 4
-              , TEMPDIR(4)
-              #if HOTENDS > 5
-                , TEMPDIR(5)
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
+          REPEAT_S(2, HOTENDS, _TEMPDIR)
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
     };
 
     for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
       const int8_t tdir = temp_dir[e];
       if (tdir) {
         const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
         const bool heater_on = (temp_hotend[e].target > 0
           #if ENABLED(PIDTEMP)
@@ -2384,38 +2361,23 @@ void Temperature::isr() {
       }while(0)
     #endif
 
     /**
      * Standard heater PWM modulation
      */
     if (pwm_count_tmp >= 127) {
       pwm_count_tmp -= 127;
 
       #if HOTENDS
-        #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N])
-        _PWM_MOD_E(0);
-        #if HOTENDS > 1
-          _PWM_MOD_E(1);
-          #if HOTENDS > 2
-            _PWM_MOD_E(2);
-            #if HOTENDS > 3
-              _PWM_MOD_E(3);
-              #if HOTENDS > 4
-                _PWM_MOD_E(4);
-                #if HOTENDS > 5
-                  _PWM_MOD_E(5);
-                #endif // HOTENDS > 5
-              #endif // HOTENDS > 4
-            #endif // HOTENDS > 3
-          #endif // HOTENDS > 2
-        #endif // HOTENDS > 1
-      #endif // HOTENDS
+        #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N]);
+        REPEAT(HOTENDS, _PWM_MOD_E);
+      #endif
 
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
@@ -2431,38 +2393,23 @@ void Temperature::isr() {
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif
       #endif
     }
     else {
       #define _PWM_LOW(N,S) do{ if (S.count <= pwm_count_tmp) WRITE_HEATER_##N(LOW); }while(0)
       #if HOTENDS
-        #define _PWM_LOW_E(N) _PWM_LOW(N, soft_pwm_hotend[N])
-        _PWM_LOW_E(0);
-        #if HOTENDS > 1
-          _PWM_LOW_E(1);
-          #if HOTENDS > 2
-            _PWM_LOW_E(2);
-            #if HOTENDS > 3
-              _PWM_LOW_E(3);
-              #if HOTENDS > 4
-                _PWM_LOW_E(4);
-                #if HOTENDS > 5
-                  _PWM_LOW_E(5);
-                #endif // HOTENDS > 5
-              #endif // HOTENDS > 4
-            #endif // HOTENDS > 3
-          #endif // HOTENDS > 2
-        #endif // HOTENDS > 1
-      #endif // HOTENDS
+        #define _PWM_LOW_E(N) _PWM_LOW(N, soft_pwm_hotend[N]);
+        REPEAT(HOTENDS, _PWM_LOW_E);
+      #endif
 
       #if HAS_HEATED_BED
         _PWM_LOW(BED, soft_pwm_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_LOW(CHAMBER, soft_pwm_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
@@ -2497,64 +2444,34 @@ void Temperature::isr() {
      */
     #define _SLOW_SET(NR,PWM,V) do{ if (PWM.ready(V)) WRITE_HEATER_##NR(V); }while(0)
     #define _SLOW_PWM(NR,PWM,SRC) do{ PWM.count = SRC.soft_pwm_amount; _SLOW_SET(NR,PWM,(PWM.count > 0)); }while(0)
     #define _PWM_OFF(NR,PWM) do{ if (PWM.count < slow_pwm_count) _SLOW_SET(NR,PWM,0); }while(0)
 
     static uint8_t slow_pwm_count = 0;
 
     if (slow_pwm_count == 0) {
 
       #if HOTENDS
-        #define _SLOW_PWM_E(N) _SLOW_PWM(N, soft_pwm_hotend[N], temp_hotend[N])
-        _SLOW_PWM_E(0);
-        #if HOTENDS > 1
-          _SLOW_PWM_E(1);
-          #if HOTENDS > 2
-            _SLOW_PWM_E(2);
-            #if HOTENDS > 3
-              _SLOW_PWM_E(3);
-              #if HOTENDS > 4
-                _SLOW_PWM_E(4);
-                #if HOTENDS > 5
-                  _SLOW_PWM_E(5);
-                #endif // HOTENDS > 5
-              #endif // HOTENDS > 4
-            #endif // HOTENDS > 3
-          #endif // HOTENDS > 2
-        #endif // HOTENDS > 1
-      #endif // HOTENDS
+        #define _SLOW_PWM_E(N) _SLOW_PWM(N, soft_pwm_hotend[N], temp_hotend[N]);
+        REPEAT(HOTENDS, _SLOW_PWM_E);
+      #endif
 
       #if HAS_HEATED_BED
         _SLOW_PWM(BED, soft_pwm_bed, temp_bed);
       #endif
 
     } // slow_pwm_count == 0
 
     #if HOTENDS
       #define _PWM_OFF_E(N) _PWM_OFF(N, soft_pwm_hotend[N]);
-      _PWM_OFF_E(0);
-      #if HOTENDS > 1
-        _PWM_OFF_E(1);
-        #if HOTENDS > 2
-          _PWM_OFF_E(2);
-          #if HOTENDS > 3
-            _PWM_OFF_E(3);
-            #if HOTENDS > 4
-              _PWM_OFF_E(4);
-              #if HOTENDS > 5
-                _PWM_OFF_E(5);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
-    #endif // HOTENDS
+      REPEAT(HOTENDS, _PWM_OFF_E);
+    #endif
 
     #if HAS_HEATED_BED
       _PWM_OFF(BED, soft_pwm_bed);
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
         pwm_count_tmp = 0;
         #define _PWM_FAN(N) do{                                 \
           soft_pwm_count_fan[N] = soft_pwm_amount_fan[N] >> 1;  \
@@ -2591,37 +2508,22 @@ void Temperature::isr() {
     // 5:                /  4 = 244.1406 Hz
     pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
 
     // increment slow_pwm_count only every 64th pwm_count,
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
       #if HOTENDS
-        soft_pwm_hotend[0].dec();
-        #if HOTENDS > 1
-          soft_pwm_hotend[1].dec();
-          #if HOTENDS > 2
-            soft_pwm_hotend[2].dec();
-            #if HOTENDS > 3
-              soft_pwm_hotend[3].dec();
-              #if HOTENDS > 4
-                soft_pwm_hotend[4].dec();
-                #if HOTENDS > 5
-                  soft_pwm_hotend[5].dec();
-                #endif // HOTENDS > 5
-              #endif // HOTENDS > 4
-            #endif // HOTENDS > 3
-          #endif // HOTENDS > 2
-        #endif // HOTENDS > 1
-      #endif // HOTENDS
+        HOTEND_LOOP() soft_pwm_hotend[e].dec();
+      #endif
       #if HAS_HEATED_BED
         soft_pwm_bed.dec();
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //

commit a84e3d1b8049653345d694c1171d6d3491ebf618
Author: LinFor <linfor@gmail.com>
Date:   Thu Nov 7 02:49:17 2019 +0300

    Use native ADC resolution where possible (#15719)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 601e83ebd0..447dc96a63 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -295,21 +295,21 @@ volatile bool Temperature::temp_meas_ready = false;
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
-  uint32_t Temperature::current_ADCKey_raw = 1024;
+  uint32_t Temperature::current_ADCKey_raw = HAL_ADC_RANGE;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
@@ -1301,21 +1301,21 @@ void Temperature::manage_heater() {
     if (t.pre_calc) { // pre-calculate some variables
       t.pre_calc     = false;
       t.res_25_recip = 1.0f / t.res_25;
       t.res_25_log   = logf(t.res_25);
       t.beta_recip   = 1.0f / t.beta;
       t.sh_alpha     = RECIPROCAL(THERMISTOR_RESISTANCE_NOMINAL_C - (THERMISTOR_ABS_ZERO_C))
                         - (t.beta_recip * t.res_25_log) - (t.sh_c_coeff * cu(t.res_25_log));
     }
 
     // maximum adc value .. take into account the over sampling
-    const int adc_max = (THERMISTOR_ADC_RESOLUTION * OVERSAMPLENR) - 1,
+    const int adc_max = MAX_RAW_THERMISTOR_VALUE,
               adc_raw = constrain(raw, 1, adc_max - 1); // constrain to prevent divide-by-zero
 
     const float adc_inverse = (adc_max - adc_raw) - 0.5f,
                 resistance = t.series_res * (adc_raw + 0.5f) / adc_inverse,
                 log_resistance = logf(resistance);
 
     float value = t.sh_alpha;
     value += log_resistance * t.beta_recip;
     if (t.sh_c_coeff != 0)
       value += t.sh_c_coeff * cu(log_resistance);
@@ -2735,29 +2735,29 @@ void Temperature::isr() {
       case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
     #endif
 
     #if HAS_ADC_BUTTONS
       case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < 16) {
           raw_ADCKey_value = HAL_READ_ADC();
-          if (raw_ADCKey_value <= 900) {
+          if (raw_ADCKey_value <= 900UL * HAL_ADC_RANGE / 1024UL) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
           else { //ADC Key release
             if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
             if (ADCKey_pressed) {
               ADCKey_count = 0;
-              current_ADCKey_raw = 1024;
+              current_ADCKey_raw = HAL_ADC_RANGE;
             }
           }
         }
         if (ADCKey_count == 16) ADCKey_pressed = true;
         break;
     #endif // ADC_KEYPAD
 
     case StartupDelay: break;
 
   } // switch(adc_sensor_state)

commit 15f94e5ee5eb35aab7d8121eeabf2b1b01104f43
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 2 07:09:57 2019 -0500

    Add NUL_STR global

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6f62854e83..601e83ebd0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -532,21 +532,21 @@ volatile bool Temperature::temp_meas_ready = false;
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_ECHOLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
-          const char * const estring = GHV(PSTR("bed"), PSTR(""));
+          const char * const estring = GHV(PSTR("bed"), NUL_STR);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #elif ENABLED(PIDTEMP)
           say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #else
           say_default_(); SERIAL_ECHOLNPAIR("bedKp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("bedKi ", tune_pid.Ki);

commit 7d24f152d8c44b08730091cebe069238d347053b
Author: LinFor <linfor@gmail.com>
Date:   Wed Oct 30 23:10:08 2019 +0300

    Fix a typo breaking the build (#15726)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c33efb4030..6f62854e83 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -759,21 +759,21 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
     static millis_t expire_ms;
     switch (killed) {
       case 0:
         expire_ms = ms + BOGUS_TEMPERATURE_GRACE_PERIOD;
         ++killed;
         break;
       case 1:
         if (ELAPSED(ms, expire_ms)) ++killed;
         break;
       case 2:
-        loud_kill(lcd_msg1, heater);
+        loud_kill(lcd_msg, heater);
         ++killed;
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
     if (!killed) { killed = 1; loud_kill(lcd_msg, heater); }
   #endif
 }
 

commit 0d7736d6636760a4fd706aab3558e5ea67487e14
Author: Bo Herrmannsen <bo.herrmannsen@gmail.com>
Date:   Wed Oct 16 22:02:37 2019 +0200

    Enable M191 (#15531)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e1cd9c5619..c33efb4030 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -3153,21 +3153,21 @@ void Temperature::isr() {
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
       return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_BED
 
-  #if 0 && HAS_HEATED_CHAMBER
+  #if HAS_HEATED_CHAMBER
 
     #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
       #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
       #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
     #endif
 
     bool Temperature::wait_for_chamber(const bool no_wait_for_cooling/*=true*/) {
       #if TEMP_CHAMBER_RESIDENCY_TIME > 0

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ba4aec0155..e1cd9c5619 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -87,31 +87,31 @@
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
-  #define _BED_PSTR(M,E) (E) == H_BED ? PSTR(M) :
+  #define _BED_PSTR(h) (h) == H_BED ? GET_TEXT(MSG_BED) :
 #else
-  #define _BED_PSTR(M,E)
+  #define _BED_PSTR(h)
 #endif
 #if HAS_HEATED_CHAMBER
-  #define _CHAMBER_PSTR(M,E) (E) == H_CHAMBER ? PSTR(M) :
+  #define _CHAMBER_PSTR(h) (h) == H_CHAMBER ? GET_TEXT(MSG_CHAMBER) :
 #else
-  #define _CHAMBER_PSTR(M,E)
+  #define _CHAMBER_PSTR(h)
 #endif
-#define _E_PSTR(M,E,N) ((HOTENDS) > (N) && (E) == (N)) ? PSTR(LCD_STR_E##N " " M) :
-#define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,1) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) PSTR(LCD_STR_E0 " " M)
+#define _E_PSTR(h,N) ((HOTENDS) > N && (h) == N) ? PSTR(LCD_STR_E##N) :
+#define HEATER_PSTR(h) _BED_PSTR(h) _CHAMBER_PSTR(h) _E_PSTR(h,1) _E_PSTR(h,2) _E_PSTR(h,3) _E_PSTR(h,4) _E_PSTR(h,5) PSTR(LCD_STR_E0)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HOTENDS
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
 #endif
@@ -511,24 +511,24 @@ volatile bool Temperature::temp_meas_ready = false;
               isbed
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current_temp > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current_temp + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
                 if (current_temp > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
-                _temp_error(heater, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, heater));
+                _temp_error(heater, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
             }
             else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater));
+              _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_ECHOLNPGM(MSG_PID_TIMEOUT);
@@ -614,59 +614,48 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
     #endif
     default:
       #if HOTENDS
         return temp_hotend[heater_id].soft_pwm_amount;
       #else
         return 0;
       #endif
   }
 }
 
+#define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
+
 #if HAS_AUTO_FAN
 
-  #define AUTO_1_IS_0 (E1_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
-  #define AUTO_2_IS_0 (E2_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
-  #define AUTO_2_IS_1 (E2_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
-  #define AUTO_3_IS_0 (E3_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
-  #define AUTO_3_IS_1 (E3_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
-  #define AUTO_3_IS_2 (E3_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
-  #define AUTO_4_IS_0 (E4_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
-  #define AUTO_4_IS_1 (E4_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
-  #define AUTO_4_IS_2 (E4_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
-  #define AUTO_4_IS_3 (E4_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
-  #define AUTO_5_IS_0 (E5_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
-  #define AUTO_5_IS_1 (E5_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
-  #define AUTO_5_IS_2 (E5_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
-  #define AUTO_5_IS_3 (E5_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
-  #define AUTO_5_IS_4 (E5_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
+    #define _EFAN(A,B) _EFANOVERLAP(A,B) ? B :
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HOTENDS > 1
-        , AUTO_1_IS_0 ? 0 : 1
+        , _EFAN(1,0) 1
       #endif
       #if HOTENDS > 2
-        , AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 : 2
+        , _EFAN(2,0) _EFAN(2,1) 2
       #endif
       #if HOTENDS > 3
-        , AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 : 3
+        , _EFAN(3,0) _EFAN(3,1) _EFAN(3,2) 3
       #endif
       #if HOTENDS > 4
-        , AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
+        , _EFAN(4,0) _EFAN(4,1) _EFAN(4,2) _EFAN(4,3) 4
       #endif
       #if HOTENDS > 5
-        , AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
+        , _EFAN(5,0) _EFAN(5,1) _EFAN(5,2) _EFAN(5,3) _EFAN(5,4) 5
       #endif
       #if HAS_AUTO_CHAMBER_FAN
-        , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
+        #define _CFAN(B) _FANOVERLAP(CHAMBER,B) ? B :
+        , _CFAN(0) _CFAN(1) _CFAN(2) _CFAN(3) _CFAN(4) _CFAN(5) 6
       #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
@@ -724,30 +713,30 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
-inline void loud_kill(PGM_P const lcd_msg) {
+inline void loud_kill(PGM_P const lcd_msg, const heater_ind_t heater) {
   Running = false;
   #if USE_BEEPER
     for (uint8_t i = 20; i--;) {
       WRITE(BEEPER_PIN, HIGH); delay(25);
       WRITE(BEEPER_PIN, LOW); delay(80);
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
-  kill(lcd_msg);
+  kill(lcd_msg, HEATER_PSTR(heater));
 }
 
 void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
 
   static uint8_t killed = 0;
 
   if (IsRunning()
     #if BOGUS_TEMPERATURE_GRACE_PERIOD
       && killed == 2
     #endif
@@ -770,37 +759,37 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
     static millis_t expire_ms;
     switch (killed) {
       case 0:
         expire_ms = ms + BOGUS_TEMPERATURE_GRACE_PERIOD;
         ++killed;
         break;
       case 1:
         if (ELAPSED(ms, expire_ms)) ++killed;
         break;
       case 2:
-        loud_kill(lcd_msg);
+        loud_kill(lcd_msg1, heater);
         ++killed;
         break;
     }
   #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
   #else
-    if (!killed) { killed = 1; loud_kill(lcd_msg); }
+    if (!killed) { killed = 1; loud_kill(lcd_msg, heater); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
-  _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
+  _temp_error(heater, PSTR(MSG_T_MAXTEMP), GET_TEXT(MSG_ERR_MAXTEMP));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
-  _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
+  _temp_error(heater, PSTR(MSG_T_MINTEMP), GET_TEXT(MSG_ERR_MINTEMP));
 }
 
 #if HOTENDS
 
   float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
@@ -1012,48 +1001,48 @@ void Temperature::manage_heater() {
     if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   millis_t ms = millis();
 
   #if HOTENDS
 
     HOTEND_LOOP() {
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         if (degHotend(e) > temp_range[e].maxtemp)
-          _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
+          _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
       #endif
 
       #if HEATER_IDLE_HANDLER
         hotend_idle[e].update(ms);
       #endif
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         // Check for thermal runaway
         thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
       #endif
 
       temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
       #if WATCH_HOTENDS
         // Make sure temperature is increasing
         if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
           if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
-            _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
+            _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
           else                                                                 // Start again if the target is still far off
             start_watching_hotend(e);
         }
       #endif
 
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         // Make sure measured temperatures are close together
         if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
-          _temp_error(H_E0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
+          _temp_error(H_E0, PSTR(MSG_REDUNDANCY), GET_TEXT(MSG_ERR_REDUNDANT_TEMP));
       #endif
 
     } // HOTEND_LOOP
 
   #endif // HOTENDS
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
@@ -1065,28 +1054,28 @@ void Temperature::manage_heater() {
      * Dynamically set the volumetric multiplier based
      * on the delayed Filament Width measurement.
      */
     filwidth.update_volumetric();
   #endif
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP)
-        _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_BED));
+        _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
-          _temp_error(H_BED, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_BED));
+          _temp_error(H_BED, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
           #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
@@ -1143,28 +1132,28 @@ void Temperature::manage_heater() {
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (degChamber() > CHAMBER_MAXTEMP)
-        _temp_error(H_CHAMBER, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_CHAMBER));
+        _temp_error(H_CHAMBER, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
-          _temp_error(H_CHAMBER, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_CHAMBER));
+          _temp_error(H_CHAMBER, PSTR(MSG_T_HEATING_FAILED), GET_TEXT(MSG_HEATING_FAILED_LCD));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
         #if ENABLED(CHAMBER_LIMIT_SWITCHING)
@@ -1678,33 +1667,33 @@ void Temperature::init() {
   #if HAS_ADC_BUTTONS
     HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
   #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
-  #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
+  #if HAS_AUTO_FAN_1 && !_EFANOVERLAP(1,0)
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif
-  #if HAS_AUTO_FAN_2 && !(AUTO_2_IS_0 || AUTO_2_IS_1)
+  #if HAS_AUTO_FAN_2 && !(_EFANOVERLAP(2,0) || _EFANOVERLAP(2,1))
     INIT_E_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
   #endif
-  #if HAS_AUTO_FAN_3 && !(AUTO_3_IS_0 || AUTO_3_IS_1 || AUTO_3_IS_2)
+  #if HAS_AUTO_FAN_3 && !(_EFANOVERLAP(3,0) || _EFANOVERLAP(3,1) || _EFANOVERLAP(3,2))
     INIT_E_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
   #endif
-  #if HAS_AUTO_FAN_4 && !(AUTO_4_IS_0 || AUTO_4_IS_1 || AUTO_4_IS_2 || AUTO_4_IS_3)
+  #if HAS_AUTO_FAN_4 && !(_EFANOVERLAP(4,0) || _EFANOVERLAP(4,1) || _EFANOVERLAP(4,2) || _EFANOVERLAP(4,3))
     INIT_E_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
   #endif
-  #if HAS_AUTO_FAN_5 && !(AUTO_5_IS_0 || AUTO_5_IS_1 || AUTO_5_IS_2 || AUTO_5_IS_3 || AUTO_5_IS_4)
+  #if HAS_AUTO_FAN_5 && !(_EFANOVERLAP(5,0) || _EFANOVERLAP(5,1) || _EFANOVERLAP(5,2) || _EFANOVERLAP(5,3) || _EFANOVERLAP(5,4))
     INIT_E_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
     INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HOTENDS
@@ -1921,21 +1910,21 @@ void Temperature::init() {
         #endif
 
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
           sm.timer = millis() + period_seconds * 1000UL;
           break;
         }
         else if (PENDING(millis(), sm.timer)) break;
         sm.state = TRRunaway;
 
       case TRRunaway:
-        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater_id));
+        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), GET_TEXT(MSG_THERMAL_RUNAWAY));
     }
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif
@@ -2916,21 +2905,21 @@ void Temperature::isr() {
 
   #if HOTENDS && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       ui.status_printf_P(0,
         #if HOTENDS > 1
           PSTR("E%c " S_FMT), '1' + e
         #else
           PSTR("E " S_FMT)
         #endif
-        , heating ? PSTR(MSG_HEATING) : PSTR(MSG_COOLING)
+        , heating ? GET_TEXT(MSG_HEATING) : GET_TEXT(MSG_COOLING)
       );
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME

commit cc822c1a0513362e28f1b3aff76d4c4c06446f01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 19:44:33 2019 -0500

    Use lambdas in menus, where possible (#15452)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e689b94071..ba4aec0155 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -96,22 +96,22 @@ Temperature thermalManager;
 #if HAS_HEATED_BED
   #define _BED_PSTR(M,E) (E) == H_BED ? PSTR(M) :
 #else
   #define _BED_PSTR(M,E)
 #endif
 #if HAS_HEATED_CHAMBER
   #define _CHAMBER_PSTR(M,E) (E) == H_CHAMBER ? PSTR(M) :
 #else
   #define _CHAMBER_PSTR(M,E)
 #endif
-#define _E_PSTR(M,E,N) ((HOTENDS) >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
-#define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
+#define _E_PSTR(M,E,N) ((HOTENDS) > (N) && (E) == (N)) ? PSTR(LCD_STR_E##N " " M) :
+#define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,1) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) PSTR(LCD_STR_E0 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 #if HOTENDS
   hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
 #endif
@@ -150,53 +150,38 @@ Temperature thermalManager;
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
     uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
   #endif
 
-  #if HAS_LCD_MENU
-
-    uint8_t Temperature::lcd_tmpfan_speed[
-      #if ENABLED(SINGLENOZZLE)
-        _MAX(EXTRUDERS, FAN_COUNT)
-      #else
-        FAN_COUNT
-      #endif
-    ]; // = { 0 }
-
-  #endif
-
   /**
    * Set the print fan speed for a target extruder
    */
   void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE)
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;
-    #if HAS_LCD_MENU
-      lcd_tmpfan_speed[target] = speed;
-    #endif
   }
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else

commit 43aba9f9180741daedf52b7fe716edcaf3b83ef0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Oct 6 01:27:03 2019 +0200

    Fix compile errors & temp range

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index eb37325da2..e689b94071 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -382,21 +382,21 @@ volatile bool Temperature::temp_meas_ready = false;
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
-    if (target > GHV(BED_MAXTEMP, temp_range[heater].maxtemp) - 15) {
+    if (target > GHV(BED_MAXTEMP - 10, temp_range[heater].maxtemp - 15)) {
       SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
@@ -850,21 +850,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
           temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
           work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
           work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
 
           pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
 
           #if ENABLED(PID_EXTRUSION_SCALING)
             #if HOTENDS == 1
               constexpr bool this_hotend = true;
             #else
-              const bool this_hotend = (e == active_extruder);
+              const bool this_hotend = (ee == active_extruder);
             #endif
             work_pid[ee].Kc = 0;
             if (this_hotend) {
               const long e_position = stepper.position(E_AXIS);
               if (e_position > last_e_position) {
                 lpq[lpq_ptr] = e_position - last_e_position;
                 last_e_position = e_position;
               }
               else
                 lpq[lpq_ptr] = 0;
@@ -879,21 +879,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         }
         temp_dState[ee] = temp_hotend[ee].celsius;
 
       #else // PID_OPENLOOP
 
         const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
       #endif // PID_OPENLOOP
 
       #if ENABLED(PID_DEBUG)
-        if (e == active_extruder) {
+        if (ee == active_extruder) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(
             MSG_PID_DEBUG, ee,
             MSG_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
             MSG_PID_DEBUG_OUTPUT, pid_output
           );
           #if DISABLED(PID_OPENLOOP)
           {
             SERIAL_ECHOPAIR(
               MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,

commit e3fd0519b323182a3d096eca8209c4eaf56b6802
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:44:07 2019 -0500

    Reduce need for UNUSED

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 79825ec518..eb37325da2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -806,27 +806,21 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }
 
 #if HOTENDS
 
-  float Temperature::get_pid_output_hotend(const uint8_t e) {
-    #if HOTENDS == 1
-      #define _HOTEND_TEST true
-    #else
-      #define _HOTEND_TEST (e == active_extruder)
-    #endif
-    E_UNUSED();
+  float Temperature::get_pid_output_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
 
         float pid_output;
@@ -853,22 +847,27 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
 
           work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
           const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
           temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
           work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
           work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
 
           pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
 
           #if ENABLED(PID_EXTRUSION_SCALING)
+            #if HOTENDS == 1
+              constexpr bool this_hotend = true;
+            #else
+              const bool this_hotend = (e == active_extruder);
+            #endif
             work_pid[ee].Kc = 0;
-            if (_HOTEND_TEST) {
+            if (this_hotend) {
               const long e_position = stepper.position(E_AXIS);
               if (e_position > last_e_position) {
                 lpq[lpq_ptr] = e_position - last_e_position;
                 last_e_position = e_position;
               }
               else
                 lpq[lpq_ptr] = 0;
 
               if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
               work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
@@ -888,42 +887,43 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
 
       #if ENABLED(PID_DEBUG)
         if (e == active_extruder) {
           SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(
             MSG_PID_DEBUG, ee,
             MSG_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
             MSG_PID_DEBUG_OUTPUT, pid_output
           );
           #if DISABLED(PID_OPENLOOP)
+          {
             SERIAL_ECHOPAIR(
               MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
               MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
               MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
               #if ENABLED(PID_EXTRUSION_SCALING)
                 , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
               #endif
             );
+          }
           #endif
           SERIAL_EOL();
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
       #if HEATER_IDLE_HANDLER
-        #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
+        const bool is_idling = hotend_idle[ee].timed_out;
       #else
-        #define _TIMED_OUT_TEST false
+        constexpr bool is_idling = false;
       #endif
-      const float pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
-      #undef _TIMED_OUT_TEST
+      const float pid_output = (!is_idling && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
 
     #endif
 
     return pid_output;
   }
 
 #endif // HOTENDS
 
 #if ENABLED(PIDTEMPBED)
 
@@ -964,29 +964,31 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_BED_POWER), 0, MAX_BED_POWER);
       }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
+    {
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPAIR(
         " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output,
         #if DISABLED(PID_OPENLOOP)
           MSG_PID_DEBUG_PTERM, work_pid.Kp,
           MSG_PID_DEBUG_ITERM, work_pid.Ki,
           MSG_PID_DEBUG_DTERM, work_pid.Kd,
         #endif
       );
+    }
     #endif
 
     return pid_output;
   }
 
 #endif // PIDTEMPBED
 
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
@@ -1804,22 +1806,21 @@ void Temperature::init() {
     paused = false;
   #endif
 }
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
-  void Temperature::start_watching_hotend(const uint8_t e) {
-    E_UNUSED();
+  void Temperature::start_watching_hotend(const uint8_t E_NAME) {
     const uint8_t ee = HOTEND_INDEX;
     if (degTargetHotend(ee) && degHotend(ee) < degTargetHotend(ee) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
       watch_hotend[ee].target = degHotend(ee) + WATCH_TEMP_INCREASE;
       watch_hotend[ee].next_ms = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_hotend[ee].next_ms = 0;
   }
 #endif
 

commit 98f614ddb12429edceb4bc8e32dd574f653c5eb8
Author: LinFor <linfor@gmail.com>
Date:   Tue Oct 1 06:19:12 2019 +0300

    Use MAX_BED_POWER instead of BANG_MAX to heat outside PID_FUNCTIONAL_RANGE (#15431)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 47942441f6..79825ec518 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -936,21 +936,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
       static bool pid_reset = true;
       float pid_output = 0;
       const float max_power_over_i_gain = float(MAX_BED_POWER) / temp_bed.pid.Ki - float(MIN_BED_POWER),
                   pid_error = temp_bed.target - temp_bed.celsius;
 
       if (!temp_bed.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
         pid_output = 0;
         pid_reset = true;
       }
       else if (pid_error > PID_FUNCTIONAL_RANGE) {
-        pid_output = BANG_MAX;
+        pid_output = MAX_BED_POWER;
         pid_reset = true;
       }
       else {
         if (pid_reset) {
           temp_iState = 0.0;
           work_pid.Kd = 0.0;
           pid_reset = false;
         }
 
         temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);

commit 139b7196a0eb2cf74763c9879ff5e1e14ac935c3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 17:57:29 2019 -0500

    Watchdog cleanup (#15283)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c0a12c7ffa..47942441f6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -993,21 +993,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
-    if (!inited) return watchdog_reset();
+    if (!inited) return watchdog_refresh();
   #endif
 
   #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
@@ -1511,24 +1511,22 @@ void Temperature::updateTemperaturesFromRawValues() {
   #if HAS_TEMP_CHAMBER
     temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filwidth.update_measured_mm();
   #endif
 
-  #if ENABLED(USE_WATCHDOG)
-    // Reset the watchdog after we know we have a temperature measurement.
-    watchdog_reset();
-  #endif
+  // Reset the watchdog on good temperature measurement
+  watchdog_refresh();
 
   temp_meas_ready = false;
 }
 
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef ALFAWISE_UX0

commit 41ea2d8c31f10c09715079d7fc2d0dff1444a459
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Sep 28 22:37:41 2019 +0200

    Fix auto-fan compile error (#15402)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d637b68d7b..c0a12c7ffa 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -658,24 +658,24 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   void Temperature::checkExtruderAutoFans() {
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HOTENDS > 1
         , AUTO_1_IS_0 ? 0 : 1
       #endif
       #if HOTENDS > 2
         , AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 : 2
       #endif
       #if HOTENDS > 3
-        , AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 : 3,
+        , AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 : 3
       #endif
       #if HOTENDS > 4
-        , AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4,
+        , AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
       #endif
       #if HOTENDS > 5
         , AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
       #endif
     };
     uint8_t fanState = 0;
 

commit a18d16fb8b92c78093e25f8bb88cd0a49074678e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Sep 27 03:38:43 2019 -0600

    Do not implicitly concatenate localized strings (#15383)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9542aa2ed2..d637b68d7b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2926,25 +2926,28 @@ void Temperature::isr() {
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if HOTENDS && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
-      #if HOTENDS > 1
-        ui.status_printf_P(0, heating ? PSTR("E%c " MSG_HEATING) : PSTR("E%c " MSG_COOLING), '1' + e);
-      #else
-        ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
-      #endif
+      ui.status_printf_P(0,
+        #if HOTENDS > 1
+          PSTR("E%c " S_FMT), '1' + e
+        #else
+          PSTR("E " S_FMT)
+        #endif
+        , heating ? PSTR(MSG_HEATING) : PSTR(MSG_COOLING)
+      );
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60

commit c3f09e2b1bde37bfec8e7de877571455d750c64c
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Sep 25 21:43:00 2019 +0700

    Set MAX_OVERSHOOT_PID_AUTOTUNE to 30 (#15257)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cda946dc98..9542aa2ed2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -493,21 +493,21 @@ volatile bool Temperature::temp_meas_ready = false;
             }
             SHV((bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             minT = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
-        #define MAX_OVERSHOOT_PID_AUTOTUNE 20
+        #define MAX_OVERSHOOT_PID_AUTOTUNE 30
       #endif
       if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);

commit 3819f7994539d962c6970df1f4251bf78bd451fc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 22:30:13 2019 -0500

    Fix pid_output declaration

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3147477357..cda946dc98 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -814,29 +814,30 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
 #if HOTENDS
 
   float Temperature::get_pid_output_hotend(const uint8_t e) {
     #if HOTENDS == 1
       #define _HOTEND_TEST true
     #else
       #define _HOTEND_TEST (e == active_extruder)
     #endif
     E_UNUSED();
     const uint8_t ee = HOTEND_INDEX;
-    float pid_output;
     #if ENABLED(PIDTEMP)
       #if DISABLED(PID_OPENLOOP)
         static hotend_pid_t work_pid[HOTENDS];
         static float temp_iState[HOTENDS] = { 0 },
                      temp_dState[HOTENDS] = { 0 };
         static bool pid_reset[HOTENDS] = { false };
         const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
 
+        float pid_output;
+
         if (temp_hotend[ee].target == 0
           || pid_error < -(PID_FUNCTIONAL_RANGE)
           #if HEATER_IDLE_HANDLER
             || hotend_idle[ee].timed_out
           #endif
         ) {
           pid_output = 0;
           pid_reset[ee] = true;
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
@@ -907,21 +908,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
         }
       #endif // PID_DEBUG
 
     #else // No PID enabled
 
       #if HEATER_IDLE_HANDLER
         #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
       #else
         #define _TIMED_OUT_TEST false
       #endif
-      pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
+      const float pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
       #undef _TIMED_OUT_TEST
 
     #endif
 
     return pid_output;
   }
 
 #endif // HOTENDS
 
 #if ENABLED(PIDTEMPBED)

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6388530af4..3147477357 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -238,21 +238,21 @@ Temperature thermalManager;
 #if HAS_TEMP_CHAMBER
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
     #endif
     #if WATCH_CHAMBER
-      heater_watch_t Temperature::watch_chamber = { 0 };
+      heater_watch_t Temperature::watch_chamber{0};
     #endif
     millis_t Temperature::next_chamber_check_ms;
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   //hotend_pid_t Temperature::pid[HOTENDS];
 #endif
 
@@ -923,21 +923,21 @@ void Temperature::min_temp_error(const heater_ind_t heater) {
   }
 
 #endif // HOTENDS
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
-      static PID_t work_pid = { 0 };
+      static PID_t work_pid{0};
       static float temp_iState = 0, temp_dState = 0;
       static bool pid_reset = true;
       float pid_output = 0;
       const float max_power_over_i_gain = float(MAX_BED_POWER) / temp_bed.pid.Ki - float(MIN_BED_POWER),
                   pid_error = temp_bed.target - temp_bed.celsius;
 
       if (!temp_bed.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
         pid_output = 0;
         pid_reset = true;
       }

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6f46a86ef5..6388530af4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1313,41 +1313,42 @@ void Temperature::manage_heater() {
 
   float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
     //#endif
 
     if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
 
-    if (user_thermistor[t_index].pre_calc) {
-      // pre-calculate some variables
-      user_thermistor[t_index].pre_calc = false;
-      user_thermistor[t_index].res_25_recip = 1.0f / user_thermistor[t_index].res_25;
-      user_thermistor[t_index].res_25_log = logf(user_thermistor[t_index].res_25);
-      user_thermistor[t_index].beta_recip = 1.0f / user_thermistor[t_index].beta;
-      user_thermistor[t_index].sh_alpha = (1.0f / (THERMISTOR_RESISTANCE_NOMINAL_C - THERMISTOR_ABS_ZERO_C)) - (user_thermistor[t_index].beta_recip * user_thermistor[t_index].res_25_log) - (user_thermistor[t_index].sh_c_coeff * user_thermistor[t_index].res_25_log * user_thermistor[t_index].res_25_log * user_thermistor[t_index].res_25_log);
+    user_thermistor_t &t = user_thermistor[t_index];
+    if (t.pre_calc) { // pre-calculate some variables
+      t.pre_calc     = false;
+      t.res_25_recip = 1.0f / t.res_25;
+      t.res_25_log   = logf(t.res_25);
+      t.beta_recip   = 1.0f / t.beta;
+      t.sh_alpha     = RECIPROCAL(THERMISTOR_RESISTANCE_NOMINAL_C - (THERMISTOR_ABS_ZERO_C))
+                        - (t.beta_recip * t.res_25_log) - (t.sh_c_coeff * cu(t.res_25_log));
     }
 
     // maximum adc value .. take into account the over sampling
     const int adc_max = (THERMISTOR_ADC_RESOLUTION * OVERSAMPLENR) - 1,
               adc_raw = constrain(raw, 1, adc_max - 1); // constrain to prevent divide-by-zero
 
     const float adc_inverse = (adc_max - adc_raw) - 0.5f,
-                resistance = user_thermistor[t_index].series_res * (adc_raw + 0.5f) / adc_inverse,
+                resistance = t.series_res * (adc_raw + 0.5f) / adc_inverse,
                 log_resistance = logf(resistance);
 
-    float value = user_thermistor[t_index].sh_alpha;
-    value += log_resistance * user_thermistor[t_index].beta_recip;
-    if (user_thermistor[t_index].sh_c_coeff != 0)
-      value += user_thermistor[t_index].sh_c_coeff * log_resistance * log_resistance * log_resistance;
+    float value = t.sh_alpha;
+    value += log_resistance * t.beta_recip;
+    if (t.sh_c_coeff != 0)
+      value += t.sh_c_coeff * cu(log_resistance);
     value = 1.0f / value;
 
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  int32_t clocks = TCNT5 - tcnt5;
     //  if (clocks >= 0) {
     //    clocks_total += clocks;
     //    calls++;
     //  }
     //#endif
 

commit 75927e17dd2114c14a593c12394d941eff684685
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:48:58 2019 -0500

    Filament Width Sensor singleton (#15191)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 2f64652879..6f46a86ef5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -294,37 +294,29 @@ volatile bool Temperature::temp_meas_ready = false;
 #endif
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #ifdef MILLISECONDS_PREHEAT_TIME
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
-#endif
-
 #if HAS_AUTO_FAN
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
-#endif
-
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = 1024;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
@@ -1075,30 +1067,25 @@ void Temperature::manage_heater() {
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     /**
-     * Filament Width Sensor dynamically sets the volumetric multiplier
-     * based on a delayed measurement of the filament diameter.
+     * Dynamically set the volumetric multiplier based
+     * on the delayed Filament Width measurement.
      */
-    if (filament_sensor) {
-      meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
-      if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
-      LIMIT(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
-      planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
-    }
-  #endif // FILAMENT_WIDTH_SENSOR
+    filwidth.update_volumetric();
+  #endif
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (degBed() > BED_MAXTEMP)
         _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_BED));
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
@@ -1519,55 +1506,31 @@ void Temperature::updateTemperaturesFromRawValues() {
   #if HAS_HEATED_BED
     temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
     temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    filament_width_meas = analog_to_mm_fil_width();
+    filwidth.update_measured_mm();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();
   #endif
 
   temp_meas_ready = false;
 }
 
-
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-
-  // Convert raw Filament Width to millimeters
-  float Temperature::analog_to_mm_fil_width() {
-    return current_raw_filwidth * 5.0f * (1.0f / 16383.0f);
-  }
-
-  /**
-   * Convert Filament Width (mm) to a simple ratio
-   * and reduce to an 8 bit value.
-   *
-   * A nominal width of 1.75 and measured width of 1.73
-   * gives (100 * 1.75 / 1.73) for a ratio of 101 and
-   * a return value of 1.
-   */
-  int8_t Temperature::widthFil_to_size_ratio() {
-    if (ABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
-      return int(100.0f * filament_width_nominal / filament_width_meas) - 100;
-    return 0;
-  }
-
-#endif
-
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
 #ifdef ALFAWISE_UX0
   #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
 #else
   #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
 #endif
@@ -2234,32 +2197,28 @@ void Temperature::set_current_temp_raw() {
   #if HAS_JOY_ADC_Y
     joystick.y.update();
   #endif
   #if HAS_JOY_ADC_Z
     joystick.z.update();
   #endif
 
   temp_meas_ready = true;
 }
 
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  uint32_t raw_filwidth_value; // = 0
-#endif
-
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
+    filwidth.reading_ready();
   #endif
 
   #if HOTENDS
     HOTEND_LOOP() temp_hotend[e].reset();
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       temp_hotend[1].reset();
     #endif
   #endif
 
   #if HAS_HEATED_BED
@@ -2774,24 +2733,22 @@ void Temperature::isr() {
     #if HAS_TEMP_ADC_5
       case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
       case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
-        else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
-          raw_filwidth_value -= raw_filwidth_value >> 7; // Subtract 1/128th of the raw_filwidth_value
-          raw_filwidth_value += uint32_t(HAL_READ_ADC()) << 7; // Add new ADC reading, scaled by 128
-        }
+        else
+          filwidth.accumulate(HAL_READ_ADC());
       break;
     #endif
 
     #if HAS_JOY_ADC_X
       case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
       case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
     #endif
 
     #if HAS_JOY_ADC_Y
       case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4cac00371f..2f64652879 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -105,25 +105,23 @@ Temperature thermalManager;
 #endif
 #define _E_PSTR(M,E,N) ((HOTENDS) >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
 #define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
-hotend_info_t Temperature::temp_hotend[HOTENDS
-  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    + 1
-  #endif
-]; // = { 0 }
+#if HOTENDS
+  hotend_info_t Temperature::temp_hotend[HOTEND_TEMPS]; // = { 0 }
+#endif
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if FAN_COUNT > 0
@@ -276,29 +274,31 @@ hotend_info_t Temperature::temp_hotend[HOTENDS
 
 volatile bool Temperature::temp_meas_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
   lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
 #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) < (HEATER_##N##_RAW_HI_TEMP) ? 1 : -1)
 
-// Init mintemp and maxtemp with extreme values to prevent false errors during startup
-constexpr temp_range_t sensor_heater_0 { HEATER_0_RAW_LO_TEMP, HEATER_0_RAW_HI_TEMP, 0, 16383 },
-                       sensor_heater_1 { HEATER_1_RAW_LO_TEMP, HEATER_1_RAW_HI_TEMP, 0, 16383 },
-                       sensor_heater_2 { HEATER_2_RAW_LO_TEMP, HEATER_2_RAW_HI_TEMP, 0, 16383 },
-                       sensor_heater_3 { HEATER_3_RAW_LO_TEMP, HEATER_3_RAW_HI_TEMP, 0, 16383 },
-                       sensor_heater_4 { HEATER_4_RAW_LO_TEMP, HEATER_4_RAW_HI_TEMP, 0, 16383 },
-                       sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 };
+#if HOTENDS
+  // Init mintemp and maxtemp with extreme values to prevent false errors during startup
+  constexpr temp_range_t sensor_heater_0 { HEATER_0_RAW_LO_TEMP, HEATER_0_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_1 { HEATER_1_RAW_LO_TEMP, HEATER_1_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_2 { HEATER_2_RAW_LO_TEMP, HEATER_2_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_3 { HEATER_3_RAW_LO_TEMP, HEATER_3_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_4 { HEATER_4_RAW_LO_TEMP, HEATER_4_RAW_HI_TEMP, 0, 16383 },
+                         sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 };
 
-temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5);
+  temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5);
+#endif
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #ifdef MILLISECONDS_PREHEAT_TIME
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
@@ -620,31 +620,34 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
       #endif
       return;
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
-Temperature::Temperature() { }
-
 int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   switch (heater_id) {
-    default: return temp_hotend[heater_id].soft_pwm_amount;
     #if HAS_HEATED_BED
       case H_BED: return temp_bed.soft_pwm_amount;
     #endif
     #if HAS_HEATED_CHAMBER
       case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
+    default:
+      #if HOTENDS
+        return temp_hotend[heater_id].soft_pwm_amount;
+      #else
+        return 0;
+      #endif
   }
 }
 
 #if HAS_AUTO_FAN
 
   #define AUTO_1_IS_0 (E1_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_2_IS_0 (E2_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_2_IS_1 (E2_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_3_IS_0 (E3_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_3_IS_1 (E3_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
@@ -809,128 +812,132 @@ void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg,
 }
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }
 
-float Temperature::get_pid_output_hotend(const uint8_t e) {
-  #if HOTENDS == 1
-    #define _HOTEND_TEST true
-  #else
-    #define _HOTEND_TEST (e == active_extruder)
-  #endif
-  E_UNUSED();
-  const uint8_t ee = HOTEND_INDEX;
-  float pid_output;
-  #if ENABLED(PIDTEMP)
-    #if DISABLED(PID_OPENLOOP)
-      static hotend_pid_t work_pid[HOTENDS];
-      static float temp_iState[HOTENDS] = { 0 },
-                   temp_dState[HOTENDS] = { 0 };
-      static bool pid_reset[HOTENDS] = { false };
-      const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
-
-      if (temp_hotend[ee].target == 0
-        || pid_error < -(PID_FUNCTIONAL_RANGE)
-        #if HEATER_IDLE_HANDLER
-          || hotend_idle[ee].timed_out
-        #endif
-      ) {
-        pid_output = 0;
-        pid_reset[ee] = true;
-      }
-      else if (pid_error > PID_FUNCTIONAL_RANGE) {
-        pid_output = BANG_MAX;
-        pid_reset[ee] = true;
-      }
-      else {
-        if (pid_reset[ee]) {
-          temp_iState[ee] = 0.0;
-          work_pid[ee].Kd = 0.0;
-          pid_reset[ee] = false;
+#if HOTENDS
+
+  float Temperature::get_pid_output_hotend(const uint8_t e) {
+    #if HOTENDS == 1
+      #define _HOTEND_TEST true
+    #else
+      #define _HOTEND_TEST (e == active_extruder)
+    #endif
+    E_UNUSED();
+    const uint8_t ee = HOTEND_INDEX;
+    float pid_output;
+    #if ENABLED(PIDTEMP)
+      #if DISABLED(PID_OPENLOOP)
+        static hotend_pid_t work_pid[HOTENDS];
+        static float temp_iState[HOTENDS] = { 0 },
+                     temp_dState[HOTENDS] = { 0 };
+        static bool pid_reset[HOTENDS] = { false };
+        const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
+
+        if (temp_hotend[ee].target == 0
+          || pid_error < -(PID_FUNCTIONAL_RANGE)
+          #if HEATER_IDLE_HANDLER
+            || hotend_idle[ee].timed_out
+          #endif
+        ) {
+          pid_output = 0;
+          pid_reset[ee] = true;
         }
+        else if (pid_error > PID_FUNCTIONAL_RANGE) {
+          pid_output = BANG_MAX;
+          pid_reset[ee] = true;
+        }
+        else {
+          if (pid_reset[ee]) {
+            temp_iState[ee] = 0.0;
+            work_pid[ee].Kd = 0.0;
+            pid_reset[ee] = false;
+          }
 
-        work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
-        const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
-        temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
-        work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
-        work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
-
-        pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
-
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          work_pid[ee].Kc = 0;
-          if (_HOTEND_TEST) {
-            const long e_position = stepper.position(E_AXIS);
-            if (e_position > last_e_position) {
-              lpq[lpq_ptr] = e_position - last_e_position;
-              last_e_position = e_position;
-            }
-            else
-              lpq[lpq_ptr] = 0;
+          work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
+          const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
+          temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
+          work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
+          work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
+
+          pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
+
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            work_pid[ee].Kc = 0;
+            if (_HOTEND_TEST) {
+              const long e_position = stepper.position(E_AXIS);
+              if (e_position > last_e_position) {
+                lpq[lpq_ptr] = e_position - last_e_position;
+                last_e_position = e_position;
+              }
+              else
+                lpq[lpq_ptr] = 0;
 
-            if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-            work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
-            pid_output += work_pid[ee].Kc;
-          }
-        #endif // PID_EXTRUSION_SCALING
+              if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
+              work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
+              pid_output += work_pid[ee].Kc;
+            }
+          #endif // PID_EXTRUSION_SCALING
 
-        LIMIT(pid_output, 0, PID_MAX);
-      }
-      temp_dState[ee] = temp_hotend[ee].celsius;
+          LIMIT(pid_output, 0, PID_MAX);
+        }
+        temp_dState[ee] = temp_hotend[ee].celsius;
 
-    #else // PID_OPENLOOP
+      #else // PID_OPENLOOP
 
-      const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
+        const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
-    #endif // PID_OPENLOOP
+      #endif // PID_OPENLOOP
 
-    #if ENABLED(PID_DEBUG)
-      if (e == active_extruder) {
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPAIR(
-          MSG_PID_DEBUG, ee,
-          MSG_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
-          MSG_PID_DEBUG_OUTPUT, pid_output
-        );
-        #if DISABLED(PID_OPENLOOP)
+      #if ENABLED(PID_DEBUG)
+        if (e == active_extruder) {
+          SERIAL_ECHO_START();
           SERIAL_ECHOPAIR(
-            MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
-            MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
-            MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
-            #if ENABLED(PID_EXTRUSION_SCALING)
-              , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
-            #endif
+            MSG_PID_DEBUG, ee,
+            MSG_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
+            MSG_PID_DEBUG_OUTPUT, pid_output
           );
-        #endif
-        SERIAL_EOL();
-      }
-    #endif // PID_DEBUG
+          #if DISABLED(PID_OPENLOOP)
+            SERIAL_ECHOPAIR(
+              MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
+              MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
+              MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
+              #if ENABLED(PID_EXTRUSION_SCALING)
+                , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
+              #endif
+            );
+          #endif
+          SERIAL_EOL();
+        }
+      #endif // PID_DEBUG
 
-  #else // No PID enabled
+    #else // No PID enabled
+
+      #if HEATER_IDLE_HANDLER
+        #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
+      #else
+        #define _TIMED_OUT_TEST false
+      #endif
+      pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
+      #undef _TIMED_OUT_TEST
 
-    #if HEATER_IDLE_HANDLER
-      #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
-    #else
-      #define _TIMED_OUT_TEST false
     #endif
-    pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
-    #undef _TIMED_OUT_TEST
 
-  #endif
+    return pid_output;
+  }
 
-  return pid_output;
-}
+#endif // HOTENDS
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
       static PID_t work_pid = { 0 };
       static float temp_iState = 0, temp_dState = 0;
       static bool pid_reset = true;
@@ -1018,58 +1025,60 @@ void Temperature::manage_heater() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
     if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
     if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
-  #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
-    millis_t ms = millis();
-  #endif
+  millis_t ms = millis();
 
-  HOTEND_LOOP() {
-    #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-      if (degHotend(e) > temp_range[e].maxtemp)
-        _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
-    #endif
+  #if HOTENDS
 
-    #if HEATER_IDLE_HANDLER
-      hotend_idle[e].update(ms);
-    #endif
+    HOTEND_LOOP() {
+      #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+        if (degHotend(e) > temp_range[e].maxtemp)
+          _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
+      #endif
 
-    #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-      // Check for thermal runaway
-      thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
-    #endif
+      #if HEATER_IDLE_HANDLER
+        hotend_idle[e].update(ms);
+      #endif
 
-    temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
+      #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+        // Check for thermal runaway
+        thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+      #endif
 
-    #if WATCH_HOTENDS
-      // Make sure temperature is increasing
-      if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
-        if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
-          _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
-        else                                                                 // Start again if the target is still far off
-          start_watching_hotend(e);
-      }
-    #endif
+      temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      // Make sure measured temperatures are close together
-      if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
-        _temp_error(H_E0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
-    #endif
+      #if WATCH_HOTENDS
+        // Make sure temperature is increasing
+        if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
+          if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
+            _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
+          else                                                                 // Start again if the target is still far off
+            start_watching_hotend(e);
+        }
+      #endif
 
-  } // HOTEND_LOOP
+      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+        // Make sure measured temperatures are close together
+        if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
+          _temp_error(H_E0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
+      #endif
+
+    } // HOTEND_LOOP
+
+  #endif // HOTENDS
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     /**
@@ -1199,20 +1208,22 @@ void Temperature::manage_heater() {
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
         thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
     }
 
     // TODO: Implement true PID pwm
     //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
+
+  UNUSED(ms);
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
@@ -1351,112 +1362,114 @@ void Temperature::manage_heater() {
     //    clocks_total += clocks;
     //    calls++;
     //  }
     //#endif
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
     return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
-// Derived from RepRap FiveD extruder::getTemperature()
-// For hot end temperature measurement.
-float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
-  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    if (e > HOTENDS)
-  #else
-    if (e >= HOTENDS)
-  #endif
-    {
-      SERIAL_ERROR_START();
-      SERIAL_ECHO((int)e);
-      SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
-      kill();
-      return 0.0;
-    }
+#if HOTENDS
+  // Derived from RepRap FiveD extruder::getTemperature()
+  // For hot end temperature measurement.
+  float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      if (e > HOTENDS)
+    #else
+      if (e >= HOTENDS)
+    #endif
+      {
+        SERIAL_ERROR_START();
+        SERIAL_ECHO((int)e);
+        SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
+        kill();
+        return 0.0;
+      }
 
-  switch (e) {
-    case 0:
-      #if ENABLED(HEATER_0_USER_THERMISTOR)
-        return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
-      #elif ENABLED(HEATER_0_USES_MAX6675)
-        return raw * 0.25;
-      #elif ENABLED(HEATER_0_USES_AD595)
-        return TEMP_AD595(raw);
-      #elif ENABLED(HEATER_0_USES_AD8495)
-        return TEMP_AD8495(raw);
-      #else
-        break;
-      #endif
-    case 1:
-      #if ENABLED(HEATER_1_USER_THERMISTOR)
-        return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
-      #elif ENABLED(HEATER_1_USES_MAX6675)
-        return raw * 0.25;
-      #elif ENABLED(HEATER_1_USES_AD595)
-        return TEMP_AD595(raw);
-      #elif ENABLED(HEATER_1_USES_AD8495)
-        return TEMP_AD8495(raw);
-      #else
-        break;
-      #endif
-    case 2:
-      #if ENABLED(HEATER_2_USER_THERMISTOR)
-        return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
-      #elif ENABLED(HEATER_2_USES_AD595)
-        return TEMP_AD595(raw);
-      #elif ENABLED(HEATER_2_USES_AD8495)
-        return TEMP_AD8495(raw);
-      #else
-        break;
-      #endif
-    case 3:
-      #if ENABLED(HEATER_3_USER_THERMISTOR)
-        return user_thermistor_to_deg_c(CTI_HOTEND_3, raw);
-      #elif ENABLED(HEATER_3_USES_AD595)
-        return TEMP_AD595(raw);
-      #elif ENABLED(HEATER_3_USES_AD8495)
-        return TEMP_AD8495(raw);
-      #else
-        break;
-      #endif
-    case 4:
-      #if ENABLED(HEATER_4_USER_THERMISTOR)
-        return user_thermistor_to_deg_c(CTI_HOTEND_4, raw);
-      #elif ENABLED(HEATER_4_USES_AD595)
-        return TEMP_AD595(raw);
-      #elif ENABLED(HEATER_4_USES_AD8495)
-        return TEMP_AD8495(raw);
-      #else
-        break;
-      #endif
-    case 5:
-      #if ENABLED(HEATER_5_USER_THERMISTOR)
-        return user_thermistor_to_deg_c(CTI_HOTEND_5, raw);
-      #elif ENABLED(HEATER_5_USES_AD595)
-        return TEMP_AD595(raw);
-      #elif ENABLED(HEATER_5_USES_AD8495)
-        return TEMP_AD8495(raw);
-      #else
-        break;
-      #endif
-    default: break;
-  }
+    switch (e) {
+      case 0:
+        #if ENABLED(HEATER_0_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
+        #elif ENABLED(HEATER_0_USES_MAX6675)
+          return raw * 0.25;
+        #elif ENABLED(HEATER_0_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_0_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      case 1:
+        #if ENABLED(HEATER_1_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
+        #elif ENABLED(HEATER_1_USES_MAX6675)
+          return raw * 0.25;
+        #elif ENABLED(HEATER_1_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_1_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      case 2:
+        #if ENABLED(HEATER_2_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
+        #elif ENABLED(HEATER_2_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_2_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      case 3:
+        #if ENABLED(HEATER_3_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_3, raw);
+        #elif ENABLED(HEATER_3_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_3_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      case 4:
+        #if ENABLED(HEATER_4_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_4, raw);
+        #elif ENABLED(HEATER_4_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_4_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      case 5:
+        #if ENABLED(HEATER_5_USER_THERMISTOR)
+          return user_thermistor_to_deg_c(CTI_HOTEND_5, raw);
+        #elif ENABLED(HEATER_5_USES_AD595)
+          return TEMP_AD595(raw);
+        #elif ENABLED(HEATER_5_USES_AD8495)
+          return TEMP_AD8495(raw);
+        #else
+          break;
+        #endif
+      default: break;
+    }
 
-  #if HOTEND_USES_THERMISTOR
-    // Thermistor with conversion table?
-    const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
-    SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
-  #endif
+    #if HOTEND_USES_THERMISTOR
+      // Thermistor with conversion table?
+      const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
+      SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
+    #endif
 
-  return 0;
-}
+    return 0;
+  }
+#endif // HOTENDS
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
     #if ENABLED(HEATER_BED_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
@@ -1493,21 +1506,23 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
     temp_hotend[1].raw = READ_MAX6675(1);
   #endif
-  HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
+  #if HOTENDS
+    HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
+  #endif
   #if HAS_HEATED_BED
     temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
     temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
@@ -1795,21 +1810,21 @@ void Temperature::init() {
               #endif
               #ifdef HEATER_5_MAXTEMP
                 _TEMP_MAX_E(5);
               #endif
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
-  #endif // HOTENDS > 1
+  #endif // HOTENDS
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
     #ifdef BED_MAXTEMP
       while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
   #endif // HAS_HEATED_BED
 
@@ -1969,21 +1984,23 @@ void Temperature::init() {
   }
 
 #endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif
 
-  HOTEND_LOOP() setTargetHotend(0, e);
+  #if HOTENDS
+    HOTEND_LOOP() setTargetHotend(0, e);
+  #endif
 
   #if HAS_HEATED_BED
     setTargetBed(0);
   #endif
 
   #if HAS_HEATED_CHAMBER
     setTargetChamber(0);
   #endif
 
   // Unpause and reset everything
@@ -2231,92 +2248,98 @@ void Temperature::set_current_temp_raw() {
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
-  HOTEND_LOOP() temp_hotend[e].reset();
-  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    temp_hotend[1].reset();
+  #if HOTENDS
+    HOTEND_LOOP() temp_hotend[e].reset();
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      temp_hotend[1].reset();
+    #endif
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.reset();
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.reset();
   #endif
 
   #if HAS_JOY_ADC_X
     joystick.x.reset();
   #endif
   #if HAS_JOY_ADC_Y
     joystick.y.reset();
   #endif
   #if HAS_JOY_ADC_Z
     joystick.z.reset();
   #endif
 
-  static constexpr int8_t temp_dir[] = {
-    #if ENABLED(HEATER_0_USES_MAX6675)
-      0
-    #else
-      TEMPDIR(0)
-    #endif
-    #if HOTENDS > 1
-      #if ENABLED(HEATER_1_USES_MAX6675)
-        , 0
+  #if HOTENDS
+
+    static constexpr int8_t temp_dir[] = {
+      #if ENABLED(HEATER_0_USES_MAX6675)
+        0
       #else
-        , TEMPDIR(1)
+        TEMPDIR(0)
       #endif
-      #if HOTENDS > 2
-        , TEMPDIR(2)
-        #if HOTENDS > 3
-          , TEMPDIR(3)
-          #if HOTENDS > 4
-            , TEMPDIR(4)
-            #if HOTENDS > 5
-              , TEMPDIR(5)
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-  };
-
-  for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
-    const int8_t tdir = temp_dir[e];
-    if (tdir) {
-      const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
-      const bool heater_on = (temp_hotend[e].target > 0
-        #if ENABLED(PIDTEMP)
-          || temp_hotend[e].soft_pwm_amount > 0
+      #if HOTENDS > 1
+        #if ENABLED(HEATER_1_USES_MAX6675)
+          , 0
+        #else
+          , TEMPDIR(1)
         #endif
-      );
-      if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
-      if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
+        #if HOTENDS > 2
+          , TEMPDIR(2)
+          #if HOTENDS > 3
+            , TEMPDIR(3)
+            #if HOTENDS > 4
+              , TEMPDIR(4)
+              #if HOTENDS > 5
+                , TEMPDIR(5)
+              #endif // HOTENDS > 5
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+    };
+
+    for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
+      const int8_t tdir = temp_dir[e];
+      if (tdir) {
+        const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
+        const bool heater_on = (temp_hotend[e].target > 0
+          #if ENABLED(PIDTEMP)
+            || temp_hotend[e].soft_pwm_amount > 0
+          #endif
+        );
+        if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
+        if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
+          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+            if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+          #endif
+              min_temp_error((heater_ind_t)e);
+        }
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+          else
+            consecutive_low_temperature_error[e] = 0;
         #endif
-            min_temp_error((heater_ind_t)e);
       }
-      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-        else
-          consecutive_low_temperature_error[e] = 0;
-      #endif
     }
-  }
+
+  #endif // HOTENDS
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<=(B))
     #else
       #define BEDCMP(A,B) ((A)>=(B))
     #endif
     const bool bed_on = (temp_bed.target > 0)
       #if ENABLED(PIDTEMPBED)
         || (temp_bed.soft_pwm_amount > 0)
@@ -2392,69 +2415,73 @@ void Temperature::isr() {
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
     static bool ADCKey_pressed = false;
   #endif
 
-  #if ENABLED(SLOW_PWM_HEATERS)
-    static uint8_t slow_pwm_count = 0;
+  #if HOTENDS
+    static SoftPWM soft_pwm_hotend[HOTENDS];
   #endif
 
-  static SoftPWM soft_pwm_hotend[HOTENDS];
-
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
   #endif
 
   #if HAS_HEATED_CHAMBER
     static SoftPWM soft_pwm_chamber;
   #endif
 
   #if DISABLED(SLOW_PWM_HEATERS)
-    constexpr uint8_t pwm_mask =
-      #if ENABLED(SOFT_PWM_DITHER)
-        _BV(SOFT_PWM_SCALE) - 1
-      #else
-        0
-      #endif
-    ;
+
+    #if HOTENDS || HAS_HEATED_BED || HAS_HEATED_CHAMBER
+      constexpr uint8_t pwm_mask =
+        #if ENABLED(SOFT_PWM_DITHER)
+          _BV(SOFT_PWM_SCALE) - 1
+        #else
+          0
+        #endif
+      ;
+      #define _PWM_MOD(N,S,T) do{                           \
+        const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
+        WRITE_HEATER_##N(on);                               \
+      }while(0)
+    #endif
 
     /**
      * Standard heater PWM modulation
      */
     if (pwm_count_tmp >= 127) {
       pwm_count_tmp -= 127;
-      #define _PWM_MOD(N,S,T) do{                           \
-        const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
-        WRITE_HEATER_##N(on);                               \
-      }while(0)
-      #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N])
-      _PWM_MOD_E(0);
-      #if HOTENDS > 1
-        _PWM_MOD_E(1);
-        #if HOTENDS > 2
-          _PWM_MOD_E(2);
-          #if HOTENDS > 3
-            _PWM_MOD_E(3);
-            #if HOTENDS > 4
-              _PWM_MOD_E(4);
-              #if HOTENDS > 5
-                _PWM_MOD_E(5);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
+
+      #if HOTENDS
+        #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N])
+        _PWM_MOD_E(0);
+        #if HOTENDS > 1
+          _PWM_MOD_E(1);
+          #if HOTENDS > 2
+            _PWM_MOD_E(2);
+            #if HOTENDS > 3
+              _PWM_MOD_E(3);
+              #if HOTENDS > 4
+                _PWM_MOD_E(4);
+                #if HOTENDS > 5
+                  _PWM_MOD_E(5);
+                #endif // HOTENDS > 5
+              #endif // HOTENDS > 4
+            #endif // HOTENDS > 3
+          #endif // HOTENDS > 2
+        #endif // HOTENDS > 1
+      #endif // HOTENDS
 
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
@@ -2531,20 +2558,22 @@ void Temperature::isr() {
 
     /**
      * SLOW PWM HEATERS
      *
      * For relay-driven heaters
      */
     #define _SLOW_SET(NR,PWM,V) do{ if (PWM.ready(V)) WRITE_HEATER_##NR(V); }while(0)
     #define _SLOW_PWM(NR,PWM,SRC) do{ PWM.count = SRC.soft_pwm_amount; _SLOW_SET(NR,PWM,(PWM.count > 0)); }while(0)
     #define _PWM_OFF(NR,PWM) do{ if (PWM.count < slow_pwm_count) _SLOW_SET(NR,PWM,0); }while(0)
 
+    static uint8_t slow_pwm_count = 0;
+
     if (slow_pwm_count == 0) {
 
       #if HOTENDS
         #define _SLOW_PWM_E(N) _SLOW_PWM(N, soft_pwm_hotend[N], temp_hotend[N])
         _SLOW_PWM_E(0);
         #if HOTENDS > 1
           _SLOW_PWM_E(1);
           #if HOTENDS > 2
             _SLOW_PWM_E(2);
             #if HOTENDS > 3
@@ -2627,36 +2656,38 @@ void Temperature::isr() {
     // 4:                /  8 = 122.0703 Hz
     // 5:                /  4 = 244.1406 Hz
     pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
 
     // increment slow_pwm_count only every 64th pwm_count,
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
-      soft_pwm_hotend[0].dec();
-      #if HOTENDS > 1
-        soft_pwm_hotend[1].dec();
-        #if HOTENDS > 2
-          soft_pwm_hotend[2].dec();
-          #if HOTENDS > 3
-            soft_pwm_hotend[3].dec();
-            #if HOTENDS > 4
-              soft_pwm_hotend[4].dec();
-              #if HOTENDS > 5
-                soft_pwm_hotend[5].dec();
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
+      #if HOTENDS
+        soft_pwm_hotend[0].dec();
+        #if HOTENDS > 1
+          soft_pwm_hotend[1].dec();
+          #if HOTENDS > 2
+            soft_pwm_hotend[2].dec();
+            #if HOTENDS > 3
+              soft_pwm_hotend[3].dec();
+              #if HOTENDS > 4
+                soft_pwm_hotend[4].dec();
+                #if HOTENDS > 5
+                  soft_pwm_hotend[5].dec();
+                #endif // HOTENDS > 5
+              #endif // HOTENDS > 4
+            #endif // HOTENDS > 3
+          #endif // HOTENDS > 2
+        #endif // HOTENDS > 1
+      #endif // HOTENDS
       #if HAS_HEATED_BED
         soft_pwm_bed.dec();
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
@@ -2933,21 +2964,21 @@ void Temperature::isr() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         PORT_REDIRECT(SERIAL_BOTH);
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
-  #if HAS_DISPLAY
+  #if HOTENDS && HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
         ui.status_printf_P(0, heating ? PSTR("E%c " MSG_HEATING) : PSTR("E%c " MSG_COOLING), '1' + e);
       #else
         ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 

commit 565a0e11ed2d386ef343bf68274334c884dc6dbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 9 02:56:23 2019 -0500

    Prevent 'current' name conflict, if needed

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index db584f17a4..4cac00371f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -339,21 +339,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
    * temperature to succeed.
    */
   void Temperature::PID_autotune(const float &target, const heater_ind_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
-    float current = 0.0;
+    float current_temp = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float maxT = 0, minT = 10000;
 
@@ -403,63 +403,63 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = GHV(temp_bed.current, temp_hotend[heater].current);
+      const float start_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
       adaptive_fan_slowing = false;
     #endif
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current = GHV(temp_bed.current, temp_hotend[heater].current);
-        NOLESS(maxT, current);
-        NOMORE(minT, current);
+        current_temp = GHV(temp_bed.celsius, temp_hotend[heater].celsius);
+        NOLESS(maxT, current_temp);
+        NOMORE(minT, current_temp);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
-          ONHEATING(start_temp, current, target);
+          ONHEATING(start_temp, current_temp, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
-        if (heating && current > target) {
+        if (heating && current_temp > target) {
           if (ELAPSED(ms, t2 + 5000UL)) {
             heating = false;
             SHV((bias - d) >> 1, (bias - d) >> 1);
             t1 = ms;
             t_high = t1 - t2;
             maxT = target;
           }
         }
 
-        if (!heating && current < target) {
+        if (!heating && current_temp < target) {
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               LIMIT(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
@@ -503,21 +503,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
             cycles++;
             minT = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
-      if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
+      if (current_temp > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
@@ -528,29 +528,29 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
           if (
             #if WATCH_BED && WATCH_HOTENDS
               true
             #elif WATCH_HOTENDS
               !isbed
             #else
               isbed
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
-              if (current > next_watch_temp) {                      // Over the watch temp?
-                next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
+              if (current_temp > next_watch_temp) {                      // Over the watch temp?
+                next_watch_temp = current_temp + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
-                if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
+                if (current_temp > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
                 _temp_error(heater, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, heater));
             }
-            else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
+            else if (current_temp < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
               _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
@@ -678,25 +678,25 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
       #if HOTENDS > 5
         , AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
       #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
-      if (temp_hotend[e].current >= EXTRUDER_AUTO_FAN_TEMPERATURE)
+      if (temp_hotend[e].celsius >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_AUTO_CHAMBER_FAN
-      if (temp_chamber.current >= CHAMBER_AUTO_FAN_TEMPERATURE)
+      if (temp_chamber.celsius >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                  \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)          \
         analogWrite(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
       else                                               \
         WRITE(P##_AUTO_FAN_PIN, D);                      \
     }while(0)
 
@@ -824,21 +824,21 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
   #endif
   E_UNUSED();
   const uint8_t ee = HOTEND_INDEX;
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       static hotend_pid_t work_pid[HOTENDS];
       static float temp_iState[HOTENDS] = { 0 },
                    temp_dState[HOTENDS] = { 0 };
       static bool pid_reset[HOTENDS] = { false };
-      const float pid_error = temp_hotend[ee].target - temp_hotend[ee].current;
+      const float pid_error = temp_hotend[ee].target - temp_hotend[ee].celsius;
 
       if (temp_hotend[ee].target == 0
         || pid_error < -(PID_FUNCTIONAL_RANGE)
         #if HEATER_IDLE_HANDLER
           || hotend_idle[ee].timed_out
         #endif
       ) {
         pid_output = 0;
         pid_reset[ee] = true;
       }
@@ -846,21 +846,21 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
         pid_output = BANG_MAX;
         pid_reset[ee] = true;
       }
       else {
         if (pid_reset[ee]) {
           temp_iState[ee] = 0.0;
           work_pid[ee].Kd = 0.0;
           pid_reset[ee] = false;
         }
 
-        work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].current) - work_pid[ee].Kd);
+        work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].celsius) - work_pid[ee].Kd);
         const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
         temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
         work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
         work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
 
         pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
 
         #if ENABLED(PID_EXTRUSION_SCALING)
           work_pid[ee].Kc = 0;
           if (_HOTEND_TEST) {
@@ -873,34 +873,34 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
               lpq[lpq_ptr] = 0;
 
             if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
             work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
             pid_output += work_pid[ee].Kc;
           }
         #endif // PID_EXTRUSION_SCALING
 
         LIMIT(pid_output, 0, PID_MAX);
       }
-      temp_dState[ee] = temp_hotend[ee].current;
+      temp_dState[ee] = temp_hotend[ee].celsius;
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       if (e == active_extruder) {
         SERIAL_ECHO_START();
         SERIAL_ECHOPAIR(
           MSG_PID_DEBUG, ee,
-          MSG_PID_DEBUG_INPUT, temp_hotend[ee].current,
+          MSG_PID_DEBUG_INPUT, temp_hotend[ee].celsius,
           MSG_PID_DEBUG_OUTPUT, pid_output
         );
         #if DISABLED(PID_OPENLOOP)
           SERIAL_ECHOPAIR(
             MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
             MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
             MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
             #if ENABLED(PID_EXTRUSION_SCALING)
               , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
             #endif
@@ -910,77 +910,77 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
       }
     #endif // PID_DEBUG
 
   #else // No PID enabled
 
     #if HEATER_IDLE_HANDLER
       #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
     #else
       #define _TIMED_OUT_TEST false
     #endif
-    pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].current < temp_hotend[ee].target) ? BANG_MAX : 0;
+    pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].celsius < temp_hotend[ee].target) ? BANG_MAX : 0;
     #undef _TIMED_OUT_TEST
 
   #endif
 
   return pid_output;
 }
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
       static PID_t work_pid = { 0 };
       static float temp_iState = 0, temp_dState = 0;
       static bool pid_reset = true;
       float pid_output = 0;
       const float max_power_over_i_gain = float(MAX_BED_POWER) / temp_bed.pid.Ki - float(MIN_BED_POWER),
-                  pid_error = temp_bed.target - temp_bed.current;
+                  pid_error = temp_bed.target - temp_bed.celsius;
 
       if (!temp_bed.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
         pid_output = 0;
         pid_reset = true;
       }
       else if (pid_error > PID_FUNCTIONAL_RANGE) {
         pid_output = BANG_MAX;
         pid_reset = true;
       }
       else {
         if (pid_reset) {
           temp_iState = 0.0;
           work_pid.Kd = 0.0;
           pid_reset = false;
         }
 
         temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
 
         work_pid.Kp = temp_bed.pid.Kp * pid_error;
         work_pid.Ki = temp_bed.pid.Ki * temp_iState;
-        work_pid.Kd = work_pid.Kd + PID_K2 * (temp_bed.pid.Kd * (temp_dState - temp_bed.current) - work_pid.Kd);
+        work_pid.Kd = work_pid.Kd + PID_K2 * (temp_bed.pid.Kd * (temp_dState - temp_bed.celsius) - work_pid.Kd);
 
-        temp_dState = temp_bed.current;
+        temp_dState = temp_bed.celsius;
 
         pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_BED_POWER), 0, MAX_BED_POWER);
       }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPAIR(
-        " PID_BED_DEBUG : Input ", temp_bed.current, " Output ", pid_output,
+        " PID_BED_DEBUG : Input ", temp_bed.celsius, " Output ", pid_output,
         #if DISABLED(PID_OPENLOOP)
           MSG_PID_DEBUG_PTERM, work_pid.Kp,
           MSG_PID_DEBUG_ITERM, work_pid.Ki,
           MSG_PID_DEBUG_DTERM, work_pid.Kd,
         #endif
       );
     #endif
 
     return pid_output;
   }
@@ -1009,63 +1009,63 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (temp_hotend[0].current > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
-    if (temp_hotend[0].current < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
+    if (temp_hotend[0].celsius > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
+    if (temp_hotend[0].celsius < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
-    if (temp_hotend[1].current > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
-    if (temp_hotend[1].current < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
+    if (temp_hotend[1].celsius > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
+    if (temp_hotend[1].celsius < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   HOTEND_LOOP() {
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       if (degHotend(e) > temp_range[e].maxtemp)
         _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
     #endif
 
     #if HEATER_IDLE_HANDLER
       hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
-      thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+      thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].celsius, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
-    temp_hotend[e].soft_pwm_amount = (temp_hotend[e].current > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].current < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
+    temp_hotend[e].soft_pwm_amount = (temp_hotend[e].celsius > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].celsius < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
     #if WATCH_HOTENDS
       // Make sure temperature is increasing
       if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
         if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
           _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
         else                                                                 // Start again if the target is still far off
           start_watching_hotend(e);
       }
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       // Make sure measured temperatures are close together
-      if (ABS(temp_hotend[0].current - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
+      if (ABS(temp_hotend[0].celsius - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
         _temp_error(H_E0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
     #endif
 
   } // HOTEND_LOOP
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
@@ -1113,45 +1113,45 @@ void Temperature::manage_heater() {
         #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
           last_pause_state = paused;
         #endif
       #endif
 
       #if HEATER_IDLE_HANDLER
         bed_idle.update(ms);
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
-        thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
+        thermal_runaway_protection(tr_state_machine_bed, temp_bed.celsius, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
       #endif
 
       #if HEATER_IDLE_HANDLER
         if (bed_idle.timed_out) {
           temp_bed.soft_pwm_amount = 0;
           #if DISABLED(PIDTEMPBED)
             WRITE_HEATER_BED(LOW);
           #endif
         }
         else
       #endif
       {
         #if ENABLED(PIDTEMPBED)
-          temp_bed.soft_pwm_amount = WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
+          temp_bed.soft_pwm_amount = WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
         #else
           // Check if temperature is within the correct band
-          if (WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP)) {
+          if (WITHIN(temp_bed.celsius, BED_MINTEMP, BED_MAXTEMP)) {
             #if ENABLED(BED_LIMIT_SWITCHING)
-              if (temp_bed.current >= temp_bed.target + BED_HYSTERESIS)
+              if (temp_bed.celsius >= temp_bed.target + BED_HYSTERESIS)
                 temp_bed.soft_pwm_amount = 0;
-              else if (temp_bed.current <= temp_bed.target - (BED_HYSTERESIS))
+              else if (temp_bed.celsius <= temp_bed.target - (BED_HYSTERESIS))
                 temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
             #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
-              temp_bed.soft_pwm_amount = temp_bed.current < temp_bed.target ? MAX_BED_POWER >> 1 : 0;
+              temp_bed.soft_pwm_amount = temp_bed.celsius < temp_bed.target ? MAX_BED_POWER >> 1 : 0;
             #endif
           }
           else {
             temp_bed.soft_pwm_amount = 0;
             WRITE_HEATER_BED(LOW);
           }
         #endif
       }
 
     } while (false);
@@ -1175,42 +1175,42 @@ void Temperature::manage_heater() {
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
           _temp_error(H_CHAMBER, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_CHAMBER));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
-      if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
+      if (WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
         #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-          if (temp_chamber.current >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
+          if (temp_chamber.celsius >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
             temp_chamber.soft_pwm_amount = 0;
-          else if (temp_chamber.current <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
+          else if (temp_chamber.celsius <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
             temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
         #else
-          temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
+          temp_chamber.soft_pwm_amount = temp_chamber.celsius < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
         #endif
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.celsius, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
     }
 
     // TODO: Implement true PID pwm
-    //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
+    //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.celsius, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
@@ -1493,26 +1493,26 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
     temp_hotend[1].raw = READ_MAX6675(1);
   #endif
-  HOTEND_LOOP() temp_hotend[e].current = analog_to_celsius_hotend(temp_hotend[e].raw, e);
+  HOTEND_LOOP() temp_hotend[e].celsius = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #if HAS_HEATED_BED
-    temp_bed.current = analog_to_celsius_bed(temp_bed.raw);
+    temp_bed.celsius = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
-    temp_chamber.current = analog_to_celsius_chamber(temp_chamber.raw);
+    temp_chamber.celsius = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog_to_mm_fil_width();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.

commit dbee0e9c5424770b9abf8815c0cb8b49de7db77f
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Sep 8 00:55:34 2019 -0500

    Analog joystick jogging control (#14648)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fb762ed597..db584f17a4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -57,20 +57,24 @@
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
+#if ENABLED(JOYSTICK)
+  #include "../feature/joystick.h"
+#endif
+
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
 #if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
@@ -1678,20 +1682,32 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_ADC_3
     HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_ADC_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_ADC_5
     HAL_ANALOG_SELECT(TEMP_5_PIN);
   #endif
+  #if HAS_JOY_ADC_X
+    HAL_ANALOG_SELECT(JOY_X_PIN);
+  #endif
+  #if HAS_JOY_ADC_Y
+    HAL_ANALOG_SELECT(JOY_Y_PIN);
+  #endif
+  #if HAS_JOY_ADC_Z
+    HAL_ANALOG_SELECT(JOY_Z_PIN);
+  #endif
+  #if HAS_JOY_ADC_EN
+    SET_INPUT_PULLUP(JOY_EN_PIN);
+  #endif
   #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
   #if HAS_ADC_BUTTONS
@@ -2188,20 +2204,30 @@ void Temperature::set_current_temp_raw() {
   #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
     temp_bed.update();
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.update();
   #endif
 
+  #if HAS_JOY_ADC_X
+    joystick.x.update();
+  #endif
+  #if HAS_JOY_ADC_Y
+    joystick.y.update();
+  #endif
+  #if HAS_JOY_ADC_Z
+    joystick.z.update();
+  #endif
+
   temp_meas_ready = true;
 }
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint32_t raw_filwidth_value; // = 0
 #endif
 
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
@@ -2218,20 +2244,30 @@ void Temperature::readings_ready() {
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.reset();
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.reset();
   #endif
 
+  #if HAS_JOY_ADC_X
+    joystick.x.reset();
+  #endif
+  #if HAS_JOY_ADC_Y
+    joystick.y.reset();
+  #endif
+  #if HAS_JOY_ADC_Z
+    joystick.z.reset();
+  #endif
+
   static constexpr int8_t temp_dir[] = {
     #if ENABLED(HEATER_0_USES_MAX6675)
       0
     #else
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
       #if ENABLED(HEATER_1_USES_MAX6675)
         , 0
       #else
@@ -2714,20 +2750,35 @@ void Temperature::isr() {
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
           raw_filwidth_value -= raw_filwidth_value >> 7; // Subtract 1/128th of the raw_filwidth_value
           raw_filwidth_value += uint32_t(HAL_READ_ADC()) << 7; // Add new ADC reading, scaled by 128
         }
       break;
     #endif
 
+    #if HAS_JOY_ADC_X
+      case PrepareJoy_X: HAL_START_ADC(JOY_X_PIN); break;
+      case MeasureJoy_X: ACCUMULATE_ADC(joystick.x); break;
+    #endif
+
+    #if HAS_JOY_ADC_Y
+      case PrepareJoy_Y: HAL_START_ADC(JOY_Y_PIN); break;
+      case MeasureJoy_Y: ACCUMULATE_ADC(joystick.y); break;
+    #endif
+
+    #if HAS_JOY_ADC_Z
+      case PrepareJoy_Z: HAL_START_ADC(JOY_Z_PIN); break;
+      case MeasureJoy_Z: ACCUMULATE_ADC(joystick.z); break;
+    #endif
+
     #if HAS_ADC_BUTTONS
       case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < 16) {
           raw_ADCKey_value = HAL_READ_ADC();
           if (raw_ADCKey_value <= 900) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;

commit 91c3b8e3ca81afdc280b7d130a234ff537e0cf3e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 5 20:01:38 2019 -0500

    Reformat ADC cases

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1634cfc120..fb762ed597 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2663,109 +2663,73 @@ void Temperature::isr() {
     }
 
     case StartSampling:                                   // Start of sampling loops. Do updates/checks.
       if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
-      case PrepareTemp_0:
-        HAL_START_ADC(TEMP_0_PIN);
-        break;
-      case MeasureTemp_0:
-        ACCUMULATE_ADC(temp_hotend[0]);
-        break;
+      case PrepareTemp_0: HAL_START_ADC(TEMP_0_PIN); break;
+      case MeasureTemp_0: ACCUMULATE_ADC(temp_hotend[0]); break;
     #endif
 
     #if HAS_HEATED_BED
-      case PrepareTemp_BED:
-        HAL_START_ADC(TEMP_BED_PIN);
-        break;
-      case MeasureTemp_BED:
-        ACCUMULATE_ADC(temp_bed);
-        break;
+      case PrepareTemp_BED: HAL_START_ADC(TEMP_BED_PIN); break;
+      case MeasureTemp_BED: ACCUMULATE_ADC(temp_bed); break;
     #endif
 
     #if HAS_TEMP_CHAMBER
-      case PrepareTemp_CHAMBER:
-        HAL_START_ADC(TEMP_CHAMBER_PIN);
-        break;
-      case MeasureTemp_CHAMBER:
-        ACCUMULATE_ADC(temp_chamber);
-        break;
+      case PrepareTemp_CHAMBER: HAL_START_ADC(TEMP_CHAMBER_PIN); break;
+      case MeasureTemp_CHAMBER: ACCUMULATE_ADC(temp_chamber); break;
     #endif
 
     #if HAS_TEMP_ADC_1
-      case PrepareTemp_1:
-        HAL_START_ADC(TEMP_1_PIN);
-        break;
-      case MeasureTemp_1:
-        ACCUMULATE_ADC(temp_hotend[1]);
-        break;
+      case PrepareTemp_1: HAL_START_ADC(TEMP_1_PIN); break;
+      case MeasureTemp_1: ACCUMULATE_ADC(temp_hotend[1]); break;
     #endif
 
     #if HAS_TEMP_ADC_2
-      case PrepareTemp_2:
-        HAL_START_ADC(TEMP_2_PIN);
-        break;
-      case MeasureTemp_2:
-        ACCUMULATE_ADC(temp_hotend[2]);
-        break;
+      case PrepareTemp_2: HAL_START_ADC(TEMP_2_PIN); break;
+      case MeasureTemp_2: ACCUMULATE_ADC(temp_hotend[2]); break;
     #endif
 
     #if HAS_TEMP_ADC_3
-      case PrepareTemp_3:
-        HAL_START_ADC(TEMP_3_PIN);
-        break;
-      case MeasureTemp_3:
-        ACCUMULATE_ADC(temp_hotend[3]);
-        break;
+      case PrepareTemp_3: HAL_START_ADC(TEMP_3_PIN); break;
+      case MeasureTemp_3: ACCUMULATE_ADC(temp_hotend[3]); break;
     #endif
 
     #if HAS_TEMP_ADC_4
-      case PrepareTemp_4:
-        HAL_START_ADC(TEMP_4_PIN);
-        break;
-      case MeasureTemp_4:
-        ACCUMULATE_ADC(temp_hotend[4]);
-        break;
+      case PrepareTemp_4: HAL_START_ADC(TEMP_4_PIN); break;
+      case MeasureTemp_4: ACCUMULATE_ADC(temp_hotend[4]); break;
     #endif
 
     #if HAS_TEMP_ADC_5
-      case PrepareTemp_5:
-        HAL_START_ADC(TEMP_5_PIN);
-        break;
-      case MeasureTemp_5:
-        ACCUMULATE_ADC(temp_hotend[5]);
-        break;
+      case PrepareTemp_5: HAL_START_ADC(TEMP_5_PIN); break;
+      case MeasureTemp_5: ACCUMULATE_ADC(temp_hotend[5]); break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      case Prepare_FILWIDTH:
-        HAL_START_ADC(FILWIDTH_PIN);
-      break;
+      case Prepare_FILWIDTH: HAL_START_ADC(FILWIDTH_PIN); break;
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
           raw_filwidth_value -= raw_filwidth_value >> 7; // Subtract 1/128th of the raw_filwidth_value
           raw_filwidth_value += uint32_t(HAL_READ_ADC()) << 7; // Add new ADC reading, scaled by 128
         }
       break;
     #endif
 
     #if HAS_ADC_BUTTONS
-      case Prepare_ADC_KEY:
-        HAL_START_ADC(ADC_KEYPAD_PIN);
-        break;
+      case Prepare_ADC_KEY: HAL_START_ADC(ADC_KEYPAD_PIN); break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < 16) {
           raw_ADCKey_value = HAL_READ_ADC();
           if (raw_ADCKey_value <= 900) {
             NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
           else { //ADC Key release

commit 4cdf7a1b933fff5f6bf7a86a9c6f53fc16782737
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 5 19:44:55 2019 -0500

    Add ADC helpers to temp_info_t

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 30087e306e..1634cfc120 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2157,79 +2157,79 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // HAS_MAX6675
 
 /**
  * Get raw temperatures
  */
 void Temperature::set_current_temp_raw() {
 
   #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
-    temp_hotend[0].raw = temp_hotend[0].acc;
+    temp_hotend[0].update();
   #endif
 
   #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = temp_hotend[1].acc;
     #elif DISABLED(HEATER_1_USES_MAX6675)
-      temp_hotend[1].raw = temp_hotend[1].acc;
+      temp_hotend[1].update();
     #endif
     #if HAS_TEMP_ADC_2
-      temp_hotend[2].raw = temp_hotend[2].acc;
+      temp_hotend[2].update();
       #if HAS_TEMP_ADC_3
-        temp_hotend[3].raw = temp_hotend[3].acc;
+        temp_hotend[3].update();
         #if HAS_TEMP_ADC_4
-          temp_hotend[4].raw = temp_hotend[4].acc;
+          temp_hotend[4].update();
           #if HAS_TEMP_ADC_5
-            temp_hotend[5].raw = temp_hotend[5].acc;
+            temp_hotend[5].update();
           #endif // HAS_TEMP_ADC_5
         #endif // HAS_TEMP_ADC_4
       #endif // HAS_TEMP_ADC_3
     #endif // HAS_TEMP_ADC_2
   #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
-    temp_bed.raw = temp_bed.acc;
+    temp_bed.update();
   #endif
 
   #if HAS_TEMP_CHAMBER
-    temp_chamber.raw = temp_chamber.acc;
+    temp_chamber.update();
   #endif
 
   temp_meas_ready = true;
 }
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint32_t raw_filwidth_value; // = 0
 #endif
 
 void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
-  HOTEND_LOOP() temp_hotend[e].acc = 0;
+  HOTEND_LOOP() temp_hotend[e].reset();
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    temp_hotend[1].acc = 0;
+    temp_hotend[1].reset();
   #endif
 
   #if HAS_HEATED_BED
-    temp_bed.acc = 0;
+    temp_bed.reset();
   #endif
 
   #if HAS_TEMP_CHAMBER
-    temp_chamber.acc = 0;
+    temp_chamber.reset();
   #endif
 
   static constexpr int8_t temp_dir[] = {
     #if ENABLED(HEATER_0_USES_MAX6675)
       0
     #else
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
       #if ENABLED(HEATER_1_USES_MAX6675)
@@ -2631,21 +2631,21 @@ void Temperature::isr() {
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
   #define ACCUMULATE_ADC(obj) do{ \
     if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
-    else obj.acc += HAL_READ_ADC(); \
+    else obj.sample(HAL_READ_ADC()); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;

commit bf3cd8e5aa2dc5d5451d658a8d9d77de3e0bb455
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 4 22:34:00 2019 -0500

    Tweak var names

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 04492987b7..30087e306e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -344,21 +344,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
   void Temperature::PID_autotune(const float &target, const heater_ind_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
-    float max = 0, min = 10000;
+    float maxT = 0, minT = 10000;
 
     const bool isbed = (heater == H_BED);
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (isbed ? (B) : (H))
       #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
       #define ONHEATINGSTART() (isbed ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
       #define ONHEATING(S,C,T) (isbed ? printerEventLEDs.onBedHeating(S,C,T) : printerEventLEDs.onHotendHeating(S,C,T))
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
@@ -417,58 +417,58 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
         current = GHV(temp_bed.current, temp_hotend[heater].current);
-        NOLESS(max, current);
-        NOMORE(min, current);
+        NOLESS(maxT, current);
+        NOMORE(minT, current);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
         if (heating && current > target) {
           if (ELAPSED(ms, t2 + 5000UL)) {
             heating = false;
             SHV((bias - d) >> 1, (bias - d) >> 1);
             t1 = ms;
             t_high = t1 - t2;
-            max = target;
+            maxT = target;
           }
         }
 
         if (!heating && current < target) {
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               LIMIT(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
-              SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, min, MSG_T_MAX, max);
+              SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, minT, MSG_T_MAX, maxT);
               if (cycles > 2) {
-                const float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
+                const float Ku = (4.0f * d) / (float(M_PI) * (maxT - minT) * 0.5f),
                             Tu = float(t_low + t_high) * 0.001f,
                             pf = isbed ? 0.2f : 0.6f,
                             df = isbed ? 1.0f / 3.0f : 1.0f / 8.0f;
 
                 SERIAL_ECHOPAIR(MSG_KU, Ku, MSG_TU, Tu);
                 if (isbed) { // Do not remove this otherwise PID autotune won't work right for the bed!
                   tune_pid.Kp = Ku * 0.2f;
                   tune_pid.Ki = 2 * tune_pid.Kp / Tu;
                   tune_pid.Kd = tune_pid.Kp * Tu / 3;
                   SERIAL_ECHOLNPGM("\n" " No overshoot"); // Works far better for the bed. Classic and some have bad ringing.
@@ -490,21 +490,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
                 SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
                 tune_pid.Kp = 0.2 * Ku;
                 tune_pid.Ki = 2 * tune_pid.Kp / Tu;
                 tune_pid.Kd = tune_pid.Kp * Tu / 3;
                 SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd);
                 */
               }
             }
             SHV((bias + d) >> 1, (bias + d) >> 1);
             cycles++;
-            min = target;
+            minT = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
       if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);

commit 12344085c0b7e51a0f8bdf54955a284dfb2be24f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 2 19:21:47 2019 -0500

    Update temperature.cpp

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a43fa12d0b..04492987b7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2989,21 +2989,21 @@ void Temperature::isr() {
           #if TEMP_RESIDENCY_TIME > 0
             SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
               SERIAL_ECHO(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
-        manage_inactivity();
+        idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degHotend(target_extruder);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           // Gradually change LED strip from violet to red as nozzle heats up
           if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0

commit 451a942e951d7802342f94d97c4013319c240296
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 2 01:04:00 2019 -0500

    Suspend queue during wait_for_hotend

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 04492987b7..a43fa12d0b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2989,21 +2989,21 @@ void Temperature::isr() {
           #if TEMP_RESIDENCY_TIME > 0
             SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
               SERIAL_ECHO(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
-        idle();
+        manage_inactivity();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degHotend(target_extruder);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           // Gradually change LED strip from violet to red as nozzle heats up
           if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0

commit 05995d1fd6c3b85717d428ff5c0c269f7872857b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Aug 20 09:01:37 2019 +0200

    Unify buzz methods as MarlinUI::buzz (#14803)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 79f63b5315..04492987b7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -61,21 +61,21 @@
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
-#if HAS_BUZZER && PIN_EXISTS(BEEPER)
+#if USE_BEEPER
   #include "../libs/buzzer.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
@@ -742,21 +742,21 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 
 inline void loud_kill(PGM_P const lcd_msg) {
   Running = false;
-  #if HAS_BUZZER && PIN_EXISTS(BEEPER)
+  #if USE_BEEPER
     for (uint8_t i = 20; i--;) {
       WRITE(BEEPER_PIN, HIGH); delay(25);
       WRITE(BEEPER_PIN, LOW); delay(80);
     }
     WRITE(BEEPER_PIN, HIGH);
   #endif
   kill(lcd_msg);
 }
 
 void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {

commit 4575978a1fc83853579ec85ebd1549fdeae0b03b
Author: Tim Moore <tim@youngmoores.com>
Date:   Fri Aug 16 16:42:24 2019 -0700

    Fix auto power for chamber fan (#14922)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1dd774d1ba..79f63b5315 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -647,27 +647,20 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
   #define AUTO_3_IS_2 (E3_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
   #define AUTO_4_IS_0 (E4_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_4_IS_1 (E4_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_4_IS_2 (E4_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
   #define AUTO_4_IS_3 (E4_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
   #define AUTO_5_IS_0 (E5_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_5_IS_1 (E5_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_5_IS_2 (E5_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
   #define AUTO_5_IS_3 (E5_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
   #define AUTO_5_IS_4 (E5_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_0 (CHAMBER_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_1 (CHAMBER_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_2 (CHAMBER_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_3 (CHAMBER_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_4 (CHAMBER_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_5 (CHAMBER_AUTO_FAN_PIN == E5_AUTO_FAN_PIN)
-  #define AUTO_CHAMBER_IS_E (AUTO_CHAMBER_IS_0 || AUTO_CHAMBER_IS_1 || AUTO_CHAMBER_IS_2 || AUTO_CHAMBER_IS_3 || AUTO_CHAMBER_IS_4 || AUTO_CHAMBER_IS_5)
   #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
     static const uint8_t fanBit[] PROGMEM = {
       0
       #if HOTENDS > 1
         , AUTO_1_IS_0 ? 0 : 1
       #endif
       #if HOTENDS > 2
         , AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 : 2
@@ -702,21 +695,21 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
       else                                               \
         WRITE(P##_AUTO_FAN_PIN, D);                      \
     }while(0)
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanBit); f++) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
-        #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
+        #if ENABLED(AUTO_POWER_CHAMBER_FAN)
           case CHAMBER_FAN_INDEX:
             chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
             break;
         #endif
         default:
           #if ENABLED(AUTO_POWER_E_FANS)
             autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
           #endif
           break;
       }

commit 77f637763cf89a12515c3c29337466ed7d6557cf
Author: Tim Moore <tim@youngmoores.com>
Date:   Tue Aug 6 21:25:47 2019 -0700

    Overlord configs. Fix buzzer, redundant temp. (#14833)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b77fb79d6e..1dd774d1ba 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2213,20 +2213,23 @@ void Temperature::readings_ready() {
 
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
   HOTEND_LOOP() temp_hotend[e].acc = 0;
+  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+    temp_hotend[1].acc = 0;
+  #endif
 
   #if HAS_HEATED_BED
     temp_bed.acc = 0;
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.acc = 0;
   #endif
 
   static constexpr int8_t temp_dir[] = {

commit fc39c925ca0e40ea41b217b910913f0e935338b5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 5 21:59:44 2019 -0500

    Grace period followup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 518ed923a5..b77fb79d6e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2222,23 +2222,20 @@ void Temperature::readings_ready() {
   HOTEND_LOOP() temp_hotend[e].acc = 0;
 
   #if HAS_HEATED_BED
     temp_bed.acc = 0;
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.acc = 0;
   #endif
 
-  // Give ADC temperature readings time to settle at boot-up before testing
-  if (grace_period) return;
-
   static constexpr int8_t temp_dir[] = {
     #if ENABLED(HEATER_0_USES_MAX6675)
       0
     #else
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
       #if ENABLED(HEATER_1_USES_MAX6675)
         , 0
       #else

commit 5bc2fb022ca437d7e70f195bdb7d946ceb3a623a
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Tue Aug 6 08:33:15 2019 +0700

    THERMAL_PROTECTION_GRACE_PERIOD is obsolete (#14798)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 812a4739b6..518ed923a5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -75,24 +75,20 @@
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
   #endif
 #endif
 
-#ifndef THERMAL_PROTECTION_GRACE_PERIOD
-  #define THERMAL_PROTECTION_GRACE_PERIOD 0 // No grace period needed on well-behaved boards
-#endif
-
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
   #define _BED_PSTR(M,E) (E) == H_BED ? PSTR(M) :
 #else
@@ -1029,32 +1025,23 @@ void Temperature::manage_heater() {
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].current > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
     if (temp_hotend[1].current < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
-  #if HAS_THERMAL_PROTECTION
-    #if THERMAL_PROTECTION_GRACE_PERIOD > 0
-      static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD;
-      if (ELAPSED(ms, grace_period)) grace_period = 0UL;
-    #else
-      static constexpr millis_t grace_period = 0UL;
-    #endif
-  #endif
-
   HOTEND_LOOP() {
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-      if (!grace_period && degHotend(e) > temp_range[e].maxtemp)
+      if (degHotend(e) > temp_range[e].maxtemp)
         _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
     #endif
 
     #if HEATER_IDLE_HANDLER
       hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
       thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
@@ -1096,21 +1083,21 @@ void Temperature::manage_heater() {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       LIMIT(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
-      if (!grace_period && degBed() > BED_MAXTEMP)
+      if (degBed() > BED_MAXTEMP)
         _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_BED));
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(H_BED, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_BED));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
@@ -1174,21 +1161,21 @@ void Temperature::manage_heater() {
 
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-      if (!grace_period && degChamber() > CHAMBER_MAXTEMP)
+      if (degChamber() > CHAMBER_MAXTEMP)
         _temp_error(H_CHAMBER, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_CHAMBER));
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
           _temp_error(H_CHAMBER, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_CHAMBER));
         else
           start_watching_chamber();                 // Start again if the target is still far off
@@ -2217,46 +2204,41 @@ void Temperature::set_current_temp_raw() {
 
   temp_meas_ready = true;
 }
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint32_t raw_filwidth_value; // = 0
 #endif
 
 void Temperature::readings_ready() {
 
-  #if THERMAL_PROTECTION_GRACE_PERIOD > 0
-    const millis_t ms = millis();
-    static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD; // NOTE: millis() == 0 on reset
-    if (ELAPSED(ms, grace_period)) grace_period = 0;
-  #else
-    static constexpr millis_t grace_period = 0;
-  #endif
-
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
   HOTEND_LOOP() temp_hotend[e].acc = 0;
 
   #if HAS_HEATED_BED
     temp_bed.acc = 0;
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.acc = 0;
   #endif
 
+  // Give ADC temperature readings time to settle at boot-up before testing
+  if (grace_period) return;
+
   static constexpr int8_t temp_dir[] = {
     #if ENABLED(HEATER_0_USES_MAX6675)
       0
     #else
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
       #if ENABLED(HEATER_1_USES_MAX6675)
         , 0
       #else
@@ -2270,23 +2252,20 @@ void Temperature::readings_ready() {
             , TEMPDIR(4)
             #if HOTENDS > 5
               , TEMPDIR(5)
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   };
 
-  // Give ADC temperature readings time to settle at boot-up before testing
-  if (grace_period) return;
-
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
     const int8_t tdir = temp_dir[e];
     if (tdir) {
       const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
       const bool heater_on = (temp_hotend[e].target > 0
         #if ENABLED(PIDTEMP)
           || temp_hotend[e].soft_pwm_amount > 0
         #endif
       );
       if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);

commit c4bb458763c810f29025fc6b2c5829022ed509c7
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Jul 29 02:14:50 2019 +0200

    BUZZ cleanup (#14760)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 72e49dc06d..812a4739b6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -61,21 +61,21 @@
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
-#if HAS_BUZZER
+#if HAS_BUZZER && PIN_EXISTS(BEEPER)
   #include "../libs/buzzer.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);

commit 1579091c206c14bbf7c88186fae07ccddc001a36
Author: mikeshub <mikesbaker@gmail.com>
Date:   Sun Jul 28 15:50:25 2019 -0500

    PID loop improvements (#14746)
    
    * Fix macro evaluation in `temperature.cpp`
    * Improve bed PID, PID debug output
    * Add min PID power define

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a5736dc298..72e49dc06d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -462,26 +462,37 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               LIMIT(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, min, MSG_T_MAX, max);
               if (cycles > 2) {
                 const float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
                             Tu = float(t_low + t_high) * 0.001f,
                             pf = isbed ? 0.2f : 0.6f,
                             df = isbed ? 1.0f / 3.0f : 1.0f / 8.0f;
-                tune_pid.Kp = Ku * pf;
-                tune_pid.Kd = tune_pid.Kp * Tu * df;
-                tune_pid.Ki = 2 * tune_pid.Kp / Tu;
+
                 SERIAL_ECHOPAIR(MSG_KU, Ku, MSG_TU, Tu);
-                SERIAL_ECHOLNPGM("\n" MSG_CLASSIC_PID);
-                SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
+                if (isbed) { // Do not remove this otherwise PID autotune won't work right for the bed!
+                  tune_pid.Kp = Ku * 0.2f;
+                  tune_pid.Ki = 2 * tune_pid.Kp / Tu;
+                  tune_pid.Kd = tune_pid.Kp * Tu / 3;
+                  SERIAL_ECHOLNPGM("\n" " No overshoot"); // Works far better for the bed. Classic and some have bad ringing.
+                  SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
+                }
+                else {
+                  tune_pid.Kp = Ku * pf;
+                  tune_pid.Kd = tune_pid.Kp * Tu * df;
+                  tune_pid.Ki = 2 * tune_pid.Kp / Tu;
+                  SERIAL_ECHOLNPGM("\n" MSG_CLASSIC_PID);
+                  SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
+                }
+
                 /**
                 tune_pid.Kp = 0.33 * Ku;
                 tune_pid.Ki = tune_pid.Kp / Tu;
                 tune_pid.Kd = tune_pid.Kp * Tu / 3;
                 SERIAL_ECHOLNPGM(" Some overshoot");
                 SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
                 tune_pid.Kp = 0.2 * Ku;
                 tune_pid.Ki = 2 * tune_pid.Kp / Tu;
                 tune_pid.Kd = tune_pid.Kp * Tu / 3;
                 SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd);
@@ -843,26 +854,26 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
         pid_reset[ee] = true;
       }
       else {
         if (pid_reset[ee]) {
           temp_iState[ee] = 0.0;
           work_pid[ee].Kd = 0.0;
           pid_reset[ee] = false;
         }
 
         work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].current) - work_pid[ee].Kd);
-        const float max_power_over_i_gain = (float)PID_MAX / PID_PARAM(Ki, ee);
+        const float max_power_over_i_gain = float(PID_MAX) / PID_PARAM(Ki, ee) - float(MIN_POWER);
         temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
         work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
         work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
 
-        pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd;
+        pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd + float(MIN_POWER);
 
         #if ENABLED(PID_EXTRUSION_SCALING)
           work_pid[ee].Kc = 0;
           if (_HOTEND_TEST) {
             const long e_position = stepper.position(E_AXIS);
             if (e_position > last_e_position) {
               lpq[lpq_ptr] = e_position - last_e_position;
               last_e_position = e_position;
             }
             else
@@ -878,37 +889,39 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
       }
       temp_dState[ee] = temp_hotend[ee].current;
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPAIR(
-        MSG_PID_DEBUG, ee,
-        MSG_PID_DEBUG_INPUT, temp_hotend[ee].current,
-        MSG_PID_DEBUG_OUTPUT, pid_output
-      );
-      #if DISABLED(PID_OPENLOOP)
+      if (e == active_extruder) {
+        SERIAL_ECHO_START();
         SERIAL_ECHOPAIR(
-          MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
-          MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
-          MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
-          #endif
+          MSG_PID_DEBUG, ee,
+          MSG_PID_DEBUG_INPUT, temp_hotend[ee].current,
+          MSG_PID_DEBUG_OUTPUT, pid_output
         );
-      #endif
-      SERIAL_EOL();
+        #if DISABLED(PID_OPENLOOP)
+          SERIAL_ECHOPAIR(
+            MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
+            MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
+            MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
+            #if ENABLED(PID_EXTRUSION_SCALING)
+              , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
+            #endif
+          );
+        #endif
+        SERIAL_EOL();
+      }
     #endif // PID_DEBUG
 
   #else // No PID enabled
 
     #if HEATER_IDLE_HANDLER
       #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
     #else
       #define _TIMED_OUT_TEST false
     #endif
     pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].current < temp_hotend[ee].target) ? BANG_MAX : 0;
@@ -920,33 +933,50 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
 }
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
       static PID_t work_pid = { 0 };
       static float temp_iState = 0, temp_dState = 0;
-
-      const float max_power_over_i_gain = (float)MAX_BED_POWER / temp_bed.pid.Ki,
+      static bool pid_reset = true;
+      float pid_output = 0;
+      const float max_power_over_i_gain = float(MAX_BED_POWER) / temp_bed.pid.Ki - float(MIN_BED_POWER),
                   pid_error = temp_bed.target - temp_bed.current;
 
-      temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
+      if (!temp_bed.target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
+        pid_output = 0;
+        pid_reset = true;
+      }
+      else if (pid_error > PID_FUNCTIONAL_RANGE) {
+        pid_output = BANG_MAX;
+        pid_reset = true;
+      }
+      else {
+        if (pid_reset) {
+          temp_iState = 0.0;
+          work_pid.Kd = 0.0;
+          pid_reset = false;
+        }
 
-      work_pid.Kp = temp_bed.pid.Kp * pid_error;
-      work_pid.Ki = temp_bed.pid.Ki * temp_iState;
-      work_pid.Kd = work_pid.Kd + PID_K2 * (temp_bed.pid.Kd * (temp_dState - temp_bed.current) - work_pid.Kd);
+        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
 
-      temp_dState = temp_bed.current;
+        work_pid.Kp = temp_bed.pid.Kp * pid_error;
+        work_pid.Ki = temp_bed.pid.Ki * temp_iState;
+        work_pid.Kd = work_pid.Kd + PID_K2 * (temp_bed.pid.Kd * (temp_dState - temp_bed.current) - work_pid.Kd);
 
-      const float pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd, 0, MAX_BED_POWER);
+        temp_dState = temp_bed.current;
+
+        pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd + float(MIN_BED_POWER), 0, MAX_BED_POWER);
+      }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPAIR(

commit d9303b213791b709233e3316fd0c2358a25cb291
Author: mikeshub <mikesbaker@gmail.com>
Date:   Sun Jul 21 21:36:00 2019 -0500

    Fix MAX6675_SEPARATE_SPI boot loop (#14698)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f32d689ef6..a5736dc298 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -26,21 +26,21 @@
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 
-#define MAX6675_SEPARATE_SPI EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PIN_EXISTS(MAX6675_SCK, MAX6675_DO)
+#define MAX6675_SEPARATE_SPI (EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PIN_EXISTS(MAX6675_SCK, MAX6675_DO))
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if EITHER(BABYSTEPPING, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)

commit 27c487bab744a22aeb580a0471591adba040bc68
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:12:39 2019 -0600

    Print progress enhancements (#14647)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0cdce6dc72..f32d689ef6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2916,21 +2916,21 @@ void Temperature::isr() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         PORT_REDIRECT(SERIAL_BOTH);
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
-  #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
+  #if HAS_DISPLAY
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
         ui.status_printf_P(0, heating ? PSTR("E%c " MSG_HEATING) : PSTR("E%c " MSG_COOLING), '1' + e);
       #else
         ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 

commit ef2a2eb984a39f40318d67b205a5498908348b31
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 17 01:44:10 2019 -0500

    Temp tweak

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b8a14ae76b..0cdce6dc72 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -970,24 +970,21 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
-    if (!inited) {
-      watchdog_reset();
-      return;
-    }
+    if (!inited) return watchdog_reset();
   #endif
 
   #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 

commit 45bde333d594b7a7031780acad88c9af80dde026
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jul 15 01:05:24 2019 +0200

    Initial Longer3D LK1/2 (Alfawise U20/U20+/U30) support (#14597)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cf489abc4d..b8a14ae76b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1533,21 +1533,25 @@ void Temperature::updateTemperaturesFromRawValues() {
     return 0;
   }
 
 #endif
 
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 // Init fans according to whether they're native PWM or Software PWM
-#define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
+#ifdef ALFAWISE_UX0
+  #define _INIT_SOFT_FAN(P) OUT_WRITE_OD(P, FAN_INVERTING ? LOW : HIGH)
+#else
+  #define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
+#endif
 #if ENABLED(FAN_SOFT_PWM)
   #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
   #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
@@ -1556,21 +1560,20 @@ void Temperature::updateTemperaturesFromRawValues() {
   #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
 #else
   #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 #if CHAMBER_AUTO_FAN_SPEED != 255
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
 #else
   #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
-
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
@@ -1583,40 +1586,51 @@ void Temperature::init() {
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
   #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
-    OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
+    #ifdef ALFAWISE_UX0
+      OUT_WRITE_OD(HEATER_0_PIN, HEATER_0_INVERTING);
+    #else
+      OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
+    #endif
   #endif
+
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
     OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
   #endif
   #if HAS_HEATER_3
     OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
     OUT_WRITE(HEATER_4_PIN, HEATER_4_INVERTING);
   #endif
   #if HAS_HEATER_5
     OUT_WRITE(HEATER_5_PIN, HEATER_5_INVERTING);
   #endif
+
   #if HAS_HEATED_BED
-    OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
+    #ifdef ALFAWISE_UX0
+      OUT_WRITE_OD(HEATER_BED_PIN, HEATER_BED_INVERTING);
+    #else
+      OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
+    #endif
   #endif
+
   #if HAS_HEATED_CHAMBER
     OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
   #endif
 
   #if HAS_FAN0
     INIT_FAN_PIN(FAN_PIN);
   #endif
   #if HAS_FAN1
     INIT_FAN_PIN(FAN1_PIN);
   #endif

commit eaf1c0954eff9a8a6473a8853a47478a4a6cb73b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 14 08:56:29 2019 -0500

    Update some precompiler tests

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b6d35b9534..cf489abc4d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -998,22 +998,20 @@ void Temperature::manage_heater() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].current > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
     if (temp_hotend[0].current < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].current > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
     if (temp_hotend[1].current < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
-  #define HAS_THERMAL_PROTECTION (ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER))
-
   #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   #if HAS_THERMAL_PROTECTION
     #if THERMAL_PROTECTION_GRACE_PERIOD > 0
       static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD;
       if (ELAPSED(ms, grace_period)) grace_period = 0UL;
     #else
       static constexpr millis_t grace_period = 0UL;
@@ -1926,21 +1924,21 @@ void Temperature::init() {
           break;
         }
         else if (PENDING(millis(), sm.timer)) break;
         sm.state = TRRunaway;
 
       case TRRunaway:
         _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater_id));
     }
   }
 
-#endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
+#endif // HAS_THERMAL_PROTECTION
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif
 
   HOTEND_LOOP() setTargetHotend(0, e);
 
   #if HAS_HEATED_BED

commit 8babf55b181841a272ee25f44e86abf5b0d9f94a
Author: Pavel4e5 <50713272+Pavel4e5@users.noreply.github.com>
Date:   Thu Jul 11 23:47:41 2019 +0500

    Init ADC keypad analog input (#14585)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d7e4423bc4..b6d35b9534 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1668,20 +1668,23 @@ void Temperature::init() {
   #endif
   #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
+  #if HAS_ADC_BUTTONS
+    HAL_ANALOG_SELECT(ADC_KEYPAD_PIN);
+  #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
     INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif

commit ed0e6afacbbd5ef8836166feccbd4b50fc9da009
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 10 03:33:28 2019 -0500

    Apply LIMIT macro

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 43efb79333..d7e4423bc4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -453,21 +453,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
         }
 
         if (!heating && current < target) {
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
-              bias = constrain(bias, 20, max_pow - 20);
+              LIMIT(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, min, MSG_T_MAX, max);
               if (cycles > 2) {
                 const float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
                             Tu = float(t_low + t_high) * 0.001f,
                             pf = isbed ? 0.2f : 0.6f,
                             df = isbed ? 1.0f / 3.0f : 1.0f / 8.0f;
                 tune_pid.Kp = Ku * pf;
                 tune_pid.Kd = tune_pid.Kp * Tu * df;
@@ -867,21 +867,21 @@ float Temperature::get_pid_output_hotend(const uint8_t e) {
             }
             else
               lpq[lpq_ptr] = 0;
 
             if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
             work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
             pid_output += work_pid[ee].Kc;
           }
         #endif // PID_EXTRUSION_SCALING
 
-        pid_output = constrain(pid_output, 0, PID_MAX);
+        LIMIT(pid_output, 0, PID_MAX);
       }
       temp_dState[ee] = temp_hotend[ee].current;
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
@@ -1063,21 +1063,21 @@ void Temperature::manage_heater() {
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     /**
      * Filament Width Sensor dynamically sets the volumetric multiplier
      * based on a delayed measurement of the filament diameter.
      */
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
-      meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
+      LIMIT(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (!grace_period && degBed() > BED_MAXTEMP)
         _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_BED));
     #endif

commit 5519054f50c2e0e532f8a541f156ef350aaecc9c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 9 21:35:07 2019 -0500

    Improve BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE (#13740)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f98f76c8d8..43efb79333 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -739,55 +739,75 @@ int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
       }
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
+
+inline void loud_kill(PGM_P const lcd_msg) {
+  Running = false;
+  #if HAS_BUZZER && PIN_EXISTS(BEEPER)
+    for (uint8_t i = 20; i--;) {
+      WRITE(BEEPER_PIN, HIGH); delay(25);
+      WRITE(BEEPER_PIN, LOW); delay(80);
+    }
+    WRITE(BEEPER_PIN, HIGH);
+  #endif
+  kill(lcd_msg);
+}
+
 void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
-  static bool killed = false;
-  if (IsRunning()) {
+
+  static uint8_t killed = 0;
+
+  if (IsRunning()
+    #if BOGUS_TEMPERATURE_GRACE_PERIOD
+      && killed == 2
+    #endif
+  ) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(MSG_STOPPED_HEATER);
     if (heater >= 0) SERIAL_ECHO((int)heater);
     #if HAS_HEATED_CHAMBER
       else if (heater == H_CHAMBER) SERIAL_ECHOPGM(MSG_HEATER_CHAMBER);
     #endif
     else SERIAL_ECHOPGM(MSG_HEATER_BED);
     SERIAL_EOL();
   }
 
-  #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
-    if (!killed) {
-      Running = false;
-      killed = true;
-
-      disable_all_heaters();
+  disable_all_heaters(); // always disable (even for bogus temp)
 
-      #if HAS_BUZZER && PIN_EXISTS(BEEPER)
-        for (uint8_t i = 20; i--;) {
-          WRITE(BEEPER_PIN, HIGH); delay(25);
-          WRITE(BEEPER_PIN, LOW); delay(80);
-        }
-        WRITE(BEEPER_PIN, HIGH);
-      #endif
-
-      kill(lcd_msg);
+  #if BOGUS_TEMPERATURE_GRACE_PERIOD
+    const millis_t ms = millis();
+    static millis_t expire_ms;
+    switch (killed) {
+      case 0:
+        expire_ms = ms + BOGUS_TEMPERATURE_GRACE_PERIOD;
+        ++killed;
+        break;
+      case 1:
+        if (ELAPSED(ms, expire_ms)) ++killed;
+        break;
+      case 2:
+        loud_kill(lcd_msg);
+        ++killed;
+        break;
     }
-    else
-      disable_all_heaters(); // paranoia
-  #else
+  #elif defined(BOGUS_TEMPERATURE_GRACE_PERIOD)
     UNUSED(killed);
+  #else
+    if (!killed) { killed = 1; loud_kill(lcd_msg); }
   #endif
 }
 
 void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
 void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 16ae6b996c..f98f76c8d8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -136,41 +136,41 @@ hotend_info_t Temperature::temp_hotend[HOTENDS
     void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
       switch (tmp_temp) {
         case 1:
           set_fan_speed(fan, old_fan_speed[fan]);
           break;
         case 2:
           old_fan_speed[fan] = fan_speed[fan];
           set_fan_speed(fan, new_fan_speed[fan]);
           break;
         default:
-          new_fan_speed[fan] = MIN(tmp_temp, 255U);
+          new_fan_speed[fan] = _MIN(tmp_temp, 255U);
           break;
       }
     }
 
   #endif
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
     uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
   #endif
 
   #if HAS_LCD_MENU
 
     uint8_t Temperature::lcd_tmpfan_speed[
       #if ENABLED(SINGLENOZZLE)
-        MAX(EXTRUDERS, FAN_COUNT)
+        _MAX(EXTRUDERS, FAN_COUNT)
       #else
         FAN_COUNT
       #endif
     ]; // = { 0 }
 
   #endif
 
   /**
    * Set the print fan speed for a target extruder
    */
@@ -969,27 +969,27 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (temp_hotend[0].current > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
-    if (temp_hotend[0].current < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
+    if (temp_hotend[0].current > _MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
+    if (temp_hotend[0].current < _MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
-    if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
-    if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
+    if (temp_hotend[1].current > _MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
+    if (temp_hotend[1].current < _MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   #define HAS_THERMAL_PROTECTION (ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER))
 
   #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   #if HAS_THERMAL_PROTECTION
     #if THERMAL_PROTECTION_GRACE_PERIOD > 0
@@ -1318,21 +1318,21 @@ void Temperature::manage_heater() {
 
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  int32_t clocks = TCNT5 - tcnt5;
     //  if (clocks >= 0) {
     //    clocks_total += clocks;
     //    calls++;
     //  }
     //#endif
 
     // Return degrees C (up to 999, as the LCD only displays 3 digits)
-    return MIN(value + THERMISTOR_ABS_ZERO_C, 999);
+    return _MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
@@ -1877,21 +1877,21 @@ void Temperature::init() {
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < tr_target_temperature[heater_index]) break;
         sm.state = TRStable;
 
       // While the temperature is stable watch for a bad temperature
       case TRStable:
 
         #if ENABLED(ADAPTIVE_FAN_SLOWING)
           if (adaptive_fan_slowing && heater_id >= 0) {
-            const int fan_index = MIN(heater_id, FAN_COUNT - 1);
+            const int fan_index = _MIN(heater_id, FAN_COUNT - 1);
             if (fan_speed[fan_index] == 0 || current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.25f))
               fan_speed_scaler[fan_index] = 128;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.3335f))
               fan_speed_scaler[fan_index] = 96;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.5f))
               fan_speed_scaler[fan_index] = 64;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else
               fan_speed_scaler[fan_index] = 0;

commit f7eeae8424ac51125c01d8ddc0d1ad7e6c626e9d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 2 21:34:40 2019 -0500

    Indent a line

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0a3825f88b..16ae6b996c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2225,21 +2225,21 @@ void Temperature::readings_ready() {
       const bool heater_on = (temp_hotend[e].target > 0
         #if ENABLED(PIDTEMP)
           || temp_hotend[e].soft_pwm_amount > 0
         #endif
       );
       if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
       if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
         #endif
-          min_temp_error((heater_ind_t)e);
+            min_temp_error((heater_ind_t)e);
       }
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         else
           consecutive_low_temperature_error[e] = 0;
       #endif
     }
   }
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0

commit 720bc7c00b0eedf2e7601d5fc6e6ff61f9833562
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 2 08:39:55 2019 -0500

    Named indices for Temperature class (#14479)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9856dc0f34..0a3825f88b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -87,26 +87,26 @@
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
-  #define _BED_PSTR(M,E) (E) == -1 ? PSTR(M) :
+  #define _BED_PSTR(M,E) (E) == H_BED ? PSTR(M) :
 #else
   #define _BED_PSTR(M,E)
 #endif
 #if HAS_HEATED_CHAMBER
-  #define _CHAMBER_PSTR(M,E) (E) == -2 ? PSTR(M) :
+  #define _CHAMBER_PSTR(M,E) (E) == H_CHAMBER ? PSTR(M) :
 #else
   #define _CHAMBER_PSTR(M,E)
 #endif
 #define _E_PSTR(M,E,N) ((HOTENDS) >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
 #define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
@@ -338,33 +338,33 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    * Needs sufficient heater power to make some overshoot at target
    * temperature to succeed.
    */
-  void Temperature::PID_autotune(const float &target, const int8_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
+  void Temperature::PID_autotune(const float &target, const heater_ind_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
-    const bool isbed = (heater < 0);
+    const bool isbed = (heater == H_BED);
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (isbed ? (B) : (H))
       #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
       #define ONHEATINGSTART() (isbed ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
       #define ONHEATING(S,C,T) (isbed ? printerEventLEDs.onBedHeating(S,C,T) : printerEventLEDs.onHotendHeating(S,C,T))
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
@@ -611,40 +611,30 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
-int16_t Temperature::getHeaterPower(const int8_t heater) {
-  return (
-    #if HAS_HEATED_CHAMBER
-      #if HAS_HEATED_BED
-        heater == -2
-      #else
-        heater < 0
-      #endif
-      ? temp_chamber.soft_pwm_amount :
-    #endif
+int16_t Temperature::getHeaterPower(const heater_ind_t heater_id) {
+  switch (heater_id) {
+    default: return temp_hotend[heater_id].soft_pwm_amount;
     #if HAS_HEATED_BED
-      #if HAS_HEATED_CHAMBER
-        heater == -1
-      #else
-        heater < 0
-      #endif
-      ? temp_bed.soft_pwm_amount :
+      case H_BED: return temp_bed.soft_pwm_amount;
+    #endif
+    #if HAS_HEATED_CHAMBER
+      case H_CHAMBER: return temp_chamber.soft_pwm_amount;
     #endif
-    temp_hotend[heater].soft_pwm_amount
-  );
+  }
 }
 
 #if HAS_AUTO_FAN
 
   #define AUTO_1_IS_0 (E1_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_2_IS_0 (E2_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_2_IS_1 (E2_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_3_IS_0 (E3_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_3_IS_1 (E3_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_3_IS_2 (E3_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
@@ -749,29 +739,29 @@ int16_t Temperature::getHeaterPower(const int8_t heater) {
       }
       SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
-void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
+void Temperature::_temp_error(const heater_ind_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;
   if (IsRunning()) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(MSG_STOPPED_HEATER);
     if (heater >= 0) SERIAL_ECHO((int)heater);
     #if HAS_HEATED_CHAMBER
-      else if (heater == -2) SERIAL_ECHOPGM(MSG_HEATER_CHAMBER);
+      else if (heater == H_CHAMBER) SERIAL_ECHOPGM(MSG_HEATER_CHAMBER);
     #endif
     else SERIAL_ECHOPGM(MSG_HEATER_BED);
     SERIAL_EOL();
   }
 
   #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
     if (!killed) {
       Running = false;
       killed = true;
 
@@ -787,127 +777,130 @@ void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P
 
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #else
     UNUSED(killed);
   #endif
 }
 
-void Temperature::max_temp_error(const int8_t heater) {
+void Temperature::max_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
-void Temperature::min_temp_error(const int8_t heater) {
+void Temperature::min_temp_error(const heater_ind_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }
 
-float Temperature::get_pid_output(const int8_t e) {
+float Temperature::get_pid_output_hotend(const uint8_t e) {
   #if HOTENDS == 1
     #define _HOTEND_TEST true
   #else
     #define _HOTEND_TEST (e == active_extruder)
   #endif
   E_UNUSED();
+  const uint8_t ee = HOTEND_INDEX;
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       static hotend_pid_t work_pid[HOTENDS];
       static float temp_iState[HOTENDS] = { 0 },
                    temp_dState[HOTENDS] = { 0 };
       static bool pid_reset[HOTENDS] = { false };
-      const float pid_error = temp_hotend[HOTEND_INDEX].target - temp_hotend[HOTEND_INDEX].current;
+      const float pid_error = temp_hotend[ee].target - temp_hotend[ee].current;
 
-      if (temp_hotend[HOTEND_INDEX].target == 0
+      if (temp_hotend[ee].target == 0
         || pid_error < -(PID_FUNCTIONAL_RANGE)
         #if HEATER_IDLE_HANDLER
-          || hotend_idle[HOTEND_INDEX].timed_out
+          || hotend_idle[ee].timed_out
         #endif
       ) {
         pid_output = 0;
-        pid_reset[HOTEND_INDEX] = true;
+        pid_reset[ee] = true;
       }
       else if (pid_error > PID_FUNCTIONAL_RANGE) {
         pid_output = BANG_MAX;
-        pid_reset[HOTEND_INDEX] = true;
+        pid_reset[ee] = true;
       }
       else {
-        if (pid_reset[HOTEND_INDEX]) {
-          temp_iState[HOTEND_INDEX] = 0.0;
-          work_pid[HOTEND_INDEX].Kd = 0.0;
-          pid_reset[HOTEND_INDEX] = false;
+        if (pid_reset[ee]) {
+          temp_iState[ee] = 0.0;
+          work_pid[ee].Kd = 0.0;
+          pid_reset[ee] = false;
         }
 
-        work_pid[HOTEND_INDEX].Kd = work_pid[HOTEND_INDEX].Kd + PID_K2 * (PID_PARAM(Kd, HOTEND_INDEX) * (temp_dState[HOTEND_INDEX] - temp_hotend[HOTEND_INDEX].current) - work_pid[HOTEND_INDEX].Kd);
-        const float max_power_over_i_gain = (float)PID_MAX / PID_PARAM(Ki, HOTEND_INDEX);
-        temp_iState[HOTEND_INDEX] = constrain(temp_iState[HOTEND_INDEX] + pid_error, 0, max_power_over_i_gain);
-        work_pid[HOTEND_INDEX].Kp = PID_PARAM(Kp, HOTEND_INDEX) * pid_error;
-        work_pid[HOTEND_INDEX].Ki = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
+        work_pid[ee].Kd = work_pid[ee].Kd + PID_K2 * (PID_PARAM(Kd, ee) * (temp_dState[ee] - temp_hotend[ee].current) - work_pid[ee].Kd);
+        const float max_power_over_i_gain = (float)PID_MAX / PID_PARAM(Ki, ee);
+        temp_iState[ee] = constrain(temp_iState[ee] + pid_error, 0, max_power_over_i_gain);
+        work_pid[ee].Kp = PID_PARAM(Kp, ee) * pid_error;
+        work_pid[ee].Ki = PID_PARAM(Ki, ee) * temp_iState[ee];
 
-        pid_output = work_pid[HOTEND_INDEX].Kp + work_pid[HOTEND_INDEX].Ki + work_pid[HOTEND_INDEX].Kd;
+        pid_output = work_pid[ee].Kp + work_pid[ee].Ki + work_pid[ee].Kd;
 
         #if ENABLED(PID_EXTRUSION_SCALING)
-          work_pid[HOTEND_INDEX].Kc = 0;
+          work_pid[ee].Kc = 0;
           if (_HOTEND_TEST) {
             const long e_position = stepper.position(E_AXIS);
             if (e_position > last_e_position) {
               lpq[lpq_ptr] = e_position - last_e_position;
               last_e_position = e_position;
             }
             else
               lpq[lpq_ptr] = 0;
 
             if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-            work_pid[HOTEND_INDEX].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
-            pid_output += work_pid[HOTEND_INDEX].Kc;
+            work_pid[ee].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, ee);
+            pid_output += work_pid[ee].Kc;
           }
         #endif // PID_EXTRUSION_SCALING
 
         pid_output = constrain(pid_output, 0, PID_MAX);
       }
-      temp_dState[HOTEND_INDEX] = temp_hotend[HOTEND_INDEX].current;
+      temp_dState[ee] = temp_hotend[ee].current;
 
     #else // PID_OPENLOOP
 
-      const float pid_output = constrain(temp_hotend[HOTEND_INDEX].target, 0, PID_MAX);
+      const float pid_output = constrain(temp_hotend[ee].target, 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOPAIR(
-        MSG_PID_DEBUG, HOTEND_INDEX,
-        MSG_PID_DEBUG_INPUT, temp_hotend[HOTEND_INDEX].current,
+        MSG_PID_DEBUG, ee,
+        MSG_PID_DEBUG_INPUT, temp_hotend[ee].current,
         MSG_PID_DEBUG_OUTPUT, pid_output
       );
       #if DISABLED(PID_OPENLOOP)
         SERIAL_ECHOPAIR(
-          MSG_PID_DEBUG_PTERM, work_pid[HOTEND_INDEX].Kp,
-          MSG_PID_DEBUG_ITERM, work_pid[HOTEND_INDEX].Ki,
-          MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd
+          MSG_PID_DEBUG_PTERM, work_pid[ee].Kp,
+          MSG_PID_DEBUG_ITERM, work_pid[ee].Ki,
+          MSG_PID_DEBUG_DTERM, work_pid[ee].Kd
           #if ENABLED(PID_EXTRUSION_SCALING)
-            , MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc
+            , MSG_PID_DEBUG_CTERM, work_pid[ee].Kc
           #endif
         );
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
-  #else /* PID off */
+  #else // No PID enabled
+
     #if HEATER_IDLE_HANDLER
-      #define _TIMED_OUT_TEST hotend_idle[HOTEND_INDEX].timed_out
+      #define _TIMED_OUT_TEST hotend_idle[ee].timed_out
     #else
       #define _TIMED_OUT_TEST false
     #endif
-    pid_output = (!_TIMED_OUT_TEST && temp_hotend[HOTEND_INDEX].current < temp_hotend[HOTEND_INDEX].target) ? BANG_MAX : 0;
+    pid_output = (!_TIMED_OUT_TEST && temp_hotend[ee].current < temp_hotend[ee].target) ? BANG_MAX : 0;
     #undef _TIMED_OUT_TEST
+
   #endif
 
   return pid_output;
 }
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
@@ -976,75 +969,75 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (temp_hotend[0].current > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(0);
-    if (temp_hotend[0].current < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(0);
+    if (temp_hotend[0].current > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(H_E0);
+    if (temp_hotend[0].current < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(H_E0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
-    if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
-    if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
+    if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(H_E1);
+    if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(H_E1);
   #endif
 
   #define HAS_THERMAL_PROTECTION (ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER))
 
   #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   #if HAS_THERMAL_PROTECTION
     #if THERMAL_PROTECTION_GRACE_PERIOD > 0
       static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD;
       if (ELAPSED(ms, grace_period)) grace_period = 0UL;
     #else
       static constexpr millis_t grace_period = 0UL;
     #endif
   #endif
 
   HOTEND_LOOP() {
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       if (!grace_period && degHotend(e) > temp_range[e].maxtemp)
-        _temp_error(e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
+        _temp_error((heater_ind_t)e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
     #endif
 
     #if HEATER_IDLE_HANDLER
       hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
-      thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+      thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, (heater_ind_t)e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
-    temp_hotend[e].soft_pwm_amount = (temp_hotend[e].current > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].current < temp_range[e].maxtemp ? (int)get_pid_output(e) >> 1 : 0;
+    temp_hotend[e].soft_pwm_amount = (temp_hotend[e].current > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].current < temp_range[e].maxtemp ? (int)get_pid_output_hotend(e) >> 1 : 0;
 
     #if WATCH_HOTENDS
       // Make sure temperature is increasing
       if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
         if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
-          _temp_error(e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
+          _temp_error((heater_ind_t)e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
         else                                                                 // Start again if the target is still far off
-          start_watching_heater(e);
+          start_watching_hotend(e);
       }
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       // Make sure measured temperatures are close together
       if (ABS(temp_hotend[0].current - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
-        _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
+        _temp_error(H_E0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
     #endif
 
   } // HOTEND_LOOP
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
@@ -1059,28 +1052,28 @@ void Temperature::manage_heater() {
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
     #if ENABLED(THERMAL_PROTECTION_BED)
       if (!grace_period && degBed() > BED_MAXTEMP)
-        _temp_error(-1, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -1));
+        _temp_error(H_BED, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_BED));
     #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
-          _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
+          _temp_error(H_BED, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_BED));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
     do {
 
       #if DISABLED(PIDTEMPBED)
         if (PENDING(ms, next_bed_check_ms)
           #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
@@ -1091,21 +1084,21 @@ void Temperature::manage_heater() {
         #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
           last_pause_state = paused;
         #endif
       #endif
 
       #if HEATER_IDLE_HANDLER
         bed_idle.update(ms);
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
-        thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
+        thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, H_BED, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
       #endif
 
       #if HEATER_IDLE_HANDLER
         if (bed_idle.timed_out) {
           temp_bed.soft_pwm_amount = 0;
           #if DISABLED(PIDTEMPBED)
             WRITE_HEATER_BED(LOW);
           #endif
         }
         else
@@ -1137,28 +1130,28 @@ void Temperature::manage_heater() {
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (!grace_period && degChamber() > CHAMBER_MAXTEMP)
-        _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
+        _temp_error(H_CHAMBER, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, H_CHAMBER));
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
       if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
         if (degChamber() < watch_chamber.target)    // Failed to increase enough?
-          _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
+          _temp_error(H_CHAMBER, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, H_CHAMBER));
         else
           start_watching_chamber();                 // Start again if the target is still far off
       }
     #endif
 
     if (ELAPSED(ms, next_chamber_check_ms)) {
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
         #if ENABLED(CHAMBER_LIMIT_SWITCHING)
@@ -1169,21 +1162,21 @@ void Temperature::manage_heater() {
         #else
           temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
         #endif
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, H_CHAMBER, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
     }
 
     // TODO: Implement true PID pwm
     //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
@@ -1775,28 +1768,29 @@ void Temperature::init() {
     paused = false;
   #endif
 }
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
-  void Temperature::start_watching_heater(const uint8_t e) {
+  void Temperature::start_watching_hotend(const uint8_t e) {
     E_UNUSED();
-    if (degTargetHotend(HOTEND_INDEX) && degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
-      watch_hotend[HOTEND_INDEX].target = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
-      watch_hotend[HOTEND_INDEX].next_ms = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
+    const uint8_t ee = HOTEND_INDEX;
+    if (degTargetHotend(ee) && degHotend(ee) < degTargetHotend(ee) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
+      watch_hotend[ee].target = degHotend(ee) + WATCH_TEMP_INCREASE;
+      watch_hotend[ee].next_ms = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
     }
     else
-      watch_hotend[HOTEND_INDEX].next_ms = 0;
+      watch_hotend[ee].next_ms = 0;
   }
 #endif
 
 #if WATCH_BED
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M140, M190)
    */
   void Temperature::start_watching_bed() {
@@ -1830,28 +1824,28 @@ void Temperature::init() {
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
     Temperature::tr_state_machine_t Temperature::tr_state_machine[HOTENDS]; // = { { TRInactive, 0 } };
   #endif
   #if HAS_THERMALLY_PROTECTED_BED
     Temperature::tr_state_machine_t Temperature::tr_state_machine_bed; // = { TRInactive, 0 };
   #endif
   #if ENABLED(THERMAL_PROTECTION_CHAMBER)
     Temperature::tr_state_machine_t Temperature::tr_state_machine_chamber; // = { TRInactive, 0 };
   #endif
 
-  void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
+  void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
-      if (heater_id == -2) SERIAL_ECHOPGM("chamber");
+      if (heater_id == H_CHAMBER) SERIAL_ECHOPGM("chamber");
       if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
       SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
       if (heater_id >= 0)
         SERIAL_ECHOPAIR(" ;  Idle Timeout:", hotend_idle[heater_id].timed_out);
       else
         SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
       SERIAL_EOL();
     //*/
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
@@ -2226,58 +2220,58 @@ void Temperature::readings_ready() {
 
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
     const int8_t tdir = temp_dir[e];
     if (tdir) {
       const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
       const bool heater_on = (temp_hotend[e].target > 0
         #if ENABLED(PIDTEMP)
           || temp_hotend[e].soft_pwm_amount > 0
         #endif
       );
-      if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error(e);
+      if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error((heater_ind_t)e);
       if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
         #endif
-          min_temp_error(e);
+          min_temp_error((heater_ind_t)e);
       }
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         else
           consecutive_low_temperature_error[e] = 0;
       #endif
     }
   }
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<=(B))
     #else
       #define BEDCMP(A,B) ((A)>=(B))
     #endif
     const bool bed_on = (temp_bed.target > 0)
       #if ENABLED(PIDTEMPBED)
         || (temp_bed.soft_pwm_amount > 0)
       #endif
     ;
-    if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(-1);
-    if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(-1);
+    if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(H_BED);
+    if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(H_BED);
   #endif
 
   #if HAS_HEATED_CHAMBER
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<=(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>=(B))
     #endif
     const bool chamber_on = (temp_chamber.target > 0);
-    if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(-2);
-    if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(-2);
+    if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(H_CHAMBER);
+    if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(H_CHAMBER);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
@@ -2775,34 +2769,34 @@ void Temperature::isr() {
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
-    , const int8_t e=-3
+    , const heater_ind_t e=INDEX_NONE
   ) {
     char k;
     switch (e) {
       #if HAS_TEMP_CHAMBER
-        case -2: k = 'C'; break;
+        case H_CHAMBER: k = 'C'; break;
       #endif
       #if HAS_TEMP_HOTEND
         default: k = 'T'; break;
         #if HAS_HEATED_BED
-          case -1: k = 'B'; break;
+          case H_BED: k = 'B'; break;
         #endif
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-          case -3: k = 'R'; break;
+          case H_REDUNDANT: k = 'R'; break;
         #endif
       #elif HAS_HEATED_BED
         default: k = 'B'; break;
       #endif
     }
     SERIAL_CHAR(' ');
     SERIAL_CHAR(k);
     #if HOTENDS > 1
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
@@ -2825,65 +2819,65 @@ void Temperature::isr() {
       print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(target_extruder)
         #endif
       );
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         if (include_r) print_heater_state(redundant_temperature, degTargetHotend(target_extruder)
           #if ENABLED(SHOW_TEMP_ADC_VALUES)
             , redundant_temperature_raw
           #endif
-          , -3 // REDUNDANT
+          , H_REDUNDANT
         );
       #endif
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
-        , -1 // BED
+        , H_BED
       );
     #endif
     #if HAS_TEMP_CHAMBER
       print_heater_state(degChamber()
         #if HAS_HEATED_CHAMBER
           , degTargetChamber()
         #else
           , 0
         #endif
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawChamberTemp()
         #endif
-        , -2 // CHAMBER
+        , H_CHAMBER
       );
     #endif // HAS_TEMP_CHAMBER
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
-        , e
+        , (heater_ind_t)e
       );
     #endif
-    SERIAL_ECHOPAIR(" @:", getHeaterPower(target_extruder));
+    SERIAL_ECHOPAIR(" @:", getHeaterPower((heater_ind_t)target_extruder));
     #if HAS_HEATED_BED
-      SERIAL_ECHOPAIR(" B@:", getHeaterPower(-1));
+      SERIAL_ECHOPAIR(" B@:", getHeaterPower(H_BED));
     #endif
     #if HAS_HEATED_CHAMBER
-      SERIAL_ECHOPAIR(" C@:", getHeaterPower(-2));
+      SERIAL_ECHOPAIR(" C@:", getHeaterPower(H_CHAMBER));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
-        SERIAL_ECHO(getHeaterPower(e));
+        SERIAL_ECHO(getHeaterPower((heater_ind_t)e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {

commit d4415dcf592bbb1db869316a3020d92fa5a23edb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 2 04:04:49 2019 -0500

    Fix analogWrite ambiguity

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ea01cc27be..9856dc0f34 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -692,25 +692,25 @@ int16_t Temperature::getHeaterPower(const int8_t heater) {
 
     HOTEND_LOOP()
       if (temp_hotend[e].current >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_AUTO_CHAMBER_FAN
       if (temp_chamber.current >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
-    #define _UPDATE_AUTO_FAN(P,D,A) do{             \
-      if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)     \
-        analogWrite(P##_AUTO_FAN_PIN, D ? A : 0);   \
-      else                                          \
-        WRITE(P##_AUTO_FAN_PIN, D);                 \
+    #define _UPDATE_AUTO_FAN(P,D,A) do{                  \
+      if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)          \
+        analogWrite(pin_t(P##_AUTO_FAN_PIN), D ? A : 0); \
+      else                                               \
+        WRITE(P##_AUTO_FAN_PIN, D);                      \
     }while(0)
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanBit); f++) {
       const uint8_t realFan = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, realFan)) continue;
       const bool fan_on = TEST(fanState, realFan);
       switch (f) {
         #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
           case CHAMBER_FAN_INDEX:

commit c28e08c8495a0cfa4b382632e8d853079d47b8c0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 1 09:40:54 2019 -0500

    Fix mintemp/maxtemp monitoring for thermocouples

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0bff0ad675..ea01cc27be 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2187,64 +2187,71 @@ void Temperature::readings_ready() {
   HOTEND_LOOP() temp_hotend[e].acc = 0;
 
   #if HAS_HEATED_BED
     temp_bed.acc = 0;
   #endif
 
   #if HAS_TEMP_CHAMBER
     temp_chamber.acc = 0;
   #endif
 
-  int constexpr temp_dir[] = {
+  static constexpr int8_t temp_dir[] = {
     #if ENABLED(HEATER_0_USES_MAX6675)
-       0
+      0
     #else
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
-      , TEMPDIR(1)
+      #if ENABLED(HEATER_1_USES_MAX6675)
+        , 0
+      #else
+        , TEMPDIR(1)
+      #endif
       #if HOTENDS > 2
         , TEMPDIR(2)
         #if HOTENDS > 3
           , TEMPDIR(3)
           #if HOTENDS > 4
             , TEMPDIR(4)
             #if HOTENDS > 5
               , TEMPDIR(5)
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   };
 
   // Give ADC temperature readings time to settle at boot-up before testing
   if (grace_period) return;
 
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
-    const int16_t tdir = temp_dir[e], rawtemp = temp_hotend[e].raw * tdir;
-    const bool heater_on = (temp_hotend[e].target > 0)
-      #if ENABLED(PIDTEMP)
-        || (temp_hotend[e].soft_pwm_amount > 0)
-      #endif
-    ;
-    if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error(e);
-    if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
+    const int8_t tdir = temp_dir[e];
+    if (tdir) {
+      const int16_t rawtemp = temp_hotend[e].raw * tdir; // normal direction, +rawtemp, else -rawtemp
+      const bool heater_on = (temp_hotend[e].target > 0
+        #if ENABLED(PIDTEMP)
+          || temp_hotend[e].soft_pwm_amount > 0
+        #endif
+      );
+      if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error(e);
+      if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
+        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+        #endif
+          min_temp_error(e);
+      }
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-        if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+        else
+          consecutive_low_temperature_error[e] = 0;
       #endif
-          min_temp_error(e);
     }
-    #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-      else
-        consecutive_low_temperature_error[e] = 0;
-    #endif
   }
 
   #if HAS_HEATED_BED
     #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<=(B))
     #else
       #define BEDCMP(A,B) ((A)>=(B))
     #endif
     const bool bed_on = (temp_bed.target > 0)
       #if ENABLED(PIDTEMPBED)

commit d16954dc885f75869b572549c5e90561b89a95bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 29 22:49:50 2019 -0500

    Make KEEPALIVE_STATE a scoped auto-restore (#14446)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f5a37568a9..0bff0ad675 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2918,21 +2918,20 @@ void Temperature::isr() {
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
-        const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degHotend(target_extruder);
         printerEventLEDs.onHotendHeatingStart();
       #endif
 
       float target_temp = -1.0, old_temp = 9999.0;
       bool wants_to_cool = false, first_loop = true;
@@ -3012,24 +3011,20 @@ void Temperature::isr() {
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         ui.reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onHeatingDone();
         #endif
       }
 
-      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
-        gcode.busy_state = old_busy_state;
-      #endif
-
       return wait_for_heatup;
     }
 
   #endif // HAS_TEMP_HOTEND
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
       #define MIN_COOLING_SLOPE_DEG_BED 1.50
     #endif
@@ -3051,21 +3046,20 @@ void Temperature::isr() {
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       float target_temp = -1, old_temp = 9999;
       bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
-        const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
         printerEventLEDs.onBedHeatingStart();
       #endif
 
       do {
         // Target temperature might be changed during the loop
@@ -3138,24 +3132,20 @@ void Temperature::isr() {
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
           first_loop = false;
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
-      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
-        gcode.busy_state = old_busy_state;
-      #endif
-
       return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_BED
 
   #if 0 && HAS_HEATED_CHAMBER
 
     #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
       #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
     #endif
@@ -3172,21 +3162,20 @@ void Temperature::isr() {
         // Loop until the temperature is very close target
         #define TEMP_CHAMBER_CONDITIONS (wants_to_cool ? isCoolingChamber() : isHeatingChamber())
       #endif
 
       float target_temp = -1, old_temp = 9999;
       bool wants_to_cool = false, first_loop = true;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
-        const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetChamber()) {
           wants_to_cool = isCoolingChamber();
           target_temp = degTargetChamber();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
@@ -3240,20 +3229,16 @@ void Temperature::isr() {
             old_temp = temp;
           }
         }
 
         first_loop = false;
 
       } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
-      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
-        gcode.busy_state = old_busy_state;
-      #endif
-
       return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_CHAMBER
 
 #endif // HAS_TEMP_SENSOR

commit a9445d557e2824f5da4bc5972ee88d58bbed2572
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jun 29 01:54:22 2019 +0200

    Remove extra #if (#14439)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fc93319de6..f5a37568a9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1960,31 +1960,27 @@ void Temperature::disable_all_heaters() {
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.target = 0;
     temp_bed.soft_pwm_amount = 0;
-    #if HAS_HEATED_BED
-      WRITE_HEATER_BED(LOW);
-    #endif
+    WRITE_HEATER_BED(LOW);
   #endif
 
   #if HAS_HEATED_CHAMBER
     temp_chamber.target = 0;
     temp_chamber.soft_pwm_amount = 0;
-    #if HAS_HEATED_CHAMBER
-      WRITE_HEATER_CHAMBER(LOW);
-    #endif
+    WRITE_HEATER_CHAMBER(LOW);
   #endif
 }
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
         HOTEND_LOOP() hotend_idle[e].expire(); // timeout immediately

commit 4d5a1984e216098b49cf1c590272b45d4177e86f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 17:03:43 2019 -0500

    Simplified fan handling code

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 828c34e4ce..fc93319de6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2385,22 +2385,23 @@ void Temperature::isr() {
       #if HAS_HEATED_BED
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #define _FAN_PWM(N) do{ \
-          soft_pwm_count_fan[N] = (soft_pwm_count_fan[N] & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
-          WRITE_FAN_N(N, soft_pwm_count_fan[N] > pwm_mask ? HIGH : LOW); \
+          uint8_t &spcf = soft_pwm_count_fan[N]; \
+          spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
+          WRITE_FAN(N, spcf > pwm_mask ? HIGH : LOW); \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif
@@ -2431,27 +2432,27 @@ void Temperature::isr() {
       #if HAS_HEATED_BED
         _PWM_LOW(BED, soft_pwm_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_LOW(CHAMBER, soft_pwm_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
-          if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
+          if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(0, LOW);
         #endif
         #if HAS_FAN1
-          if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
+          if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN(1, LOW);
         #endif
         #if HAS_FAN2
-          if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
+          if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN(2, LOW);
         #endif
       #endif
     }
 
     // SOFT_PWM_SCALE to frequency:
     //
     // 0: 16000000/64/256/128 =   7.6294 Hz
     // 1:                / 64 =  15.2588 Hz
     // 2:                / 32 =  30.5176 Hz
     // 3:                / 16 =  61.0352 Hz
@@ -2518,42 +2519,42 @@ void Temperature::isr() {
       #endif // HOTENDS > 1
     #endif // HOTENDS
 
     #if HAS_HEATED_BED
       _PWM_OFF(BED, soft_pwm_bed);
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
         pwm_count_tmp = 0;
-        #define _PWM_FAN(N,I) do{                               \
-          soft_pwm_count_fan[I] = soft_pwm_amount_fan[I] >> 1;  \
-          WRITE_FAN##N(soft_pwm_count_fan[I] > 0 ? HIGH : LOW); \
+        #define _PWM_FAN(N) do{                                 \
+          soft_pwm_count_fan[N] = soft_pwm_amount_fan[N] >> 1;  \
+          WRITE_FAN(N, soft_pwm_count_fan[N] > 0 ? HIGH : LOW); \
         }while(0)
         #if HAS_FAN0
-          _PWM_FAN(,0);
+          _PWM_FAN(0);
         #endif
         #if HAS_FAN1
-          _PWM_FAN(1,1);
+          _PWM_FAN(1);
         #endif
         #if HAS_FAN2
-          _PWM_FAN(2,2);
+          _PWM_FAN(2);
         #endif
       }
       #if HAS_FAN0
-        if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
+        if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(0, LOW);
       #endif
       #if HAS_FAN1
-        if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
+        if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN(1, LOW);
       #endif
       #if HAS_FAN2
-        if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
+        if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN(2, LOW);
       #endif
     #endif // FAN_SOFT_PWM
 
     // SOFT_PWM_SCALE to frequency:
     //
     // 0: 16000000/64/256/128 =   7.6294 Hz
     // 1:                / 64 =  15.2588 Hz
     // 2:                / 32 =  30.5176 Hz
     // 3:                / 16 =  61.0352 Hz
     // 4:                /  8 = 122.0703 Hz

commit a8d68b7c8a5ed440b2d12aea077ad05cadbaadfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:58:40 2019 -0500

    Common method for scaled fan speed

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 35ace2c42a..828c34e4ce 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -164,20 +164,23 @@ hotend_info_t Temperature::temp_hotend[HOTENDS
     uint8_t Temperature::lcd_tmpfan_speed[
       #if ENABLED(SINGLENOZZLE)
         MAX(EXTRUDERS, FAN_COUNT)
       #else
         FAN_COUNT
       #endif
     ]; // = { 0 }
 
   #endif
 
+  /**
+   * Set the print fan speed for a target extruder
+   */
   void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
 
     NOMORE(speed, 255U);
 
     #if ENABLED(SINGLENOZZLE)
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9553e8e3b7..35ace2c42a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 81209f53102e53a0a00227eae5d2ea0ee3bdd255
Author: Tim Moore <tim@youngmoores.com>
Date:   Thu Jun 27 19:29:53 2019 -0700

    'M105 R' to report redundant temp sensor (#14324)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 3382368da3..9553e8e3b7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -105,21 +105,25 @@ Temperature thermalManager;
 #endif
 #define _E_PSTR(M,E,N) ((HOTENDS) >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
 #define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
-hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
+hotend_info_t Temperature::temp_hotend[HOTENDS
+  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+    + 1
+  #endif
+]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if ENABLED(AUTO_POWER_CHAMBER_FAN)
   uint8_t Temperature::chamberfan_speed; // = 0
 #endif
 
 #if FAN_COUNT > 0
@@ -2766,56 +2770,71 @@ void Temperature::isr() {
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const int8_t e=-3
   ) {
-    #if !(HAS_HEATED_BED && HAS_TEMP_HOTEND && HAS_TEMP_CHAMBER) && HOTENDS <= 1
-      UNUSED(e);
-    #endif
-
-    SERIAL_CHAR(' ');
-    SERIAL_CHAR(
-      #if HAS_TEMP_CHAMBER && HAS_HEATED_BED && HAS_TEMP_HOTEND
-        e == -2 ? 'C' : e == -1 ? 'B' : 'T'
-      #elif HAS_HEATED_BED && HAS_TEMP_HOTEND
-        e == -1 ? 'B' : 'T'
-      #elif HAS_TEMP_HOTEND
-        'T'
-      #else
-        'B'
+    char k;
+    switch (e) {
+      #if HAS_TEMP_CHAMBER
+        case -2: k = 'C'; break;
       #endif
-    );
+      #if HAS_TEMP_HOTEND
+        default: k = 'T'; break;
+        #if HAS_HEATED_BED
+          case -1: k = 'B'; break;
+        #endif
+        #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+          case -3: k = 'R'; break;
+        #endif
+      #elif HAS_HEATED_BED
+        default: k = 'B'; break;
+      #endif
+    }
+    SERIAL_CHAR(' ');
+    SERIAL_CHAR(k);
     #if HOTENDS > 1
       if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
     SERIAL_CHAR(':');
     SERIAL_ECHO(c);
     SERIAL_ECHOPAIR(" /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_ECHOPAIR(" (", r / OVERSAMPLENR);
+      SERIAL_ECHOPAIR(" (", r * RECIPROCAL(OVERSAMPLENR));
       SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
-  void Temperature::print_heater_states(const uint8_t target_extruder) {
+  void Temperature::print_heater_states(const uint8_t target_extruder
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      , const bool include_r/*=false*/
+    #endif
+  ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(target_extruder)
         #endif
       );
+      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+        if (include_r) print_heater_state(redundant_temperature, degTargetHotend(target_extruder)
+          #if ENABLED(SHOW_TEMP_ADC_VALUES)
+            , redundant_temperature_raw
+          #endif
+          , -3 // REDUNDANT
+        );
+      #endif
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
         , -1 // BED
       );
     #endif
     #if HAS_TEMP_CHAMBER

commit 8ce84fa44fd4f728249335df9d03a3444fd8933c
Author: Tim Moore <tim@youngmoores.com>
Date:   Thu Jun 27 14:28:07 2019 -0700

    Add temperature-based auto power options (#14397)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 27b8eb803d..3382368da3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -677,25 +677,25 @@ int16_t Temperature::getHeaterPower(const int8_t heater) {
       #if HOTENDS > 5
         , AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
       #endif
       #if HAS_AUTO_CHAMBER_FAN
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
       #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
-      if (temp_hotend[e].current > EXTRUDER_AUTO_FAN_TEMPERATURE)
+      if (temp_hotend[e].current >= EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_AUTO_CHAMBER_FAN
-      if (temp_chamber.current > CHAMBER_AUTO_FAN_TEMPERATURE)
+      if (temp_chamber.current >= CHAMBER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{             \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)     \
         analogWrite(P##_AUTO_FAN_PIN, D ? A : 0);   \
       else                                          \
         WRITE(P##_AUTO_FAN_PIN, D);                 \
     }while(0)
 

commit 8934b32f1b9bd388eae25f0372ed62b57200bab8
Author: Eric Ptak <trouch@trouch.com>
Date:   Wed Jun 26 07:40:29 2019 +0200

    Fysetc AIO II / Cheetah STM32F1 (#14407)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 23f2d003da..27b8eb803d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -344,21 +344,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
     const bool isbed = (heater < 0);
-    
+
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (isbed ? (B) : (H))
       #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
       #define ONHEATINGSTART() (isbed ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
       #define ONHEATING(S,C,T) (isbed ? printerEventLEDs.onBedHeating(S,C,T) : printerEventLEDs.onHotendHeating(S,C,T))
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)

commit 1db7013e3be036381df249d6b482e20aed31c811
Author: mikeshub <mikesbaker@gmail.com>
Date:   Sat Jun 22 16:52:56 2019 -0500

    Fix and improve PID loops (#14373)
    
    - Windup guarding was missing. The kludge in place of windup guard is removed. D term filter calculations are simplified to require fewer `float` calculations. Sign change for D term output to make debugging output clearer.
    - Use "no overshoot" for bed PID tuning.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a496748581..23f2d003da 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -343,41 +343,43 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
+    const bool isbed = (heater < 0);
+    
     #if HAS_PID_FOR_BOTH
-      #define GHV(B,H) (heater < 0 ? (B) : (H))
-      #define SHV(B,H) do{ if (heater < 0) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
-      #define ONHEATINGSTART() (heater < 0 ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
-      #define ONHEATING(S,C,T) do{ if (heater < 0) printerEventLEDs.onBedHeating(S,C,T); else printerEventLEDs.onHotendHeating(S,C,T); }while(0)
+      #define GHV(B,H) (isbed ? (B) : (H))
+      #define SHV(B,H) do{ if (isbed) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
+      #define ONHEATINGSTART() (isbed ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
+      #define ONHEATING(S,C,T) (isbed ? printerEventLEDs.onBedHeating(S,C,T) : printerEventLEDs.onHotendHeating(S,C,T))
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
       #define SHV(B,H) (temp_hotend[heater].soft_pwm_amount = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
 
     #if WATCH_BED || WATCH_HOTENDS
       #define HAS_TP_BED BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
       #if HAS_TP_BED && BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
-        #define GTV(B,H) (heater < 0 ? (B) : (H))
+        #define GTV(B,H) (isbed ? (B) : (H))
       #elif HAS_TP_BED
         #define GTV(B,H) (B)
       #else
         #define GTV(B,H) (H)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
@@ -449,37 +451,39 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, min, MSG_T_MAX, max);
               if (cycles > 2) {
-                float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
-                      Tu = ((float)(t_low + t_high) * 0.001f);
-                tune_pid.Kp = 0.6f * Ku;
+                const float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
+                            Tu = float(t_low + t_high) * 0.001f,
+                            pf = isbed ? 0.2f : 0.6f,
+                            df = isbed ? 1.0f / 3.0f : 1.0f / 8.0f;
+                tune_pid.Kp = Ku * pf;
+                tune_pid.Kd = tune_pid.Kp * Tu * df;
                 tune_pid.Ki = 2 * tune_pid.Kp / Tu;
-                tune_pid.Kd = tune_pid.Kp * Tu * 0.125f;
                 SERIAL_ECHOPAIR(MSG_KU, Ku, MSG_TU, Tu);
                 SERIAL_ECHOLNPGM("\n" MSG_CLASSIC_PID);
                 SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
                 /**
-                tune_pid.Kp = 0.33*Ku;
-                tune_pid.Ki = tune_pid.Kp/Tu;
-                tune_pid.Kd = tune_pid.Kp*Tu/3;
+                tune_pid.Kp = 0.33 * Ku;
+                tune_pid.Ki = tune_pid.Kp / Tu;
+                tune_pid.Kd = tune_pid.Kp * Tu / 3;
                 SERIAL_ECHOLNPGM(" Some overshoot");
                 SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
-                tune_pid.Kp = 0.2*Ku;
-                tune_pid.Ki = 2*tune_pid.Kp/Tu;
-                tune_pid.Kd = tune_pid.Kp*Tu/3;
+                tune_pid.Kp = 0.2 * Ku;
+                tune_pid.Ki = 2 * tune_pid.Kp / Tu;
+                tune_pid.Kd = tune_pid.Kp * Tu / 3;
                 SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd);
                 */
               }
             }
             SHV((bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             min = target;
           }
         }
       }
@@ -489,34 +493,34 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
       if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
-          print_heater_states(heater >= 0 ? heater : active_extruder);
+          print_heater_states(isbed ? active_extruder : heater);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_BED || WATCH_HOTENDS
           if (
             #if WATCH_BED && WATCH_HOTENDS
               true
             #elif WATCH_HOTENDS
-              heater >= 0
+              !isbed
             #else
-              heater < 0
+              isbed
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
                 if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
                 _temp_error(heater, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, heater));
@@ -562,21 +566,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
 
         #define _SET_EXTRUDER_PID() do { \
           PID_PARAM(Kp, heater) = tune_pid.Kp; \
           PID_PARAM(Ki, heater) = scalePID_i(tune_pid.Ki); \
           PID_PARAM(Kd, heater) = scalePID_d(tune_pid.Kd); \
           updatePID(); }while(0)
 
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
-            if (heater < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();
+            if (isbed) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onPidTuningDone(color);
         #endif
@@ -798,74 +802,70 @@ float Temperature::get_pid_output(const int8_t e) {
     #define _HOTEND_TEST (e == active_extruder)
   #endif
   E_UNUSED();
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       static hotend_pid_t work_pid[HOTENDS];
       static float temp_iState[HOTENDS] = { 0 },
                    temp_dState[HOTENDS] = { 0 };
       static bool pid_reset[HOTENDS] = { false };
-      float pid_error = temp_hotend[HOTEND_INDEX].target - temp_hotend[HOTEND_INDEX].current;
-      work_pid[HOTEND_INDEX].Kd = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (temp_hotend[HOTEND_INDEX].current - temp_dState[HOTEND_INDEX]) + float(PID_K1) * work_pid[HOTEND_INDEX].Kd;
-      temp_dState[HOTEND_INDEX] = temp_hotend[HOTEND_INDEX].current;
+      const float pid_error = temp_hotend[HOTEND_INDEX].target - temp_hotend[HOTEND_INDEX].current;
 
       if (temp_hotend[HOTEND_INDEX].target == 0
         || pid_error < -(PID_FUNCTIONAL_RANGE)
         #if HEATER_IDLE_HANDLER
           || hotend_idle[HOTEND_INDEX].timed_out
         #endif
       ) {
         pid_output = 0;
         pid_reset[HOTEND_INDEX] = true;
       }
       else if (pid_error > PID_FUNCTIONAL_RANGE) {
         pid_output = BANG_MAX;
         pid_reset[HOTEND_INDEX] = true;
       }
       else {
         if (pid_reset[HOTEND_INDEX]) {
           temp_iState[HOTEND_INDEX] = 0.0;
+          work_pid[HOTEND_INDEX].Kd = 0.0;
           pid_reset[HOTEND_INDEX] = false;
         }
-        temp_iState[HOTEND_INDEX] += pid_error;
+
+        work_pid[HOTEND_INDEX].Kd = work_pid[HOTEND_INDEX].Kd + PID_K2 * (PID_PARAM(Kd, HOTEND_INDEX) * (temp_dState[HOTEND_INDEX] - temp_hotend[HOTEND_INDEX].current) - work_pid[HOTEND_INDEX].Kd);
+        const float max_power_over_i_gain = (float)PID_MAX / PID_PARAM(Ki, HOTEND_INDEX);
+        temp_iState[HOTEND_INDEX] = constrain(temp_iState[HOTEND_INDEX] + pid_error, 0, max_power_over_i_gain);
         work_pid[HOTEND_INDEX].Kp = PID_PARAM(Kp, HOTEND_INDEX) * pid_error;
         work_pid[HOTEND_INDEX].Ki = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
 
-        pid_output = work_pid[HOTEND_INDEX].Kp + work_pid[HOTEND_INDEX].Ki - work_pid[HOTEND_INDEX].Kd;
+        pid_output = work_pid[HOTEND_INDEX].Kp + work_pid[HOTEND_INDEX].Ki + work_pid[HOTEND_INDEX].Kd;
 
         #if ENABLED(PID_EXTRUSION_SCALING)
           work_pid[HOTEND_INDEX].Kc = 0;
           if (_HOTEND_TEST) {
             const long e_position = stepper.position(E_AXIS);
             if (e_position > last_e_position) {
               lpq[lpq_ptr] = e_position - last_e_position;
               last_e_position = e_position;
             }
             else
               lpq[lpq_ptr] = 0;
 
             if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
             work_pid[HOTEND_INDEX].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
             pid_output += work_pid[HOTEND_INDEX].Kc;
           }
         #endif // PID_EXTRUSION_SCALING
 
-        if (pid_output > PID_MAX) {
-          if (pid_error > 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
-          pid_output = PID_MAX;
-        }
-        else if (pid_output < 0) {
-          if (pid_error < 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
-          pid_output = 0;
-        }
+        pid_output = constrain(pid_output, 0, PID_MAX);
       }
+      temp_dState[HOTEND_INDEX] = temp_hotend[HOTEND_INDEX].current;
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_hotend[HOTEND_INDEX].target, 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOPAIR(
@@ -901,37 +901,32 @@ float Temperature::get_pid_output(const int8_t e) {
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
       static PID_t work_pid = { 0 };
       static float temp_iState = 0, temp_dState = 0;
 
-      float pid_error = temp_bed.target - temp_bed.current;
-      temp_iState += pid_error;
+      const float max_power_over_i_gain = (float)MAX_BED_POWER / temp_bed.pid.Ki,
+                  pid_error = temp_bed.target - temp_bed.current;
+
+      temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
+
       work_pid.Kp = temp_bed.pid.Kp * pid_error;
       work_pid.Ki = temp_bed.pid.Ki * temp_iState;
-      work_pid.Kd = PID_K2 * temp_bed.pid.Kd * (temp_bed.current - temp_dState) + PID_K1 * work_pid.Kd;
+      work_pid.Kd = work_pid.Kd + PID_K2 * (temp_bed.pid.Kd * (temp_dState - temp_bed.current) - work_pid.Kd);
 
       temp_dState = temp_bed.current;
 
-      float pid_output = work_pid.Kp + work_pid.Ki - work_pid.Kd;
-      if (pid_output > MAX_BED_POWER) {
-        if (pid_error > 0) temp_iState -= pid_error; // conditional un-integration
-        pid_output = MAX_BED_POWER;
-      }
-      else if (pid_output < 0) {
-        if (pid_error < 0) temp_iState -= pid_error; // conditional un-integration
-        pid_output = 0;
-      }
+      const float pid_output = constrain(work_pid.Kp + work_pid.Ki + work_pid.Kd, 0, MAX_BED_POWER);
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPAIR(

commit 2290b269dc862709c7055784d2e130517a02231c
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Jun 18 07:15:41 2019 +0200

    Unused variable (#14301)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 662d2bc2ab..a496748581 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -771,20 +771,22 @@ void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P
           WRITE(BEEPER_PIN, HIGH); delay(25);
           WRITE(BEEPER_PIN, LOW); delay(80);
         }
         WRITE(BEEPER_PIN, HIGH);
       #endif
 
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
+  #else
+    UNUSED(killed);
   #endif
 }
 
 void Temperature::max_temp_error(const int8_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
 void Temperature::min_temp_error(const int8_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }

commit bd494a6bd6dcdd3e467a3eb1d34e10def363742b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Wed May 29 00:43:31 2019 +0200

    Update defines for patched temperature macros (#14161)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0c63c544c4..662d2bc2ab 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1224,24 +1224,24 @@ void Temperature::manage_heater() {
       #endif
       #if ENABLED(HEATER_3_USER_THERMISTOR)
         { true, 0, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
       #endif
       #if ENABLED(HEATER_4_USER_THERMISTOR)
         { true, 0, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
       #endif
       #if ENABLED(HEATER_5_USER_THERMISTOR)
         { true, 0, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
       #endif
-      #if ENABLED(BED_USER_THERMISTOR)
+      #if ENABLED(HEATER_BED_USER_THERMISTOR)
         { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
       #endif
-      #if ENABLED(CHAMBER_USER_THERMISTOR)
+      #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
         { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
       #endif
     };
     COPY(thermalManager.user_thermistor, user_thermistor);
   }
 
   void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
 
     if (eprom)
       SERIAL_ECHOPGM("  M305 ");
@@ -1269,24 +1269,24 @@ void Temperature::manage_heater() {
       #endif
       #if ENABLED(HEATER_3_USER_THERMISTOR)
         t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :
       #endif
       #if ENABLED(HEATER_4_USER_THERMISTOR)
         t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :
       #endif
       #if ENABLED(HEATER_5_USER_THERMISTOR)
         t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :
       #endif
-      #if ENABLED(BED_USER_THERMISTOR)
+      #if ENABLED(HEATER_BED_USER_THERMISTOR)
         t_index == CTI_BED ? PSTR("BED") :
       #endif
-      #if ENABLED(CHAMBER_USER_THERMISTOR)
+      #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
         t_index == CTI_CHAMBER ? PSTR("CHAMBER") :
       #endif
       nullptr
     );
     SERIAL_EOL();
   }
 
   float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
@@ -1422,39 +1422,39 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
     SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
   #endif
 
   return 0;
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
-    #if ENABLED(BED_USER_THERMISTOR)
+    #if ENABLED(HEATER_BED_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_BED_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
-    #if ENABLED(CHAMBER_USER_THERMISTOR)
+    #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(CHAMBER_TEMPTABLE, CHAMBER_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_CHAMBER_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif

commit e09d8811c183819610f1c6a3a1d4b898df13f408
Author: doggyfan <49303635+doggyfan@users.noreply.github.com>
Date:   Tue May 28 21:36:03 2019 +0100

    Apply grace period to thermistor failure testing (#14167)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 717489857c..0c63c544c4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -75,20 +75,24 @@
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
   #endif
 #endif
 
+#ifndef THERMAL_PROTECTION_GRACE_PERIOD
+  #define THERMAL_PROTECTION_GRACE_PERIOD 0 // No grace period needed on well-behaved boards
+#endif
+
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
   #define _BED_PSTR(M,E) (E) == -1 ? PSTR(M) :
 #else
@@ -984,23 +988,20 @@ void Temperature::manage_heater() {
     if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
   #endif
 
   #define HAS_THERMAL_PROTECTION (ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER))
 
   #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   #if HAS_THERMAL_PROTECTION
-    #ifndef THERMAL_PROTECTION_GRACE_PERIOD
-      #define THERMAL_PROTECTION_GRACE_PERIOD 0 // No grace period needed on well-behaved boards
-    #endif
     #if THERMAL_PROTECTION_GRACE_PERIOD > 0
       static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD;
       if (ELAPSED(ms, grace_period)) grace_period = 0UL;
     #else
       static constexpr millis_t grace_period = 0UL;
     #endif
   #endif
 
   HOTEND_LOOP() {
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
@@ -2159,20 +2160,29 @@ void Temperature::set_current_temp_raw() {
   #endif
 
   temp_meas_ready = true;
 }
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint32_t raw_filwidth_value; // = 0
 #endif
 
 void Temperature::readings_ready() {
+
+  #if THERMAL_PROTECTION_GRACE_PERIOD > 0
+    const millis_t ms = millis();
+    static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD; // NOTE: millis() == 0 on reset
+    if (ELAPSED(ms, grace_period)) grace_period = 0;
+  #else
+    static constexpr millis_t grace_period = 0;
+  #endif
+
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
   HOTEND_LOOP() temp_hotend[e].acc = 0;
 
@@ -2200,20 +2210,23 @@ void Temperature::readings_ready() {
             , TEMPDIR(4)
             #if HOTENDS > 5
               , TEMPDIR(5)
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   };
 
+  // Give ADC temperature readings time to settle at boot-up before testing
+  if (grace_period) return;
+
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
     const int16_t tdir = temp_dir[e], rawtemp = temp_hotend[e].raw * tdir;
     const bool heater_on = (temp_hotend[e].target > 0)
       #if ENABLED(PIDTEMP)
         || (temp_hotend[e].soft_pwm_amount > 0)
       #endif
     ;
     if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error(e);
     if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED

commit 605ec0a4784768d09d78587240be80e8cc998c70
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 26 01:30:15 2019 -0500

    Fix thermistor table warning

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f8494bfa06..717489857c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1424,39 +1424,39 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
   return 0;
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
     #if ENABLED(BED_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_BED, raw);
     #elif ENABLED(HEATER_BED_USES_THERMISTOR)
-      SCAN_THERMISTOR_TABLE(BEDTEMPTABLE, BEDTEMPTABLE_LEN);
+      SCAN_THERMISTOR_TABLE(BED_TEMPTABLE, BED_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_BED_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
     #if ENABLED(CHAMBER_USER_THERMISTOR)
       return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
     #elif ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
-      SCAN_THERMISTOR_TABLE(CHAMBERTEMPTABLE, CHAMBERTEMPTABLE_LEN);
+      SCAN_THERMISTOR_TABLE(CHAMBER_TEMPTABLE, CHAMBER_TEMPTABLE_LEN);
     #elif ENABLED(HEATER_CHAMBER_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 

commit 48d1bd29cb51da730b02cec7313889b859bb1ba2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 25 15:19:47 2019 -0500

    Shift m before compare to 0

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 462942d768..f8494bfa06 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1184,23 +1184,22 @@ void Temperature::manage_heater() {
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
   uint8_t l = 0, r = LEN, m;                                           \
   for (;;) {                                                           \
-    m = l + r;                                                         \
+    m = (l + r) >> 1;                                                  \
     if (!m) return short(pgm_read_word(&TBL[0][1]));                   \
-    m >>= 1;                                                           \
     if (m == l || m == r) return short(pgm_read_word(&TBL[LEN-1][1])); \
     short v00 = pgm_read_word(&TBL[m-1][0]),                           \
           v10 = pgm_read_word(&TBL[m-0][0]);                           \
          if (raw < v00) r = m;                                         \
     else if (raw > v10) l = m;                                         \
     else {                                                             \
       const short v01 = short(pgm_read_word(&TBL[m-1][1])),            \
                   v11 = short(pgm_read_word(&TBL[m-0][1]));            \
       return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);  \
     }                                                                  \

commit 594f6b14bed89d137ca3d9dadaeb978653fe661a
Author: doggyfan <49303635+doggyfan@users.noreply.github.com>
Date:   Wed May 22 03:31:05 2019 +0100

    Limit user thermistor to 999, fix thermistor table macro (#14080)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a6902af884..462942d768 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -61,20 +61,24 @@
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
+#if HAS_BUZZER
+  #include "../libs/buzzer.h"
+#endif
+
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
   #endif
 #endif
 
@@ -743,24 +747,36 @@ void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(MSG_STOPPED_HEATER);
     if (heater >= 0) SERIAL_ECHO((int)heater);
     #if HAS_HEATED_CHAMBER
       else if (heater == -2) SERIAL_ECHOPGM(MSG_HEATER_CHAMBER);
     #endif
     else SERIAL_ECHOPGM(MSG_HEATER_BED);
     SERIAL_EOL();
   }
+
   #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
     if (!killed) {
       Running = false;
       killed = true;
+
+      disable_all_heaters();
+
+      #if HAS_BUZZER && PIN_EXISTS(BEEPER)
+        for (uint8_t i = 20; i--;) {
+          WRITE(BEEPER_PIN, HIGH); delay(25);
+          WRITE(BEEPER_PIN, LOW); delay(80);
+        }
+        WRITE(BEEPER_PIN, HIGH);
+      #endif
+
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #endif
 }
 
 void Temperature::max_temp_error(const int8_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
@@ -1168,29 +1184,31 @@ void Temperature::manage_heater() {
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
   uint8_t l = 0, r = LEN, m;                                           \
   for (;;) {                                                           \
-    m = (l + r) >> 1;                                                  \
-    if (m == l || m == r) return (short)pgm_read_word(&TBL[LEN-1][1]); \
+    m = l + r;                                                         \
+    if (!m) return short(pgm_read_word(&TBL[0][1]));                   \
+    m >>= 1;                                                           \
+    if (m == l || m == r) return short(pgm_read_word(&TBL[LEN-1][1])); \
     short v00 = pgm_read_word(&TBL[m-1][0]),                           \
           v10 = pgm_read_word(&TBL[m-0][0]);                           \
          if (raw < v00) r = m;                                         \
     else if (raw > v10) l = m;                                         \
     else {                                                             \
-      const short v01 = (short)pgm_read_word(&TBL[m-1][1]),            \
-                  v11 = (short)pgm_read_word(&TBL[m-0][1]);            \
+      const short v01 = short(pgm_read_word(&TBL[m-1][1])),            \
+                  v11 = short(pgm_read_word(&TBL[m-0][1]));            \
       return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);  \
     }                                                                  \
   }                                                                    \
 }while(0)
 
 #if HAS_USER_THERMISTORS
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
   void Temperature::reset_user_thermistors() {
@@ -1294,35 +1312,30 @@ void Temperature::manage_heater() {
     const float adc_inverse = (adc_max - adc_raw) - 0.5f,
                 resistance = user_thermistor[t_index].series_res * (adc_raw + 0.5f) / adc_inverse,
                 log_resistance = logf(resistance);
 
     float value = user_thermistor[t_index].sh_alpha;
     value += log_resistance * user_thermistor[t_index].beta_recip;
     if (user_thermistor[t_index].sh_c_coeff != 0)
       value += user_thermistor[t_index].sh_c_coeff * log_resistance * log_resistance * log_resistance;
     value = 1.0f / value;
 
-    // Convert to degrees C
-    float deg_c = value + THERMISTOR_ABS_ZERO_C;
-
-    // Test only
-    //deg_c = constrain(deg_c, 6, 100);
-
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  int32_t clocks = TCNT5 - tcnt5;
     //  if (clocks >= 0) {
     //    clocks_total += clocks;
     //    calls++;
     //  }
     //#endif
 
-    return deg_c;
+    // Return degrees C (up to 999, as the LCD only displays 3 digits)
+    return MIN(value + THERMISTOR_ABS_ZERO_C, 999);
   }
 #endif
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)

commit 3cd19a8ec080dda75c6326886e90fc2f0972b499
Author: Pavel4e5 <50713272+Pavel4e5@users.noreply.github.com>
Date:   Sun May 19 06:52:55 2019 +0500

    Improve Zonestar keypad responsiveness (#14056)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a4a94fc678..a6902af884 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -303,21 +303,21 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
   uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 // public:
 
 #if HAS_ADC_BUTTONS
-  uint32_t Temperature::current_ADCKey_raw = 0;
+  uint32_t Temperature::current_ADCKey_raw = 1024;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
@@ -2293,20 +2293,21 @@ public:
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
+    static bool ADCKey_pressed = false;
   #endif
 
   #if ENABLED(SLOW_PWM_HEATERS)
     static uint8_t slow_pwm_count = 0;
   #endif
 
   static SoftPWM soft_pwm_hotend[HOTENDS];
 
   #if HAS_HEATED_BED
     static SoftPWM soft_pwm_bed;
@@ -2695,30 +2696,33 @@ void Temperature::isr() {
 
     #if HAS_ADC_BUTTONS
       case Prepare_ADC_KEY:
         HAL_START_ADC(ADC_KEYPAD_PIN);
         break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < 16) {
           raw_ADCKey_value = HAL_READ_ADC();
-          if (raw_ADCKey_value > 900) {
-            //ADC Key release
-            ADCKey_count = 0;
-            current_ADCKey_raw = 0;
-          }
-          else {
-            current_ADCKey_raw += raw_ADCKey_value;
+          if (raw_ADCKey_value <= 900) {
+            NOMORE(current_ADCKey_raw, raw_ADCKey_value);
             ADCKey_count++;
           }
+          else { //ADC Key release
+            if (ADCKey_count > 0) ADCKey_count++; else ADCKey_pressed = false;
+            if (ADCKey_pressed) {
+              ADCKey_count = 0;
+              current_ADCKey_raw = 1024;
+            }
+          }
         }
+        if (ADCKey_count == 16) ADCKey_pressed = true;
         break;
     #endif // ADC_KEYPAD
 
     case StartupDelay: break;
 
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e7b39e16fc..a4a94fc678 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1257,21 +1257,21 @@ void Temperature::manage_heater() {
       #endif
       #if ENABLED(HEATER_5_USER_THERMISTOR)
         t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :
       #endif
       #if ENABLED(BED_USER_THERMISTOR)
         t_index == CTI_BED ? PSTR("BED") :
       #endif
       #if ENABLED(CHAMBER_USER_THERMISTOR)
         t_index == CTI_CHAMBER ? PSTR("CHAMBER") :
       #endif
-      NULL
+      nullptr
     );
     SERIAL_EOL();
   }
 
   float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
     //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
     //  static uint32_t clocks_total = 0;
     //  static uint32_t calls = 0;
     //  uint32_t tcnt5 = TCNT5;
     //#endif

commit a50436613834b183e5fccbf8f653af269d5d87dc
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue May 7 21:14:12 2019 +0200

    Fix probe fan compiling error (#13930)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a134465c9f..e7b39e16fc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -131,22 +131,23 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
           set_fan_speed(fan, new_fan_speed[fan]);
           break;
         default:
           new_fan_speed[fan] = MIN(tmp_temp, 255U);
           break;
       }
     }
 
   #endif
 
-  #if ENABLED(PROBING_FANS_OFF)
+  #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
     bool Temperature::fans_paused; // = false;
+    uint8_t Temperature::saved_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
   #endif
 
   #if HAS_LCD_MENU
 
     uint8_t Temperature::lcd_tmpfan_speed[
       #if ENABLED(SINGLENOZZLE)
@@ -174,21 +175,20 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
 
     fan_speed[target] = speed;
     #if HAS_LCD_MENU
       lcd_tmpfan_speed[target] = speed;
     #endif
   }
 
   #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
-      static uint8_t saved_fan_speed[FAN_COUNT]; // = { 0 }
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else
           FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }
     }
 
   #endif

commit 483822f3aa0108e87884160f62761d2a8655eebd
Author: Stephan <stephan.veigl@gmail.com>
Date:   Tue May 7 02:55:01 2019 +0200

    Fix some THERMAL_PROTECTION_CHAMBER issues (#13678)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b349a3dea3..a134465c9f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -226,22 +226,22 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
   chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
     #endif
     #if WATCH_CHAMBER
       heater_watch_t Temperature::watch_chamber = { 0 };
-      millis_t Temperature::next_chamber_check_ms;
     #endif
+    millis_t Temperature::next_chamber_check_ms;
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   //hotend_pid_t Temperature::pid[HOTENDS];
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
@@ -1051,114 +1051,120 @@ void Temperature::manage_heater() {
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
-    #if DISABLED(PIDTEMPBED)
-      if (PENDING(ms, next_bed_check_ms)
+    do {
+
+      #if DISABLED(PIDTEMPBED)
+        if (PENDING(ms, next_bed_check_ms)
+          #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
+            && paused == last_pause_state
+          #endif
+        ) break;
+        next_bed_check_ms = ms + BED_CHECK_INTERVAL;
         #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
-          && paused == last_pause_state
+          last_pause_state = paused;
         #endif
-      ) return;
-      next_bed_check_ms = ms + BED_CHECK_INTERVAL;
-      #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
-        last_pause_state = paused;
       #endif
-    #endif
 
-    #if HEATER_IDLE_HANDLER
-      bed_idle.update(ms);
-    #endif
+      #if HEATER_IDLE_HANDLER
+        bed_idle.update(ms);
+      #endif
 
-    #if HAS_THERMALLY_PROTECTED_BED
-      thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
-    #endif
+      #if HAS_THERMALLY_PROTECTED_BED
+        thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
+      #endif
 
-    #if HEATER_IDLE_HANDLER
-      if (bed_idle.timed_out) {
-        temp_bed.soft_pwm_amount = 0;
-        #if DISABLED(PIDTEMPBED)
-          WRITE_HEATER_BED(LOW);
-        #endif
-      }
-      else
-    #endif
-    {
-      #if ENABLED(PIDTEMPBED)
-        temp_bed.soft_pwm_amount = WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
-      #else
-        // Check if temperature is within the correct band
-        if (WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP)) {
-          #if ENABLED(BED_LIMIT_SWITCHING)
-            if (temp_bed.current >= temp_bed.target + BED_HYSTERESIS)
-              temp_bed.soft_pwm_amount = 0;
-            else if (temp_bed.current <= temp_bed.target - (BED_HYSTERESIS))
-              temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
-          #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
-            temp_bed.soft_pwm_amount = temp_bed.current < temp_bed.target ? MAX_BED_POWER >> 1 : 0;
-          #endif
-        }
-        else {
+      #if HEATER_IDLE_HANDLER
+        if (bed_idle.timed_out) {
           temp_bed.soft_pwm_amount = 0;
-          WRITE_HEATER_BED(LOW);
+          #if DISABLED(PIDTEMPBED)
+            WRITE_HEATER_BED(LOW);
+          #endif
         }
+        else
       #endif
-    }
+      {
+        #if ENABLED(PIDTEMPBED)
+          temp_bed.soft_pwm_amount = WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
+        #else
+          // Check if temperature is within the correct band
+          if (WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP)) {
+            #if ENABLED(BED_LIMIT_SWITCHING)
+              if (temp_bed.current >= temp_bed.target + BED_HYSTERESIS)
+                temp_bed.soft_pwm_amount = 0;
+              else if (temp_bed.current <= temp_bed.target - (BED_HYSTERESIS))
+                temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
+            #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
+              temp_bed.soft_pwm_amount = temp_bed.current < temp_bed.target ? MAX_BED_POWER >> 1 : 0;
+            #endif
+          }
+          else {
+            temp_bed.soft_pwm_amount = 0;
+            WRITE_HEATER_BED(LOW);
+          }
+        #endif
+      }
+
+    } while (false);
+
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_CHAMBER)
       if (!grace_period && degChamber() > CHAMBER_MAXTEMP)
         _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
     #endif
 
     #if WATCH_CHAMBER
       // Make sure temperature is increasing
-      if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
-        if (degChamber() < watch_chamber.target)   // Failed to increase enough?
+      if (watch_chamber.elapsed(ms)) {              // Time to check the chamber?
+        if (degChamber() < watch_chamber.target)    // Failed to increase enough?
           _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
         else
-          start_watching_chamber();                     // Start again if the target is still far off
+          start_watching_chamber();                 // Start again if the target is still far off
       }
-    #endif // WATCH_CHAMBER
+    #endif
 
-    if (PENDING(ms, next_chamber_check_ms)) return;
-    next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
+    if (ELAPSED(ms, next_chamber_check_ms)) {
+      next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
-    if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
-      #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-        if (temp_chamber.current >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
-          temp_chamber.soft_pwm_amount = 0;
-        else if (temp_chamber.current <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
-          temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
-      #else
-        temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
+      if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
+        #if ENABLED(CHAMBER_LIMIT_SWITCHING)
+          if (temp_chamber.current >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
+            temp_chamber.soft_pwm_amount = 0;
+          else if (temp_chamber.current <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
+            temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
+        #else
+          temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
+        #endif
+      }
+      else {
+        temp_chamber.soft_pwm_amount = 0;
+        WRITE_HEATER_CHAMBER(LOW);
+      }
+
+      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
     }
-    else {
-      temp_chamber.soft_pwm_amount = 0;
-      WRITE_HEATER_CHAMBER(LOW);
-    }
-
-    #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-      thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
-    #endif
 
     // TODO: Implement true PID pwm
     //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
   #endif // HAS_HEATED_CHAMBER
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
@@ -1781,22 +1787,22 @@ void Temperature::init() {
       watch_bed.target = degBed() + WATCH_BED_TEMP_INCREASE;
       watch_bed.next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_bed.next_ms = 0;
   }
 #endif
 
 #if WATCH_CHAMBER
   /**
-   * Start Heating Sanity Check for hotends that are below
-   * their target temperature by a configurable margin.
+   * Start Heating Sanity Check for chamber that is below
+   * its target temperature by a configurable margin.
    * This is called when the temperature is set. (M141, M191)
    */
   void Temperature::start_watching_chamber() {
     if (degChamber() < degTargetChamber() - (WATCH_CHAMBER_TEMP_INCREASE + TEMP_CHAMBER_HYSTERESIS + 1)) {
       watch_chamber.target = degChamber() + WATCH_CHAMBER_TEMP_INCREASE;
       watch_chamber.next_ms = millis() + (WATCH_CHAMBER_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_chamber.next_ms = 0;
   }

commit 23a8707ef1969be3db28251ccee2287e1ea7b9e4
Author: doggyfan <49303635+doggyfan@users.noreply.github.com>
Date:   Tue May 7 00:51:06 2019 +0100

    Configurable Thermistor (#13888)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 16d551a9a2..b349a3dea3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1176,83 +1176,225 @@ void Temperature::manage_heater() {
          if (raw < v00) r = m;                                         \
     else if (raw > v10) l = m;                                         \
     else {                                                             \
       const short v01 = (short)pgm_read_word(&TBL[m-1][1]),            \
                   v11 = (short)pgm_read_word(&TBL[m-0][1]);            \
       return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);  \
     }                                                                  \
   }                                                                    \
 }while(0)
 
+#if HAS_USER_THERMISTORS
+
+  user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
+
+  void Temperature::reset_user_thermistors() {
+    user_thermistor_t user_thermistor[USER_THERMISTORS] = {
+      #if ENABLED(HEATER_0_USER_THERMISTOR)
+        { true, 0, 0, HOTEND0_PULLUP_RESISTOR_OHMS, HOTEND0_RESISTANCE_25C_OHMS, 0, 0, HOTEND0_BETA, 0 },
+      #endif
+      #if ENABLED(HEATER_1_USER_THERMISTOR)
+        { true, 0, 0, HOTEND1_PULLUP_RESISTOR_OHMS, HOTEND1_RESISTANCE_25C_OHMS, 0, 0, HOTEND1_BETA, 0 },
+      #endif
+      #if ENABLED(HEATER_2_USER_THERMISTOR)
+        { true, 0, 0, HOTEND2_PULLUP_RESISTOR_OHMS, HOTEND2_RESISTANCE_25C_OHMS, 0, 0, HOTEND2_BETA, 0 },
+      #endif
+      #if ENABLED(HEATER_3_USER_THERMISTOR)
+        { true, 0, 0, HOTEND3_PULLUP_RESISTOR_OHMS, HOTEND3_RESISTANCE_25C_OHMS, 0, 0, HOTEND3_BETA, 0 },
+      #endif
+      #if ENABLED(HEATER_4_USER_THERMISTOR)
+        { true, 0, 0, HOTEND4_PULLUP_RESISTOR_OHMS, HOTEND4_RESISTANCE_25C_OHMS, 0, 0, HOTEND4_BETA, 0 },
+      #endif
+      #if ENABLED(HEATER_5_USER_THERMISTOR)
+        { true, 0, 0, HOTEND5_PULLUP_RESISTOR_OHMS, HOTEND5_RESISTANCE_25C_OHMS, 0, 0, HOTEND5_BETA, 0 },
+      #endif
+      #if ENABLED(BED_USER_THERMISTOR)
+        { true, 0, 0, BED_PULLUP_RESISTOR_OHMS, BED_RESISTANCE_25C_OHMS, 0, 0, BED_BETA, 0 },
+      #endif
+      #if ENABLED(CHAMBER_USER_THERMISTOR)
+        { true, 0, 0, CHAMBER_PULLUP_RESISTOR_OHMS, CHAMBER_RESISTANCE_25C_OHMS, 0, 0, CHAMBER_BETA, 0 }
+      #endif
+    };
+    COPY(thermalManager.user_thermistor, user_thermistor);
+  }
+
+  void Temperature::log_user_thermistor(const uint8_t t_index, const bool eprom/*=false*/) {
+
+    if (eprom)
+      SERIAL_ECHOPGM("  M305 ");
+    else
+      SERIAL_ECHO_START();
+    SERIAL_CHAR('P');
+    SERIAL_CHAR('0' + t_index);
+
+    const user_thermistor_t &t = user_thermistor[t_index];
+
+    SERIAL_ECHOPAIR_F(" R", t.series_res, 1);
+    SERIAL_ECHOPAIR_F(" T", t.res_25, 1);
+    SERIAL_ECHOPAIR_F(" B", t.beta, 1);
+    SERIAL_ECHOPAIR_F(" C", t.sh_c_coeff, 9);
+    SERIAL_ECHOPGM(" ; ");
+    serialprintPGM(
+      #if ENABLED(HEATER_0_USER_THERMISTOR)
+        t_index == CTI_HOTEND_0 ? PSTR("HOTEND 0") :
+      #endif
+      #if ENABLED(HEATER_1_USER_THERMISTOR)
+        t_index == CTI_HOTEND_1 ? PSTR("HOTEND 1") :
+      #endif
+      #if ENABLED(HEATER_2_USER_THERMISTOR)
+        t_index == CTI_HOTEND_2 ? PSTR("HOTEND 2") :
+      #endif
+      #if ENABLED(HEATER_3_USER_THERMISTOR)
+        t_index == CTI_HOTEND_3 ? PSTR("HOTEND 3") :
+      #endif
+      #if ENABLED(HEATER_4_USER_THERMISTOR)
+        t_index == CTI_HOTEND_4 ? PSTR("HOTEND 4") :
+      #endif
+      #if ENABLED(HEATER_5_USER_THERMISTOR)
+        t_index == CTI_HOTEND_5 ? PSTR("HOTEND 5") :
+      #endif
+      #if ENABLED(BED_USER_THERMISTOR)
+        t_index == CTI_BED ? PSTR("BED") :
+      #endif
+      #if ENABLED(CHAMBER_USER_THERMISTOR)
+        t_index == CTI_CHAMBER ? PSTR("CHAMBER") :
+      #endif
+      NULL
+    );
+    SERIAL_EOL();
+  }
+
+  float Temperature::user_thermistor_to_deg_c(const uint8_t t_index, const int raw) {
+    //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
+    //  static uint32_t clocks_total = 0;
+    //  static uint32_t calls = 0;
+    //  uint32_t tcnt5 = TCNT5;
+    //#endif
+
+    if (!WITHIN(t_index, 0, COUNT(user_thermistor) - 1)) return 25;
+
+    if (user_thermistor[t_index].pre_calc) {
+      // pre-calculate some variables
+      user_thermistor[t_index].pre_calc = false;
+      user_thermistor[t_index].res_25_recip = 1.0f / user_thermistor[t_index].res_25;
+      user_thermistor[t_index].res_25_log = logf(user_thermistor[t_index].res_25);
+      user_thermistor[t_index].beta_recip = 1.0f / user_thermistor[t_index].beta;
+      user_thermistor[t_index].sh_alpha = (1.0f / (THERMISTOR_RESISTANCE_NOMINAL_C - THERMISTOR_ABS_ZERO_C)) - (user_thermistor[t_index].beta_recip * user_thermistor[t_index].res_25_log) - (user_thermistor[t_index].sh_c_coeff * user_thermistor[t_index].res_25_log * user_thermistor[t_index].res_25_log * user_thermistor[t_index].res_25_log);
+    }
+
+    // maximum adc value .. take into account the over sampling
+    const int adc_max = (THERMISTOR_ADC_RESOLUTION * OVERSAMPLENR) - 1,
+              adc_raw = constrain(raw, 1, adc_max - 1); // constrain to prevent divide-by-zero
+
+    const float adc_inverse = (adc_max - adc_raw) - 0.5f,
+                resistance = user_thermistor[t_index].series_res * (adc_raw + 0.5f) / adc_inverse,
+                log_resistance = logf(resistance);
+
+    float value = user_thermistor[t_index].sh_alpha;
+    value += log_resistance * user_thermistor[t_index].beta_recip;
+    if (user_thermistor[t_index].sh_c_coeff != 0)
+      value += user_thermistor[t_index].sh_c_coeff * log_resistance * log_resistance * log_resistance;
+    value = 1.0f / value;
+
+    // Convert to degrees C
+    float deg_c = value + THERMISTOR_ABS_ZERO_C;
+
+    // Test only
+    //deg_c = constrain(deg_c, 6, 100);
+
+    //#if (MOTHERBOARD == BOARD_RAMPS_14_EFB)
+    //  int32_t clocks = TCNT5 - tcnt5;
+    //  if (clocks >= 0) {
+    //    clocks_total += clocks;
+    //    calls++;
+    //  }
+    //#endif
+
+    return deg_c;
+  }
+#endif
+
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif
     {
       SERIAL_ERROR_START();
       SERIAL_ECHO((int)e);
       SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
       kill();
       return 0.0;
     }
 
   switch (e) {
     case 0:
-      #if ENABLED(HEATER_0_USES_MAX6675)
+      #if ENABLED(HEATER_0_USER_THERMISTOR)
+        return user_thermistor_to_deg_c(CTI_HOTEND_0, raw);
+      #elif ENABLED(HEATER_0_USES_MAX6675)
         return raw * 0.25;
       #elif ENABLED(HEATER_0_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_0_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 1:
-      #if ENABLED(HEATER_1_USES_MAX6675)
+      #if ENABLED(HEATER_1_USER_THERMISTOR)
+        return user_thermistor_to_deg_c(CTI_HOTEND_1, raw);
+      #elif ENABLED(HEATER_1_USES_MAX6675)
         return raw * 0.25;
       #elif ENABLED(HEATER_1_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_1_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 2:
-      #if ENABLED(HEATER_2_USES_AD595)
+      #if ENABLED(HEATER_2_USER_THERMISTOR)
+        return user_thermistor_to_deg_c(CTI_HOTEND_2, raw);
+      #elif ENABLED(HEATER_2_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_2_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 3:
-      #if ENABLED(HEATER_3_USES_AD595)
+      #if ENABLED(HEATER_3_USER_THERMISTOR)
+        return user_thermistor_to_deg_c(CTI_HOTEND_3, raw);
+      #elif ENABLED(HEATER_3_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_3_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 4:
-      #if ENABLED(HEATER_4_USES_AD595)
+      #if ENABLED(HEATER_4_USER_THERMISTOR)
+        return user_thermistor_to_deg_c(CTI_HOTEND_4, raw);
+      #elif ENABLED(HEATER_4_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_4_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 5:
-      #if ENABLED(HEATER_5_USES_AD595)
+      #if ENABLED(HEATER_5_USER_THERMISTOR)
+        return user_thermistor_to_deg_c(CTI_HOTEND_5, raw);
+      #elif ENABLED(HEATER_5_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_5_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     default: break;
   }
 
   #if HOTEND_USES_THERMISTOR
@@ -1261,37 +1403,41 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
     SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
   #endif
 
   return 0;
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog_to_celsius_bed(const int raw) {
-    #if ENABLED(HEATER_BED_USES_THERMISTOR)
+    #if ENABLED(BED_USER_THERMISTOR)
+      return user_thermistor_to_deg_c(CTI_BED, raw);
+    #elif ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BEDTEMPTABLE, BEDTEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_BED_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog_to_celsius_chamber(const int raw) {
-    #if ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
+    #if ENABLED(CHAMBER_USER_THERMISTOR)
+      return user_thermistor_to_deg_c(CTI_CHAMBER, raw);
+    #elif ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(CHAMBERTEMPTABLE, CHAMBERTEMPTABLE_LEN);
     #elif ENABLED(HEATER_CHAMBER_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER

commit 9853331b34ef6fd214a8f1fbc315e722c90b7341
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 5 22:54:49 2019 -0500

    Fix temp init, loosen ADC grace period

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 25b1f59902..16d551a9a2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1524,21 +1524,21 @@ void Temperature::init() {
 
   #if HOTENDS
 
     #define _TEMP_MIN_E(NR) do{ \
       temp_range[NR].mintemp = HEATER_ ##NR## _MINTEMP; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < HEATER_ ##NR## _MINTEMP) \
         temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
     #define _TEMP_MAX_E(NR) do{ \
       temp_range[NR].maxtemp = HEATER_ ##NR## _MAXTEMP; \
-      while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) > HEATER_ ##NR## _MAXTEMP) \
+      while (analog_to_celsius_hotend(temp_range[NR].raw_max, NR) > HEATER_ ##NR## _MAXTEMP) \
         temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
     }while(0)
 
     #ifdef HEATER_0_MINTEMP
       _TEMP_MIN_E(0);
     #endif
     #ifdef HEATER_0_MAXTEMP
       _TEMP_MAX_E(0);
     #endif
     #if HOTENDS > 1
@@ -1582,30 +1582,30 @@ void Temperature::init() {
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
   #endif // HOTENDS > 1
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
     #ifdef BED_MAXTEMP
-      while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) mintemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
+      while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) maxtemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
     #endif
   #endif // HAS_HEATED_BED
 
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
     #ifdef CHAMBER_MAXTEMP
-      while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) mintemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
+      while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) maxtemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
   #endif
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
 #if WATCH_HOTENDS
   /**

commit e2a77ed8813ebe33b75479bd43b9d1308da48b12
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun May 5 05:51:47 2019 +0200

    Bring chamber temp to completion (#13837)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 82aad2d766..25b1f59902 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -103,20 +103,24 @@ Temperature thermalManager;
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
+#if ENABLED(AUTO_POWER_CHAMBER_FAN)
+  uint8_t Temperature::chamberfan_speed; // = 0
+#endif
+
 #if FAN_COUNT > 0
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
     uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
 
     void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
       switch (tmp_temp) {
         case 1:
@@ -633,85 +637,105 @@ int16_t Temperature::getHeaterPower(const int8_t heater) {
   #define AUTO_5_IS_1 (E5_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_5_IS_2 (E5_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
   #define AUTO_5_IS_3 (E5_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
   #define AUTO_5_IS_4 (E5_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
   #define AUTO_CHAMBER_IS_0 (CHAMBER_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_CHAMBER_IS_1 (CHAMBER_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
   #define AUTO_CHAMBER_IS_2 (CHAMBER_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
   #define AUTO_CHAMBER_IS_3 (CHAMBER_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
   #define AUTO_CHAMBER_IS_4 (CHAMBER_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
   #define AUTO_CHAMBER_IS_5 (CHAMBER_AUTO_FAN_PIN == E5_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_E (AUTO_CHAMBER_IS_0 || AUTO_CHAMBER_IS_1 || AUTO_CHAMBER_IS_2 || AUTO_CHAMBER_IS_3 || AUTO_CHAMBER_IS_4 || AUTO_CHAMBER_IS_5)
+  #define CHAMBER_FAN_INDEX HOTENDS
 
   void Temperature::checkExtruderAutoFans() {
     static const uint8_t fanBit[] PROGMEM = {
-                    0,
-      AUTO_1_IS_0 ? 0 :               1,
-      AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
-      AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
-      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 :               4,
-      AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
-      #if HAS_TEMP_CHAMBER
+      0
+      #if HOTENDS > 1
+        , AUTO_1_IS_0 ? 0 : 1
+      #endif
+      #if HOTENDS > 2
+        , AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 : 2
+      #endif
+      #if HOTENDS > 3
+        , AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 : 3,
+      #endif
+      #if HOTENDS > 4
+        , AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4,
+      #endif
+      #if HOTENDS > 5
+        , AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
+      #endif
+      #if HAS_AUTO_CHAMBER_FAN
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
       #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (temp_hotend[e].current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
-    #if HAS_TEMP_CHAMBER
-      if (temp_chamber.current > EXTRUDER_AUTO_FAN_TEMPERATURE)
-        SBI(fanState, pgm_read_byte(&fanBit[6]));
+    #if HAS_AUTO_CHAMBER_FAN
+      if (temp_chamber.current > CHAMBER_AUTO_FAN_TEMPERATURE)
+        SBI(fanState, pgm_read_byte(&fanBit[CHAMBER_FAN_INDEX]));
     #endif
 
-    #define _UPDATE_AUTO_FAN(P,D,A) do{                               \
-      if (PWM_PIN(P##_AUTO_FAN_PIN) && EXTRUDER_AUTO_FAN_SPEED < 255) \
-        analogWrite(P##_AUTO_FAN_PIN, A);                             \
-      else                                                            \
-        WRITE(P##_AUTO_FAN_PIN, D);                                   \
+    #define _UPDATE_AUTO_FAN(P,D,A) do{             \
+      if (PWM_PIN(P##_AUTO_FAN_PIN) && A < 255)     \
+        analogWrite(P##_AUTO_FAN_PIN, D ? A : 0);   \
+      else                                          \
+        WRITE(P##_AUTO_FAN_PIN, D);                 \
     }while(0)
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanBit); f++) {
-      const uint8_t bit = pgm_read_byte(&fanBit[f]);
-      if (TEST(fanDone, bit)) continue;
-      const bool fan_on = TEST(fanState, bit);
-      const uint8_t speed = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
-      #if ENABLED(AUTO_POWER_E_FANS)
-        autofan_speed[f] = speed;
-      #endif
+      const uint8_t realFan = pgm_read_byte(&fanBit[f]);
+      if (TEST(fanDone, realFan)) continue;
+      const bool fan_on = TEST(fanState, realFan);
+      switch (f) {
+        #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
+          case CHAMBER_FAN_INDEX:
+            chamberfan_speed = fan_on ? CHAMBER_AUTO_FAN_SPEED : 0;
+            break;
+        #endif
+        default:
+          #if ENABLED(AUTO_POWER_E_FANS)
+            autofan_speed[realFan] = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
+          #endif
+          break;
+      }
+
       switch (f) {
         #if HAS_AUTO_FAN_0
-          case 0: _UPDATE_AUTO_FAN(E0, fan_on, speed); break;
+          case 0: _UPDATE_AUTO_FAN(E0, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_1
-          case 1: _UPDATE_AUTO_FAN(E1, fan_on, speed); break;
+          case 1: _UPDATE_AUTO_FAN(E1, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_2
-          case 2: _UPDATE_AUTO_FAN(E2, fan_on, speed); break;
+          case 2: _UPDATE_AUTO_FAN(E2, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_3
-          case 3: _UPDATE_AUTO_FAN(E3, fan_on, speed); break;
+          case 3: _UPDATE_AUTO_FAN(E3, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_4
-          case 4: _UPDATE_AUTO_FAN(E4, fan_on, speed); break;
+          case 4: _UPDATE_AUTO_FAN(E4, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
         #if HAS_AUTO_FAN_5
-          case 5: _UPDATE_AUTO_FAN(E5, fan_on, speed); break;
+          case 5: _UPDATE_AUTO_FAN(E5, fan_on, EXTRUDER_AUTO_FAN_SPEED); break;
         #endif
-        #if HAS_AUTO_CHAMBER_FAN
-          case 6: _UPDATE_AUTO_FAN(CHAMBER, fan_on, speed); break;
+        #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
+          case CHAMBER_FAN_INDEX: _UPDATE_AUTO_FAN(CHAMBER, fan_on, CHAMBER_AUTO_FAN_SPEED); break;
         #endif
       }
-      SBI(fanDone, bit);
-      UNUSED(fan_on); UNUSED(speed);
+      SBI(fanDone, realFan);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;
@@ -1079,71 +1103,67 @@ void Temperature::manage_heater() {
           #endif
         }
         else {
           temp_bed.soft_pwm_amount = 0;
           WRITE_HEATER_BED(LOW);
         }
       #endif
     }
   #endif // HAS_HEATED_BED
 
-  #if HAS_TEMP_CHAMBER
+  #if HAS_HEATED_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
-    #if HAS_HEATED_CHAMBER
-
-      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        if (!grace_period && degChamber() > CHAMBER_MAXTEMP)
-          _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
-      #endif
-
-      #if WATCH_CHAMBER
-        // Make sure temperature is increasing
-        if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
-          if (degChamber() < watch_chamber.target)   // Failed to increase enough?
-            _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
-          else
-            start_watching_chamber();                     // Start again if the target is still far off
-        }
-      #endif // WATCH_CHAMBER
-
-      if (PENDING(ms, next_chamber_check_ms)) return;
-      next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
+    #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+      if (!grace_period && degChamber() > CHAMBER_MAXTEMP)
+        _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
+    #endif
 
-      if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
-        #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-          if (temp_chamber.current >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
-            temp_chamber.soft_pwm_amount = 0;
-          else if (temp_chamber.current <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
-            temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
-        #else
-          temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
-        #endif
-      }
-      else {
-        temp_chamber.soft_pwm_amount = 0;
-        WRITE_HEATER_CHAMBER(LOW);
+    #if WATCH_CHAMBER
+      // Make sure temperature is increasing
+      if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
+        if (degChamber() < watch_chamber.target)   // Failed to increase enough?
+          _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
+        else
+          start_watching_chamber();                     // Start again if the target is still far off
       }
+    #endif // WATCH_CHAMBER
+
+    if (PENDING(ms, next_chamber_check_ms)) return;
+    next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
-      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+    if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
+      #if ENABLED(CHAMBER_LIMIT_SWITCHING)
+        if (temp_chamber.current >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
+          temp_chamber.soft_pwm_amount = 0;
+        else if (temp_chamber.current <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
+          temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
+      #else
+        temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
       #endif
+    }
+    else {
+      temp_chamber.soft_pwm_amount = 0;
+      WRITE_HEATER_CHAMBER(LOW);
+    }
 
-      // TODO: Implement true PID pwm
-      //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
+    #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+      thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+    #endif
 
-    #endif // HAS_HEATED_CHAMBER
+    // TODO: Implement true PID pwm
+    //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
-  #endif // HAS_TEMP_CHAMBER
+  #endif // HAS_HEATED_CHAMBER
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
@@ -1346,25 +1366,31 @@ void Temperature::updateTemperaturesFromRawValues() {
 #else
   #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
 #endif
 #if ENABLED(FAST_PWM_FAN)
   #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
 #else
   #define SET_FAST_PWM_FREQ(P) NOOP
 #endif
 #define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
 #if EXTRUDER_AUTO_FAN_SPEED != 255
-  #define INIT_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
+  #define INIT_E_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
+#else
+  #define INIT_E_AUTO_FAN_PIN(P) SET_OUTPUT(P)
+#endif
+#if CHAMBER_AUTO_FAN_SPEED != 255
+  #define INIT_CHAMBER_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
 #else
-  #define INIT_AUTO_FAN_PIN(P) SET_OUTPUT(P)
+  #define INIT_CHAMBER_AUTO_FAN_PIN(P) SET_OUTPUT(P)
 #endif
 
+
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
@@ -1465,39 +1491,39 @@ void Temperature::init() {
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
-    INIT_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
+    INIT_E_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
-    INIT_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
+    INIT_E_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_2 && !(AUTO_2_IS_0 || AUTO_2_IS_1)
-    INIT_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
+    INIT_E_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_3 && !(AUTO_3_IS_0 || AUTO_3_IS_1 || AUTO_3_IS_2)
-    INIT_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
+    INIT_E_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_4 && !(AUTO_4_IS_0 || AUTO_4_IS_1 || AUTO_4_IS_2 || AUTO_4_IS_3)
-    INIT_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
+    INIT_E_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_5 && !(AUTO_5_IS_0 || AUTO_5_IS_1 || AUTO_5_IS_2 || AUTO_5_IS_3 || AUTO_5_IS_4)
-    INIT_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
+    INIT_E_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
   #endif
-  #if HAS_AUTO_CHAMBER_FAN && !(AUTO_CHAMBER_IS_0 || AUTO_CHAMBER_IS_1 || AUTO_CHAMBER_IS_2 || AUTO_CHAMBER_IS_3 || AUTO_CHAMBER_IS_4 || AUTO_CHAMBER_IS_5)
-    INIT_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
+  #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_E
+    INIT_CHAMBER_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HOTENDS
 
     #define _TEMP_MIN_E(NR) do{ \
       temp_range[NR].mintemp = HEATER_ ##NR## _MINTEMP; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < HEATER_ ##NR## _MINTEMP) \
@@ -2608,36 +2634,32 @@ void Temperature::isr() {
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
         , -1 // BED
       );
     #endif
     #if HAS_TEMP_CHAMBER
-      #if HAS_HEATED_CHAMBER
-        print_heater_state(degChamber(), degTargetChamber()
-          #if ENABLED(SHOW_TEMP_ADC_VALUES)
-            , rawChamberTemp()
-          #endif
+      print_heater_state(degChamber()
+        #if HAS_HEATED_CHAMBER
+          , degTargetChamber()
+        #else
+          , 0
+        #endif
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , rawChamberTemp()
+        #endif
         , -2 // CHAMBER
       );
-      #else
-        print_heater_state(degChamber(), 0
-          #if ENABLED(SHOW_TEMP_ADC_VALUES)
-            , rawChamberTemp()
-          #endif
-          , -2 // CHAMBER
-        );
-      #endif // HAS_HEATED_CHAMBER
-    #endif
+    #endif // HAS_TEMP_CHAMBER
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , e
       );
     #endif
     SERIAL_ECHOPAIR(" @:", getHeaterPower(target_extruder));
     #if HAS_HEATED_BED
@@ -2928,11 +2950,113 @@ void Temperature::isr() {
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_BED
 
+  #if 0 && HAS_HEATED_CHAMBER
+
+    #ifndef MIN_COOLING_SLOPE_DEG_CHAMBER
+      #define MIN_COOLING_SLOPE_DEG_CHAMBER 1.50
+    #endif
+    #ifndef MIN_COOLING_SLOPE_TIME_CHAMBER
+      #define MIN_COOLING_SLOPE_TIME_CHAMBER 60
+    #endif
+
+    bool Temperature::wait_for_chamber(const bool no_wait_for_cooling/*=true*/) {
+      #if TEMP_CHAMBER_RESIDENCY_TIME > 0
+        millis_t residency_start_ms = 0;
+        // Loop until the temperature has stabilized
+        #define TEMP_CHAMBER_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL))
+      #else
+        // Loop until the temperature is very close target
+        #define TEMP_CHAMBER_CONDITIONS (wants_to_cool ? isCoolingChamber() : isHeatingChamber())
+      #endif
+
+      float target_temp = -1, old_temp = 9999;
+      bool wants_to_cool = false, first_loop = true;
+      wait_for_heatup = true;
+      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
+        KEEPALIVE_STATE(NOT_BUSY);
+      #endif
+
+      do {
+        // Target temperature might be changed during the loop
+        if (target_temp != degTargetChamber()) {
+          wants_to_cool = isCoolingChamber();
+          target_temp = degTargetChamber();
+
+          // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
+          if (no_wait_for_cooling && wants_to_cool) break;
+        }
+
+        now = millis();
+        if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
+          next_temp_ms = now + 1000UL;
+          print_heater_states(active_extruder);
+          #if TEMP_CHAMBER_RESIDENCY_TIME > 0
+            SERIAL_ECHOPGM(" W:");
+            if (residency_start_ms)
+              SERIAL_ECHO(long((((TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+            else
+              SERIAL_CHAR('?');
+          #endif
+          SERIAL_EOL();
+        }
+
+        idle();
+        gcode.reset_stepper_timeout(); // Keep steppers powered
+
+        const float temp = degChamber();
+
+        #if TEMP_CHAMBER_RESIDENCY_TIME > 0
+
+          const float temp_diff = ABS(target_temp - temp);
+
+          if (!residency_start_ms) {
+            // Start the TEMP_CHAMBER_RESIDENCY_TIME timer when we reach target temp for the first time.
+            if (temp_diff < TEMP_CHAMBER_WINDOW) {
+              residency_start_ms = now;
+              if (first_loop) residency_start_ms += (TEMP_CHAMBER_RESIDENCY_TIME) * 1000UL;
+            }
+          }
+          else if (temp_diff > TEMP_CHAMBER_HYSTERESIS) {
+            // Restart the timer whenever the temperature falls outside the hysteresis.
+            residency_start_ms = now;
+          }
+
+        #endif // TEMP_CHAMBER_RESIDENCY_TIME > 0
+
+        // Prevent a wait-forever situation if R is misused i.e. M191 R0
+        if (wants_to_cool) {
+          // Break after MIN_COOLING_SLOPE_TIME_CHAMBER seconds
+          // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_CHAMBER
+          if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+            if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_CHAMBER)) break;
+            next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_CHAMBER;
+            old_temp = temp;
+          }
+        }
+
+        first_loop = false;
+
+      } while (wait_for_heatup && TEMP_CHAMBER_CONDITIONS);
+
+      if (wait_for_heatup) ui.reset_status();
+
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        gcode.busy_state = old_busy_state;
+      #endif
+
+      return wait_for_heatup;
+    }
+
+  #endif // HAS_HEATED_CHAMBER
+
 #endif // HAS_TEMP_SENSOR

commit 3fcab8dbf1f0746a6d3825a9ec099fedbd958943
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 4 16:50:44 2019 -0400

    Option to disable fans during pause (#13820)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1c22df4d1e..82aad2d766 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -167,34 +167,34 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
     #endif
 
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;
     #if HAS_LCD_MENU
       lcd_tmpfan_speed[target] = speed;
     #endif
   }
 
-  #if ENABLED(PROBING_FANS_OFF)
+  #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
 
     void Temperature::set_fans_paused(const bool p) {
       static uint8_t saved_fan_speed[FAN_COUNT]; // = { 0 }
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
           FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else
           FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }
     }
 
-  #endif // PROBING_FANS_OFF
+  #endif
 
 #endif // FAN_COUNT > 0
 
 #if WATCH_HOTENDS
   heater_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
 #if HEATER_IDLE_HANDLER
   heater_idle_t Temperature::hotend_idle[HOTENDS]; // = { { 0 } }
 #endif
 

commit 2f32a6612d0155fd01d15497205bb63e68ae1e7a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 4 14:36:59 2019 -0500

    Clean up Temperature::set_fans_paused

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 957b2db2ab..1c22df4d1e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -129,21 +129,20 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
         default:
           new_fan_speed[fan] = MIN(tmp_temp, 255U);
           break;
       }
     }
 
   #endif
 
   #if ENABLED(PROBING_FANS_OFF)
     bool Temperature::fans_paused; // = false;
-    uint8_t Temperature::paused_fan_speed[FAN_COUNT]; // = { 0 }
   #endif
 
   #if ENABLED(ADAPTIVE_FAN_SLOWING)
     uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
   #endif
 
   #if HAS_LCD_MENU
 
     uint8_t Temperature::lcd_tmpfan_speed[
       #if ENABLED(SINGLENOZZLE)
@@ -171,26 +170,27 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
 
     fan_speed[target] = speed;
     #if HAS_LCD_MENU
       lcd_tmpfan_speed[target] = speed;
     #endif
   }
 
   #if ENABLED(PROBING_FANS_OFF)
 
     void Temperature::set_fans_paused(const bool p) {
+      static uint8_t saved_fan_speed[FAN_COUNT]; // = { 0 }
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
-          FANS_LOOP(x) { paused_fan_speed[x] = fan_speed[x]; fan_speed[x] = 0; }
+          FANS_LOOP(i) { saved_fan_speed[i] = fan_speed[i]; fan_speed[i] = 0; }
         else
-          FANS_LOOP(x) fan_speed[x] = paused_fan_speed[x];
+          FANS_LOOP(i) fan_speed[i] = saved_fan_speed[i];
       }
     }
 
   #endif // PROBING_FANS_OFF
 
 #endif // FAN_COUNT > 0
 
 #if WATCH_HOTENDS
   heater_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif

commit ee243e4edfe45fa855d4ff71abf8a9a118b66369
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Wed May 1 22:55:58 2019 -0400

    Fix mixing extruder filament change (#13803)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 25a45661aa..957b2db2ab 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2818,29 +2818,30 @@ void Temperature::isr() {
       #define MIN_COOLING_SLOPE_TIME_BED 60
     #endif
 
     bool Temperature::wait_for_bed(const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
+        bool first_loop = true;
         // Loop until the temperature has stabilized
         #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       float target_temp = -1, old_temp = 9999;
-      bool wants_to_cool = false, first_loop = true;
+      bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
@@ -2910,21 +2911,23 @@ void Temperature::isr() {
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
-        first_loop = false;
+        #if TEMP_BED_RESIDENCY_TIME > 0
+          first_loop = false;
+        #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;

commit 875e673a8c1efd58ca19ae1d883c195338733f37
Author: Kajetan Rzepecki <kajetan.rzepecki+github@gmail.com>
Date:   Mon Apr 22 03:50:32 2019 +0200

    Add HAL-based thermal protection grace period for all heaters (#13778)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0991cb167b..25a45661aa 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -937,27 +937,43 @@ void Temperature::manage_heater() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (temp_hotend[0].current > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(0);
     if (temp_hotend[0].current < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
     if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
   #endif
 
-  #if WATCH_HOTENDS || WATCH_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER || WATCH_CHAMBER
+  #define HAS_THERMAL_PROTECTION (ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER))
+
+  #if HAS_THERMAL_PROTECTION || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
+  #if HAS_THERMAL_PROTECTION
+    #ifndef THERMAL_PROTECTION_GRACE_PERIOD
+      #define THERMAL_PROTECTION_GRACE_PERIOD 0 // No grace period needed on well-behaved boards
+    #endif
+    #if THERMAL_PROTECTION_GRACE_PERIOD > 0
+      static millis_t grace_period = ms + THERMAL_PROTECTION_GRACE_PERIOD;
+      if (ELAPSED(ms, grace_period)) grace_period = 0UL;
+    #else
+      static constexpr millis_t grace_period = 0UL;
+    #endif
+  #endif
+
   HOTEND_LOOP() {
-    if (degHotend(e) > temp_range[e].maxtemp)
-      _temp_error(e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
+    #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+      if (!grace_period && degHotend(e) > temp_range[e].maxtemp)
+        _temp_error(e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
+    #endif
 
     #if HEATER_IDLE_HANDLER
       hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
       thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
@@ -996,22 +1012,24 @@ void Temperature::manage_heater() {
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
-    if (degBed() > BED_MAXTEMP)
-      _temp_error(-1, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -1));
+    #if ENABLED(THERMAL_PROTECTION_BED)
+      if (!grace_period && degBed() > BED_MAXTEMP)
+        _temp_error(-1, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -1));
+    #endif
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
@@ -1069,22 +1087,24 @@ void Temperature::manage_heater() {
   #endif // HAS_HEATED_BED
 
   #if HAS_TEMP_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if HAS_HEATED_CHAMBER
 
-      if (degChamber() > CHAMBER_MAXTEMP)
-        _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
+      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+        if (!grace_period && degChamber() > CHAMBER_MAXTEMP)
+          _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
+      #endif
 
       #if WATCH_CHAMBER
         // Make sure temperature is increasing
         if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
           if (degChamber() < watch_chamber.target)   // Failed to increase enough?
             _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
           else
             start_watching_chamber();                     // Start again if the target is still far off
         }
       #endif // WATCH_CHAMBER
@@ -1603,48 +1623,48 @@ void Temperature::init() {
   void Temperature::start_watching_chamber() {
     if (degChamber() < degTargetChamber() - (WATCH_CHAMBER_TEMP_INCREASE + TEMP_CHAMBER_HYSTERESIS + 1)) {
       watch_chamber.target = degChamber() + WATCH_CHAMBER_TEMP_INCREASE;
       watch_chamber.next_ms = millis() + (WATCH_CHAMBER_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_chamber.next_ms = 0;
   }
 #endif
 
-#if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
+#if HAS_THERMAL_PROTECTION
 
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
     Temperature::tr_state_machine_t Temperature::tr_state_machine[HOTENDS]; // = { { TRInactive, 0 } };
   #endif
   #if HAS_THERMALLY_PROTECTED_BED
     Temperature::tr_state_machine_t Temperature::tr_state_machine_bed; // = { TRInactive, 0 };
   #endif
   #if ENABLED(THERMAL_PROTECTION_CHAMBER)
     Temperature::tr_state_machine_t Temperature::tr_state_machine_chamber; // = { TRInactive, 0 };
   #endif
 
   void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
-        if (heater_id == -2) SERIAL_ECHOPGM("chamber");
-        if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
-        SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
-        if (heater_id >= 0)
-          SERIAL_ECHOPAIR(" ;  Idle Timeout:", hotend_idle[heater_id].timed_out);
-        else
-          SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
-        SERIAL_EOL();
-    */
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
+      if (heater_id == -2) SERIAL_ECHOPGM("chamber");
+      if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
+      SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
+      if (heater_id >= 0)
+        SERIAL_ECHOPAIR(" ;  Idle Timeout:", hotend_idle[heater_id].timed_out);
+      else
+        SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
+      SERIAL_EOL();
+    //*/
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
       if ((heater_id >= 0 && hotend_idle[heater_id].timed_out)
         #if HAS_HEATED_BED
           || (heater_id < 0 && bed_idle.timed_out)
         #endif
       ) {

commit 5f70c876ae521913eaeb4e1917db869445e9fe69
Author: Kajetan Rzepecki <kajetan.rzepecki+github@gmail.com>
Date:   Sat Apr 20 20:57:38 2019 +0200

    Fix _temp_error-related compile error (#13768)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b8ea8fd9bd..0991cb167b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -79,31 +79,31 @@
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
-  #define _BED_PSTR(M,E) (E) == -1 ? PSTR(M ## _BED) :
+  #define _BED_PSTR(M,E) (E) == -1 ? PSTR(M) :
 #else
   #define _BED_PSTR(M,E)
 #endif
 #if HAS_HEATED_CHAMBER
-  #define _CHAMBER_PSTR(M,E) (E) == -2 ? PSTR(M ## _CHAMBER) :
+  #define _CHAMBER_PSTR(M,E) (E) == -2 ? PSTR(M) :
 #else
   #define _CHAMBER_PSTR(M,E)
 #endif
 #define _E_PSTR(M,E,N) ((HOTENDS) >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
-#define TEMP_ERR_PSTR(M,E) _BED_PSTR(M,E) _CHAMBER_PSTR(M,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
+#define TEMP_ERR_PSTR(M,E) _BED_PSTR(M##_BED,E) _CHAMBER_PSTR(M##_CHAMBER,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
@@ -997,21 +997,21 @@ void Temperature::manage_heater() {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
     if (degBed() > BED_MAXTEMP)
-      temp_error(-1, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -1));
+      _temp_error(-1, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -1));
 
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
@@ -1070,21 +1070,21 @@ void Temperature::manage_heater() {
 
   #if HAS_TEMP_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if HAS_HEATED_CHAMBER
 
       if (degChamber() > CHAMBER_MAXTEMP)
-        temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
+        _temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
 
       #if WATCH_CHAMBER
         // Make sure temperature is increasing
         if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
           if (degChamber() < watch_chamber.target)   // Failed to increase enough?
             _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
           else
             start_watching_chamber();                     // Start again if the target is still far off
         }
       #endif // WATCH_CHAMBER

commit bddb776ddb6aa8eb0eb9a15f701df24940b02b46
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 19 21:43:49 2019 -0500

    Add chamber max-temp check
    
    Followup to #13756

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4da8a377cd..b8ea8fd9bd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -943,21 +943,21 @@ void Temperature::manage_heater() {
     if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
     if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
   #endif
 
   #if WATCH_HOTENDS || WATCH_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER || WATCH_CHAMBER
     millis_t ms = millis();
   #endif
 
   HOTEND_LOOP() {
     if (degHotend(e) > temp_range[e].maxtemp)
-      temp_error(e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
+      _temp_error(e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
 
     #if HEATER_IDLE_HANDLER
       hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
       thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
@@ -1069,20 +1069,23 @@ void Temperature::manage_heater() {
   #endif // HAS_HEATED_BED
 
   #if HAS_TEMP_CHAMBER
 
     #ifndef CHAMBER_CHECK_INTERVAL
       #define CHAMBER_CHECK_INTERVAL 1000UL
     #endif
 
     #if HAS_HEATED_CHAMBER
 
+      if (degChamber() > CHAMBER_MAXTEMP)
+        temp_error(-2, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -2));
+
       #if WATCH_CHAMBER
         // Make sure temperature is increasing
         if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
           if (degChamber() < watch_chamber.target)   // Failed to increase enough?
             _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
           else
             start_watching_chamber();                     // Start again if the target is still far off
         }
       #endif // WATCH_CHAMBER
 

commit d0c1eee53be3d0b60d133251e22ba51cfc380db1
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Apr 19 20:37:12 2019 -0600

    Add extra max-temp safety checks (#13756)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8f3361944d..4da8a377cd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -79,31 +79,31 @@
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 
 #if HAS_HEATED_BED
-  #define _BED_PSTR(E) (E) == -1 ? PSTR(MSG ## _BED) :
+  #define _BED_PSTR(M,E) (E) == -1 ? PSTR(M ## _BED) :
 #else
-  #define _BED_PSTR(E)
+  #define _BED_PSTR(M,E)
 #endif
 #if HAS_HEATED_CHAMBER
-  #define _CHAMBER_PSTR(E) (E) == -2 ? PSTR(MSG ## _CHAMBER) :
+  #define _CHAMBER_PSTR(M,E) (E) == -2 ? PSTR(M ## _CHAMBER) :
 #else
-  #define _CHAMBER_PSTR(E)
+  #define _CHAMBER_PSTR(M,E)
 #endif
-#define _E_PSTR(M,E,N) (HOTENDS >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
-#define TEMP_ERR_PSTR(M,E) _BED_PSTR(E) _CHAMBER_PSTR(E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
+#define _E_PSTR(M,E,N) ((HOTENDS) >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
+#define TEMP_ERR_PSTR(M,E) _BED_PSTR(M,E) _CHAMBER_PSTR(M,E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
 hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
@@ -942,20 +942,22 @@ void Temperature::manage_heater() {
   #if ENABLED(HEATER_1_USES_MAX6675)
     if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
     if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
   #endif
 
   #if WATCH_HOTENDS || WATCH_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER || WATCH_CHAMBER
     millis_t ms = millis();
   #endif
 
   HOTEND_LOOP() {
+    if (degHotend(e) > temp_range[e].maxtemp)
+      temp_error(e, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, e));
 
     #if HEATER_IDLE_HANDLER
       hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
       thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
@@ -994,20 +996,23 @@ void Temperature::manage_heater() {
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
+    if (degBed() > BED_MAXTEMP)
+      temp_error(-1, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, -1));
+
     #if WATCH_BED
       // Make sure temperature is increasing
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
@@ -2640,21 +2645,21 @@ void Temperature::isr() {
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
-        ui.status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
+        ui.status_printf_P(0, heating ? PSTR("E%c " MSG_HEATING) : PSTR("E%c " MSG_COOLING), '1' + e);
       #else
         ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50

commit 84273557f9231c445ee30ee89dbcc66bc9c10e59
Author: Stephan <stephan.veigl@gmail.com>
Date:   Fri Apr 12 22:38:10 2019 +0200

    Move and update heated chamber settings (#13671)
    
    Co-Authored-By: the-real-orca <stephan.veigl@gmail.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d8bf25747e..8f3361944d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -588,24 +588,37 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
-int Temperature::getHeaterPower(const int heater) {
+int16_t Temperature::getHeaterPower(const int8_t heater) {
   return (
+    #if HAS_HEATED_CHAMBER
+      #if HAS_HEATED_BED
+        heater == -2
+      #else
+        heater < 0
+      #endif
+      ? temp_chamber.soft_pwm_amount :
+    #endif
     #if HAS_HEATED_BED
-      heater < 0 ? temp_bed.soft_pwm_amount :
+      #if HAS_HEATED_CHAMBER
+        heater == -1
+      #else
+        heater < 0
+      #endif
+      ? temp_bed.soft_pwm_amount :
     #endif
     temp_hotend[heater].soft_pwm_amount
   );
 }
 
 #if HAS_AUTO_FAN
 
   #define AUTO_1_IS_0 (E1_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_2_IS_0 (E2_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
   #define AUTO_2_IS_1 (E2_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
@@ -1066,25 +1079,25 @@ void Temperature::manage_heater() {
           else
             start_watching_chamber();                     // Start again if the target is still far off
         }
       #endif // WATCH_CHAMBER
 
       if (PENDING(ms, next_chamber_check_ms)) return;
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
       if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
         #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-          if (temp_chamber.current >= temp_chamber.target + CHAMBER_HYSTERESIS)
+          if (temp_chamber.current >= temp_chamber.target + TEMP_CHAMBER_HYSTERESIS)
             temp_chamber.soft_pwm_amount = 0;
-          else if (temp_chamber.current <= temp_chamber.target - (CHAMBER_HYSTERESIS))
+          else if (temp_chamber.current <= temp_chamber.target - (TEMP_CHAMBER_HYSTERESIS))
             temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
-        #else // !PIDTEMPCHAMBER && !CHAMBER_LIMIT_SWITCHING
+        #else
           temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
         #endif
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
         thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
@@ -2010,25 +2023,21 @@ void Temperature::readings_ready() {
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(-1);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(-1);
   #endif
 
   #if HAS_HEATED_CHAMBER
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<=(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>=(B))
     #endif
-    const bool chamber_on = (temp_chamber.target > 0)
-      #if ENABLED(PIDTEMPCHAMBER)
-        || (temp_chamber.soft_pwm_amount > 0)
-      #endif
-    ;
+    const bool chamber_on = (temp_chamber.target > 0);
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(-2);
     if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(-2);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
@@ -2595,25 +2604,26 @@ void Temperature::isr() {
       #endif // HAS_HEATED_CHAMBER
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , e
       );
     #endif
-    SERIAL_ECHOPGM(" @:");
-    SERIAL_ECHO(getHeaterPower(target_extruder));
+    SERIAL_ECHOPAIR(" @:", getHeaterPower(target_extruder));
     #if HAS_HEATED_BED
-      SERIAL_ECHOPGM(" B@:");
-      SERIAL_ECHO(getHeaterPower(-1));
+      SERIAL_ECHOPAIR(" B@:", getHeaterPower(-1));
+    #endif
+    #if HAS_HEATED_CHAMBER
+      SERIAL_ECHOPAIR(" C@:", getHeaterPower(-2));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
         SERIAL_ECHOPAIR(" @", e);
         SERIAL_CHAR(':');
         SERIAL_ECHO(getHeaterPower(e));
       }
     #endif
   }
 

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e7545ae8cc..d8bf25747e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -37,21 +37,21 @@
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if EITHER(BABYSTEPPING, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)
-  #include "../module/motion.h"
+  #include "../feature/babystep.h"
   #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
     #include "../gcode/gcode.h"
   #endif
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
@@ -232,24 +232,20 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
       millis_t Temperature::next_chamber_check_ms;
     #endif
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   //hotend_pid_t Temperature::pid[HOTENDS];
 #endif
 
-#if ENABLED(BABYSTEPPING)
-  volatile int16_t Temperature::babystepsTodo[XYZ] = { 0 };
-#endif
-
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
@@ -2509,108 +2505,30 @@ void Temperature::isr() {
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING)
-    #if EITHER(BABYSTEP_XY, I2C_POSITION_ENCODERS)
-      LOOP_XYZ(axis) {
-        const int16_t curTodo = babystepsTodo[axis]; // get rid of volatile for performance
-        if (curTodo) {
-          stepper.babystep((AxisEnum)axis, curTodo > 0);
-          if (curTodo > 0) babystepsTodo[axis]--; else babystepsTodo[axis]++;
-        }
-      }
-    #else
-      const int16_t curTodo = babystepsTodo[Z_AXIS];
-      if (curTodo) {
-        stepper.babystep(Z_AXIS, curTodo > 0);
-        if (curTodo > 0) babystepsTodo[Z_AXIS]--; else babystepsTodo[Z_AXIS]++;
-      }
-    #endif
+    babystep.task();
   #endif
 
   // Poll endstops state, if required
   endstops.poll();
 
   // Periodically call the planner timer
   planner.tick();
 }
 
-#if ENABLED(BABYSTEPPING)
-
-  #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
-    #define BSA_ENABLE(AXIS) do{ switch (AXIS) { case X_AXIS: enable_X(); break; case Y_AXIS: enable_Y(); break; case Z_AXIS: enable_Z(); } }while(0)
-  #else
-    #define BSA_ENABLE(AXIS) NOOP
-  #endif
-
-  #if ENABLED(BABYSTEP_WITHOUT_HOMING)
-    #define CAN_BABYSTEP(AXIS) true
-  #else
-    #define CAN_BABYSTEP(AXIS) TEST(axis_known_position, AXIS)
-  #endif
-
-  extern uint8_t axis_known_position;
-
-  void Temperature::babystep_axis(const AxisEnum axis, const int16_t distance) {
-    if (!CAN_BABYSTEP(axis)) return;
-    #if IS_CORE
-      #if ENABLED(BABYSTEP_XY)
-        switch (axis) {
-          case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
-            BSA_ENABLE(CORE_AXIS_1);
-            BSA_ENABLE(CORE_AXIS_2);
-            babystepsTodo[CORE_AXIS_1] += distance * 2;
-            babystepsTodo[CORE_AXIS_2] += distance * 2;
-            break;
-          case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
-            BSA_ENABLE(CORE_AXIS_1);
-            BSA_ENABLE(CORE_AXIS_2);
-            babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
-            babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
-            break;
-          case NORMAL_AXIS: // Z on CoreXY, Y on CoreXZ, X on CoreYZ
-          default:
-            BSA_ENABLE(NORMAL_AXIS);
-            babystepsTodo[NORMAL_AXIS] += distance;
-            break;
-        }
-      #elif CORE_IS_XZ || CORE_IS_YZ
-        // Only Z stepping needs to be handled here
-        BSA_ENABLE(CORE_AXIS_1);
-        BSA_ENABLE(CORE_AXIS_2);
-        babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
-        babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
-      #else
-        BSA_ENABLE(Z_AXIS);
-        babystepsTodo[Z_AXIS] += distance;
-      #endif
-    #else
-      #if ENABLED(BABYSTEP_XY)
-        BSA_ENABLE(axis);
-      #else
-        BSA_ENABLE(Z_AXIS);
-      #endif
-      babystepsTodo[axis] += distance;
-    #endif
-    #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
-      gcode.reset_stepper_timeout();
-    #endif
-  }
-
-#endif // BABYSTEPPING
-
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const int8_t e=-3
   ) {

commit c9079165eeea9bffd01dc67d58ee10cd89c351d7
Author: Kajetan Rzepecki <kajetan.rzepecki+github@gmail.com>
Date:   Sun Mar 31 05:31:50 2019 +0200

    Fix MAX6675 readout with Hardware SPI (#13530)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 88e0910c62..e7545ae8cc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1809,33 +1809,37 @@ void Temperature::disable_all_heaters() {
         #else
           max6675_temp_previous[hindex] // Need to return the correct previous value
         #endif
       );
 
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
-    #if MAX6675_SEPARATE_SPI
+    #if !MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
     #if COUNT_6675 > 1
       #define WRITE_MAX6675(V) do{ switch (hindex) { case 1: WRITE(MAX6675_SS2_PIN, V); break; default: WRITE(MAX6675_SS_PIN, V); } }while(0)
+      #define SET_OUTPUT_MAX6675() do{ switch (hindex) { case 1: SET_OUTPUT(MAX6675_SS2_PIN); break; default: SET_OUTPUT(MAX6675_SS_PIN); } }while(0)
     #elif ENABLED(HEATER_1_USES_MAX6675)
       #define WRITE_MAX6675(V) WRITE(MAX6675_SS2_PIN, V)
+      #define SET_OUTPUT_MAX6675() SET_OUTPUT(MAX6675_SS2_PIN)
     #else
       #define WRITE_MAX6675(V) WRITE(MAX6675_SS_PIN, V)
+      #define SET_OUTPUT_MAX6675() SET_OUTPUT(MAX6675_SS_PIN)
     #endif
 
+    SET_OUTPUT_MAX6675();
     WRITE_MAX6675(LOW);  // enable TT_MAX6675
 
     DELAY_NS(100);       // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
       max6675_temp |= (
         #if MAX6675_SEPARATE_SPI
           max6675_spi.receive()

commit ffc2c2d7c5ced5e6e4cb33698d30a779f3bcfe66
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Mar 26 06:03:23 2019 +0000

    Move FAST_PWM_FAN code to HALs (#13491)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0122367bca..88e0910c62 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1537,251 +1537,20 @@ void Temperature::init() {
     #ifdef CHAMBER_MAXTEMP
       while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) mintemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
   #endif
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
-
-#if ENABLED(FAST_PWM_FAN)
-  Temperature::Timer Temperature::get_pwm_timer(pin_t pin) {
-    #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
-      uint8_t q = 0;
-      switch (digitalPinToTimer(pin)) {
-        // Protect reserved timers (TIMER0 & TIMER1)
-        #ifdef TCCR0A
-          #if !AVR_AT90USB1286_FAMILY
-            case TIMER0A:
-          #endif
-          case TIMER0B:
-        #endif
-        #ifdef TCCR1A
-          case TIMER1A: case TIMER1B:
-        #endif
-                                            break;
-        #if defined(TCCR2) || defined(TCCR2A)
-          #ifdef TCCR2
-            case TIMER2: {
-              Temperature::Timer timer = {
-                /*TCCRnQ*/  { &TCCR2, NULL, NULL},
-                /*OCRnQ*/   { (uint16_t*)&OCR2, NULL, NULL},
-                /*ICRn*/      NULL,
-                /*n, q*/      2, 0
-              };
-            }
-          #elif defined TCCR2A
-            #if ENABLED(USE_OCR2A_AS_TOP)
-              case TIMER2A:   break; // protect TIMER2A
-              case TIMER2B: {
-                Temperature::Timer timer = {
-                  /*TCCRnQ*/  { &TCCR2A,  &TCCR2B,  NULL},
-                  /*OCRnQ*/   { (uint16_t*)&OCR2A, (uint16_t*)&OCR2B, NULL},
-                  /*ICRn*/      NULL,
-                  /*n, q*/      2, 1
-                };
-                return timer;
-              }
-            #else
-              case TIMER2B:   q += 1;
-              case TIMER2A: {
-                Temperature::Timer timer = {
-                  /*TCCRnQ*/  { &TCCR2A,  &TCCR2B,  NULL},
-                  /*OCRnQ*/   { (uint16_t*)&OCR2A, (uint16_t*)&OCR2B, NULL},
-                  /*ICRn*/      NULL,
-                                2, q
-                };
-                return timer;
-              }
-            #endif
-          #endif
-        #endif
-        #ifdef TCCR3A
-          case TIMER3C:   q += 1;
-          case TIMER3B:   q += 1;
-          case TIMER3A: {
-            Temperature::Timer timer = {
-              /*TCCRnQ*/  { &TCCR3A,  &TCCR3B,  &TCCR3C},
-              /*OCRnQ*/   { &OCR3A,   &OCR3B,   &OCR3C},
-              /*ICRn*/      &ICR3,
-              /*n, q*/      3, q
-            };
-            return timer;
-          }
-        #endif
-        #ifdef TCCR4A
-          case TIMER4C:   q += 1;
-          case TIMER4B:   q += 1;
-          case TIMER4A: {
-            Temperature::Timer timer = {
-              /*TCCRnQ*/  { &TCCR4A,  &TCCR4B,  &TCCR4C},
-              /*OCRnQ*/   { &OCR4A,   &OCR4B,   &OCR4C},
-              /*ICRn*/      &ICR4,
-              /*n, q*/      4, q
-            };
-            return timer;
-          }
-        #endif
-        #ifdef TCCR5A
-          case TIMER5C:   q += 1;
-          case TIMER5B:   q += 1;
-          case TIMER5A: {
-            Temperature::Timer timer = {
-              /*TCCRnQ*/  { &TCCR5A,  &TCCR5B,  &TCCR5C},
-              /*OCRnQ*/   { &OCR5A,   &OCR5B,   &OCR5C },
-              /*ICRn*/      &ICR5,
-              /*n, q*/      5, q
-            };
-            return timer;
-          }
-        #endif
-      }
-      Temperature::Timer timer = {
-          /*TCCRnQ*/  { NULL, NULL, NULL},
-          /*OCRnQ*/   { NULL, NULL, NULL},
-          /*ICRn*/      NULL,
-                        0, 0
-      };
-      return timer;
-    #endif // ARDUINO && !ARDUINO_ARCH_SAM
-  }
-
-  void Temperature::set_pwm_frequency(const pin_t pin, int f_desired) {
-    #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
-      Temperature::Timer timer = get_pwm_timer(pin);
-      if (timer.n == 0) return; // Don't proceed if protected timer or not recognised
-      uint16_t size;
-      if (timer.n == 2) size = 255; else size = 65535;
-
-      uint16_t res = 255;   // resolution (TOP value)
-      uint8_t j = 0;        // prescaler index
-      uint8_t wgm = 1;      // waveform generation mode
-
-      // Calculating the prescaler and resolution to use to achieve closest frequency
-      if (f_desired != 0) {
-        int f = F_CPU/(2*1024*size) + 1; // Initialize frequency as lowest (non-zero) achievable
-        uint16_t prescaler[] = {0, 1, 8, /*TIMER2 ONLY*/32, 64, /*TIMER2 ONLY*/128, 256, 1024};
-
-        // loop over prescaler values
-        for (uint8_t i = 1; i < 8; i++) {
-          uint16_t res_temp_fast = 255, res_temp_phase_correct = 255;
-          if (timer.n == 2) {
-            // No resolution calculation for TIMER2 unless enabled USE_OCR2A_AS_TOP
-            #if ENABLED(USE_OCR2A_AS_TOP)
-              res_temp_fast = (F_CPU / (prescaler[i] * f_desired)) - 1;
-              res_temp_phase_correct = F_CPU / (2 * prescaler[i] * f_desired);
-            #endif
-          }
-          else {
-            // Skip TIMER2 specific prescalers when not TIMER2
-            if (i == 3 || i == 5) continue;
-            res_temp_fast = (F_CPU / (prescaler[i] * f_desired)) - 1;
-            res_temp_phase_correct = F_CPU / (2 * prescaler[i] * f_desired);
-          }
-
-          LIMIT(res_temp_fast, 1u, size);
-          LIMIT(res_temp_phase_correct, 1u, size);
-          // Calculate frequncies of test prescaler and resolution values
-          int f_temp_fast = F_CPU / (prescaler[i] * (1 + res_temp_fast));
-          int f_temp_phase_correct = F_CPU / (2 * prescaler[i] * res_temp_phase_correct);
-
-          // If FAST values are closest to desired f
-          if (ABS(f_temp_fast - f_desired) < ABS(f - f_desired)
-              && ABS(f_temp_fast - f_desired) <= ABS(f_temp_phase_correct - f_desired)) {
-            // Remember this combination
-            f = f_temp_fast;
-            res = res_temp_fast;
-            j = i;
-            // Set the Wave Generation Mode to FAST PWM
-            if(timer.n == 2){
-              wgm =
-                #if ENABLED(USE_OCR2A_AS_TOP)
-                  WGM2_FAST_PWM_OCR2A;
-                #else
-                  WGM2_FAST_PWM;
-                #endif
-            }
-            else wgm = WGM_FAST_PWM_ICRn;
-          }
-          // If PHASE CORRECT values are closes to desired f
-          else if (ABS(f_temp_phase_correct - f_desired) < ABS(f - f_desired)) {
-            f = f_temp_phase_correct;
-            res = res_temp_phase_correct;
-            j = i;
-            // Set the Wave Generation Mode to PWM PHASE CORRECT
-            if (timer.n == 2) {
-              wgm =
-                #if ENABLED(USE_OCR2A_AS_TOP)
-                  WGM2_PWM_PC_OCR2A;
-                #else
-                  WGM2_PWM_PC;
-                #endif
-            }
-            else wgm = WGM_PWM_PC_ICRn;
-          }
-        }
-      }
-      _SET_WGMnQ(timer.TCCRnQ, wgm);
-      _SET_CSn(timer.TCCRnQ, j);
-
-      if (timer.n == 2) {
-        #if ENABLED(USE_OCR2A_AS_TOP)
-          _SET_OCRnQ(timer.OCRnQ, 0, res);  // Set OCR2A value (TOP) = res
-        #endif
-      }
-      else {
-        _SET_ICRn(timer.ICRn, res);         // Set ICRn value (TOP) = res
-      }
-    #endif // ARDUINO && !ARDUINO_ARCH_SAM
-  }
-
-  void Temperature::set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size/*=255*/, const bool invert/*=false*/) {
-    #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
-      // If v is 0 or v_size (max), digitalWrite to LOW or HIGH.
-      // Note that digitalWrite also disables pwm output for us (sets COM bit to 0)
-      if (v == 0)
-        digitalWrite(pin, invert);
-      else if (v == v_size)
-        digitalWrite(pin, !invert);
-      else {
-        Temperature::Timer timer = get_pwm_timer(pin);
-        if (timer.n == 0) return; // Don't proceed if protected timer or not recognised
-        // Set compare output mode to CLEAR -> SET or SET -> CLEAR (if inverted)
-        _SET_COMnQ(timer.TCCRnQ, timer.q
-            #ifdef TCCR2
-              + (timer.q == 2) // COM20 is on bit 4 of TCCR2, thus requires q + 1 in the macro
-            #endif
-          , COM_CLEAR_SET + invert
-        );
-
-        uint16_t top;
-        if (timer.n == 2) { // if TIMER2
-          top =
-            #if ENABLED(USE_OCR2A_AS_TOP)
-              *timer.OCRnQ[0] // top = OCR2A
-            #else
-              255 // top = 0xFF (max)
-            #endif
-          ;
-        }
-        else
-          top = *timer.ICRn; // top = ICRn
-
-        _SET_OCRnQ(timer.OCRnQ, timer.q, v * float(top / v_size)); // Scale 8/16-bit v to top value
-      }
-    #endif // ARDUINO && !ARDUINO_ARCH_SAM
-  }
-
-#endif // FAST_PWM_FAN
-
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_heater(const uint8_t e) {
     E_UNUSED();
     if (degTargetHotend(HOTEND_INDEX) && degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
       watch_hotend[HOTEND_INDEX].target = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;

commit a8fa275dc6e9d0938da4d83e8e9d9ac3a527f12b
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Sun Mar 24 04:00:31 2019 +0000

    Fix Fan 0 responding to all fan speeds (#13444)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 166c585ba3..0122367bca 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2372,21 +2372,21 @@ void Temperature::isr() {
         _PWM_MOD(BED,soft_pwm_bed,temp_bed);
       #endif
 
       #if HAS_HEATED_CHAMBER
         _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #define _FAN_PWM(N) do{ \
           soft_pwm_count_fan[N] = (soft_pwm_count_fan[N] & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
-          WRITE_FAN(soft_pwm_count_fan[N] > pwm_mask ? HIGH : LOW); \
+          WRITE_FAN_N(N, soft_pwm_count_fan[N] > pwm_mask ? HIGH : LOW); \
         }while(0)
         #if HAS_FAN0
           _FAN_PWM(0);
         #endif
         #if HAS_FAN1
           _FAN_PWM(1);
         #endif
         #if HAS_FAN2
           _FAN_PWM(2);
         #endif

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9258ce3288..166c585ba3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -26,27 +26,27 @@
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 
-#define MAX6675_SEPARATE_SPI (ENABLED(HEATER_0_USES_MAX6675) || ENABLED(HEATER_1_USES_MAX6675)) && PIN_EXISTS(MAX6675_SCK) && PIN_EXISTS(MAX6675_DO)
+#define MAX6675_SEPARATE_SPI EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675) && PIN_EXISTS(MAX6675_SCK, MAX6675_DO)
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
-#if ENABLED(BABYSTEPPING) || ENABLED(PID_EXTRUSION_SCALING)
+#if EITHER(BABYSTEPPING, PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "../module/motion.h"
   #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
     #include "../gcode/gcode.h"
   #endif
 #endif
 
@@ -353,22 +353,22 @@ temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
       #define SHV(B,H) (temp_hotend[heater].soft_pwm_amount = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
 
     #if WATCH_BED || WATCH_HOTENDS
-      #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
-      #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
+      #define HAS_TP_BED BOTH(THERMAL_PROTECTION_BED, PIDTEMPBED)
+      #if HAS_TP_BED && BOTH(THERMAL_PROTECTION_HOTENDS, PIDTEMP)
         #define GTV(B,H) (heater < 0 ? (B) : (H))
       #elif HAS_TP_BED
         #define GTV(B,H) (B)
       #else
         #define GTV(B,H) (H)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
@@ -906,21 +906,21 @@ float Temperature::get_pid_output(const int8_t e) {
 void Temperature::manage_heater() {
 
   #if EARLY_WATCHDOG
     // If thermal manager is still not running, make sure to at least reset the watchdog!
     if (!inited) {
       watchdog_reset();
       return;
     }
   #endif
 
-  #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+  #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
@@ -997,26 +997,26 @@ void Temperature::manage_heater() {
       if (watch_bed.elapsed(ms)) {        // Time to check the bed?
         if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
     #endif // WATCH_BED
 
     #if DISABLED(PIDTEMPBED)
       if (PENDING(ms, next_bed_check_ms)
-        #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+        #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
           && paused == last_pause_state
         #endif
       ) return;
       next_bed_check_ms = ms + BED_CHECK_INTERVAL;
-      #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+      #if BOTH(PROBING_HEATERS_OFF, BED_LIMIT_SWITCHING)
         last_pause_state = paused;
       #endif
     #endif
 
     #if HEATER_IDLE_HANDLER
       bed_idle.update(ms);
     #endif
 
     #if HAS_THERMALLY_PROTECTED_BED
       thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
@@ -1327,29 +1327,29 @@ void Temperature::updateTemperaturesFromRawValues() {
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
   #if MB(RUMBA)
-    #define _AD(N) (ENABLED(HEATER_##N##_USES_AD595) || ENABLED(HEATER_##N##_USES_AD8495))
+    #define _AD(N) (ANY(HEATER_##N##_USES_AD595, HEATER_##N##_USES_AD8495))
     #if _AD(0) || _AD(1) || _AD(2) || _AD(3) || _AD(4) || _AD(5) || _AD(BED) || _AD(CHAMBER)
       // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
       MCUCR = _BV(JTD);
       MCUCR = _BV(JTD);
     #endif
   #endif
 
-  #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
+  #if BOTH(PIDTEMP, PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
     OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
   #endif
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
@@ -2736,21 +2736,21 @@ void Temperature::isr() {
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING)
-    #if ENABLED(BABYSTEP_XY) || ENABLED(I2C_POSITION_ENCODERS)
+    #if EITHER(BABYSTEP_XY, I2C_POSITION_ENCODERS)
       LOOP_XYZ(axis) {
         const int16_t curTodo = babystepsTodo[axis]; // get rid of volatile for performance
         if (curTodo) {
           stepper.babystep((AxisEnum)axis, curTodo > 0);
           if (curTodo > 0) babystepsTodo[axis]--; else babystepsTodo[axis]++;
         }
       }
     #else
       const int16_t curTodo = babystepsTodo[Z_AXIS];
       if (curTodo) {
@@ -2935,21 +2935,21 @@ void Temperature::isr() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         PORT_REDIRECT(SERIAL_BOTH);
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
-  #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
+  #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
         ui.status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
       #else
         ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 

commit 59353546e81bc7f54724c04ae597f7663eff798d
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Mar 16 17:59:12 2019 +0100

    Fix BUTTON_EXISTS and misplaced comma (#13411)
    
    Fixes #13410 and redeclaration of `BUTTON_EXISTS`

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 499b4a69e6..9258ce3288 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -816,22 +816,22 @@ float Temperature::get_pid_output(const int8_t e) {
       SERIAL_ECHOPAIR(
         MSG_PID_DEBUG, HOTEND_INDEX,
         MSG_PID_DEBUG_INPUT, temp_hotend[HOTEND_INDEX].current,
         MSG_PID_DEBUG_OUTPUT, pid_output
       );
       #if DISABLED(PID_OPENLOOP)
         SERIAL_ECHOPAIR(
           MSG_PID_DEBUG_PTERM, work_pid[HOTEND_INDEX].Kp,
           MSG_PID_DEBUG_ITERM, work_pid[HOTEND_INDEX].Ki,
           MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd
-          #if ENABLED(PID_EXTRUSION_SCALING),
-            MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            , MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc
           #endif
         );
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
   #else /* PID off */
     #if HEATER_IDLE_HANDLER
       #define _TIMED_OUT_TEST hotend_idle[HOTEND_INDEX].timed_out
     #else

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 53171db22d..499b4a69e6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -650,21 +650,21 @@ int Temperature::getHeaterPower(const int heater) {
       if (temp_hotend[e].current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
       if (temp_chamber.current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[6]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{                               \
       if (PWM_PIN(P##_AUTO_FAN_PIN) && EXTRUDER_AUTO_FAN_SPEED < 255) \
-        ANALOG_WRITE(P##_AUTO_FAN_PIN, A);                            \
+        analogWrite(P##_AUTO_FAN_PIN, A);                             \
       else                                                            \
         WRITE(P##_AUTO_FAN_PIN, D);                                   \
     }while(0)
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanBit); f++) {
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, bit)) continue;
       const bool fan_on = TEST(fanState, bit);
       const uint8_t speed = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4718ae60cc..53171db22d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -603,20 +603,42 @@ int Temperature::getHeaterPower(const int heater) {
   return (
     #if HAS_HEATED_BED
       heater < 0 ? temp_bed.soft_pwm_amount :
     #endif
     temp_hotend[heater].soft_pwm_amount
   );
 }
 
 #if HAS_AUTO_FAN
 
+  #define AUTO_1_IS_0 (E1_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_2_IS_0 (E2_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_2_IS_1 (E2_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_3_IS_0 (E3_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_3_IS_1 (E3_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_3_IS_2 (E3_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
+  #define AUTO_4_IS_0 (E4_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_4_IS_1 (E4_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_4_IS_2 (E4_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
+  #define AUTO_4_IS_3 (E4_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
+  #define AUTO_5_IS_0 (E5_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_5_IS_1 (E5_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_5_IS_2 (E5_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
+  #define AUTO_5_IS_3 (E5_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
+  #define AUTO_5_IS_4 (E5_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_0 (CHAMBER_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_1 (CHAMBER_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_2 (CHAMBER_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_3 (CHAMBER_AUTO_FAN_PIN == E3_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_4 (CHAMBER_AUTO_FAN_PIN == E4_AUTO_FAN_PIN)
+  #define AUTO_CHAMBER_IS_5 (CHAMBER_AUTO_FAN_PIN == E5_AUTO_FAN_PIN)
+
   void Temperature::checkExtruderAutoFans() {
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
       AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 :               4,
       AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
       #if HAS_TEMP_CHAMBER
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
@@ -626,25 +648,25 @@ int Temperature::getHeaterPower(const int heater) {
 
     HOTEND_LOOP()
       if (temp_hotend[e].current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
       if (temp_chamber.current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[6]));
     #endif
 
-    #define _UPDATE_AUTO_FAN(P,D,A) do{           \
-      if (USEABLE_HARDWARE_PWM(P##_AUTO_FAN_PIN)) \
-        analogWrite(P##_AUTO_FAN_PIN, A);         \
-      else                                        \
-        WRITE(P##_AUTO_FAN_PIN, D);               \
+    #define _UPDATE_AUTO_FAN(P,D,A) do{                               \
+      if (PWM_PIN(P##_AUTO_FAN_PIN) && EXTRUDER_AUTO_FAN_SPEED < 255) \
+        ANALOG_WRITE(P##_AUTO_FAN_PIN, A);                            \
+      else                                                            \
+        WRITE(P##_AUTO_FAN_PIN, D);                                   \
     }while(0)
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanBit); f++) {
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (TEST(fanDone, bit)) continue;
       const bool fan_on = TEST(fanState, bit);
       const uint8_t speed = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
       #if ENABLED(AUTO_POWER_E_FANS)
         autofan_speed[f] = speed;
@@ -1273,20 +1295,39 @@ void Temperature::updateTemperaturesFromRawValues() {
       return int(100.0f * filament_width_nominal / filament_width_meas) - 100;
     return 0;
   }
 
 #endif
 
 #if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
+// Init fans according to whether they're native PWM or Software PWM
+#define _INIT_SOFT_FAN(P) OUT_WRITE(P, FAN_INVERTING ? LOW : HIGH)
+#if ENABLED(FAN_SOFT_PWM)
+  #define _INIT_FAN_PIN(P) _INIT_SOFT_FAN(P)
+#else
+  #define _INIT_FAN_PIN(P) do{ if (PWM_PIN(P)) SET_PWM(P); else _INIT_SOFT_FAN(P); }while(0)
+#endif
+#if ENABLED(FAST_PWM_FAN)
+  #define SET_FAST_PWM_FREQ(P) set_pwm_frequency(P, FAST_PWM_FAN_FREQUENCY)
+#else
+  #define SET_FAST_PWM_FREQ(P) NOOP
+#endif
+#define INIT_FAN_PIN(P) do{ _INIT_FAN_PIN(P); SET_FAST_PWM_FREQ(P); }while(0)
+#if EXTRUDER_AUTO_FAN_SPEED != 255
+  #define INIT_AUTO_FAN_PIN(P) do{ if (P == FAN1_PIN || P == FAN2_PIN) { SET_PWM(P); SET_FAST_PWM_FREQ(FAST_PWM_FAN_FREQUENCY); } else SET_OUTPUT(P); }while(0)
+#else
+  #define INIT_AUTO_FAN_PIN(P) SET_OUTPUT(P)
+#endif
+
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
@@ -1322,46 +1363,32 @@ void Temperature::init() {
   #endif
   #if HAS_HEATER_5
     OUT_WRITE(HEATER_5_PIN, HEATER_5_INVERTING);
   #endif
   #if HAS_HEATED_BED
     OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
   #endif
   #if HAS_HEATED_CHAMBER
     OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
   #endif
+
   #if HAS_FAN0
-    SET_OUTPUT(FAN_PIN);
-    #if ENABLED(FAST_PWM_FAN)
-      set_pwm_frequency(FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-    #endif
+    INIT_FAN_PIN(FAN_PIN);
   #endif
-
   #if HAS_FAN1
-    SET_OUTPUT(FAN1_PIN);
-    #if ENABLED(FAST_PWM_FAN)
-      set_pwm_frequency(FAN1_PIN, FAST_PWM_FAN_FREQUENCY);
-    #endif
+    INIT_FAN_PIN(FAN1_PIN);
   #endif
-
   #if HAS_FAN2
-    SET_OUTPUT(FAN2_PIN);
-    #if ENABLED(FAST_PWM_FAN)
-      set_pwm_frequency(FAN2_PIN, FAST_PWM_FAN_FREQUENCY);
-    #endif
+    INIT_FAN_PIN(FAN2_PIN);
   #endif
-
   #if ENABLED(USE_CONTROLLER_FAN)
-    SET_OUTPUT(CONTROLLER_FAN_PIN);
-    #if ENABLED(FAST_PWM_FAN)
-      set_pwm_frequency(CONTROLLER_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-    #endif
+    INIT_FAN_PIN(CONTROLLER_FAN_PIN);
   #endif
 
   #if MAX6675_SEPARATE_SPI
 
     OUT_WRITE(SCK_PIN, LOW);
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
     max6675_spi.init();
 
@@ -1401,88 +1428,39 @@ void Temperature::init() {
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
-    #if E0_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(E0_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(E0_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(E0_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(E0_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
-    #if E1_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(E1_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(E1_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(E1_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(E1_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_2 && !(AUTO_2_IS_0 || AUTO_2_IS_1)
-    #if E2_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(E2_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(E2_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(E2_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(E2_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_3 && !(AUTO_3_IS_0 || AUTO_3_IS_1 || AUTO_3_IS_2)
-    #if E3_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(E3_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(E3_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(E3_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(E3_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_4 && !(AUTO_4_IS_0 || AUTO_4_IS_1 || AUTO_4_IS_2 || AUTO_4_IS_3)
-    #if E4_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(E4_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(E4_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(E4_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(E4_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_FAN_5 && !(AUTO_5_IS_0 || AUTO_5_IS_1 || AUTO_5_IS_2 || AUTO_5_IS_3 || AUTO_5_IS_4)
-    #if E5_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(E5_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(E5_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(E5_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(E5_AUTO_FAN_PIN);
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !(AUTO_CHAMBER_IS_0 || AUTO_CHAMBER_IS_1 || AUTO_CHAMBER_IS_2 || AUTO_CHAMBER_IS_3 || AUTO_CHAMBER_IS_4 || AUTO_CHAMBER_IS_5)
-    #if CHAMBER_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
-      #if ENABLED(FAST_PWM_FAN)
-        set_pwm_frequency(CHAMBER_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
-      #endif
-    #else
-      SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
-    #endif
+    INIT_AUTO_FAN_PIN(CHAMBER_AUTO_FAN_PIN);
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HOTENDS
 
     #define _TEMP_MIN_E(NR) do{ \
       temp_range[NR].mintemp = HEATER_ ##NR## _MINTEMP; \
       while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < HEATER_ ##NR## _MINTEMP) \

commit 0375e92847966977b9dce02dcd1b2f9316d2a085
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 16:45:10 2019 -0500

    Followup to serial rework
    
    As mentioned in #13370

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d9920c74b0..4718ae60cc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2907,33 +2907,27 @@ void Temperature::isr() {
         #endif
         , -1 // BED
       );
     #endif
     #if HAS_TEMP_CHAMBER
       #if HAS_HEATED_CHAMBER
         print_heater_state(degChamber(), degTargetChamber()
           #if ENABLED(SHOW_TEMP_ADC_VALUES)
             , rawChamberTemp()
           #endif
-          #if NUM_SERIAL > 1
-            , port
-          #endif
         , -2 // CHAMBER
       );
       #else
         print_heater_state(degChamber(), 0
           #if ENABLED(SHOW_TEMP_ADC_VALUES)
             , rawChamberTemp()
           #endif
-          #if NUM_SERIAL > 1
-            , port
-          #endif
           , -2 // CHAMBER
         );
       #endif // HAS_HEATED_CHAMBER
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , e

commit 1f7e220387e01d8be9b370396c2c5cc7e0b34f56
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 20:43:59 2019 -0500

    Make HAL ISR macros function-like

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 46e05f58ff..d9920c74b0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2288,21 +2288,21 @@ void Temperature::readings_ready() {
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
  *  - Call planner.tick to count down its "ignore" time
  */
-HAL_TEMP_TIMER_ISR {
+HAL_TEMP_TIMER_ISR() {
   HAL_timer_isr_prologue(TEMP_TIMER_NUM);
 
   Temperature::isr();
 
   HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
 }
 
 #if ENABLED(SLOW_PWM_HEATERS) && !defined(MIN_STATE_TIME)
   #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
 #endif

commit 3419099f0a1c3b7c558b93a4562071bfff23fa45
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 19:09:19 2019 -0500

    Clean up whitespace

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c277c4a651..46e05f58ff 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2263,21 +2263,21 @@ void Temperature::readings_ready() {
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(-1);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(-1);
   #endif
 
   #if HAS_HEATED_CHAMBER
     #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<=(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>=(B))
     #endif
-    const bool chamber_on = (temp_chamber.target > 0) 
+    const bool chamber_on = (temp_chamber.target > 0)
       #if ENABLED(PIDTEMPCHAMBER)
         || (temp_chamber.soft_pwm_amount > 0)
       #endif
     ;
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(-2);
     if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(-2);
   #endif
 }
 
 /**

commit c36989c39e81dfa53f4ae324ef77501c753584c9
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Sun Mar 10 15:51:13 2019 +0100

    Fix chamber temperature measurement (#13350)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index aaffb5ad5b..c277c4a651 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -212,28 +212,28 @@ hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
   #endif
   #if DISABLED(PIDTEMPBED)
     millis_t Temperature::next_bed_check_ms;
   #endif
   #if HEATER_IDLE_HANDLER
     heater_idle_t Temperature::bed_idle; // = { 0 }
   #endif
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
+  chamber_info_t Temperature::temp_chamber; // = { 0 }
   #if HAS_HEATED_CHAMBER
     #ifdef CHAMBER_MINTEMP
       int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
     #endif
     #ifdef CHAMBER_MAXTEMP
       int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
     #endif
-    chamber_info_t temp_chamber; // = { 0 }
     #if WATCH_CHAMBER
       heater_watch_t Temperature::watch_chamber = { 0 };
       millis_t Temperature::next_chamber_check_ms;
     #endif
   #endif // HAS_HEATED_CHAMBER
 #endif // HAS_TEMP_CHAMBER
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   //hotend_pid_t Temperature::pid[HOTENDS];
@@ -1986,21 +1986,21 @@ void Temperature::disable_all_heaters() {
   #endif
 
   #if HAS_HEATED_BED
     temp_bed.target = 0;
     temp_bed.soft_pwm_amount = 0;
     #if HAS_HEATED_BED
       WRITE_HEATER_BED(LOW);
     #endif
   #endif
 
-  #if HAS_TEMP_CHAMBER
+  #if HAS_HEATED_CHAMBER
     temp_chamber.target = 0;
     temp_chamber.soft_pwm_amount = 0;
     #if HAS_HEATED_CHAMBER
       WRITE_HEATER_CHAMBER(LOW);
     #endif
   #endif
 }
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
@@ -2257,27 +2257,31 @@ void Temperature::readings_ready() {
     #endif
     const bool bed_on = (temp_bed.target > 0)
       #if ENABLED(PIDTEMPBED)
         || (temp_bed.soft_pwm_amount > 0)
       #endif
     ;
     if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(-1);
     if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(-1);
   #endif
 
-  #if HAS_TEMP_CHAMBER
-    #if TEMPDIR(BED) < 0
+  #if HAS_HEATED_CHAMBER
+    #if TEMPDIR(CHAMBER) < 0
       #define CHAMBERCMP(A,B) ((A)<=(B))
     #else
       #define CHAMBERCMP(A,B) ((A)>=(B))
     #endif
-    const bool chamber_on = (temp_chamber.target > 0) || (temp_chamber.soft_pwm_amount > 0);
+    const bool chamber_on = (temp_chamber.target > 0) 
+      #if ENABLED(PIDTEMPCHAMBER)
+        || (temp_chamber.soft_pwm_amount > 0)
+      #endif
+    ;
     if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(-2);
     if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(-2);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set

commit 33a08fc6f76465c1e318a7a1046c65ceb661caed
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 08:27:41 2019 -0500

    Fix typos from temperature rework
    
    Followup to #12201

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 94cd06ae61..aaffb5ad5b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -622,21 +622,21 @@ int Temperature::getHeaterPower(const int heater) {
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
       #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (temp_hotend[e].current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
-      if (temp_chambercurrent > EXTRUDER_AUTO_FAN_TEMPERATURE)
+      if (temp_chamber.current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[6]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{           \
       if (USEABLE_HARDWARE_PWM(P##_AUTO_FAN_PIN)) \
         analogWrite(P##_AUTO_FAN_PIN, A);         \
       else                                        \
         WRITE(P##_AUTO_FAN_PIN, D);               \
     }while(0)
 
@@ -1046,41 +1046,41 @@ void Temperature::manage_heater() {
           if (degChamber() < watch_chamber.target)   // Failed to increase enough?
             _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
           else
             start_watching_chamber();                     // Start again if the target is still far off
         }
       #endif // WATCH_CHAMBER
 
       if (PENDING(ms, next_chamber_check_ms)) return;
       next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
 
-      if (WITHIN(temp_chambercurrent, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
+      if (WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
         #if ENABLED(CHAMBER_LIMIT_SWITCHING)
-          if (temp_chambercurrent >= temp_chamber.target + CHAMBER_HYSTERESIS)
+          if (temp_chamber.current >= temp_chamber.target + CHAMBER_HYSTERESIS)
             temp_chamber.soft_pwm_amount = 0;
-          else if (temp_chambercurrent <= temp_chamber.target - (CHAMBER_HYSTERESIS))
+          else if (temp_chamber.current <= temp_chamber.target - (CHAMBER_HYSTERESIS))
             temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
         #else // !PIDTEMPCHAMBER && !CHAMBER_LIMIT_SWITCHING
-          temp_chamber.soft_pwm_amount = temp_chambercurrent < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
+          temp_chamber.soft_pwm_amount = temp_chamber.current < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
         #endif
       }
       else {
         temp_chamber.soft_pwm_amount = 0;
         WRITE_HEATER_CHAMBER(LOW);
       }
 
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        thermal_runaway_protection(tr_state_machine_chamber, temp_chambercurrent, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+        thermal_runaway_protection(tr_state_machine_chamber, temp_chamber.current, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
       #endif
 
       // TODO: Implement true PID pwm
-      //temp_bed.soft_pwm_amount = WITHIN(temp_chambercurrent, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
+      //temp_bed.soft_pwm_amount = WITHIN(temp_chamber.current, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
 
     #endif // HAS_HEATED_CHAMBER
 
   #endif // HAS_TEMP_CHAMBER
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
@@ -1228,21 +1228,21 @@ void Temperature::updateTemperaturesFromRawValues() {
     temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
     temp_hotend[1].raw = READ_MAX6675(1);
   #endif
   HOTEND_LOOP() temp_hotend[e].current = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #if HAS_HEATED_BED
     temp_bed.current = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
-    temp_chambercurrent = analog_to_celsius_chamber(temp_chamber.raw);
+    temp_chamber.current = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog_to_mm_fil_width();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.

commit dbead66988b138e67d0e8cc5901fa38672feb390
Author: Reece Kibble <reece.kibble@gmail.com>
Date:   Fri Mar 8 16:15:42 2019 +0800

    Allows user to set (almost) any PWM frequency (#12638)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b01ed04623..94cd06ae61 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1325,42 +1325,42 @@ void Temperature::init() {
   #endif
   #if HAS_HEATED_BED
     OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
   #endif
   #if HAS_HEATED_CHAMBER
     OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
   #endif
   #if HAS_FAN0
     SET_OUTPUT(FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
-      setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      set_pwm_frequency(FAN_PIN, FAST_PWM_FAN_FREQUENCY);
     #endif
   #endif
 
   #if HAS_FAN1
     SET_OUTPUT(FAN1_PIN);
     #if ENABLED(FAST_PWM_FAN)
-      setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      set_pwm_frequency(FAN1_PIN, FAST_PWM_FAN_FREQUENCY);
     #endif
   #endif
 
   #if HAS_FAN2
     SET_OUTPUT(FAN2_PIN);
     #if ENABLED(FAST_PWM_FAN)
-      setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      set_pwm_frequency(FAN2_PIN, FAST_PWM_FAN_FREQUENCY);
     #endif
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     SET_OUTPUT(CONTROLLER_FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
-      setPwmFrequency(CONTROLLER_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      set_pwm_frequency(CONTROLLER_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
     #endif
   #endif
 
   #if MAX6675_SEPARATE_SPI
 
     OUT_WRITE(SCK_PIN, LOW);
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
     max6675_spi.init();
@@ -1404,81 +1404,81 @@ void Temperature::init() {
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     #if E0_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E0_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(E0_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(E0_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
     #if E1_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E1_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(E1_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(E1_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_2 && !(AUTO_2_IS_0 || AUTO_2_IS_1)
     #if E2_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E2_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(E2_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(E2_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_3 && !(AUTO_3_IS_0 || AUTO_3_IS_1 || AUTO_3_IS_2)
     #if E3_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E3_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(E3_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(E3_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_4 && !(AUTO_4_IS_0 || AUTO_4_IS_1 || AUTO_4_IS_2 || AUTO_4_IS_3)
     #if E4_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E4_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(E4_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(E4_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_5 && !(AUTO_5_IS_0 || AUTO_5_IS_1 || AUTO_5_IS_2 || AUTO_5_IS_3 || AUTO_5_IS_4)
     #if E5_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E5_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(E5_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(E5_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(E5_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_CHAMBER_FAN && !(AUTO_CHAMBER_IS_0 || AUTO_CHAMBER_IS_1 || AUTO_CHAMBER_IS_2 || AUTO_CHAMBER_IS_3 || AUTO_CHAMBER_IS_4 || AUTO_CHAMBER_IS_5)
     #if CHAMBER_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(CHAMBER_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        set_pwm_frequency(CHAMBER_AUTO_FAN_PIN, FAST_PWM_FAN_FREQUENCY);
       #endif
     #else
       SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
     #endif
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #if HOTENDS
@@ -1559,57 +1559,247 @@ void Temperature::init() {
     #ifdef CHAMBER_MAXTEMP
       while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) mintemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
     #endif
   #endif
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
-#if ENABLED(FAST_PWM_FAN)
 
-  void Temperature::setPwmFrequency(const pin_t pin, int val) {
+#if ENABLED(FAST_PWM_FAN)
+  Temperature::Timer Temperature::get_pwm_timer(pin_t pin) {
     #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
-      val &= 0x07;
+      uint8_t q = 0;
       switch (digitalPinToTimer(pin)) {
+        // Protect reserved timers (TIMER0 & TIMER1)
         #ifdef TCCR0A
           #if !AVR_AT90USB1286_FAMILY
             case TIMER0A:
           #endif
-          case TIMER0B:                           //_SET_CS(0, val);
-                                                    break;
+          case TIMER0B:
         #endif
         #ifdef TCCR1A
-          case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
-                                                    break;
+          case TIMER1A: case TIMER1B:
         #endif
+                                            break;
         #if defined(TCCR2) || defined(TCCR2A)
           #ifdef TCCR2
-            case TIMER2:
-          #endif
-          #ifdef TCCR2A
-            case TIMER2A: case TIMER2B:
+            case TIMER2: {
+              Temperature::Timer timer = {
+                /*TCCRnQ*/  { &TCCR2, NULL, NULL},
+                /*OCRnQ*/   { (uint16_t*)&OCR2, NULL, NULL},
+                /*ICRn*/      NULL,
+                /*n, q*/      2, 0
+              };
+            }
+          #elif defined TCCR2A
+            #if ENABLED(USE_OCR2A_AS_TOP)
+              case TIMER2A:   break; // protect TIMER2A
+              case TIMER2B: {
+                Temperature::Timer timer = {
+                  /*TCCRnQ*/  { &TCCR2A,  &TCCR2B,  NULL},
+                  /*OCRnQ*/   { (uint16_t*)&OCR2A, (uint16_t*)&OCR2B, NULL},
+                  /*ICRn*/      NULL,
+                  /*n, q*/      2, 1
+                };
+                return timer;
+              }
+            #else
+              case TIMER2B:   q += 1;
+              case TIMER2A: {
+                Temperature::Timer timer = {
+                  /*TCCRnQ*/  { &TCCR2A,  &TCCR2B,  NULL},
+                  /*OCRnQ*/   { (uint16_t*)&OCR2A, (uint16_t*)&OCR2B, NULL},
+                  /*ICRn*/      NULL,
+                                2, q
+                };
+                return timer;
+              }
+            #endif
           #endif
-                                                    _SET_CS(2, val); break;
         #endif
         #ifdef TCCR3A
-          case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
+          case TIMER3C:   q += 1;
+          case TIMER3B:   q += 1;
+          case TIMER3A: {
+            Temperature::Timer timer = {
+              /*TCCRnQ*/  { &TCCR3A,  &TCCR3B,  &TCCR3C},
+              /*OCRnQ*/   { &OCR3A,   &OCR3B,   &OCR3C},
+              /*ICRn*/      &ICR3,
+              /*n, q*/      3, q
+            };
+            return timer;
+          }
         #endif
         #ifdef TCCR4A
-          case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
+          case TIMER4C:   q += 1;
+          case TIMER4B:   q += 1;
+          case TIMER4A: {
+            Temperature::Timer timer = {
+              /*TCCRnQ*/  { &TCCR4A,  &TCCR4B,  &TCCR4C},
+              /*OCRnQ*/   { &OCR4A,   &OCR4B,   &OCR4C},
+              /*ICRn*/      &ICR4,
+              /*n, q*/      4, q
+            };
+            return timer;
+          }
         #endif
         #ifdef TCCR5A
-          case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
+          case TIMER5C:   q += 1;
+          case TIMER5B:   q += 1;
+          case TIMER5A: {
+            Temperature::Timer timer = {
+              /*TCCRnQ*/  { &TCCR5A,  &TCCR5B,  &TCCR5C},
+              /*OCRnQ*/   { &OCR5A,   &OCR5B,   &OCR5C },
+              /*ICRn*/      &ICR5,
+              /*n, q*/      5, q
+            };
+            return timer;
+          }
         #endif
       }
-    #endif
+      Temperature::Timer timer = {
+          /*TCCRnQ*/  { NULL, NULL, NULL},
+          /*OCRnQ*/   { NULL, NULL, NULL},
+          /*ICRn*/      NULL,
+                        0, 0
+      };
+      return timer;
+    #endif // ARDUINO && !ARDUINO_ARCH_SAM
+  }
+
+  void Temperature::set_pwm_frequency(const pin_t pin, int f_desired) {
+    #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
+      Temperature::Timer timer = get_pwm_timer(pin);
+      if (timer.n == 0) return; // Don't proceed if protected timer or not recognised
+      uint16_t size;
+      if (timer.n == 2) size = 255; else size = 65535;
+
+      uint16_t res = 255;   // resolution (TOP value)
+      uint8_t j = 0;        // prescaler index
+      uint8_t wgm = 1;      // waveform generation mode
+
+      // Calculating the prescaler and resolution to use to achieve closest frequency
+      if (f_desired != 0) {
+        int f = F_CPU/(2*1024*size) + 1; // Initialize frequency as lowest (non-zero) achievable
+        uint16_t prescaler[] = {0, 1, 8, /*TIMER2 ONLY*/32, 64, /*TIMER2 ONLY*/128, 256, 1024};
+
+        // loop over prescaler values
+        for (uint8_t i = 1; i < 8; i++) {
+          uint16_t res_temp_fast = 255, res_temp_phase_correct = 255;
+          if (timer.n == 2) {
+            // No resolution calculation for TIMER2 unless enabled USE_OCR2A_AS_TOP
+            #if ENABLED(USE_OCR2A_AS_TOP)
+              res_temp_fast = (F_CPU / (prescaler[i] * f_desired)) - 1;
+              res_temp_phase_correct = F_CPU / (2 * prescaler[i] * f_desired);
+            #endif
+          }
+          else {
+            // Skip TIMER2 specific prescalers when not TIMER2
+            if (i == 3 || i == 5) continue;
+            res_temp_fast = (F_CPU / (prescaler[i] * f_desired)) - 1;
+            res_temp_phase_correct = F_CPU / (2 * prescaler[i] * f_desired);
+          }
+
+          LIMIT(res_temp_fast, 1u, size);
+          LIMIT(res_temp_phase_correct, 1u, size);
+          // Calculate frequncies of test prescaler and resolution values
+          int f_temp_fast = F_CPU / (prescaler[i] * (1 + res_temp_fast));
+          int f_temp_phase_correct = F_CPU / (2 * prescaler[i] * res_temp_phase_correct);
+
+          // If FAST values are closest to desired f
+          if (ABS(f_temp_fast - f_desired) < ABS(f - f_desired)
+              && ABS(f_temp_fast - f_desired) <= ABS(f_temp_phase_correct - f_desired)) {
+            // Remember this combination
+            f = f_temp_fast;
+            res = res_temp_fast;
+            j = i;
+            // Set the Wave Generation Mode to FAST PWM
+            if(timer.n == 2){
+              wgm =
+                #if ENABLED(USE_OCR2A_AS_TOP)
+                  WGM2_FAST_PWM_OCR2A;
+                #else
+                  WGM2_FAST_PWM;
+                #endif
+            }
+            else wgm = WGM_FAST_PWM_ICRn;
+          }
+          // If PHASE CORRECT values are closes to desired f
+          else if (ABS(f_temp_phase_correct - f_desired) < ABS(f - f_desired)) {
+            f = f_temp_phase_correct;
+            res = res_temp_phase_correct;
+            j = i;
+            // Set the Wave Generation Mode to PWM PHASE CORRECT
+            if (timer.n == 2) {
+              wgm =
+                #if ENABLED(USE_OCR2A_AS_TOP)
+                  WGM2_PWM_PC_OCR2A;
+                #else
+                  WGM2_PWM_PC;
+                #endif
+            }
+            else wgm = WGM_PWM_PC_ICRn;
+          }
+        }
+      }
+      _SET_WGMnQ(timer.TCCRnQ, wgm);
+      _SET_CSn(timer.TCCRnQ, j);
+
+      if (timer.n == 2) {
+        #if ENABLED(USE_OCR2A_AS_TOP)
+          _SET_OCRnQ(timer.OCRnQ, 0, res);  // Set OCR2A value (TOP) = res
+        #endif
+      }
+      else {
+        _SET_ICRn(timer.ICRn, res);         // Set ICRn value (TOP) = res
+      }
+    #endif // ARDUINO && !ARDUINO_ARCH_SAM
+  }
+
+  void Temperature::set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size/*=255*/, const bool invert/*=false*/) {
+    #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
+      // If v is 0 or v_size (max), digitalWrite to LOW or HIGH.
+      // Note that digitalWrite also disables pwm output for us (sets COM bit to 0)
+      if (v == 0)
+        digitalWrite(pin, invert);
+      else if (v == v_size)
+        digitalWrite(pin, !invert);
+      else {
+        Temperature::Timer timer = get_pwm_timer(pin);
+        if (timer.n == 0) return; // Don't proceed if protected timer or not recognised
+        // Set compare output mode to CLEAR -> SET or SET -> CLEAR (if inverted)
+        _SET_COMnQ(timer.TCCRnQ, timer.q
+            #ifdef TCCR2
+              + (timer.q == 2) // COM20 is on bit 4 of TCCR2, thus requires q + 1 in the macro
+            #endif
+          , COM_CLEAR_SET + invert
+        );
+
+        uint16_t top;
+        if (timer.n == 2) { // if TIMER2
+          top =
+            #if ENABLED(USE_OCR2A_AS_TOP)
+              *timer.OCRnQ[0] // top = OCR2A
+            #else
+              255 // top = 0xFF (max)
+            #endif
+          ;
+        }
+        else
+          top = *timer.ICRn; // top = ICRn
+
+        _SET_OCRnQ(timer.OCRnQ, timer.q, v * float(top / v_size)); // Scale 8/16-bit v to top value
+      }
+    #endif // ARDUINO && !ARDUINO_ARCH_SAM
   }
 
 #endif // FAST_PWM_FAN
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */

commit 645ca7af7ac27af9d6690659dc71ff9867b34b6c
Author: 3dlabsio <shane@warnertci.com>
Date:   Thu Mar 7 00:09:39 2019 -0800

    M141 Heated Chamber, Temperature rework (#12201)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d697939ff3..b01ed04623 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -66,59 +66,52 @@
 
 #if ENABLED(SINGLENOZZLE)
   #include "tool_change.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
-    static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
-    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
+    static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE, (void*)HEATER_5_TEMPTABLE);
+    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN, HEATER_5_TEMPTABLE_LEN);
   #endif
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
+
 #if HAS_HEATED_BED
-  #define TEMP_ERR_PSTR(MSG, E) \
-    (E) == -1 ? PSTR(MSG ## _BED) : \
-    (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
-    (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
-    (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
-    (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
-    (HOTENDS > 5 && (E) == 5) ? PSTR(MSG_E6 " " MSG) : \
-    PSTR(MSG_E1 " " MSG)
+  #define _BED_PSTR(E) (E) == -1 ? PSTR(MSG ## _BED) :
+#else
+  #define _BED_PSTR(E)
+#endif
+#if HAS_HEATED_CHAMBER
+  #define _CHAMBER_PSTR(E) (E) == -2 ? PSTR(MSG ## _CHAMBER) :
 #else
-  #define TEMP_ERR_PSTR(MSG, E) \
-    (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
-    (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
-    (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
-    (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
-    (HOTENDS > 5 && (E) == 5) ? PSTR(MSG_E6 " " MSG) : \
-    PSTR(MSG_E1 " " MSG)
+  #define _CHAMBER_PSTR(E)
 #endif
+#define _E_PSTR(M,E,N) (HOTENDS >= (N) && (E) == (N)-1) ? PSTR(MSG_E##N " " M) :
+#define TEMP_ERR_PSTR(M,E) _BED_PSTR(E) _CHAMBER_PSTR(E) _E_PSTR(M,E,2) _E_PSTR(M,E,3) _E_PSTR(M,E,4) _E_PSTR(M,E,5) _E_PSTR(M,E,6) PSTR(MSG_E1 " " M)
 
 // public:
 
 #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
 
-float Temperature::current_temperature[HOTENDS]; // = { 0.0 };
-int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
-        Temperature::target_temperature[HOTENDS]; // = { 0 }
+hotend_info_t Temperature::temp_hotend[HOTENDS]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if FAN_COUNT > 0
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
@@ -181,149 +174,146 @@ int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
       lcd_tmpfan_speed[target] = speed;
     #endif
   }
 
   #if ENABLED(PROBING_FANS_OFF)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)
-          for (uint8_t x = 0; x < FAN_COUNT; x++) {
-            paused_fan_speed[x] = fan_speed[x];
-            fan_speed[x] = 0;
-          }
+          FANS_LOOP(x) { paused_fan_speed[x] = fan_speed[x]; fan_speed[x] = 0; }
         else
-          for (uint8_t x = 0; x < FAN_COUNT; x++)
-            fan_speed[x] = paused_fan_speed[x];
+          FANS_LOOP(x) fan_speed[x] = paused_fan_speed[x];
       }
     }
 
   #endif // PROBING_FANS_OFF
 
 #endif // FAN_COUNT > 0
 
+#if WATCH_HOTENDS
+  heater_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
+#endif
+#if HEATER_IDLE_HANDLER
+  heater_idle_t Temperature::hotend_idle[HOTENDS]; // = { { 0 } }
+#endif
+
 #if HAS_HEATED_BED
-  float Temperature::current_temperature_bed = 0.0;
-  int16_t Temperature::current_temperature_bed_raw = 0,
-          Temperature::target_temperature_bed = 0;
-  uint8_t Temperature::soft_pwm_amount_bed;
+  bed_info_t Temperature::temp_bed; // = { 0 }
+  // Init min and max temp with extreme values to prevent false errors during startup
   #ifdef BED_MINTEMP
-    int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
+    int16_t Temperature::mintemp_raw_BED = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
-    int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
+    int16_t Temperature::maxtemp_raw_BED = HEATER_BED_RAW_HI_TEMP;
   #endif
-  #if WATCH_THE_BED
-    uint16_t Temperature::watch_target_bed_temp = 0;
-    millis_t Temperature::watch_bed_next_ms = 0;
+  #if WATCH_BED
+    heater_watch_t Temperature::watch_bed; // = { 0 }
   #endif
-  #if ENABLED(PIDTEMPBED)
-    PID_t Temperature::bed_pid; // Initialized by settings.load()
-  #else
+  #if DISABLED(PIDTEMPBED)
     millis_t Temperature::next_bed_check_ms;
   #endif
-  uint16_t Temperature::raw_temp_bed_value = 0;
   #if HEATER_IDLE_HANDLER
-    millis_t Temperature::bed_idle_timeout_ms = 0;
-    bool Temperature::bed_idle_timeout_exceeded = false;
+    heater_idle_t Temperature::bed_idle; // = { 0 }
   #endif
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
-  float Temperature::current_temperature_chamber = 0.0;
-  int16_t Temperature::current_temperature_chamber_raw = 0;
-  uint16_t Temperature::raw_temp_chamber_value = 0;
-#endif
+  #if HAS_HEATED_CHAMBER
+    #ifdef CHAMBER_MINTEMP
+      int16_t Temperature::mintemp_raw_CHAMBER = HEATER_CHAMBER_RAW_LO_TEMP;
+    #endif
+    #ifdef CHAMBER_MAXTEMP
+      int16_t Temperature::maxtemp_raw_CHAMBER = HEATER_CHAMBER_RAW_HI_TEMP;
+    #endif
+    chamber_info_t temp_chamber; // = { 0 }
+    #if WATCH_CHAMBER
+      heater_watch_t Temperature::watch_chamber = { 0 };
+      millis_t Temperature::next_chamber_check_ms;
+    #endif
+  #endif // HAS_HEATED_CHAMBER
+#endif // HAS_TEMP_CHAMBER
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
-  hotend_pid_t Temperature::pid[HOTENDS];
+  //hotend_pid_t Temperature::pid[HOTENDS];
 #endif
 
 #if ENABLED(BABYSTEPPING)
   volatile int16_t Temperature::babystepsTodo[XYZ] = { 0 };
 #endif
 
-#if WATCH_HOTENDS
-  uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
-  millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
-#endif
-
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   uint16_t Temperature::redundant_temperature_raw = 0;
   float Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::temp_meas_ready = false;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
-  long Temperature::last_e_position;
-  long Temperature::lpq[LPQ_MAX_LEN];
-  int Temperature::lpq_ptr = 0;
+  int32_t Temperature::last_e_position, Temperature::lpq[LPQ_MAX_LEN];
+  lpq_ptr_t Temperature::lpq_ptr = 0;
 #endif
 
-uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 };
+#define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) < (HEATER_##N##_RAW_HI_TEMP) ? 1 : -1)
+
+// Init mintemp and maxtemp with extreme values to prevent false errors during startup
+constexpr temp_range_t sensor_heater_0 { HEATER_0_RAW_LO_TEMP, HEATER_0_RAW_HI_TEMP, 0, 16383 },
+                       sensor_heater_1 { HEATER_1_RAW_LO_TEMP, HEATER_1_RAW_HI_TEMP, 0, 16383 },
+                       sensor_heater_2 { HEATER_2_RAW_LO_TEMP, HEATER_2_RAW_HI_TEMP, 0, 16383 },
+                       sensor_heater_3 { HEATER_3_RAW_LO_TEMP, HEATER_3_RAW_HI_TEMP, 0, 16383 },
+                       sensor_heater_4 { HEATER_4_RAW_LO_TEMP, HEATER_4_RAW_HI_TEMP, 0, 16383 },
+                       sensor_heater_5 { HEATER_5_RAW_LO_TEMP, HEATER_5_RAW_HI_TEMP, 0, 16383 };
 
-// Init min and max temp with extreme values to prevent false errors during startup
-int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
-        Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
-        Temperature::minttemp[HOTENDS] = { 0 },
-        Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
+temp_range_t Temperature::temp_range[HOTENDS] = ARRAY_BY_HOTENDS(sensor_heater_0, sensor_heater_1, sensor_heater_2, sensor_heater_3, sensor_heater_4, sensor_heater_5);
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #ifdef MILLISECONDS_PREHEAT_TIME
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
 #endif
 
 #if HAS_AUTO_FAN
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
-uint8_t Temperature::soft_pwm_amount[HOTENDS];
-
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
-#if HEATER_IDLE_HANDLER
-  millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
-  bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
-#endif
-
 // public:
 
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
@@ -347,105 +337,105 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (heater < 0 ? (B) : (H))
-      #define SHV(S,B,H) do{ if (heater < 0) S##_bed = B; else S [heater] = H; }while(0)
+      #define SHV(B,H) do{ if (heater < 0) temp_bed.soft_pwm_amount = B; else temp_hotend[heater].soft_pwm_amount = H; }while(0)
       #define ONHEATINGSTART() (heater < 0 ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
       #define ONHEATING(S,C,T) do{ if (heater < 0) printerEventLEDs.onBedHeating(S,C,T); else printerEventLEDs.onHotendHeating(S,C,T); }while(0)
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
-      #define SHV(S,B,H) (S##_bed = B)
+      #define SHV(B,H) (temp_bed.soft_pwm_amount = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
-      #define SHV(S,B,H) (S [heater] = H)
+      #define SHV(B,H) (temp_hotend[heater].soft_pwm_amount = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
 
-    #if WATCH_THE_BED || WATCH_HOTENDS
+    #if WATCH_BED || WATCH_HOTENDS
       #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
       #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
         #define GTV(B,H) (heater < 0 ? (B) : (H))
       #elif HAS_TP_BED
         #define GTV(B,H) (B)
       #else
         #define GTV(B,H) (H)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
-    if (target > GHV(BED_MAXTEMP, maxttemp[heater]) - 15) {
+    if (target > GHV(BED_MAXTEMP, temp_range[heater].maxtemp) - 15) {
       SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
-    SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
+    SHV(bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = GHV(current_temperature_bed, current_temperature[heater]);
+      const float start_temp = GHV(temp_bed.current, temp_hotend[heater].current);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
       adaptive_fan_slowing = false;
     #endif
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current = GHV(current_temperature_bed, current_temperature[heater]);
+        current = GHV(temp_bed.current, temp_hotend[heater].current);
         NOLESS(max, current);
         NOMORE(min, current);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
         if (heating && current > target) {
           if (ELAPSED(ms, t2 + 5000UL)) {
             heating = false;
-            SHV(soft_pwm_amount, (bias - d) >> 1, (bias - d) >> 1);
+            SHV((bias - d) >> 1, (bias - d) >> 1);
             t1 = ms;
             t_high = t1 - t2;
             max = target;
           }
         }
 
         if (!heating && current < target) {
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
@@ -472,21 +462,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
                 tune_pid.Kd = tune_pid.Kp*Tu/3;
                 SERIAL_ECHOLNPGM(" Some overshoot");
                 SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
                 tune_pid.Kp = 0.2*Ku;
                 tune_pid.Ki = 2*tune_pid.Kp/Tu;
                 tune_pid.Kd = tune_pid.Kp*Tu/3;
                 SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd);
                 */
               }
             }
-            SHV(soft_pwm_amount, (bias + d) >> 1, (bias + d) >> 1);
+            SHV((bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             min = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
@@ -497,23 +487,23 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater >= 0 ? heater : active_extruder);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
-        #if WATCH_THE_BED || WATCH_HOTENDS
+        #if WATCH_BED || WATCH_HOTENDS
           if (
-            #if WATCH_THE_BED && WATCH_HOTENDS
+            #if WATCH_BED && WATCH_HOTENDS
               true
             #elif WATCH_HOTENDS
               heater >= 0
             #else
               heater < 0
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
@@ -550,23 +540,23 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
           say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #else
           say_default_(); SERIAL_ECHOLNPAIR("bedKp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("bedKi ", tune_pid.Ki);
           say_default_(); SERIAL_ECHOLNPAIR("bedKd ", tune_pid.Kd);
         #endif
 
         #define _SET_BED_PID() do { \
-          bed_pid.Kp = tune_pid.Kp; \
-          bed_pid.Ki = scalePID_i(tune_pid.Ki); \
-          bed_pid.Kd = scalePID_d(tune_pid.Kd); \
+          temp_bed.pid.Kp = tune_pid.Kp; \
+          temp_bed.pid.Ki = scalePID_i(tune_pid.Ki); \
+          temp_bed.pid.Kd = scalePID_d(tune_pid.Kd); \
         }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
           PID_PARAM(Kp, heater) = tune_pid.Kp; \
           PID_PARAM(Ki, heater) = scalePID_i(tune_pid.Ki); \
           PID_PARAM(Kd, heater) = scalePID_d(tune_pid.Kd); \
           updatePID(); }while(0)
 
         // Use the result? (As with "M303 U1")
         if (set_result) {
@@ -605,48 +595,48 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
 int Temperature::getHeaterPower(const int heater) {
   return (
     #if HAS_HEATED_BED
-      heater < 0 ? soft_pwm_amount_bed :
+      heater < 0 ? temp_bed.soft_pwm_amount :
     #endif
-    soft_pwm_amount[heater]
+    temp_hotend[heater].soft_pwm_amount
   );
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
       AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 :               4,
       AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
       #if HAS_TEMP_CHAMBER
         , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
       #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
-      if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
+      if (temp_hotend[e].current > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
-      if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
+      if (temp_chambercurrent > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[6]));
     #endif
 
     #define _UPDATE_AUTO_FAN(P,D,A) do{           \
       if (USEABLE_HARDWARE_PWM(P##_AUTO_FAN_PIN)) \
         analogWrite(P##_AUTO_FAN_PIN, A);         \
       else                                        \
         WRITE(P##_AUTO_FAN_PIN, D);               \
     }while(0)
 
@@ -691,21 +681,26 @@ int Temperature::getHeaterPower(const int heater) {
 
 //
 // Temperature Error Handlers
 //
 void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;
   if (IsRunning()) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ECHOPGM(MSG_STOPPED_HEATER);
-    if (heater >= 0) SERIAL_ECHOLN((int)heater); else SERIAL_ECHOLNPGM(MSG_HEATER_BED);
+    if (heater >= 0) SERIAL_ECHO((int)heater);
+    #if HAS_HEATED_CHAMBER
+      else if (heater == -2) SERIAL_ECHOPGM(MSG_HEATER_CHAMBER);
+    #endif
+    else SERIAL_ECHOPGM(MSG_HEATER_BED);
+    SERIAL_EOL();
   }
   #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
     if (!killed) {
       Running = false;
       killed = true;
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #endif
@@ -714,40 +709,40 @@ void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P
 void Temperature::max_temp_error(const int8_t heater) {
   _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
 void Temperature::min_temp_error(const int8_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }
 
 float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
-    UNUSED(e);
     #define _HOTEND_TEST true
   #else
     #define _HOTEND_TEST (e == active_extruder)
   #endif
+  E_UNUSED();
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       static hotend_pid_t work_pid[HOTENDS];
       static float temp_iState[HOTENDS] = { 0 },
                    temp_dState[HOTENDS] = { 0 };
       static bool pid_reset[HOTENDS] = { false };
-      float pid_error = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
-      work_pid[HOTEND_INDEX].Kd = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + float(PID_K1) * work_pid[HOTEND_INDEX].Kd;
-      temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
+      float pid_error = temp_hotend[HOTEND_INDEX].target - temp_hotend[HOTEND_INDEX].current;
+      work_pid[HOTEND_INDEX].Kd = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (temp_hotend[HOTEND_INDEX].current - temp_dState[HOTEND_INDEX]) + float(PID_K1) * work_pid[HOTEND_INDEX].Kd;
+      temp_dState[HOTEND_INDEX] = temp_hotend[HOTEND_INDEX].current;
 
-      if (target_temperature[HOTEND_INDEX] == 0
+      if (temp_hotend[HOTEND_INDEX].target == 0
         || pid_error < -(PID_FUNCTIONAL_RANGE)
         #if HEATER_IDLE_HANDLER
-          || heater_idle_timeout_exceeded[HOTEND_INDEX]
+          || hotend_idle[HOTEND_INDEX].timed_out
         #endif
       ) {
         pid_output = 0;
         pid_reset[HOTEND_INDEX] = true;
       }
       else if (pid_error > PID_FUNCTIONAL_RANGE) {
         pid_output = BANG_MAX;
         pid_reset[HOTEND_INDEX] = true;
       }
       else {
@@ -783,94 +778,94 @@ float Temperature::get_pid_output(const int8_t e) {
           pid_output = PID_MAX;
         }
         else if (pid_output < 0) {
           if (pid_error < 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
           pid_output = 0;
         }
       }
 
     #else // PID_OPENLOOP
 
-      const float pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
+      const float pid_output = constrain(temp_hotend[HOTEND_INDEX].target, 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOPAIR(
         MSG_PID_DEBUG, HOTEND_INDEX,
-        MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX],
+        MSG_PID_DEBUG_INPUT, temp_hotend[HOTEND_INDEX].current,
         MSG_PID_DEBUG_OUTPUT, pid_output
       );
       #if DISABLED(PID_OPENLOOP)
         SERIAL_ECHOPAIR(
           MSG_PID_DEBUG_PTERM, work_pid[HOTEND_INDEX].Kp,
           MSG_PID_DEBUG_ITERM, work_pid[HOTEND_INDEX].Ki,
           MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd
           #if ENABLED(PID_EXTRUSION_SCALING),
             MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc
           #endif
         );
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
   #else /* PID off */
     #if HEATER_IDLE_HANDLER
-      #define _TIMED_OUT_TEST heater_idle_timeout_exceeded[HOTEND_INDEX]
+      #define _TIMED_OUT_TEST hotend_idle[HOTEND_INDEX].timed_out
     #else
       #define _TIMED_OUT_TEST false
     #endif
-    pid_output = (!_TIMED_OUT_TEST && current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? BANG_MAX : 0;
+    pid_output = (!_TIMED_OUT_TEST && temp_hotend[HOTEND_INDEX].current < temp_hotend[HOTEND_INDEX].target) ? BANG_MAX : 0;
     #undef _TIMED_OUT_TEST
   #endif
 
   return pid_output;
 }
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)
 
       static PID_t work_pid = { 0 };
       static float temp_iState = 0, temp_dState = 0;
 
-      float pid_error = target_temperature_bed - current_temperature_bed;
+      float pid_error = temp_bed.target - temp_bed.current;
       temp_iState += pid_error;
-      work_pid.Kp = bed_pid.Kp * pid_error;
-      work_pid.Ki = bed_pid.Ki * temp_iState;
-      work_pid.Kd = PID_K2 * bed_pid.Kd * (current_temperature_bed - temp_dState) + PID_K1 * work_pid.Kd;
+      work_pid.Kp = temp_bed.pid.Kp * pid_error;
+      work_pid.Ki = temp_bed.pid.Ki * temp_iState;
+      work_pid.Kd = PID_K2 * temp_bed.pid.Kd * (temp_bed.current - temp_dState) + PID_K1 * work_pid.Kd;
 
-      temp_dState = current_temperature_bed;
+      temp_dState = temp_bed.current;
 
       float pid_output = work_pid.Kp + work_pid.Ki - work_pid.Kd;
       if (pid_output > MAX_BED_POWER) {
         if (pid_error > 0) temp_iState -= pid_error; // conditional un-integration
         pid_output = MAX_BED_POWER;
       }
       else if (pid_output < 0) {
         if (pid_error < 0) temp_iState -= pid_error; // conditional un-integration
         pid_output = 0;
       }
 
     #else // PID_OPENLOOP
 
-      const float pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
+      const float pid_output = constrain(temp_bed.target, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPAIR(
-        " PID_BED_DEBUG : Input ", current_temperature_bed, " Output ", pid_output,
+        " PID_BED_DEBUG : Input ", temp_bed.current, " Output ", pid_output,
         #if DISABLED(PID_OPENLOOP)
           MSG_PID_DEBUG_PTERM, work_pid.Kp,
           MSG_PID_DEBUG_ITERM, work_pid.Ki,
           MSG_PID_DEBUG_DTERM, work_pid.Kd,
         #endif
       );
     #endif
 
     return pid_output;
   }
@@ -902,60 +897,59 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (current_temperature[0] > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(0);
-    if (current_temperature[0] < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(0);
+    if (temp_hotend[0].current > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(0);
+    if (temp_hotend[0].current < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
-    if (current_temperature[1] > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
-    if (current_temperature[1] < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
+    if (temp_hotend[1].current > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
+    if (temp_hotend[1].current < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
   #endif
 
-  #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
+  #if WATCH_HOTENDS || WATCH_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER || WATCH_CHAMBER
     millis_t ms = millis();
   #endif
 
   HOTEND_LOOP() {
 
     #if HEATER_IDLE_HANDLER
-      if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
-        heater_idle_timeout_exceeded[e] = true;
+      hotend_idle[e].update(ms);
     #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
       // Check for thermal runaway
-      thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+      thermal_runaway_protection(tr_state_machine[e], temp_hotend[e].current, temp_hotend[e].target, e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
-    soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
+    temp_hotend[e].soft_pwm_amount = (temp_hotend[e].current > temp_range[e].mintemp || is_preheating(e)) && temp_hotend[e].current < temp_range[e].maxtemp ? (int)get_pid_output(e) >> 1 : 0;
 
     #if WATCH_HOTENDS
       // Make sure temperature is increasing
-      if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
-        if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
+      if (watch_hotend[e].next_ms && ELAPSED(ms, watch_hotend[e].next_ms)) { // Time to check this extruder?
+        if (degHotend(e) < watch_hotend[e].target)                             // Failed to increase enough?
           _temp_error(e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
         else                                                                 // Start again if the target is still far off
           start_watching_heater(e);
       }
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       // Make sure measured temperatures are close together
-      if (ABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
+      if (ABS(temp_hotend[0].current - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
         _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
     #endif
 
   } // HOTEND_LOOP
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
@@ -969,82 +963,128 @@ void Temperature::manage_heater() {
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if HAS_HEATED_BED
 
-    #if WATCH_THE_BED
+    #if WATCH_BED
       // Make sure temperature is increasing
-      if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
-        if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
+      if (watch_bed.elapsed(ms)) {        // Time to check the bed?
+        if (degBed() < watch_bed.target)                                // Failed to increase enough?
           _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
         else                                                            // Start again if the target is still far off
           start_watching_bed();
       }
-    #endif // WATCH_THE_BED
+    #endif // WATCH_BED
 
     #if DISABLED(PIDTEMPBED)
       if (PENDING(ms, next_bed_check_ms)
         #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
           && paused == last_pause_state
         #endif
       ) return;
       next_bed_check_ms = ms + BED_CHECK_INTERVAL;
       #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
         last_pause_state = paused;
       #endif
     #endif
 
     #if HEATER_IDLE_HANDLER
-      if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
-        bed_idle_timeout_exceeded = true;
+      bed_idle.update(ms);
     #endif
 
     #if HAS_THERMALLY_PROTECTED_BED
-      thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
+      thermal_runaway_protection(tr_state_machine_bed, temp_bed.current, temp_bed.target, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
     #endif
 
     #if HEATER_IDLE_HANDLER
-      if (bed_idle_timeout_exceeded) {
-        soft_pwm_amount_bed = 0;
+      if (bed_idle.timed_out) {
+        temp_bed.soft_pwm_amount = 0;
         #if DISABLED(PIDTEMPBED)
           WRITE_HEATER_BED(LOW);
         #endif
       }
       else
     #endif
     {
       #if ENABLED(PIDTEMPBED)
-        soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
+        temp_bed.soft_pwm_amount = WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
       #else
         // Check if temperature is within the correct band
-        if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
+        if (WITHIN(temp_bed.current, BED_MINTEMP, BED_MAXTEMP)) {
           #if ENABLED(BED_LIMIT_SWITCHING)
-            if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
-              soft_pwm_amount_bed = 0;
-            else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
-              soft_pwm_amount_bed = MAX_BED_POWER >> 1;
+            if (temp_bed.current >= temp_bed.target + BED_HYSTERESIS)
+              temp_bed.soft_pwm_amount = 0;
+            else if (temp_bed.current <= temp_bed.target - (BED_HYSTERESIS))
+              temp_bed.soft_pwm_amount = MAX_BED_POWER >> 1;
           #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
-            soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
+            temp_bed.soft_pwm_amount = temp_bed.current < temp_bed.target ? MAX_BED_POWER >> 1 : 0;
           #endif
         }
         else {
-          soft_pwm_amount_bed = 0;
+          temp_bed.soft_pwm_amount = 0;
           WRITE_HEATER_BED(LOW);
         }
       #endif
     }
   #endif // HAS_HEATED_BED
+
+  #if HAS_TEMP_CHAMBER
+
+    #ifndef CHAMBER_CHECK_INTERVAL
+      #define CHAMBER_CHECK_INTERVAL 1000UL
+    #endif
+
+    #if HAS_HEATED_CHAMBER
+
+      #if WATCH_CHAMBER
+        // Make sure temperature is increasing
+        if (watch_chamber.elapsed(ms)) {                  // Time to check the chamber?
+          if (degChamber() < watch_chamber.target)   // Failed to increase enough?
+            _temp_error(-2, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -2));
+          else
+            start_watching_chamber();                     // Start again if the target is still far off
+        }
+      #endif // WATCH_CHAMBER
+
+      if (PENDING(ms, next_chamber_check_ms)) return;
+      next_chamber_check_ms = ms + CHAMBER_CHECK_INTERVAL;
+
+      if (WITHIN(temp_chambercurrent, CHAMBER_MINTEMP, CHAMBER_MAXTEMP)) {
+        #if ENABLED(CHAMBER_LIMIT_SWITCHING)
+          if (temp_chambercurrent >= temp_chamber.target + CHAMBER_HYSTERESIS)
+            temp_chamber.soft_pwm_amount = 0;
+          else if (temp_chambercurrent <= temp_chamber.target - (CHAMBER_HYSTERESIS))
+            temp_chamber.soft_pwm_amount = MAX_CHAMBER_POWER >> 1;
+        #else // !PIDTEMPCHAMBER && !CHAMBER_LIMIT_SWITCHING
+          temp_chamber.soft_pwm_amount = temp_chambercurrent < temp_chamber.target ? MAX_CHAMBER_POWER >> 1 : 0;
+        #endif
+      }
+      else {
+        temp_chamber.soft_pwm_amount = 0;
+        WRITE_HEATER_CHAMBER(LOW);
+      }
+
+      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+        thermal_runaway_protection(tr_state_machine_chamber, temp_chambercurrent, temp_chamber.target, -2, THERMAL_PROTECTION_CHAMBER_PERIOD, THERMAL_PROTECTION_CHAMBER_HYSTERESIS);
+      #endif
+
+      // TODO: Implement true PID pwm
+      //temp_bed.soft_pwm_amount = WITHIN(temp_chambercurrent, CHAMBER_MINTEMP, CHAMBER_MAXTEMP) ? (int)get_pid_output_chamber() >> 1 : 0;
+
+    #endif // HAS_HEATED_CHAMBER
+
+  #endif // HAS_TEMP_CHAMBER
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
 /**
  * Bisect search for the range of the 'raw' value, then interpolate
  * proportionally between the under and over values.
  */
 #define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
@@ -1118,20 +1158,28 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
         break;
       #endif
     case 4:
       #if ENABLED(HEATER_4_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_4_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
+    case 5:
+      #if ENABLED(HEATER_5_USES_AD595)
+        return TEMP_AD595(raw);
+      #elif ENABLED(HEATER_5_USES_AD8495)
+        return TEMP_AD8495(raw);
+      #else
+        break;
+      #endif
     default: break;
   }
 
   #if HOTEND_USES_THERMISTOR
     // Thermistor with conversion table?
     const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
     SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
   #endif
 
   return 0;
@@ -1149,52 +1197,52 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
-  float Temperature::analog_to_celsiusChamber(const int raw) {
+  float Temperature::analog_to_celsius_chamber(const int raw) {
     #if ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(CHAMBERTEMPTABLE, CHAMBERTEMPTABLE_LEN);
     #elif ENABLED(HEATER_CHAMBER_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
-    current_temperature_raw[0] = READ_MAX6675(0);
+    temp_hotend[0].raw = READ_MAX6675(0);
   #endif
   #if ENABLED(HEATER_1_USES_MAX6675)
-    current_temperature_raw[1] = READ_MAX6675(1);
+    temp_hotend[1].raw = READ_MAX6675(1);
   #endif
-  HOTEND_LOOP() current_temperature[e] = analog_to_celsius_hotend(current_temperature_raw[e], e);
+  HOTEND_LOOP() temp_hotend[e].current = analog_to_celsius_hotend(temp_hotend[e].raw, e);
   #if HAS_HEATED_BED
-    current_temperature_bed = analog_to_celsius_bed(current_temperature_bed_raw);
+    temp_bed.current = analog_to_celsius_bed(temp_bed.raw);
   #endif
   #if HAS_TEMP_CHAMBER
-    current_temperature_chamber = analog_to_celsiusChamber(current_temperature_chamber_raw);
+    temp_chambercurrent = analog_to_celsius_chamber(temp_chamber.raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog_to_mm_fil_width();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.
@@ -1237,54 +1285,57 @@ void Temperature::updateTemperaturesFromRawValues() {
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
-  #if MB(RUMBA) && ( \
-       ENABLED(HEATER_0_USES_AD595)  || ENABLED(HEATER_1_USES_AD595)  || ENABLED(HEATER_2_USES_AD595)  || ENABLED(HEATER_3_USES_AD595)  || ENABLED(HEATER_4_USES_AD595)  || ENABLED(HEATER_BED_USES_AD595)  || ENABLED(HEATER_CHAMBER_USES_AD595) \
-    || ENABLED(HEATER_0_USES_AD8495) || ENABLED(HEATER_1_USES_AD8495) || ENABLED(HEATER_2_USES_AD8495) || ENABLED(HEATER_3_USES_AD8495) || ENABLED(HEATER_4_USES_AD8495) || ENABLED(HEATER_BED_USES_AD8495) || ENABLED(HEATER_CHAMBER_USES_AD8495))
-    // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
-    MCUCR = _BV(JTD);
-    MCUCR = _BV(JTD);
+  #if MB(RUMBA)
+    #define _AD(N) (ENABLED(HEATER_##N##_USES_AD595) || ENABLED(HEATER_##N##_USES_AD8495))
+    #if _AD(0) || _AD(1) || _AD(2) || _AD(3) || _AD(4) || _AD(5) || _AD(BED) || _AD(CHAMBER)
+      // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
+      MCUCR = _BV(JTD);
+      MCUCR = _BV(JTD);
+    #endif
   #endif
 
-  // Finish init of mult hotend arrays
-  HOTEND_LOOP() maxttemp[e] = maxttemp[0];
-
   #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
     OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
   #endif
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
     OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
   #endif
   #if HAS_HEATER_3
     OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
     OUT_WRITE(HEATER_4_PIN, HEATER_4_INVERTING);
   #endif
+  #if HAS_HEATER_5
+    OUT_WRITE(HEATER_5_PIN, HEATER_5_INVERTING);
+  #endif
   #if HAS_HEATED_BED
     OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
   #endif
-
+  #if HAS_HEATED_CHAMBER
+    OUT_WRITE(HEATER_CHAMBER_PIN, HEATER_CHAMBER_INVERTING);
+  #endif
   #if HAS_FAN0
     SET_OUTPUT(FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
       setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
   #endif
 
   #if HAS_FAN1
     SET_OUTPUT(FAN1_PIN);
     #if ENABLED(FAST_PWM_FAN)
@@ -1423,105 +1474,100 @@ void Temperature::init() {
         setPwmFrequency(CHAMBER_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
     #endif
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
-  #define TEMP_MIN_ROUTINE(NR) \
-    minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
-    while (analog_to_celsius_hotend(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
-      if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
-        minttemp_raw[NR] += OVERSAMPLENR; \
-      else \
-        minttemp_raw[NR] -= OVERSAMPLENR; \
-    }
-  #define TEMP_MAX_ROUTINE(NR) \
-    maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
-    while (analog_to_celsius_hotend(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
-      if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
-        maxttemp_raw[NR] -= OVERSAMPLENR; \
-      else \
-        maxttemp_raw[NR] += OVERSAMPLENR; \
-    }
+  #if HOTENDS
 
-  #ifdef HEATER_0_MINTEMP
-    TEMP_MIN_ROUTINE(0);
-  #endif
-  #ifdef HEATER_0_MAXTEMP
-    TEMP_MAX_ROUTINE(0);
-  #endif
-  #if HOTENDS > 1
-    #ifdef HEATER_1_MINTEMP
-      TEMP_MIN_ROUTINE(1);
+    #define _TEMP_MIN_E(NR) do{ \
+      temp_range[NR].mintemp = HEATER_ ##NR## _MINTEMP; \
+      while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) < HEATER_ ##NR## _MINTEMP) \
+        temp_range[NR].raw_min += TEMPDIR(NR) * (OVERSAMPLENR); \
+    }while(0)
+    #define _TEMP_MAX_E(NR) do{ \
+      temp_range[NR].maxtemp = HEATER_ ##NR## _MAXTEMP; \
+      while (analog_to_celsius_hotend(temp_range[NR].raw_min, NR) > HEATER_ ##NR## _MAXTEMP) \
+        temp_range[NR].raw_max -= TEMPDIR(NR) * (OVERSAMPLENR); \
+    }while(0)
+
+    #ifdef HEATER_0_MINTEMP
+      _TEMP_MIN_E(0);
     #endif
-    #ifdef HEATER_1_MAXTEMP
-      TEMP_MAX_ROUTINE(1);
+    #ifdef HEATER_0_MAXTEMP
+      _TEMP_MAX_E(0);
     #endif
-    #if HOTENDS > 2
-      #ifdef HEATER_2_MINTEMP
-        TEMP_MIN_ROUTINE(2);
+    #if HOTENDS > 1
+      #ifdef HEATER_1_MINTEMP
+        _TEMP_MIN_E(1);
       #endif
-      #ifdef HEATER_2_MAXTEMP
-        TEMP_MAX_ROUTINE(2);
+      #ifdef HEATER_1_MAXTEMP
+        _TEMP_MAX_E(1);
       #endif
-      #if HOTENDS > 3
-        #ifdef HEATER_3_MINTEMP
-          TEMP_MIN_ROUTINE(3);
+      #if HOTENDS > 2
+        #ifdef HEATER_2_MINTEMP
+          _TEMP_MIN_E(2);
         #endif
-        #ifdef HEATER_3_MAXTEMP
-          TEMP_MAX_ROUTINE(3);
+        #ifdef HEATER_2_MAXTEMP
+          _TEMP_MAX_E(2);
         #endif
-        #if HOTENDS > 4
-          #ifdef HEATER_4_MINTEMP
-            TEMP_MIN_ROUTINE(4);
+        #if HOTENDS > 3
+          #ifdef HEATER_3_MINTEMP
+            _TEMP_MIN_E(3);
           #endif
-          #ifdef HEATER_4_MAXTEMP
-            TEMP_MAX_ROUTINE(4);
+          #ifdef HEATER_3_MAXTEMP
+            _TEMP_MAX_E(3);
           #endif
-          #if HOTENDS > 5
-            #ifdef HEATER_5_MINTEMP
-              TEMP_MIN_ROUTINE(5);
+          #if HOTENDS > 4
+            #ifdef HEATER_4_MINTEMP
+              _TEMP_MIN_E(4);
             #endif
-            #ifdef HEATER_5_MAXTEMP
-              TEMP_MAX_ROUTINE(5);
+            #ifdef HEATER_4_MAXTEMP
+              _TEMP_MAX_E(4);
             #endif
-          #endif // HOTENDS > 5
-        #endif // HOTENDS > 4
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
+            #if HOTENDS > 5
+              #ifdef HEATER_5_MINTEMP
+                _TEMP_MIN_E(5);
+              #endif
+              #ifdef HEATER_5_MAXTEMP
+                _TEMP_MAX_E(5);
+              #endif
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+
   #endif // HOTENDS > 1
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
-      while (analog_to_celsius_bed(bed_minttemp_raw) < BED_MINTEMP) {
-        #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
-          bed_minttemp_raw += OVERSAMPLENR;
-        #else
-          bed_minttemp_raw -= OVERSAMPLENR;
-        #endif
-      }
-    #endif // BED_MINTEMP
+      while (analog_to_celsius_bed(mintemp_raw_BED) < BED_MINTEMP) mintemp_raw_BED += TEMPDIR(BED) * (OVERSAMPLENR);
+    #endif
     #ifdef BED_MAXTEMP
-      while (analog_to_celsius_bed(bed_maxttemp_raw) > BED_MAXTEMP) {
-        #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
-          bed_maxttemp_raw -= OVERSAMPLENR;
-        #else
-          bed_maxttemp_raw += OVERSAMPLENR;
-        #endif
-      }
-    #endif // BED_MAXTEMP
+      while (analog_to_celsius_bed(maxtemp_raw_BED) > BED_MAXTEMP) mintemp_raw_BED -= TEMPDIR(BED) * (OVERSAMPLENR);
+    #endif
   #endif // HAS_HEATED_BED
 
+  #if HAS_HEATED_CHAMBER
+    #ifdef CHAMBER_MINTEMP
+      while (analog_to_celsius_chamber(mintemp_raw_CHAMBER) < CHAMBER_MINTEMP) mintemp_raw_CHAMBER += TEMPDIR(CHAMBER) * (OVERSAMPLENR);
+    #endif
+    #ifdef CHAMBER_MAXTEMP
+      while (analog_to_celsius_chamber(maxtemp_raw_CHAMBER) > CHAMBER_MAXTEMP) mintemp_raw_CHAMBER -= TEMPDIR(CHAMBER) * (OVERSAMPLENR);
+    #endif
+  #endif
+
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
 #if ENABLED(FAST_PWM_FAN)
 
   void Temperature::setPwmFrequency(const pin_t pin, int val) {
     #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
       val &= 0x07;
@@ -1561,106 +1607,121 @@ void Temperature::init() {
 
 #endif // FAST_PWM_FAN
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_heater(const uint8_t e) {
-    #if HOTENDS == 1
-      UNUSED(e);
-    #endif
+    E_UNUSED();
     if (degTargetHotend(HOTEND_INDEX) && degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
-      watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
-      watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
+      watch_hotend[HOTEND_INDEX].target = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
+      watch_hotend[HOTEND_INDEX].next_ms = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
     }
     else
-      watch_heater_next_ms[HOTEND_INDEX] = 0;
+      watch_hotend[HOTEND_INDEX].next_ms = 0;
   }
 #endif
 
-#if WATCH_THE_BED
+#if WATCH_BED
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M140, M190)
    */
   void Temperature::start_watching_bed() {
     if (degTargetBed() && degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
-      watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
-      watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
+      watch_bed.target = degBed() + WATCH_BED_TEMP_INCREASE;
+      watch_bed.next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
     }
     else
-      watch_bed_next_ms = 0;
+      watch_bed.next_ms = 0;
   }
 #endif
 
-#if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
+#if WATCH_CHAMBER
+  /**
+   * Start Heating Sanity Check for hotends that are below
+   * their target temperature by a configurable margin.
+   * This is called when the temperature is set. (M141, M191)
+   */
+  void Temperature::start_watching_chamber() {
+    if (degChamber() < degTargetChamber() - (WATCH_CHAMBER_TEMP_INCREASE + TEMP_CHAMBER_HYSTERESIS + 1)) {
+      watch_chamber.target = degChamber() + WATCH_CHAMBER_TEMP_INCREASE;
+      watch_chamber.next_ms = millis() + (WATCH_CHAMBER_TEMP_PERIOD) * 1000UL;
+    }
+    else
+      watch_chamber.next_ms = 0;
+  }
+#endif
+
+#if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
 
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-    Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
-    millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
+    Temperature::tr_state_machine_t Temperature::tr_state_machine[HOTENDS]; // = { { TRInactive, 0 } };
   #endif
-
   #if HAS_THERMALLY_PROTECTED_BED
-    Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
-    millis_t Temperature::thermal_runaway_bed_timer;
+    Temperature::tr_state_machine_t Temperature::tr_state_machine_bed; // = { TRInactive, 0 };
+  #endif
+  #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+    Temperature::tr_state_machine_t Temperature::tr_state_machine_chamber; // = { TRInactive, 0 };
   #endif
 
-  void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
+  void Temperature::thermal_runaway_protection(Temperature::tr_state_machine_t &sm, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
         SERIAL_ECHO_START();
         SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
+        if (heater_id == -2) SERIAL_ECHOPGM("chamber");
         if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
-        SERIAL_ECHOPAIR(" ;  State:", *state, " ;  Timer:", *timer, " ;  Temperature:", current, " ;  Target Temp:", target);
+        SERIAL_ECHOPAIR(" ;  State:", sm.state, " ;  Timer:", sm.timer, " ;  Temperature:", current, " ;  Target Temp:", target);
         if (heater_id >= 0)
-          SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
+          SERIAL_ECHOPAIR(" ;  Idle Timeout:", hotend_idle[heater_id].timed_out);
         else
-          SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
+          SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle.timed_out);
         SERIAL_EOL();
     */
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
-      if ((heater_id >= 0 && heater_idle_timeout_exceeded[heater_id])
+      if ((heater_id >= 0 && hotend_idle[heater_id].timed_out)
         #if HAS_HEATED_BED
-          || (heater_id < 0 && bed_idle_timeout_exceeded)
+          || (heater_id < 0 && bed_idle.timed_out)
         #endif
       ) {
-        *state = TRInactive;
+        sm.state = TRInactive;
         tr_target_temperature[heater_index] = 0;
       }
       else
     #endif
     {
       // If the target temperature changes, restart
       if (tr_target_temperature[heater_index] != target) {
         tr_target_temperature[heater_index] = target;
-        *state = target > 0 ? TRFirstHeating : TRInactive;
+        sm.state = target > 0 ? TRFirstHeating : TRInactive;
       }
     }
 
-    switch (*state) {
+    switch (sm.state) {
       // Inactive state waits for a target temperature to be set
       case TRInactive: break;
 
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < tr_target_temperature[heater_index]) break;
-        *state = TRStable;
+        sm.state = TRStable;
 
       // While the temperature is stable watch for a bad temperature
       case TRStable:
 
         #if ENABLED(ADAPTIVE_FAN_SLOWING)
           if (adaptive_fan_slowing && heater_id >= 0) {
             const int fan_index = MIN(heater_id, FAN_COUNT - 1);
             if (fan_speed[fan_index] == 0 || current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.25f))
               fan_speed_scaler[fan_index] = 128;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.3335f))
@@ -1668,53 +1729,57 @@ void Temperature::init() {
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.5f))
               fan_speed_scaler[fan_index] = 64;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else
               fan_speed_scaler[fan_index] = 0;
           }
         #endif
 
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
-          *timer = millis() + period_seconds * 1000UL;
+          sm.timer = millis() + period_seconds * 1000UL;
           break;
         }
-        else if (PENDING(millis(), *timer)) break;
-        *state = TRRunaway;
+        else if (PENDING(millis(), sm.timer)) break;
+        sm.state = TRRunaway;
 
       case TRRunaway:
         _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater_id));
     }
   }
 
-#endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
+#endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif
 
   HOTEND_LOOP() setTargetHotend(0, e);
 
   #if HAS_HEATED_BED
     setTargetBed(0);
   #endif
 
+  #if HAS_HEATED_CHAMBER
+    setTargetChamber(0);
+  #endif
+
   // Unpause and reset everything
   #if ENABLED(PROBING_HEATERS_OFF)
     pause(false);
   #endif
 
   #define DISABLE_HEATER(NR) { \
     setTargetHotend(0, NR); \
-    soft_pwm_amount[NR] = 0; \
+    temp_hotend[NR].soft_pwm_amount = 0; \
     WRITE_HEATER_ ##NR (LOW); \
   }
 
   #if HAS_TEMP_HOTEND
     DISABLE_HEATER(0);
     #if HOTENDS > 1
       DISABLE_HEATER(1);
       #if HOTENDS > 2
         DISABLE_HEATER(2);
         #if HOTENDS > 3
@@ -1724,37 +1789,45 @@ void Temperature::disable_all_heaters() {
             #if HOTENDS > 5
               DISABLE_HEATER(5);
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   #endif
 
   #if HAS_HEATED_BED
-    target_temperature_bed = 0;
-    soft_pwm_amount_bed = 0;
+    temp_bed.target = 0;
+    temp_bed.soft_pwm_amount = 0;
     #if HAS_HEATED_BED
       WRITE_HEATER_BED(LOW);
     #endif
   #endif
+
+  #if HAS_TEMP_CHAMBER
+    temp_chamber.target = 0;
+    temp_chamber.soft_pwm_amount = 0;
+    #if HAS_HEATED_CHAMBER
+      WRITE_HEATER_CHAMBER(LOW);
+    #endif
+  #endif
 }
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
-        HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
+        HOTEND_LOOP() hotend_idle[e].expire(); // timeout immediately
         #if HAS_HEATED_BED
-          start_bed_idle_timer(0); // timeout immediately
+          bed_idle.expire(); // timeout immediately
         #endif
       }
       else {
         HOTEND_LOOP() reset_heater_idle_timer(e);
         #if HAS_HEATED_BED
           reset_bed_idle_timer();
         #endif
       }
     }
   }
@@ -1879,80 +1952,77 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // HAS_MAX6675
 
 /**
  * Get raw temperatures
  */
 void Temperature::set_current_temp_raw() {
 
   #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
-    current_temperature_raw[0] = raw_temp_value[0];
+    temp_hotend[0].raw = temp_hotend[0].acc;
   #endif
 
   #if HAS_TEMP_ADC_1
-
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      redundant_temperature_raw = raw_temp_value[1];
+      redundant_temperature_raw = temp_hotend[1].acc;
     #elif DISABLED(HEATER_1_USES_MAX6675)
-      current_temperature_raw[1] = raw_temp_value[1];
+      temp_hotend[1].raw = temp_hotend[1].acc;
     #endif
-
     #if HAS_TEMP_ADC_2
-      current_temperature_raw[2] = raw_temp_value[2];
+      temp_hotend[2].raw = temp_hotend[2].acc;
       #if HAS_TEMP_ADC_3
-        current_temperature_raw[3] = raw_temp_value[3];
+        temp_hotend[3].raw = temp_hotend[3].acc;
         #if HAS_TEMP_ADC_4
-          current_temperature_raw[4] = raw_temp_value[4];
+          temp_hotend[4].raw = temp_hotend[4].acc;
           #if HAS_TEMP_ADC_5
-            current_temperature_raw[5] = raw_temp_value[5];
+            temp_hotend[5].raw = temp_hotend[5].acc;
           #endif // HAS_TEMP_ADC_5
         #endif // HAS_TEMP_ADC_4
       #endif // HAS_TEMP_ADC_3
     #endif // HAS_TEMP_ADC_2
-
   #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
-    current_temperature_bed_raw = raw_temp_bed_value;
+    temp_bed.raw = temp_bed.acc;
   #endif
+
   #if HAS_TEMP_CHAMBER
-    current_temperature_chamber_raw = raw_temp_chamber_value;
+    temp_chamber.raw = temp_chamber.acc;
   #endif
+
   temp_meas_ready = true;
 }
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint32_t raw_filwidth_value; // = 0
 #endif
 
 void Temperature::readings_ready() {
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
-  ZERO(raw_temp_value);
+  HOTEND_LOOP() temp_hotend[e].acc = 0;
 
   #if HAS_HEATED_BED
-    raw_temp_bed_value = 0;
+    temp_bed.acc = 0;
   #endif
 
   #if HAS_TEMP_CHAMBER
-    raw_temp_chamber_value = 0;
+    temp_chamber.acc = 0;
   #endif
 
-  #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
-
   int constexpr temp_dir[] = {
     #if ENABLED(HEATER_0_USES_MAX6675)
        0
     #else
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
       , TEMPDIR(1)
       #if HOTENDS > 2
         , TEMPDIR(2)
@@ -1963,52 +2033,63 @@ void Temperature::readings_ready() {
             #if HOTENDS > 5
               , TEMPDIR(5)
             #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   };
 
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
-    const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
-    const bool heater_on = (target_temperature[e] > 0)
+    const int16_t tdir = temp_dir[e], rawtemp = temp_hotend[e].raw * tdir;
+    const bool heater_on = (temp_hotend[e].target > 0)
       #if ENABLED(PIDTEMP)
-        || (soft_pwm_amount[e] > 0)
+        || (temp_hotend[e].soft_pwm_amount > 0)
       #endif
     ;
-    if (rawtemp > maxttemp_raw[e] * tdir) max_temp_error(e);
-    if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
+    if (rawtemp > temp_range[e].raw_max * tdir) max_temp_error(e);
+    if (heater_on && rawtemp < temp_range[e].raw_min * tdir && !is_preheating(e)) {
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
       #endif
           min_temp_error(e);
     }
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       else
         consecutive_low_temperature_error[e] = 0;
     #endif
   }
 
   #if HAS_HEATED_BED
-    #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
+    #if TEMPDIR(BED) < 0
       #define BEDCMP(A,B) ((A)<=(B))
     #else
       #define BEDCMP(A,B) ((A)>=(B))
     #endif
-    const bool bed_on = (target_temperature_bed > 0)
+    const bool bed_on = (temp_bed.target > 0)
       #if ENABLED(PIDTEMPBED)
-        || (soft_pwm_amount_bed > 0)
+        || (temp_bed.soft_pwm_amount > 0)
       #endif
     ;
-    if (BEDCMP(current_temperature_bed_raw, bed_maxttemp_raw)) max_temp_error(-1);
-    if (BEDCMP(bed_minttemp_raw, current_temperature_bed_raw) && bed_on) min_temp_error(-1);
+    if (BEDCMP(temp_bed.raw, maxtemp_raw_BED)) max_temp_error(-1);
+    if (bed_on && BEDCMP(mintemp_raw_BED, temp_bed.raw)) min_temp_error(-1);
+  #endif
+
+  #if HAS_TEMP_CHAMBER
+    #if TEMPDIR(BED) < 0
+      #define CHAMBERCMP(A,B) ((A)<=(B))
+    #else
+      #define CHAMBERCMP(A,B) ((A)>=(B))
+    #endif
+    const bool chamber_on = (temp_chamber.target > 0) || (temp_chamber.soft_pwm_amount > 0);
+    if (CHAMBERCMP(temp_chamber.raw, maxtemp_raw_CHAMBER)) max_temp_error(-2);
+    if (chamber_on && CHAMBERCMP(mintemp_raw_CHAMBER, temp_chamber.raw)) min_temp_error(-2);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
@@ -2021,141 +2102,159 @@ void Temperature::readings_ready() {
  *  - Call planner.tick to count down its "ignore" time
  */
 HAL_TEMP_TIMER_ISR {
   HAL_timer_isr_prologue(TEMP_TIMER_NUM);
 
   Temperature::isr();
 
   HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
 }
 
+#if ENABLED(SLOW_PWM_HEATERS) && !defined(MIN_STATE_TIME)
+  #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
+#endif
+
+class SoftPWM {
+public:
+  uint8_t count;
+  inline bool add(const uint8_t mask, const uint8_t amount) {
+    count = (count & mask) + amount; return (count > mask);
+  }
+  #if ENABLED(SLOW_PWM_HEATERS)
+    bool state_heater;
+    uint8_t state_timer_heater;
+    inline void dec() { if (state_timer_heater > 0) state_timer_heater--; }
+    inline bool ready(const bool v) {
+      const bool rdy = !state_timer_heater;
+      if (rdy && state_heater != v) {
+        state_heater = v;
+        state_timer_heater = MIN_STATE_TIME;
+      }
+      return rdy;
+    }
+  #endif
+};
+
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
   #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
   #endif
 
-  // Static members for each heater
   #if ENABLED(SLOW_PWM_HEATERS)
     static uint8_t slow_pwm_count = 0;
-    #define ISR_STATICS(n) \
-      static uint8_t soft_pwm_count_ ## n, \
-                     state_heater_ ## n = 0, \
-                     state_timer_heater_ ## n = 0
-  #else
-    #define ISR_STATICS(n) static uint8_t soft_pwm_count_ ## n = 0
-  #endif
-
-  // Statics per heater
-  ISR_STATICS(0);
-  #if HOTENDS > 1
-    ISR_STATICS(1);
-    #if HOTENDS > 2
-      ISR_STATICS(2);
-      #if HOTENDS > 3
-        ISR_STATICS(3);
-        #if HOTENDS > 4
-          ISR_STATICS(4);
-          #if HOTENDS > 5
-            ISR_STATICS(5);
-          #endif // HOTENDS > 5
-        #endif // HOTENDS > 4
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
-  #endif // HOTENDS > 1
+  #endif
+
+  static SoftPWM soft_pwm_hotend[HOTENDS];
+
   #if HAS_HEATED_BED
-    ISR_STATICS(BED);
+    static SoftPWM soft_pwm_bed;
+  #endif
+
+  #if HAS_HEATED_CHAMBER
+    static SoftPWM soft_pwm_chamber;
   #endif
 
   #if DISABLED(SLOW_PWM_HEATERS)
     constexpr uint8_t pwm_mask =
       #if ENABLED(SOFT_PWM_DITHER)
         _BV(SOFT_PWM_SCALE) - 1
       #else
         0
       #endif
     ;
 
     /**
      * Standard heater PWM modulation
      */
     if (pwm_count_tmp >= 127) {
       pwm_count_tmp -= 127;
-      soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
-      WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
+      #define _PWM_MOD(N,S,T) do{                           \
+        const bool on = S.add(pwm_mask, T.soft_pwm_amount); \
+        WRITE_HEATER_##N(on);                               \
+      }while(0)
+      #define _PWM_MOD_E(N) _PWM_MOD(N,soft_pwm_hotend[N],temp_hotend[N])
+      _PWM_MOD_E(0);
       #if HOTENDS > 1
-        soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
-        WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
+        _PWM_MOD_E(1);
         #if HOTENDS > 2
-          soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
-          WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
+          _PWM_MOD_E(2);
           #if HOTENDS > 3
-            soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
-            WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
+            _PWM_MOD_E(3);
             #if HOTENDS > 4
-              soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
-              WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
+              _PWM_MOD_E(4);
               #if HOTENDS > 5
-                soft_pwm_count_5 = (soft_pwm_count_5 & pwm_mask) + soft_pwm_amount[5];
-                WRITE_HEATER_5(soft_pwm_count_5 > pwm_mask ? HIGH : LOW);
+                _PWM_MOD_E(5);
               #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
       #if HAS_HEATED_BED
-        soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
-        WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
+        _PWM_MOD(BED,soft_pwm_bed,temp_bed);
+      #endif
+
+      #if HAS_HEATED_CHAMBER
+        _PWM_MOD(CHAMBER,soft_pwm_chamber,temp_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
+        #define _FAN_PWM(N) do{ \
+          soft_pwm_count_fan[N] = (soft_pwm_count_fan[N] & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
+          WRITE_FAN(soft_pwm_count_fan[N] > pwm_mask ? HIGH : LOW); \
+        }while(0)
         #if HAS_FAN0
-          soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
-          WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
+          _FAN_PWM(0);
         #endif
         #if HAS_FAN1
-          soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + (soft_pwm_amount_fan[1] >> 1);
-          WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
+          _FAN_PWM(1);
         #endif
         #if HAS_FAN2
-          soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + (soft_pwm_amount_fan[2] >> 1);
-          WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
+          _FAN_PWM(2);
         #endif
       #endif
     }
     else {
-      if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
-      #if HOTENDS > 1
-        if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
-        #if HOTENDS > 2
-          if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
-          #if HOTENDS > 3
-            if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
-            #if HOTENDS > 4
-              if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
-              #if HOTENDS > 5
-                if (soft_pwm_count_5 <= pwm_count_tmp) WRITE_HEATER_5(LOW);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
+      #define _PWM_LOW(N,S) do{ if (S.count <= pwm_count_tmp) WRITE_HEATER_##N(LOW); }while(0)
+      #if HOTENDS
+        #define _PWM_LOW_E(N) _PWM_LOW(N, soft_pwm_hotend[N])
+        _PWM_LOW_E(0);
+        #if HOTENDS > 1
+          _PWM_LOW_E(1);
+          #if HOTENDS > 2
+            _PWM_LOW_E(2);
+            #if HOTENDS > 3
+              _PWM_LOW_E(3);
+              #if HOTENDS > 4
+                _PWM_LOW_E(4);
+                #if HOTENDS > 5
+                  _PWM_LOW_E(5);
+                #endif // HOTENDS > 5
+              #endif // HOTENDS > 4
+            #endif // HOTENDS > 3
+          #endif // HOTENDS > 2
+        #endif // HOTENDS > 1
+      #endif // HOTENDS
 
       #if HAS_HEATED_BED
-        if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
+        _PWM_LOW(BED, soft_pwm_bed);
+      #endif
+
+      #if HAS_HEATED_CHAMBER
+        _PWM_LOW(CHAMBER, soft_pwm_chamber);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
           if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
         #endif
         #if HAS_FAN1
           if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
         #endif
         #if HAS_FAN2
@@ -2174,110 +2273,91 @@ void Temperature::isr() {
     // 5:                /  4 = 244.1406 Hz
     pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
 
   #else // SLOW_PWM_HEATERS
 
     /**
      * SLOW PWM HEATERS
      *
      * For relay-driven heaters
      */
-    #ifndef MIN_STATE_TIME
-      #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
-    #endif
-
-    // Macros for Slow PWM timer logic
-    #define _SLOW_PWM_ROUTINE(NR, src) \
-      soft_pwm_count_ ##NR = src; \
-      if (soft_pwm_count_ ##NR > 0) { \
-        if (state_timer_heater_ ##NR == 0) { \
-          if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
-          state_heater_ ##NR = 1; \
-          WRITE_HEATER_ ##NR(1); \
-        } \
-      } \
-      else { \
-        if (state_timer_heater_ ##NR == 0) { \
-          if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
-          state_heater_ ##NR = 0; \
-          WRITE_HEATER_ ##NR(0); \
-        } \
-      }
-    #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
-
-    #define PWM_OFF_ROUTINE(NR) \
-      if (soft_pwm_count_ ##NR < slow_pwm_count) { \
-        if (state_timer_heater_ ##NR == 0) { \
-          if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
-          state_heater_ ##NR = 0; \
-          WRITE_HEATER_ ##NR (0); \
-        } \
-      }
+    #define _SLOW_SET(NR,PWM,V) do{ if (PWM.ready(V)) WRITE_HEATER_##NR(V); }while(0)
+    #define _SLOW_PWM(NR,PWM,SRC) do{ PWM.count = SRC.soft_pwm_amount; _SLOW_SET(NR,PWM,(PWM.count > 0)); }while(0)
+    #define _PWM_OFF(NR,PWM) do{ if (PWM.count < slow_pwm_count) _SLOW_SET(NR,PWM,0); }while(0)
 
     if (slow_pwm_count == 0) {
 
-      SLOW_PWM_ROUTINE(0);
+      #if HOTENDS
+        #define _SLOW_PWM_E(N) _SLOW_PWM(N, soft_pwm_hotend[N], temp_hotend[N])
+        _SLOW_PWM_E(0);
+        #if HOTENDS > 1
+          _SLOW_PWM_E(1);
+          #if HOTENDS > 2
+            _SLOW_PWM_E(2);
+            #if HOTENDS > 3
+              _SLOW_PWM_E(3);
+              #if HOTENDS > 4
+                _SLOW_PWM_E(4);
+                #if HOTENDS > 5
+                  _SLOW_PWM_E(5);
+                #endif // HOTENDS > 5
+              #endif // HOTENDS > 4
+            #endif // HOTENDS > 3
+          #endif // HOTENDS > 2
+        #endif // HOTENDS > 1
+      #endif // HOTENDS
+
+      #if HAS_HEATED_BED
+        _SLOW_PWM(BED, soft_pwm_bed, temp_bed);
+      #endif
+
+    } // slow_pwm_count == 0
+
+    #if HOTENDS
+      #define _PWM_OFF_E(N) _PWM_OFF(N, soft_pwm_hotend[N]);
+      _PWM_OFF_E(0);
       #if HOTENDS > 1
-        SLOW_PWM_ROUTINE(1);
+        _PWM_OFF_E(1);
         #if HOTENDS > 2
-          SLOW_PWM_ROUTINE(2);
+          _PWM_OFF_E(2);
           #if HOTENDS > 3
-            SLOW_PWM_ROUTINE(3);
+            _PWM_OFF_E(3);
             #if HOTENDS > 4
-              SLOW_PWM_ROUTINE(4);
+              _PWM_OFF_E(4);
               #if HOTENDS > 5
-                SLOW_PWM_ROUTINE(5);
+                _PWM_OFF_E(5);
               #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
-      #if HAS_HEATED_BED
-        _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
-      #endif
+    #endif // HOTENDS
 
-    } // slow_pwm_count == 0
-
-    PWM_OFF_ROUTINE(0);
-    #if HOTENDS > 1
-      PWM_OFF_ROUTINE(1);
-      #if HOTENDS > 2
-        PWM_OFF_ROUTINE(2);
-        #if HOTENDS > 3
-          PWM_OFF_ROUTINE(3);
-          #if HOTENDS > 4
-            PWM_OFF_ROUTINE(4);
-            #if HOTENDS > 5
-              PWM_OFF_ROUTINE(5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
     #if HAS_HEATED_BED
-      PWM_OFF_ROUTINE(BED); // BED
+      _PWM_OFF(BED, soft_pwm_bed);
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
         pwm_count_tmp = 0;
+        #define _PWM_FAN(N,I) do{                               \
+          soft_pwm_count_fan[I] = soft_pwm_amount_fan[I] >> 1;  \
+          WRITE_FAN##N(soft_pwm_count_fan[I] > 0 ? HIGH : LOW); \
+        }while(0)
         #if HAS_FAN0
-          soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
-          WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
+          _PWM_FAN(,0);
         #endif
         #if HAS_FAN1
-          soft_pwm_count_fan[1] = soft_pwm_amount_fan[1] >> 1;
-          WRITE_FAN1(soft_pwm_count_fan[1] > 0 ? HIGH : LOW);
+          _PWM_FAN(1,1);
         #endif
         #if HAS_FAN2
-          soft_pwm_count_fan[2] = soft_pwm_amount_fan[2] >> 1;
-          WRITE_FAN2(soft_pwm_count_fan[2] > 0 ? HIGH : LOW);
+          _PWM_FAN(2,2);
         #endif
       }
       #if HAS_FAN0
         if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
       #endif
       #if HAS_FAN1
         if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
       #endif
       #if HAS_FAN2
         if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
@@ -2293,61 +2373,61 @@ void Temperature::isr() {
     // 4:                /  8 = 122.0703 Hz
     // 5:                /  4 = 244.1406 Hz
     pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
 
     // increment slow_pwm_count only every 64th pwm_count,
     // i.e. yielding a PWM frequency of 16/128 Hz (8s).
     if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7F;
 
-      if (state_timer_heater_0 > 0) state_timer_heater_0--;
+      soft_pwm_hotend[0].dec();
       #if HOTENDS > 1
-        if (state_timer_heater_1 > 0) state_timer_heater_1--;
+        soft_pwm_hotend[1].dec();
         #if HOTENDS > 2
-          if (state_timer_heater_2 > 0) state_timer_heater_2--;
+          soft_pwm_hotend[2].dec();
           #if HOTENDS > 3
-            if (state_timer_heater_3 > 0) state_timer_heater_3--;
+            soft_pwm_hotend[3].dec();
             #if HOTENDS > 4
-              if (state_timer_heater_4 > 0) state_timer_heater_4--;
+              soft_pwm_hotend[4].dec();
               #if HOTENDS > 5
-                if (state_timer_heater_5 > 0) state_timer_heater_5--;
+                soft_pwm_hotend[5].dec();
               #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
-        if (state_timer_heater_BED > 0) state_timer_heater_BED--;
+        soft_pwm_bed.dec();
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
 
   /**
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
-  #define ACCUMULATE_ADC(var) do{ \
+  #define ACCUMULATE_ADC(obj) do{ \
     if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
-    else var += HAL_READ_ADC(); \
+    else obj.acc += HAL_READ_ADC(); \
   }while(0)
 
   ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
@@ -2369,84 +2449,84 @@ void Temperature::isr() {
         temp_count = 0;
         readings_ready();
       }
       break;
 
     #if HAS_TEMP_ADC_0
       case PrepareTemp_0:
         HAL_START_ADC(TEMP_0_PIN);
         break;
       case MeasureTemp_0:
-        ACCUMULATE_ADC(raw_temp_value[0]);
+        ACCUMULATE_ADC(temp_hotend[0]);
         break;
     #endif
 
     #if HAS_HEATED_BED
       case PrepareTemp_BED:
         HAL_START_ADC(TEMP_BED_PIN);
         break;
       case MeasureTemp_BED:
-        ACCUMULATE_ADC(raw_temp_bed_value);
+        ACCUMULATE_ADC(temp_bed);
         break;
     #endif
 
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER:
         HAL_START_ADC(TEMP_CHAMBER_PIN);
         break;
       case MeasureTemp_CHAMBER:
-        ACCUMULATE_ADC(raw_temp_chamber_value);
+        ACCUMULATE_ADC(temp_chamber);
         break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1:
         HAL_START_ADC(TEMP_1_PIN);
         break;
       case MeasureTemp_1:
-        ACCUMULATE_ADC(raw_temp_value[1]);
+        ACCUMULATE_ADC(temp_hotend[1]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_2
       case PrepareTemp_2:
         HAL_START_ADC(TEMP_2_PIN);
         break;
       case MeasureTemp_2:
-        ACCUMULATE_ADC(raw_temp_value[2]);
+        ACCUMULATE_ADC(temp_hotend[2]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_3
       case PrepareTemp_3:
         HAL_START_ADC(TEMP_3_PIN);
         break;
       case MeasureTemp_3:
-        ACCUMULATE_ADC(raw_temp_value[3]);
+        ACCUMULATE_ADC(temp_hotend[3]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_4
       case PrepareTemp_4:
         HAL_START_ADC(TEMP_4_PIN);
         break;
       case MeasureTemp_4:
-        ACCUMULATE_ADC(raw_temp_value[4]);
+        ACCUMULATE_ADC(temp_hotend[4]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_5
       case PrepareTemp_5:
         HAL_START_ADC(TEMP_5_PIN);
         break;
       case MeasureTemp_5:
-        ACCUMULATE_ADC(raw_temp_value[5]);
+        ACCUMULATE_ADC(temp_hotend[5]);
         break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH:
         HAL_START_ADC(FILWIDTH_PIN);
       break;
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
@@ -2628,26 +2708,41 @@ void Temperature::isr() {
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
         , -1 // BED
       );
     #endif
     #if HAS_TEMP_CHAMBER
-      print_heater_state(degChamber(), 0
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawChamberTemp()
-        #endif
+      #if HAS_HEATED_CHAMBER
+        print_heater_state(degChamber(), degTargetChamber()
+          #if ENABLED(SHOW_TEMP_ADC_VALUES)
+            , rawChamberTemp()
+          #endif
+          #if NUM_SERIAL > 1
+            , port
+          #endif
         , -2 // CHAMBER
       );
+      #else
+        print_heater_state(degChamber(), 0
+          #if ENABLED(SHOW_TEMP_ADC_VALUES)
+            , rawChamberTemp()
+          #endif
+          #if NUM_SERIAL > 1
+            , port
+          #endif
+          , -2 // CHAMBER
+        );
+      #endif // HAS_HEATED_CHAMBER
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         , e
       );
     #endif
     SERIAL_ECHOPGM(" @:");

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a333f02206..d697939ff3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -449,51 +449,40 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
-              SERIAL_ECHOPAIR(MSG_BIAS, bias);
-              SERIAL_ECHOPAIR(MSG_D, d);
-              SERIAL_ECHOPAIR(MSG_T_MIN, min);
-              SERIAL_ECHOPAIR(MSG_T_MAX, max);
+              SERIAL_ECHOPAIR(MSG_BIAS, bias, MSG_D, d, MSG_T_MIN, min, MSG_T_MAX, max);
               if (cycles > 2) {
                 float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
                       Tu = ((float)(t_low + t_high) * 0.001f);
-                SERIAL_ECHOPAIR(MSG_KU, Ku);
-                SERIAL_ECHOPAIR(MSG_TU, Tu);
                 tune_pid.Kp = 0.6f * Ku;
                 tune_pid.Ki = 2 * tune_pid.Kp / Tu;
                 tune_pid.Kd = tune_pid.Kp * Tu * 0.125f;
+                SERIAL_ECHOPAIR(MSG_KU, Ku, MSG_TU, Tu);
                 SERIAL_ECHOLNPGM("\n" MSG_CLASSIC_PID);
-                SERIAL_ECHOPAIR(MSG_KP, tune_pid.Kp);
-                SERIAL_ECHOPAIR(MSG_KI, tune_pid.Ki);
-                SERIAL_ECHOLNPAIR(MSG_KD, tune_pid.Kd);
+                SERIAL_ECHOLNPAIR(MSG_KP, tune_pid.Kp, MSG_KI, tune_pid.Ki, MSG_KD, tune_pid.Kd);
                 /**
                 tune_pid.Kp = 0.33*Ku;
                 tune_pid.Ki = tune_pid.Kp/Tu;
                 tune_pid.Kd = tune_pid.Kp*Tu/3;
                 SERIAL_ECHOLNPGM(" Some overshoot");
-                SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp);
-                SERIAL_ECHOPAIR(" Ki: ", tune_pid.Ki);
-                SERIAL_ECHOPAIR(" Kd: ", tune_pid.Kd);
+                SERIAL_ECHOLNPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd, " No overshoot");
                 tune_pid.Kp = 0.2*Ku;
                 tune_pid.Ki = 2*tune_pid.Kp/Tu;
                 tune_pid.Kd = tune_pid.Kp*Tu/3;
-                SERIAL_ECHOLNPGM(" No overshoot");
-                SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp);
-                SERIAL_ECHOPAIR(" Ki: ", tune_pid.Ki);
-                SERIAL_ECHOPAIR(" Kd: ", tune_pid.Kd);
+                SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp, " Ki: ", tune_pid.Ki, " Kd: ", tune_pid.Kd);
                 */
               }
             }
             SHV(soft_pwm_amount, (bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             min = target;
           }
         }
       }
 
@@ -800,30 +789,34 @@ float Temperature::get_pid_output(const int8_t e) {
       }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       SERIAL_ECHO_START();
-      SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
-      SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
-      SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
+      SERIAL_ECHOPAIR(
+        MSG_PID_DEBUG, HOTEND_INDEX,
+        MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX],
+        MSG_PID_DEBUG_OUTPUT, pid_output
+      );
       #if DISABLED(PID_OPENLOOP)
-        SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, work_pid[HOTEND_INDEX].Kp);
-        SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, work_pid[HOTEND_INDEX].Ki);
-        SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd);
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc);
-        #endif
+        SERIAL_ECHOPAIR(
+          MSG_PID_DEBUG_PTERM, work_pid[HOTEND_INDEX].Kp,
+          MSG_PID_DEBUG_ITERM, work_pid[HOTEND_INDEX].Ki,
+          MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd
+          #if ENABLED(PID_EXTRUSION_SCALING),
+            MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc
+          #endif
+        );
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
   #else /* PID off */
     #if HEATER_IDLE_HANDLER
       #define _TIMED_OUT_TEST heater_idle_timeout_exceeded[HOTEND_INDEX]
     #else
       #define _TIMED_OUT_TEST false
     #endif
@@ -862,27 +855,28 @@ float Temperature::get_pid_output(const int8_t e) {
       }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
       SERIAL_ECHO_START();
-      SERIAL_ECHOPAIR(" PID_BED_DEBUG : Input ", current_temperature_bed);
-      SERIAL_ECHOPAIR(" Output ", pid_output);
-      #if DISABLED(PID_OPENLOOP)
-        SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, work_pid.Kp);
-        SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, work_pid.Ki);
-        SERIAL_ECHOLNPAIR(MSG_PID_DEBUG_DTERM, work_pid.Kd);
-      #endif
+      SERIAL_ECHOLNPAIR(
+        " PID_BED_DEBUG : Input ", current_temperature_bed, " Output ", pid_output,
+        #if DISABLED(PID_OPENLOOP)
+          MSG_PID_DEBUG_PTERM, work_pid.Kp,
+          MSG_PID_DEBUG_ITERM, work_pid.Ki,
+          MSG_PID_DEBUG_DTERM, work_pid.Kd,
+        #endif
+      );
     #endif
 
     return pid_output;
   }
 
 #endif // PIDTEMPBED
 
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
@@ -1615,24 +1609,21 @@ void Temperature::init() {
   #endif
 
   void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
         SERIAL_ECHO_START();
         SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
         if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
-        SERIAL_ECHOPAIR(" ;  State:", *state);
-        SERIAL_ECHOPAIR(" ;  Timer:", *timer);
-        SERIAL_ECHOPAIR(" ;  Temperature:", current);
-        SERIAL_ECHOPAIR(" ;  Target Temp:", target);
+        SERIAL_ECHOPAIR(" ;  State:", *state, " ;  Timer:", *timer, " ;  Temperature:", current, " ;  Target Temp:", target);
         if (heater_id >= 0)
           SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
         else
           SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
         SERIAL_EOL();
     */
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
 
     #if HEATER_IDLE_HANDLER

commit 2212da453aa8a575df529cd4333b5248d9bae5b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 00:41:31 2019 -0600

    Distinguish between analog/digital auto fans (#13298)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c425fadced..a333f02206 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -625,61 +625,83 @@ int Temperature::getHeaterPower(const int heater) {
     #if HAS_HEATED_BED
       heater < 0 ? soft_pwm_amount_bed :
     #endif
     soft_pwm_amount[heater]
   );
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
-    static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN, E5_AUTO_FAN_PIN, CHAMBER_AUTO_FAN_PIN };
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
-      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 :                   4,
-      AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5,
-      AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : 5
+      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 :               4,
+      AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5
+      #if HAS_TEMP_CHAMBER
+        , AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : AUTO_CHAMBER_IS_5 ? 5 : 6
+      #endif
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
       if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
-        SBI(fanState, pgm_read_byte(&fanBit[5]));
+        SBI(fanState, pgm_read_byte(&fanBit[6]));
     #endif
 
+    #define _UPDATE_AUTO_FAN(P,D,A) do{           \
+      if (USEABLE_HARDWARE_PWM(P##_AUTO_FAN_PIN)) \
+        analogWrite(P##_AUTO_FAN_PIN, A);         \
+      else                                        \
+        WRITE(P##_AUTO_FAN_PIN, D);               \
+    }while(0)
+
     uint8_t fanDone = 0;
-    for (uint8_t f = 0; f < COUNT(fanPin); f++) {
-      const pin_t pin =
-        #ifdef ARDUINO
-          pgm_read_byte(&fanPin[f])
-        #else
-          fanPin[f]
-        #endif
-      ;
+    for (uint8_t f = 0; f < COUNT(fanBit); f++) {
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
-      if (pin >= 0 && !TEST(fanDone, bit)) {
-        uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
-        #if ENABLED(AUTO_POWER_E_FANS)
-          autofan_speed[f] = newFanSpeed;
+      if (TEST(fanDone, bit)) continue;
+      const bool fan_on = TEST(fanState, bit);
+      const uint8_t speed = fan_on ? EXTRUDER_AUTO_FAN_SPEED : 0;
+      #if ENABLED(AUTO_POWER_E_FANS)
+        autofan_speed[f] = speed;
+      #endif
+      switch (f) {
+        #if HAS_AUTO_FAN_0
+          case 0: _UPDATE_AUTO_FAN(E0, fan_on, speed); break;
+        #endif
+        #if HAS_AUTO_FAN_1
+          case 1: _UPDATE_AUTO_FAN(E1, fan_on, speed); break;
+        #endif
+        #if HAS_AUTO_FAN_2
+          case 2: _UPDATE_AUTO_FAN(E2, fan_on, speed); break;
+        #endif
+        #if HAS_AUTO_FAN_3
+          case 3: _UPDATE_AUTO_FAN(E3, fan_on, speed); break;
+        #endif
+        #if HAS_AUTO_FAN_4
+          case 4: _UPDATE_AUTO_FAN(E4, fan_on, speed); break;
+        #endif
+        #if HAS_AUTO_FAN_5
+          case 5: _UPDATE_AUTO_FAN(E5, fan_on, speed); break;
+        #endif
+        #if HAS_AUTO_CHAMBER_FAN
+          case 6: _UPDATE_AUTO_FAN(CHAMBER, fan_on, speed); break;
         #endif
-        // this idiom allows both digital and PWM fan outputs (see M42 handling).
-        digitalWrite(pin, newFanSpeed);
-        analogWrite(pin, newFanSpeed);
-        SBI(fanDone, bit);
       }
+      SBI(fanDone, bit);
+      UNUSED(fan_on); UNUSED(speed);
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;

commit 38bef9da9196ed261bbee7848ed84b7d3bd071fa
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Mon Mar 4 03:03:48 2019 +0000

    Report auto temp to both serial ports, if available (#13301)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 109a3c5318..c425fadced 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2653,20 +2653,21 @@ void Temperature::isr() {
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
+        PORT_REDIRECT(SERIAL_BOTH);
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);

commit 599cdc3f0fa0ae2446bce1f7ca542ec75c5fe172
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 3 05:29:55 2019 -0600

    Remove dead code from get_pid_output
    
    See #12981

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 69a8c835fa..109a3c5318 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -718,76 +718,71 @@ float Temperature::get_pid_output(const int8_t e) {
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       static hotend_pid_t work_pid[HOTENDS];
       static float temp_iState[HOTENDS] = { 0 },
                    temp_dState[HOTENDS] = { 0 };
       static bool pid_reset[HOTENDS] = { false };
       float pid_error = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
       work_pid[HOTEND_INDEX].Kd = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + float(PID_K1) * work_pid[HOTEND_INDEX].Kd;
       temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
-      #if HEATER_IDLE_HANDLER
-        if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
-          pid_output = 0;
-          pid_reset[HOTEND_INDEX] = true;
+
+      if (target_temperature[HOTEND_INDEX] == 0
+        || pid_error < -(PID_FUNCTIONAL_RANGE)
+        #if HEATER_IDLE_HANDLER
+          || heater_idle_timeout_exceeded[HOTEND_INDEX]
+        #endif
+      ) {
+        pid_output = 0;
+        pid_reset[HOTEND_INDEX] = true;
+      }
+      else if (pid_error > PID_FUNCTIONAL_RANGE) {
+        pid_output = BANG_MAX;
+        pid_reset[HOTEND_INDEX] = true;
+      }
+      else {
+        if (pid_reset[HOTEND_INDEX]) {
+          temp_iState[HOTEND_INDEX] = 0.0;
+          pid_reset[HOTEND_INDEX] = false;
         }
-        else
-      #endif
-          if (pid_error > PID_FUNCTIONAL_RANGE) {
-            pid_output = BANG_MAX;
-            pid_reset[HOTEND_INDEX] = true;
-          }
-          else if (pid_error < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
-            #if HEATER_IDLE_HANDLER
-              || heater_idle_timeout_exceeded[HOTEND_INDEX]
-            #endif
-          ) {
-            pid_output = 0;
-            pid_reset[HOTEND_INDEX] = true;
-          }
-          else {
-            if (pid_reset[HOTEND_INDEX]) {
-              temp_iState[HOTEND_INDEX] = 0.0;
-              pid_reset[HOTEND_INDEX] = false;
-            }
-            temp_iState[HOTEND_INDEX] += pid_error;
-            work_pid[HOTEND_INDEX].Kp = PID_PARAM(Kp, HOTEND_INDEX) * pid_error;
-            work_pid[HOTEND_INDEX].Ki = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
-
-            pid_output = work_pid[HOTEND_INDEX].Kp + work_pid[HOTEND_INDEX].Ki - work_pid[HOTEND_INDEX].Kd;
-
-            #if ENABLED(PID_EXTRUSION_SCALING)
-              work_pid[HOTEND_INDEX].Kc = 0;
-              if (_HOTEND_TEST) {
-                const long e_position = stepper.position(E_AXIS);
-                if (e_position > last_e_position) {
-                  lpq[lpq_ptr] = e_position - last_e_position;
-                  last_e_position = e_position;
-                }
-                else
-                  lpq[lpq_ptr] = 0;
-
-                if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-                work_pid[HOTEND_INDEX].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
-                pid_output += work_pid[HOTEND_INDEX].Kc;
-              }
-            #endif // PID_EXTRUSION_SCALING
+        temp_iState[HOTEND_INDEX] += pid_error;
+        work_pid[HOTEND_INDEX].Kp = PID_PARAM(Kp, HOTEND_INDEX) * pid_error;
+        work_pid[HOTEND_INDEX].Ki = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
 
-            if (pid_output > PID_MAX) {
-              if (pid_error > 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
-              pid_output = PID_MAX;
-            }
-            else if (pid_output < 0) {
-              if (pid_error < 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
-              pid_output = 0;
+        pid_output = work_pid[HOTEND_INDEX].Kp + work_pid[HOTEND_INDEX].Ki - work_pid[HOTEND_INDEX].Kd;
+
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          work_pid[HOTEND_INDEX].Kc = 0;
+          if (_HOTEND_TEST) {
+            const long e_position = stepper.position(E_AXIS);
+            if (e_position > last_e_position) {
+              lpq[lpq_ptr] = e_position - last_e_position;
+              last_e_position = e_position;
             }
+            else
+              lpq[lpq_ptr] = 0;
+
+            if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
+            work_pid[HOTEND_INDEX].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
+            pid_output += work_pid[HOTEND_INDEX].Kc;
           }
+        #endif // PID_EXTRUSION_SCALING
+
+        if (pid_output > PID_MAX) {
+          if (pid_error > 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
+          pid_output = PID_MAX;
+        }
+        else if (pid_output < 0) {
+          if (pid_error < 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
+          pid_output = 0;
+        }
+      }
 
     #else // PID_OPENLOOP
 
       const float pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
 
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
@@ -799,25 +794,26 @@ float Temperature::get_pid_output(const int8_t e) {
         SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd);
         #if ENABLED(PID_EXTRUSION_SCALING)
           SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc);
         #endif
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
   #else /* PID off */
     #if HEATER_IDLE_HANDLER
-      if (heater_idle_timeout_exceeded[HOTEND_INDEX])
-        pid_output = 0;
-      else
+      #define _TIMED_OUT_TEST heater_idle_timeout_exceeded[HOTEND_INDEX]
+    #else
+      #define _TIMED_OUT_TEST false
     #endif
-    pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? BANG_MAX : 0;
+    pid_output = (!_TIMED_OUT_TEST && current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? BANG_MAX : 0;
+    #undef _TIMED_OUT_TEST
   #endif
 
   return pid_output;
 }
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)

commit 05c2f8082683bc4813f16f9c460182666a7966bf
Author: kAdonis <35379348+kAdonis@users.noreply.github.com>
Date:   Sat Mar 2 23:29:10 2019 +0100

    Fix bug in wait-for-heatup (#13290)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6f5c8e2263..69a8c835fa 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2880,22 +2880,24 @@ void Temperature::isr() {
           // Gradually change LED strip from blue to violet as bed heats up
           if (!wants_to_cool) printerEventLEDs.onBedHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
-            if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
-            if (first_loop) residency_start_ms += (TEMP_BED_RESIDENCY_TIME) * 1000UL;
+            if (temp_diff < TEMP_BED_WINDOW) {
+              residency_start_ms = now;
+              if (first_loop) residency_start_ms += (TEMP_BED_RESIDENCY_TIME) * 1000UL;
+            }
           }
           else if (temp_diff > TEMP_BED_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
         #endif // TEMP_BED_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M190 R0
         if (wants_to_cool) {

commit 7fde3ed915dd1985aa420a0b009869c7184cef71
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 28 14:35:05 2019 -0600

    Skip hysteresis check when temp is already close to target
    
    To eliminate a long delay during pause, park, and filament change

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5428069086..6f5c8e2263 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2709,21 +2709,21 @@ void Temperature::isr() {
         const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degHotend(target_extruder);
         printerEventLEDs.onHotendHeatingStart();
       #endif
 
       float target_temp = -1.0, old_temp = 9999.0;
-      bool wants_to_cool = false;
+      bool wants_to_cool = false, first_loop = true;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
           target_temp = degTargetHotend(target_extruder);
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
@@ -2752,21 +2752,24 @@ void Temperature::isr() {
           // Gradually change LED strip from violet to red as nozzle heats up
           if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
-            if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
+            if (temp_diff < TEMP_WINDOW) {
+              residency_start_ms = now;
+              if (first_loop) residency_start_ms += (TEMP_RESIDENCY_TIME) * 1000UL;
+            }
           }
           else if (temp_diff > TEMP_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
         #endif
 
         // Prevent a wait-forever situation if R is misused i.e. M109 R0
         if (wants_to_cool) {
@@ -2779,20 +2782,22 @@ void Temperature::isr() {
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
+        first_loop = false;
+
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         ui.reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onHeatingDone();
         #endif
       }
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
@@ -2821,21 +2826,21 @@ void Temperature::isr() {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         // Loop until the temperature has stabilized
         #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       float target_temp = -1, old_temp = 9999;
-      bool wants_to_cool = false;
+      bool wants_to_cool = false, first_loop = true;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
@@ -2876,20 +2881,21 @@ void Temperature::isr() {
           if (!wants_to_cool) printerEventLEDs.onBedHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
+            if (first_loop) residency_start_ms += (TEMP_BED_RESIDENCY_TIME) * 1000UL;
           }
           else if (temp_diff > TEMP_BED_HYSTERESIS) {
             // Restart the timer whenever the temperature falls outside the hysteresis.
             residency_start_ms = now;
           }
 
         #endif // TEMP_BED_RESIDENCY_TIME > 0
 
         // Prevent a wait-forever situation if R is misused i.e. M190 R0
         if (wants_to_cool) {
@@ -2902,20 +2908,22 @@ void Temperature::isr() {
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
           if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
             ui.quick_feedback();
           }
         #endif
 
+        first_loop = false;
+
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) ui.reset_status();
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;
     }

commit eb4bf93ea42c4c83335ca9cef21e78d0c752213f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 27 05:38:56 2019 -0500

    Add more Babystep options (#13262)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7d1264c148..5428069086 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -36,20 +36,27 @@
 #define MAX6675_SEPARATE_SPI (ENABLED(HEATER_0_USES_MAX6675) || ENABLED(HEATER_1_USES_MAX6675)) && PIN_EXISTS(MAX6675_SCK) && PIN_EXISTS(MAX6675_DO)
 
 #if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) || ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
+#if ENABLED(BABYSTEPPING)
+  #include "../module/motion.h"
+  #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
+    #include "../gcode/gcode.h"
+  #endif
+#endif
+
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
@@ -253,26 +260,24 @@ int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
   bool Temperature::inited = false;
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   uint16_t Temperature::redundant_temperature_raw = 0;
   float Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::temp_meas_ready = false;
 
-#if ENABLED(PIDTEMP)
-  #if ENABLED(PID_EXTRUSION_SCALING)
-    long Temperature::last_e_position;
-    long Temperature::lpq[LPQ_MAX_LEN];
-    int Temperature::lpq_ptr = 0;
-  #endif
+#if ENABLED(PID_EXTRUSION_SCALING)
+  long Temperature::last_e_position;
+  long Temperature::lpq[LPQ_MAX_LEN];
+  int Temperature::lpq_ptr = 0;
 #endif
 
 uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 };
 
 // Init min and max temp with extreme values to prevent false errors during startup
 int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
         Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
         Temperature::minttemp[HOTENDS] = { 0 },
         Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
 
@@ -305,20 +310,22 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 #if HEATER_IDLE_HANDLER
   millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
   bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
 #endif
 
+// public:
+
 #if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
@@ -2468,37 +2475,108 @@ void Temperature::isr() {
   } // switch(adc_sensor_state)
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING)
-    LOOP_XYZ(axis) {
-      const int16_t curTodo = babystepsTodo[axis]; // get rid of volatile for performance
+    #if ENABLED(BABYSTEP_XY) || ENABLED(I2C_POSITION_ENCODERS)
+      LOOP_XYZ(axis) {
+        const int16_t curTodo = babystepsTodo[axis]; // get rid of volatile for performance
+        if (curTodo) {
+          stepper.babystep((AxisEnum)axis, curTodo > 0);
+          if (curTodo > 0) babystepsTodo[axis]--; else babystepsTodo[axis]++;
+        }
+      }
+    #else
+      const int16_t curTodo = babystepsTodo[Z_AXIS];
       if (curTodo) {
-        stepper.babystep((AxisEnum)axis, curTodo > 0);
-        if (curTodo > 0) babystepsTodo[axis]--;
-                    else babystepsTodo[axis]++;
+        stepper.babystep(Z_AXIS, curTodo > 0);
+        if (curTodo > 0) babystepsTodo[Z_AXIS]--; else babystepsTodo[Z_AXIS]++;
       }
-    }
-  #endif // BABYSTEPPING
+    #endif
+  #endif
 
   // Poll endstops state, if required
   endstops.poll();
 
   // Periodically call the planner timer
   planner.tick();
 }
 
+#if ENABLED(BABYSTEPPING)
+
+  #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
+    #define BSA_ENABLE(AXIS) do{ switch (AXIS) { case X_AXIS: enable_X(); break; case Y_AXIS: enable_Y(); break; case Z_AXIS: enable_Z(); } }while(0)
+  #else
+    #define BSA_ENABLE(AXIS) NOOP
+  #endif
+
+  #if ENABLED(BABYSTEP_WITHOUT_HOMING)
+    #define CAN_BABYSTEP(AXIS) true
+  #else
+    #define CAN_BABYSTEP(AXIS) TEST(axis_known_position, AXIS)
+  #endif
+
+  extern uint8_t axis_known_position;
+
+  void Temperature::babystep_axis(const AxisEnum axis, const int16_t distance) {
+    if (!CAN_BABYSTEP(axis)) return;
+    #if IS_CORE
+      #if ENABLED(BABYSTEP_XY)
+        switch (axis) {
+          case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
+            BSA_ENABLE(CORE_AXIS_1);
+            BSA_ENABLE(CORE_AXIS_2);
+            babystepsTodo[CORE_AXIS_1] += distance * 2;
+            babystepsTodo[CORE_AXIS_2] += distance * 2;
+            break;
+          case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
+            BSA_ENABLE(CORE_AXIS_1);
+            BSA_ENABLE(CORE_AXIS_2);
+            babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
+            babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
+            break;
+          case NORMAL_AXIS: // Z on CoreXY, Y on CoreXZ, X on CoreYZ
+          default:
+            BSA_ENABLE(NORMAL_AXIS);
+            babystepsTodo[NORMAL_AXIS] += distance;
+            break;
+        }
+      #elif CORE_IS_XZ || CORE_IS_YZ
+        // Only Z stepping needs to be handled here
+        BSA_ENABLE(CORE_AXIS_1);
+        BSA_ENABLE(CORE_AXIS_2);
+        babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
+        babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
+      #else
+        BSA_ENABLE(Z_AXIS);
+        babystepsTodo[Z_AXIS] += distance;
+      #endif
+    #else
+      #if ENABLED(BABYSTEP_XY)
+        BSA_ENABLE(axis);
+      #else
+        BSA_ENABLE(Z_AXIS);
+      #endif
+      babystepsTodo[axis] += distance;
+    #endif
+    #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
+      gcode.reset_stepper_timeout();
+    #endif
+  }
+
+#endif // BABYSTEPPING
+
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     , const int8_t e=-3
   ) {

commit 64253e1a581dedda07e638ea3f17c519037df7f9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 24 15:04:29 2019 -0600

    Followup to serial reform
    
    Reference #13250

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8b494811ec..7d1264c148 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2530,52 +2530,43 @@ void Temperature::isr() {
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(target_extruder)
         #endif
-        #if NUM_SERIAL > 1
-          , port
-        #endif
       );
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
-        #if NUM_SERIAL > 1
-          , port
-        #endif
         , -1 // BED
       );
     #endif
     #if HAS_TEMP_CHAMBER
       print_heater_state(degChamber(), 0
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawChamberTemp()
         #endif
         , -2 // CHAMBER
       );
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
-        #if NUM_SERIAL > 1
-          , port
-        #endif
         , e
       );
     #endif
     SERIAL_ECHOPGM(" @:");
     SERIAL_ECHO(getHeaterPower(target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPGM(" B@:");
       SERIAL_ECHO(getHeaterPower(-1));
     #endif
     #if HOTENDS > 1

commit e15354e387cc825390fc4eaaf3ae4b784a8fd588
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 23 22:53:01 2019 -0600

    Simplify serial port redirect (#13234)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0cd526b33c..8b494811ec 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2493,59 +2493,52 @@ void Temperature::isr() {
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
-    #if NUM_SERIAL > 1
-      , const int8_t port=-1
-    #endif
     , const int8_t e=-3
   ) {
     #if !(HAS_HEATED_BED && HAS_TEMP_HOTEND && HAS_TEMP_CHAMBER) && HOTENDS <= 1
       UNUSED(e);
     #endif
 
-    SERIAL_CHAR_P(port, ' ');
-    SERIAL_CHAR_P(port,
+    SERIAL_CHAR(' ');
+    SERIAL_CHAR(
       #if HAS_TEMP_CHAMBER && HAS_HEATED_BED && HAS_TEMP_HOTEND
         e == -2 ? 'C' : e == -1 ? 'B' : 'T'
       #elif HAS_HEATED_BED && HAS_TEMP_HOTEND
         e == -1 ? 'B' : 'T'
       #elif HAS_TEMP_HOTEND
         'T'
       #else
         'B'
       #endif
     );
     #if HOTENDS > 1
-      if (e >= 0) SERIAL_CHAR_P(port, '0' + e);
+      if (e >= 0) SERIAL_CHAR('0' + e);
     #endif
-    SERIAL_CHAR_P(port, ':');
-    SERIAL_ECHO_P(port, c);
-    SERIAL_ECHOPAIR_P(port, " /" , t);
+    SERIAL_CHAR(':');
+    SERIAL_ECHO(c);
+    SERIAL_ECHOPAIR(" /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_ECHOPAIR_P(port, " (", r / OVERSAMPLENR);
-      SERIAL_CHAR_P(port, ')');
+      SERIAL_ECHOPAIR(" (", r / OVERSAMPLENR);
+      SERIAL_CHAR(')');
     #endif
     delay(2);
   }
 
-  void Temperature::print_heater_states(const uint8_t target_extruder
-    #if NUM_SERIAL > 1
-      , const int8_t port
-    #endif
-  ) {
+  void Temperature::print_heater_states(const uint8_t target_extruder) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(target_extruder)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
       );
     #endif
@@ -2572,31 +2565,31 @@ void Temperature::isr() {
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , e
       );
     #endif
-    SERIAL_ECHOPGM_P(port, " @:");
-    SERIAL_ECHO_P(port, getHeaterPower(target_extruder));
+    SERIAL_ECHOPGM(" @:");
+    SERIAL_ECHO(getHeaterPower(target_extruder));
     #if HAS_HEATED_BED
-      SERIAL_ECHOPGM_P(port, " B@:");
-      SERIAL_ECHO_P(port, getHeaterPower(-1));
+      SERIAL_ECHOPGM(" B@:");
+      SERIAL_ECHO(getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
-        SERIAL_ECHOPAIR_P(port, " @", e);
-        SERIAL_CHAR_P(port, ':');
-        SERIAL_ECHO_P(port, getHeaterPower(e));
+        SERIAL_ECHOPAIR(" @", e);
+        SERIAL_CHAR(':');
+        SERIAL_ECHO(getHeaterPower(e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bc14eebe0a..0cd526b33c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 773fa5c40f287d81f9c509405e8be22c2cfb3905
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Feb 12 00:29:17 2019 +0100

    Fix define used when PID is off (#13119)
    
    Replaced `PID_MAX` with `BANG_MAX` since it should be the correct define to be used when PID is not enabled.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1eb2d5623b..bc14eebe0a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -796,21 +796,21 @@ float Temperature::get_pid_output(const int8_t e) {
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
   #else /* PID off */
     #if HEATER_IDLE_HANDLER
       if (heater_idle_timeout_exceeded[HOTEND_INDEX])
         pid_output = 0;
       else
     #endif
-    pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
+    pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? BANG_MAX : 0;
   #endif
 
   return pid_output;
 }
 
 #if ENABLED(PIDTEMPBED)
 
   float Temperature::get_pid_output_bed() {
 
     #if DISABLED(PID_OPENLOOP)

commit 7ee35c261102a8ed2db4b77a45ea7d4b3f19d416
Author: LinFor <linfor@gmail.com>
Date:   Sun Feb 10 13:03:18 2019 +0300

    PID_MENU option to save PROGMEM in LCD menus (#13095)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b909caf158..1eb2d5623b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -701,28 +701,28 @@ void Temperature::min_temp_error(const int8_t heater) {
   _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }
 
 float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST true
   #else
     #define _HOTEND_TEST (e == active_extruder)
   #endif
+  float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       static hotend_pid_t work_pid[HOTENDS];
       static float temp_iState[HOTENDS] = { 0 },
                    temp_dState[HOTENDS] = { 0 };
       static bool pid_reset[HOTENDS] = { false };
-      float pid_output,
-            pid_error = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
+      float pid_error = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
       work_pid[HOTEND_INDEX].Kd = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + float(PID_K1) * work_pid[HOTEND_INDEX].Kd;
       temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
       #if HEATER_IDLE_HANDLER
         if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
           pid_output = 0;
           pid_reset[HOTEND_INDEX] = true;
         }
         else
       #endif
           if (pid_error > PID_FUNCTIONAL_RANGE) {

commit 0e37fe87767c26675d3e320f2d0eb03ac9af1a3c
Author: AnHardt <github@kitelab.de>
Date:   Sun Feb 10 10:54:45 2019 +0100

    Apply minimum C in M303 (#13113)
    
    Apply minimum `C` in `M303`. `PID_autotune()` needs to be called with a 'C'ycles-parameter >2 to give meaningful (different from 0) PID-factors. Therefore silently raise C to 3. Fixing one aspect of #13104

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cf6e16c24a..b909caf158 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -323,20 +323,22 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
+   * Needs sufficient heater power to make some overshoot at target
+   * temperature to succeed.
    */
   void Temperature::PID_autotune(const float &target, const int8_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
@@ -533,21 +535,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_ECHOLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
-      if (cycles > ncycles) {
+      if (cycles > ncycles && cycles > 2) {
         SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), PSTR(""));
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
           say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #elif ENABLED(PIDTEMP)
           say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
           say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);

commit 3c49396370a38b43e51694d4dc0b3708eae24536
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 5 22:56:13 2019 -0600

    Fix compile error with DUE + MAX6675 (#13086)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a201fee31b..cf6e16c24a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -26,21 +26,23 @@
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/shared/Delay.h"
 
-#if ENABLED(HEATER_0_USES_MAX6675)
+#define MAX6675_SEPARATE_SPI (ENABLED(HEATER_0_USES_MAX6675) || ENABLED(HEATER_1_USES_MAX6675)) && PIN_EXISTS(MAX6675_SCK) && PIN_EXISTS(MAX6675_DO)
+
+#if MAX6675_SEPARATE_SPI
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) || ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
@@ -1198,27 +1200,21 @@ void Temperature::updateTemperaturesFromRawValues() {
    * a return value of 1.
    */
   int8_t Temperature::widthFil_to_size_ratio() {
     if (ABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
       return int(100.0f * filament_width_nominal / filament_width_meas) - 100;
     return 0;
   }
 
 #endif
 
-#if ENABLED(HEATER_0_USES_MAX6675)
-  #ifndef MAX6675_SCK_PIN
-    #define MAX6675_SCK_PIN SCK_PIN
-  #endif
-  #ifndef MAX6675_DO_PIN
-    #define MAX6675_DO_PIN MISO_PIN
-  #endif
+#if MAX6675_SEPARATE_SPI
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
@@ -1282,32 +1278,32 @@ void Temperature::init() {
     #endif
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     SET_OUTPUT(CONTROLLER_FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
       setPwmFrequency(CONTROLLER_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
   #endif
 
-  #if ENABLED(HEATER_0_USES_MAX6675)
+  #if MAX6675_SEPARATE_SPI
 
     OUT_WRITE(SCK_PIN, LOW);
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
     max6675_spi.init();
 
     OUT_WRITE(SS_PIN, HIGH);
     OUT_WRITE(MAX6675_SS_PIN, HIGH);
 
-  #endif // HEATER_0_USES_MAX6675
+  #endif
 
   #if ENABLED(HEATER_1_USES_MAX6675)
     OUT_WRITE(MAX6675_SS2_PIN, HIGH);
   #endif
 
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
@@ -1785,42 +1781,42 @@ void Temperature::disable_all_heaters() {
         #else
           max6675_temp_previous[hindex] // Need to return the correct previous value
         #endif
       );
 
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
-    #if MB(MIGHTYBOARD_REVE)
+    #if MAX6675_SEPARATE_SPI
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
     #if COUNT_6675 > 1
       #define WRITE_MAX6675(V) do{ switch (hindex) { case 1: WRITE(MAX6675_SS2_PIN, V); break; default: WRITE(MAX6675_SS_PIN, V); } }while(0)
     #elif ENABLED(HEATER_1_USES_MAX6675)
       #define WRITE_MAX6675(V) WRITE(MAX6675_SS2_PIN, V)
     #else
       #define WRITE_MAX6675(V) WRITE(MAX6675_SS_PIN, V)
     #endif
 
     WRITE_MAX6675(LOW);  // enable TT_MAX6675
 
     DELAY_NS(100);       // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
       max6675_temp |= (
-        #if MB(MIGHTYBOARD_REVE)
+        #if MAX6675_SEPARATE_SPI
           max6675_spi.receive()
         #else
           spiRec()
         #endif
       );
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     WRITE_MAX6675(HIGH); // disable TT_MAX6675
 

commit 6fb4001b586467ed6965b944e2cf853c4afeac7b
Author: Nicolas G <ketchu13@hotmail.com>
Date:   Mon Feb 4 07:12:41 2019 +0100

    Add option to disable fan speed slowing in M303 (#13066)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0cb8b04349..a201fee31b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -89,20 +89,24 @@ Temperature thermalManager;
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
     (HOTENDS > 5 && (E) == 5) ? PSTR(MSG_E6 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #endif
 
 // public:
 
+#if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
+  bool Temperature::adaptive_fan_slowing = true;
+#endif
+
 float Temperature::current_temperature[HOTENDS]; // = { 0.0 };
 int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
         Temperature::target_temperature[HOTENDS]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if FAN_COUNT > 0
 
@@ -385,20 +389,24 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
     disable_all_heaters();
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(current_temperature_bed, current_temperature[heater]);
       LEDColor color = ONHEATINGSTART();
     #endif
 
+    #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
+      adaptive_fan_slowing = false;
+    #endif
+
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
         current = GHV(current_temperature_bed, current_temperature[heater]);
@@ -563,32 +571,41 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
             if (heater < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
+
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onPidTuningDone(color);
         #endif
 
-        return;
+        goto EXIT_M303;
       }
       ui.update();
     }
+
     disable_all_heaters();
+
     #if ENABLED(PRINTER_EVENT_LEDS)
       printerEventLEDs.onPidTuningDone(color);
     #endif
+
+    EXIT_M303:
+      #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
+        adaptive_fan_slowing = true;
+      #endif
+      return;
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
@@ -1620,22 +1637,22 @@ void Temperature::init() {
       case TRInactive: break;
 
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < tr_target_temperature[heater_index]) break;
         *state = TRStable;
 
       // While the temperature is stable watch for a bad temperature
       case TRStable:
 
-        #if ENABLED(ADAPTIVE_FAN_SLOWING) && FAN_COUNT > 0
-          if (heater_id >= 0) {
+        #if ENABLED(ADAPTIVE_FAN_SLOWING)
+          if (adaptive_fan_slowing && heater_id >= 0) {
             const int fan_index = MIN(heater_id, FAN_COUNT - 1);
             if (fan_speed[fan_index] == 0 || current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.25f))
               fan_speed_scaler[fan_index] = 128;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.3335f))
               fan_speed_scaler[fan_index] = 96;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.5f))
               fan_speed_scaler[fan_index] = 64;
             else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.8f))
               fan_speed_scaler[fan_index] = 32;
             else

commit 24fffb8d93e73cf6030f9dce2440981a9d8f6b1e
Author: Jiri <comps@users.noreply.github.com>
Date:   Thu Jan 24 23:34:40 2019 +0100

    Fix undefined lcd_tmpfan_speed on NO_LCD_MENUS (#13006)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 35086ec034..0cb8b04349 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -157,21 +157,21 @@ int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
     if (target >= FAN_COUNT) return;
 
     fan_speed[target] = speed;
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_LCD_MENU
       lcd_tmpfan_speed[target] = speed;
     #endif
   }
 
   #if ENABLED(PROBING_FANS_OFF)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {
         fans_paused = p;
         if (p)

commit acf266fe781d6d4bdad7beeb387b70c24cf2e213
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jan 20 01:47:29 2019 +0100

    Fix a compile warning, etc. (#12955)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 93cadd0641..35086ec034 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -104,21 +104,21 @@ int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
   uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
 #if FAN_COUNT > 0
 
   uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
 
   #if ENABLED(EXTRA_FAN_SPEED)
     uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
 
-    void Temperature::set_temp_fan_speed(const uint8_t fan, const int16_t tmp_temp) {
+    void Temperature::set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp) {
       switch (tmp_temp) {
         case 1:
           set_fan_speed(fan, old_fan_speed[fan]);
           break;
         case 2:
           old_fan_speed[fan] = fan_speed[fan];
           set_fan_speed(fan, new_fan_speed[fan]);
           break;
         default:
           new_fan_speed[fan] = MIN(tmp_temp, 255U);

commit 712e23c3835b582e9098fc8e9f0b13d8fb0fb5a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 17 18:03:58 2019 -0600

    Fix up some whitespace

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6e1c93d752..93cadd0641 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -155,21 +155,21 @@ int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
 
     #if ENABLED(SINGLENOZZLE)
       if (target != active_extruder) {
         if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
         return;
       }
       target = 0; // Always use fan index 0 with SINGLENOZZLE
     #endif
 
     if (target >= FAN_COUNT) return;
-    
+
     fan_speed[target] = speed;
     #if ENABLED(ULTRA_LCD)
       lcd_tmpfan_speed[target] = speed;
     #endif
   }
 
   #if ENABLED(PROBING_FANS_OFF)
 
     void Temperature::set_fans_paused(const bool p) {
       if (p != fans_paused) {

commit 7fde8d9d1e264c09246b0c7f64fc5c56b3752cd6
Author: mikeshub <mikesbaker@gmail.com>
Date:   Mon Jan 14 14:29:55 2019 -0600

    Add CreatorPro / Makerbot / QIDI / etc and Mightboard RevE support (#12855)
    
    - Fix a bug in MAXxxxx thermocouple temp reporting.
    - Add support for 3-wire HD44780.
    - Add support for PCA9533 RGB driver.
    - Add configuration examples for FlashForge CreatorPro.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e08b2332b4..6e1c93d752 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1732,40 +1732,51 @@ void Temperature::disable_all_heaters() {
 
 #if HAS_MAX6675
 
   int Temperature::read_max6675(
     #if COUNT_6675 > 1
       const uint8_t hindex
     #endif
   ) {
     #if COUNT_6675 == 1
       constexpr uint8_t hindex = 0;
+    #else
+      // Needed to return the correct temp when this is called too soon
+      static uint16_t max6675_temp_previous[COUNT_6675] = { 0 };
     #endif
 
     #define MAX6675_HEAT_INTERVAL 250UL
 
     #if ENABLED(MAX6675_IS_MAX31855)
       static uint32_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    7
       #define MAX6675_DISCARD_BITS 18
       #define MAX6675_SPEED_BITS    3  // (_BV(SPR1)) // clock √∑ 64
     #else
       static uint16_t max6675_temp = 2000;
       #define MAX6675_ERROR_MASK    4
       #define MAX6675_DISCARD_BITS  3
       #define MAX6675_SPEED_BITS    2  // (_BV(SPR0)) // clock √∑ 16
     #endif
 
     // Return last-read value between readings
     static millis_t next_max6675_ms[COUNT_6675] = { 0 };
     millis_t ms = millis();
-    if (PENDING(ms, next_max6675_ms[hindex])) return int(max6675_temp);
+    if (PENDING(ms, next_max6675_ms[hindex]))
+      return int(
+        #if COUNT_6675 == 1
+          max6675_temp
+        #else
+          max6675_temp_previous[hindex] // Need to return the correct previous value
+        #endif
+      );
+
     next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
     //
     // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
     //
     #if MB(MIGHTYBOARD_REVE)
       spiBegin();
       spiInit(MAX6675_SPEED_BITS);
     #endif
 
@@ -1817,24 +1828,28 @@ void Temperature::disable_all_heaters() {
           hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
         #elif ENABLED(HEATER_1_USES_MAX6675)
           HEATER_1_MAX6675_TMAX
         #else
           HEATER_0_MAX6675_TMAX
         #endif
       );
     }
     else
       max6675_temp >>= MAX6675_DISCARD_BITS;
-      #if ENABLED(MAX6675_IS_MAX31855)
-        // Support negative temperature
-        if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
-      #endif
+
+    #if ENABLED(MAX6675_IS_MAX31855)
+      if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000; // Support negative temperature
+    #endif
+
+    #if COUNT_6675 > 1
+      max6675_temp_previous[hindex] = max6675_temp;
+    #endif
 
     return int(max6675_temp);
   }
 
 #endif // HAS_MAX6675
 
 /**
  * Get raw temperatures
  */
 void Temperature::set_current_temp_raw() {

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 915bb5a859..e08b2332b4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -48,20 +48,24 @@
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
+#if ENABLED(SINGLENOZZLE)
+  #include "tool_change.h"
+#endif
+
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   #endif
 #endif
 
@@ -85,28 +89,113 @@ Temperature thermalManager;
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
     (HOTENDS > 5 && (E) == 5) ? PSTR(MSG_E6 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #endif
 
 // public:
 
-float Temperature::current_temperature[HOTENDS] = { 0.0 };
-int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
-        Temperature::target_temperature[HOTENDS] = { 0 };
+float Temperature::current_temperature[HOTENDS]; // = { 0.0 };
+int16_t Temperature::current_temperature_raw[HOTENDS], // = { 0 }
+        Temperature::target_temperature[HOTENDS]; // = { 0 }
 
 #if ENABLED(AUTO_POWER_E_FANS)
-  uint8_t Temperature::autofan_speed[HOTENDS] = { 0 };
+  uint8_t Temperature::autofan_speed[HOTENDS]; // = { 0 }
 #endif
 
+#if FAN_COUNT > 0
+
+  uint8_t Temperature::fan_speed[FAN_COUNT]; // = { 0 }
+
+  #if ENABLED(EXTRA_FAN_SPEED)
+    uint8_t Temperature::old_fan_speed[FAN_COUNT], Temperature::new_fan_speed[FAN_COUNT];
+
+    void Temperature::set_temp_fan_speed(const uint8_t fan, const int16_t tmp_temp) {
+      switch (tmp_temp) {
+        case 1:
+          set_fan_speed(fan, old_fan_speed[fan]);
+          break;
+        case 2:
+          old_fan_speed[fan] = fan_speed[fan];
+          set_fan_speed(fan, new_fan_speed[fan]);
+          break;
+        default:
+          new_fan_speed[fan] = MIN(tmp_temp, 255U);
+          break;
+      }
+    }
+
+  #endif
+
+  #if ENABLED(PROBING_FANS_OFF)
+    bool Temperature::fans_paused; // = false;
+    uint8_t Temperature::paused_fan_speed[FAN_COUNT]; // = { 0 }
+  #endif
+
+  #if ENABLED(ADAPTIVE_FAN_SLOWING)
+    uint8_t Temperature::fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
+  #endif
+
+  #if HAS_LCD_MENU
+
+    uint8_t Temperature::lcd_tmpfan_speed[
+      #if ENABLED(SINGLENOZZLE)
+        MAX(EXTRUDERS, FAN_COUNT)
+      #else
+        FAN_COUNT
+      #endif
+    ]; // = { 0 }
+
+  #endif
+
+  void Temperature::set_fan_speed(uint8_t target, uint16_t speed) {
+
+    NOMORE(speed, 255U);
+
+    #if ENABLED(SINGLENOZZLE)
+      if (target != active_extruder) {
+        if (target < EXTRUDERS) singlenozzle_fan_speed[target] = speed;
+        return;
+      }
+      target = 0; // Always use fan index 0 with SINGLENOZZLE
+    #endif
+
+    if (target >= FAN_COUNT) return;
+    
+    fan_speed[target] = speed;
+    #if ENABLED(ULTRA_LCD)
+      lcd_tmpfan_speed[target] = speed;
+    #endif
+  }
+
+  #if ENABLED(PROBING_FANS_OFF)
+
+    void Temperature::set_fans_paused(const bool p) {
+      if (p != fans_paused) {
+        fans_paused = p;
+        if (p)
+          for (uint8_t x = 0; x < FAN_COUNT; x++) {
+            paused_fan_speed[x] = fan_speed[x];
+            fan_speed[x] = 0;
+          }
+        else
+          for (uint8_t x = 0; x < FAN_COUNT; x++)
+            fan_speed[x] = paused_fan_speed[x];
+      }
+    }
+
+  #endif // PROBING_FANS_OFF
+
+#endif // FAN_COUNT > 0
+
 #if HAS_HEATED_BED
   float Temperature::current_temperature_bed = 0.0;
   int16_t Temperature::current_temperature_bed_raw = 0,
           Temperature::target_temperature_bed = 0;
   uint8_t Temperature::soft_pwm_amount_bed;
   #ifdef BED_MINTEMP
     int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
@@ -1522,32 +1611,52 @@ void Temperature::init() {
       // If the target temperature changes, restart
       if (tr_target_temperature[heater_index] != target) {
         tr_target_temperature[heater_index] = target;
         *state = target > 0 ? TRFirstHeating : TRInactive;
       }
     }
 
     switch (*state) {
       // Inactive state waits for a target temperature to be set
       case TRInactive: break;
+
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < tr_target_temperature[heater_index]) break;
         *state = TRStable;
+
       // While the temperature is stable watch for a bad temperature
       case TRStable:
+
+        #if ENABLED(ADAPTIVE_FAN_SLOWING) && FAN_COUNT > 0
+          if (heater_id >= 0) {
+            const int fan_index = MIN(heater_id, FAN_COUNT - 1);
+            if (fan_speed[fan_index] == 0 || current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.25f))
+              fan_speed_scaler[fan_index] = 128;
+            else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.3335f))
+              fan_speed_scaler[fan_index] = 96;
+            else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.5f))
+              fan_speed_scaler[fan_index] = 64;
+            else if (current >= tr_target_temperature[heater_id] - (hysteresis_degc * 0.8f))
+              fan_speed_scaler[fan_index] = 32;
+            else
+              fan_speed_scaler[fan_index] = 0;
+          }
+        #endif
+
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
           *timer = millis() + period_seconds * 1000UL;
           break;
         }
         else if (PENDING(millis(), *timer)) break;
         *state = TRRunaway;
+
       case TRRunaway:
         _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater_id));
     }
   }
 
 #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)

commit 459f4fef6033aa48eb7bc188a42025841d62dcea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 11 22:54:15 2019 -0600

    Fix Temperature::init bug with HEATER_4_PIN

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8adcd8c67e..915bb5a859 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1142,21 +1142,21 @@ void Temperature::init() {
   #if HAS_HEATER_1
     OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
     OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
   #endif
   #if HAS_HEATER_3
     OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
-    OUT_WRITE(HEATER_3_PIN, HEATER_4_INVERTING);
+    OUT_WRITE(HEATER_4_PIN, HEATER_4_INVERTING);
   #endif
   #if HAS_HEATED_BED
     OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
   #endif
 
   #if HAS_FAN0
     SET_OUTPUT(FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
       setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif

commit 60cb36bef3644640f2eb1c9d2b30189e41e81ef2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jan 1 14:17:48 2019 -0700

    Misc. improvements (#12747)
    
    * Make ExtUI respect MAXTEMP limits
      - Temperatures are now clamped by MAXTEMP limits rather than arbitrary values.
    * Speed up USB init, add status
      - Speed up USB initialization
      - Show status message if init failed
    * Enable status messages for EXTENSIBLE_UI
    * Adjust max limit to MAX_TEMP - 15
    * Misc. tweaks to formatting, const, etc.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cd0a66d6f4..8adcd8c67e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2463,21 +2463,21 @@ void Temperature::isr() {
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
-  #if ENABLED(ULTRA_LCD)
+  #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
         ui.status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
       #else
         ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 

commit 9d59a9c840820c761ff15647ad58d4d045d3bdcd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 20 16:18:43 2018 -0600

    Followup to #12691 (typo)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 89eaee2ef5..cd0a66d6f4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -279,21 +279,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
-    if (target > GHV(BED_MAXTEMP, maxttemp[heater]) - 15)) {
+    if (target > GHV(BED_MAXTEMP, maxttemp[heater]) - 15) {
       SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 

commit 4dad489a50cb6e5b63968e40ffb3874b70b395b3
Author: Roman Moravƒç√≠k <roman.moravcik@gmail.com>
Date:   Thu Dec 20 22:55:30 2018 +0100

    [2.0.x] Limit PID autotune target to maxtemp-15 (#12691)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c086d29e7a..89eaee2ef5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -279,20 +279,25 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
+    if (target > GHV(BED_MAXTEMP, maxttemp[heater]) - 15)) {
+      SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
+      return;
+    }
+
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(current_temperature_bed, current_temperature[heater]);
       LEDColor color = ONHEATINGSTART();

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index eef5f442af..c086d29e7a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -221,21 +221,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
 
-  inline void say_default_() { SERIAL_PROTOCOLPGM("#define DEFAULT_"); }
+  inline void say_default_() { SERIAL_ECHOPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    */
   void Temperature::PID_autotune(const float &target, const int8_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;
     int cycles = 0;
@@ -336,67 +336,67 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
-              SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
-              SERIAL_PROTOCOLPAIR(MSG_D, d);
-              SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
-              SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
+              SERIAL_ECHOPAIR(MSG_BIAS, bias);
+              SERIAL_ECHOPAIR(MSG_D, d);
+              SERIAL_ECHOPAIR(MSG_T_MIN, min);
+              SERIAL_ECHOPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
                 float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
                       Tu = ((float)(t_low + t_high) * 0.001f);
-                SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
-                SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
+                SERIAL_ECHOPAIR(MSG_KU, Ku);
+                SERIAL_ECHOPAIR(MSG_TU, Tu);
                 tune_pid.Kp = 0.6f * Ku;
                 tune_pid.Ki = 2 * tune_pid.Kp / Tu;
                 tune_pid.Kd = tune_pid.Kp * Tu * 0.125f;
-                SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
-                SERIAL_PROTOCOLPAIR(MSG_KP, tune_pid.Kp);
-                SERIAL_PROTOCOLPAIR(MSG_KI, tune_pid.Ki);
-                SERIAL_PROTOCOLLNPAIR(MSG_KD, tune_pid.Kd);
+                SERIAL_ECHOLNPGM("\n" MSG_CLASSIC_PID);
+                SERIAL_ECHOPAIR(MSG_KP, tune_pid.Kp);
+                SERIAL_ECHOPAIR(MSG_KI, tune_pid.Ki);
+                SERIAL_ECHOLNPAIR(MSG_KD, tune_pid.Kd);
                 /**
                 tune_pid.Kp = 0.33*Ku;
                 tune_pid.Ki = tune_pid.Kp/Tu;
                 tune_pid.Kd = tune_pid.Kp*Tu/3;
-                SERIAL_PROTOCOLLNPGM(" Some overshoot");
-                SERIAL_PROTOCOLPAIR(" Kp: ", tune_pid.Kp);
-                SERIAL_PROTOCOLPAIR(" Ki: ", tune_pid.Ki);
-                SERIAL_PROTOCOLPAIR(" Kd: ", tune_pid.Kd);
+                SERIAL_ECHOLNPGM(" Some overshoot");
+                SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp);
+                SERIAL_ECHOPAIR(" Ki: ", tune_pid.Ki);
+                SERIAL_ECHOPAIR(" Kd: ", tune_pid.Kd);
                 tune_pid.Kp = 0.2*Ku;
                 tune_pid.Ki = 2*tune_pid.Kp/Tu;
                 tune_pid.Kd = tune_pid.Kp*Tu/3;
-                SERIAL_PROTOCOLLNPGM(" No overshoot");
-                SERIAL_PROTOCOLPAIR(" Kp: ", tune_pid.Kp);
-                SERIAL_PROTOCOLPAIR(" Ki: ", tune_pid.Ki);
-                SERIAL_PROTOCOLPAIR(" Kd: ", tune_pid.Kd);
+                SERIAL_ECHOLNPGM(" No overshoot");
+                SERIAL_ECHOPAIR(" Kp: ", tune_pid.Kp);
+                SERIAL_ECHOPAIR(" Ki: ", tune_pid.Ki);
+                SERIAL_ECHOPAIR(" Kd: ", tune_pid.Kd);
                 */
               }
             }
             SHV(soft_pwm_amount, (bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             min = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
       if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
-        SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
+        SERIAL_ECHOLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heater_states(heater >= 0 ? heater : active_extruder);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
@@ -425,40 +425,40 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
               _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
-        SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
+        SERIAL_ECHOLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles) {
-        SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
+        SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char * const estring = GHV(PSTR("bed"), PSTR(""));
-          say_default_(); serialprintPGM(estring); SERIAL_PROTOCOLLNPAIR("Kp ", tune_pid.Kp);
-          say_default_(); serialprintPGM(estring); SERIAL_PROTOCOLLNPAIR("Ki ", tune_pid.Ki);
-          say_default_(); serialprintPGM(estring); SERIAL_PROTOCOLLNPAIR("Kd ", tune_pid.Kd);
+          say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
+          say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
+          say_default_(); serialprintPGM(estring); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #elif ENABLED(PIDTEMP)
-          say_default_(); SERIAL_PROTOCOLLNPAIR("Kp ", tune_pid.Kp);
-          say_default_(); SERIAL_PROTOCOLLNPAIR("Ki ", tune_pid.Ki);
-          say_default_(); SERIAL_PROTOCOLLNPAIR("Kd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOLNPAIR("Kp ", tune_pid.Kp);
+          say_default_(); SERIAL_ECHOLNPAIR("Ki ", tune_pid.Ki);
+          say_default_(); SERIAL_ECHOLNPAIR("Kd ", tune_pid.Kd);
         #else
-          say_default_(); SERIAL_PROTOCOLLNPAIR("bedKp ", tune_pid.Kp);
-          say_default_(); SERIAL_PROTOCOLLNPAIR("bedKi ", tune_pid.Ki);
-          say_default_(); SERIAL_PROTOCOLLNPAIR("bedKd ", tune_pid.Kd);
+          say_default_(); SERIAL_ECHOLNPAIR("bedKp ", tune_pid.Kp);
+          say_default_(); SERIAL_ECHOLNPAIR("bedKi ", tune_pid.Ki);
+          say_default_(); SERIAL_ECHOLNPAIR("bedKd ", tune_pid.Kd);
         #endif
 
         #define _SET_BED_PID() do { \
           bed_pid.Kp = tune_pid.Kp; \
           bed_pid.Ki = scalePID_i(tune_pid.Ki); \
           bed_pid.Kd = scalePID_d(tune_pid.Kd); \
         }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
           PID_PARAM(Kp, heater) = tune_pid.Kp; \
@@ -557,22 +557,22 @@ int Temperature::getHeaterPower(const int heater) {
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
 void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;
   if (IsRunning()) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
-    SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
-    if (heater >= 0) SERIAL_ERRORLN((int)heater); else SERIAL_ERRORLNPGM(MSG_HEATER_BED);
+    SERIAL_ECHOPGM(MSG_STOPPED_HEATER);
+    if (heater >= 0) SERIAL_ECHOLN((int)heater); else SERIAL_ECHOLNPGM(MSG_HEATER_BED);
   }
   #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
     if (!killed) {
       Running = false;
       killed = true;
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #endif
@@ -933,22 +933,22 @@ void Temperature::manage_heater() {
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif
     {
       SERIAL_ERROR_START();
-      SERIAL_ERROR((int)e);
-      SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
+      SERIAL_ECHO((int)e);
+      SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER_NUM);
       kill();
       return 0.0;
     }
 
   switch (e) {
     case 0:
       #if ENABLED(HEATER_0_USES_MAX6675)
         return raw * 0.25;
       #elif ENABLED(HEATER_0_USES_AD595)
         return TEMP_AD595(raw);
@@ -1677,31 +1677,31 @@ void Temperature::disable_all_heaters() {
           spiRec()
         #endif
       );
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     WRITE_MAX6675(HIGH); // disable TT_MAX6675
 
     if (max6675_temp & MAX6675_ERROR_MASK) {
       SERIAL_ERROR_START();
-      SERIAL_ERRORPGM("Temp measurement error! ");
+      SERIAL_ECHOPGM("Temp measurement error! ");
       #if MAX6675_ERROR_MASK == 7
-        SERIAL_ERRORPGM("MAX31855 ");
+        SERIAL_ECHOPGM("MAX31855 ");
         if (max6675_temp & 1)
-          SERIAL_ERRORLNPGM("Open Circuit");
+          SERIAL_ECHOLNPGM("Open Circuit");
         else if (max6675_temp & 2)
-          SERIAL_ERRORLNPGM("Short to GND");
+          SERIAL_ECHOLNPGM("Short to GND");
         else if (max6675_temp & 4)
-          SERIAL_ERRORLNPGM("Short to VCC");
+          SERIAL_ECHOLNPGM("Short to VCC");
       #else
-        SERIAL_ERRORLNPGM("MAX6675");
+        SERIAL_ECHOLNPGM("MAX6675");
       #endif
 
       // Thermocouple open
       max6675_temp = 4 * (
         #if COUNT_6675 > 1
           hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
         #elif ENABLED(HEATER_1_USES_MAX6675)
           HEATER_1_MAX6675_TMAX
         #else
           HEATER_0_MAX6675_TMAX
@@ -2358,41 +2358,41 @@ void Temperature::isr() {
     #endif
     #if NUM_SERIAL > 1
       , const int8_t port=-1
     #endif
     , const int8_t e=-3
   ) {
     #if !(HAS_HEATED_BED && HAS_TEMP_HOTEND && HAS_TEMP_CHAMBER) && HOTENDS <= 1
       UNUSED(e);
     #endif
 
-    SERIAL_PROTOCOLCHAR_P(port, ' ');
-    SERIAL_PROTOCOLCHAR_P(port,
+    SERIAL_CHAR_P(port, ' ');
+    SERIAL_CHAR_P(port,
       #if HAS_TEMP_CHAMBER && HAS_HEATED_BED && HAS_TEMP_HOTEND
         e == -2 ? 'C' : e == -1 ? 'B' : 'T'
       #elif HAS_HEATED_BED && HAS_TEMP_HOTEND
         e == -1 ? 'B' : 'T'
       #elif HAS_TEMP_HOTEND
         'T'
       #else
         'B'
       #endif
     );
     #if HOTENDS > 1
-      if (e >= 0) SERIAL_PROTOCOLCHAR_P(port, '0' + e);
+      if (e >= 0) SERIAL_CHAR_P(port, '0' + e);
     #endif
-    SERIAL_PROTOCOLCHAR_P(port, ':');
-    SERIAL_PROTOCOL_P(port, c);
-    SERIAL_PROTOCOLPAIR_P(port, " /" , t);
+    SERIAL_CHAR_P(port, ':');
+    SERIAL_ECHO_P(port, c);
+    SERIAL_ECHOPAIR_P(port, " /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_PROTOCOLPAIR_P(port, " (", r / OVERSAMPLENR);
-      SERIAL_PROTOCOLCHAR_P(port, ')');
+      SERIAL_ECHOPAIR_P(port, " (", r / OVERSAMPLENR);
+      SERIAL_CHAR_P(port, ')');
     #endif
     delay(2);
   }
 
   void Temperature::print_heater_states(const uint8_t target_extruder
     #if NUM_SERIAL > 1
       , const int8_t port
     #endif
   ) {
     #if HAS_TEMP_HOTEND
@@ -2428,31 +2428,31 @@ void Temperature::isr() {
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , e
       );
     #endif
-    SERIAL_PROTOCOLPGM_P(port, " @:");
-    SERIAL_PROTOCOL_P(port, getHeaterPower(target_extruder));
+    SERIAL_ECHOPGM_P(port, " @:");
+    SERIAL_ECHO_P(port, getHeaterPower(target_extruder));
     #if HAS_HEATED_BED
-      SERIAL_PROTOCOLPGM_P(port, " B@:");
-      SERIAL_PROTOCOL_P(port, getHeaterPower(-1));
+      SERIAL_ECHOPGM_P(port, " B@:");
+      SERIAL_ECHO_P(port, getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
-        SERIAL_PROTOCOLPAIR_P(port, " @", e);
-        SERIAL_PROTOCOLCHAR_P(port, ':');
-        SERIAL_PROTOCOL_P(port, getHeaterPower(e));
+        SERIAL_ECHOPAIR_P(port, " @", e);
+        SERIAL_CHAR_P(port, ':');
+        SERIAL_ECHO_P(port, getHeaterPower(e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {
@@ -2521,25 +2521,25 @@ void Temperature::isr() {
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { // Print temp & remaining time every 1s while waiting
           next_temp_ms = now + 1000UL;
           print_heater_states(target_extruder);
           #if TEMP_RESIDENCY_TIME > 0
-            SERIAL_PROTOCOLPGM(" W:");
+            SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
-              SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+              SERIAL_ECHO(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
             else
-              SERIAL_PROTOCOLCHAR('?');
+              SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degHotend(target_extruder);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
@@ -2644,25 +2644,25 @@ void Temperature::isr() {
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
           print_heater_states(active_extruder);
           #if TEMP_BED_RESIDENCY_TIME > 0
-            SERIAL_PROTOCOLPGM(" W:");
+            SERIAL_ECHOPGM(" W:");
             if (residency_start_ms)
-              SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+              SERIAL_ECHO(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
             else
-              SERIAL_PROTOCOLCHAR('?');
+              SERIAL_CHAR('?');
           #endif
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degBed();
 
         #if ENABLED(PRINTER_EVENT_LEDS)

commit 03ef2d6c82048564db284bc3965595c561bf5840
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 28 19:28:31 2018 -0600

    Fix "paused" message and M125 called by M25 (#12551)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 71624a266b..eef5f442af 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1915,21 +1915,21 @@ void Temperature::isr() {
   #if DISABLED(SLOW_PWM_HEATERS)
     constexpr uint8_t pwm_mask =
       #if ENABLED(SOFT_PWM_DITHER)
         _BV(SOFT_PWM_SCALE) - 1
       #else
         0
       #endif
     ;
 
     /**
-     * Standard PWM modulation
+     * Standard heater PWM modulation
      */
     if (pwm_count_tmp >= 127) {
       pwm_count_tmp -= 127;
       soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
       WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
       #if HOTENDS > 1
         soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
         WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
         #if HOTENDS > 2
           soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];

commit 09d6db491a6263b1ec02cea74cd4f416cdb7e34f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 25 18:05:18 2018 -0600

    Fix wait_for_bed compile error

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5756eda8ac..71624a266b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2600,21 +2600,21 @@ void Temperature::isr() {
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
       #define MIN_COOLING_SLOPE_DEG_BED 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_BED
       #define MIN_COOLING_SLOPE_TIME_BED 60
     #endif
 
-    bool Temperature::wait_for_bed(const bool no_wait_for_cooling
+    bool Temperature::wait_for_bed(const bool no_wait_for_cooling/*=true*/
       #if G26_CLICK_CAN_CANCEL
         , const bool click_to_cancel/*=false*/
       #endif
     ) {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         // Loop until the temperature has stabilized
         #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target

commit 8a0992d921aa11e01136fe2745c4bb0a8e368d7c
Author: Sinisa Culic <sc@dig.at>
Date:   Fri Nov 23 23:03:39 2018 +0100

    Fast PWM for controller fan (#12485)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 46b88b10f7..5756eda8ac 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1164,20 +1164,27 @@ void Temperature::init() {
     #endif
   #endif
 
   #if HAS_FAN2
     SET_OUTPUT(FAN2_PIN);
     #if ENABLED(FAST_PWM_FAN)
       setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
   #endif
 
+  #if ENABLED(USE_CONTROLLER_FAN)
+    SET_OUTPUT(CONTROLLER_FAN_PIN);
+    #if ENABLED(FAST_PWM_FAN)
+      setPwmFrequency(CONTROLLER_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+    #endif
+  #endif
+
   #if ENABLED(HEATER_0_USES_MAX6675)
 
     OUT_WRITE(SCK_PIN, LOW);
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
     max6675_spi.init();
 
     OUT_WRITE(SS_PIN, HIGH);
     OUT_WRITE(MAX6675_SS_PIN, HIGH);

commit 1f93d2bcf70f1cbe63ac9f21892543663723c8f3
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Nov 19 03:39:49 2018 +0100

    Fix LCD compile error, etc. (#12472)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 57f782e9ed..46b88b10f7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -210,21 +210,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 #if HEATER_IDLE_HANDLER
   millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
   bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
 #endif
 
-#if ENABLED(ADC_KEYPAD)
+#if HAS_ADC_BUTTONS
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
 
@@ -1862,21 +1862,21 @@ HAL_TEMP_TIMER_ISR {
 }
 
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
 
-  #if ENABLED(ADC_KEYPAD)
+  #if HAS_ADC_BUTTONS
     static unsigned int raw_ADCKey_value = 0;
   #endif
 
   // Static members for each heater
   #if ENABLED(SLOW_PWM_HEATERS)
     static uint8_t slow_pwm_count = 0;
     #define ISR_STATICS(n) \
       static uint8_t soft_pwm_count_ ## n, \
                      state_heater_ ## n = 0, \
                      state_timer_heater_ ## n = 0
@@ -2283,21 +2283,21 @@ void Temperature::isr() {
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
           raw_filwidth_value -= raw_filwidth_value >> 7; // Subtract 1/128th of the raw_filwidth_value
           raw_filwidth_value += uint32_t(HAL_READ_ADC()) << 7; // Add new ADC reading, scaled by 128
         }
       break;
     #endif
 
-    #if ENABLED(ADC_KEYPAD)
+    #if HAS_ADC_BUTTONS
       case Prepare_ADC_KEY:
         HAL_START_ADC(ADC_KEYPAD_PIN);
         break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (ADCKey_count < 16) {
           raw_ADCKey_value = HAL_READ_ADC();
           if (raw_ADCKey_value > 900) {
             //ADC Key release

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 489a06dc54..57f782e9ed 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2457,21 +2457,21 @@ void Temperature::isr() {
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if ENABLED(ULTRA_LCD)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
         ui.status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
       #else
-        ui.setstatusPGM(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
+        ui.set_status_P(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME

commit d3605cfc26074b54071ea26a50bf4a121539a0b4
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Nov 18 04:53:52 2018 +0100

    Don't start watching heaters when target is 0 (#12453)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ce483d9144..489a06dc54 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1429,37 +1429,37 @@ void Temperature::init() {
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_heater(const uint8_t e) {
     #if HOTENDS == 1
       UNUSED(e);
     #endif
-    if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
+    if (degTargetHotend(HOTEND_INDEX) && degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
       watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
       watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_heater_next_ms[HOTEND_INDEX] = 0;
   }
 #endif
 
 #if WATCH_THE_BED
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M140, M190)
    */
   void Temperature::start_watching_bed() {
-    if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
+    if (degTargetBed() && degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
       watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
       watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_bed_next_ms = 0;
   }
 #endif
 
 #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 

commit ca21ac6b9bac188560c4d316ecf1b257d3f0cec8
Author: Mateusz Krawczuk <mat.krawczuk@gmail.com>
Date:   Sat Nov 17 01:20:33 2018 +0100

    Support two MAX6675 thermocouples (#8686)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 72abb12f46..ce483d9144 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -768,22 +768,27 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (current_temperature[0] > MIN(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
-    if (current_temperature[0] < MAX(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
+    if (current_temperature[0] > MIN(HEATER_0_MAXTEMP, HEATER_0_MAX6675_TMAX - 1.0)) max_temp_error(0);
+    if (current_temperature[0] < MAX(HEATER_0_MINTEMP, HEATER_0_MAX6675_TMIN + .01)) min_temp_error(0);
+  #endif
+
+  #if ENABLED(HEATER_1_USES_MAX6675)
+    if (current_temperature[1] > MIN(HEATER_1_MAXTEMP, HEATER_1_MAX6675_TMAX - 1.0)) max_temp_error(1);
+    if (current_temperature[1] < MAX(HEATER_1_MINTEMP, HEATER_1_MAX6675_TMIN + .01)) min_temp_error(1);
   #endif
 
   #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   HOTEND_LOOP() {
 
     #if HEATER_IDLE_HANDLER
       if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
@@ -946,21 +951,23 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
       #if ENABLED(HEATER_0_USES_MAX6675)
         return raw * 0.25;
       #elif ENABLED(HEATER_0_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_0_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 1:
-      #if ENABLED(HEATER_1_USES_AD595)
+      #if ENABLED(HEATER_1_USES_MAX6675)
+        return raw * 0.25;
+      #elif ENABLED(HEATER_1_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_1_USES_AD8495)
         return TEMP_AD8495(raw);
       #else
         break;
       #endif
     case 2:
       #if ENABLED(HEATER_2_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_2_USES_AD8495)
@@ -1029,21 +1036,24 @@ float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
 #endif // HAS_TEMP_CHAMBER
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
-    current_temperature_raw[0] = read_max6675();
+    current_temperature_raw[0] = READ_MAX6675(0);
+  #endif
+  #if ENABLED(HEATER_1_USES_MAX6675)
+    current_temperature_raw[1] = READ_MAX6675(1);
   #endif
   HOTEND_LOOP() current_temperature[e] = analog_to_celsius_hotend(current_temperature_raw[e], e);
   #if HAS_HEATED_BED
     current_temperature_bed = analog_to_celsius_bed(current_temperature_bed_raw);
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber = analog_to_celsiusChamber(current_temperature_chamber_raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
@@ -1163,24 +1173,28 @@ void Temperature::init() {
 
   #if ENABLED(HEATER_0_USES_MAX6675)
 
     OUT_WRITE(SCK_PIN, LOW);
     OUT_WRITE(MOSI_PIN, HIGH);
     SET_INPUT_PULLUP(MISO_PIN);
 
     max6675_spi.init();
 
     OUT_WRITE(SS_PIN, HIGH);
-    OUT_WRITE(MAX6675_SS, HIGH);
+    OUT_WRITE(MAX6675_SS_PIN, HIGH);
 
   #endif // HEATER_0_USES_MAX6675
 
+  #if ENABLED(HEATER_1_USES_MAX6675)
+    OUT_WRITE(MAX6675_SS2_PIN, HIGH);
+  #endif
+
   HAL_adc_init();
 
   #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
   #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
   #if HAS_TEMP_ADC_2
     HAL_ANALOG_SELECT(TEMP_2_PIN);
@@ -1588,115 +1602,154 @@ void Temperature::disable_all_heaters() {
         HOTEND_LOOP() reset_heater_idle_timer(e);
         #if HAS_HEATED_BED
           reset_bed_idle_timer();
         #endif
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
-#if ENABLED(HEATER_0_USES_MAX6675)
-
-  #define MAX6675_HEAT_INTERVAL 250u
+#if HAS_MAX6675
 
-  #if ENABLED(MAX6675_IS_MAX31855)
-    uint32_t max6675_temp = 2000;
-    #define MAX6675_ERROR_MASK 7
-    #define MAX6675_DISCARD_BITS 18
-    #define MAX6675_SPEED_BITS 3  // (_BV(SPR1)) // clock √∑ 64
-  #else
-    uint16_t max6675_temp = 2000;
-    #define MAX6675_ERROR_MASK 4
-    #define MAX6675_DISCARD_BITS 3
-    #define MAX6675_SPEED_BITS 2 // (_BV(SPR0)) // clock √∑ 16
-  #endif
+  int Temperature::read_max6675(
+    #if COUNT_6675 > 1
+      const uint8_t hindex
+    #endif
+  ) {
+    #if COUNT_6675 == 1
+      constexpr uint8_t hindex = 0;
+    #endif
 
-  int Temperature::read_max6675() {
+    #define MAX6675_HEAT_INTERVAL 250UL
 
-    static millis_t next_max6675_ms = 0;
+    #if ENABLED(MAX6675_IS_MAX31855)
+      static uint32_t max6675_temp = 2000;
+      #define MAX6675_ERROR_MASK    7
+      #define MAX6675_DISCARD_BITS 18
+      #define MAX6675_SPEED_BITS    3  // (_BV(SPR1)) // clock √∑ 64
+    #else
+      static uint16_t max6675_temp = 2000;
+      #define MAX6675_ERROR_MASK    4
+      #define MAX6675_DISCARD_BITS  3
+      #define MAX6675_SPEED_BITS    2  // (_BV(SPR0)) // clock √∑ 16
+    #endif
 
+    // Return last-read value between readings
+    static millis_t next_max6675_ms[COUNT_6675] = { 0 };
     millis_t ms = millis();
+    if (PENDING(ms, next_max6675_ms[hindex])) return int(max6675_temp);
+    next_max6675_ms[hindex] = ms + MAX6675_HEAT_INTERVAL;
 
-    if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
-
-    next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
+    //
+    // TODO: spiBegin, spiRec and spiInit doesn't work when soft spi is used.
+    //
+    #if MB(MIGHTYBOARD_REVE)
+      spiBegin();
+      spiInit(MAX6675_SPEED_BITS);
+    #endif
 
-    spiBegin();
-    spiInit(MAX6675_SPEED_BITS);
+    #if COUNT_6675 > 1
+      #define WRITE_MAX6675(V) do{ switch (hindex) { case 1: WRITE(MAX6675_SS2_PIN, V); break; default: WRITE(MAX6675_SS_PIN, V); } }while(0)
+    #elif ENABLED(HEATER_1_USES_MAX6675)
+      #define WRITE_MAX6675(V) WRITE(MAX6675_SS2_PIN, V)
+    #else
+      #define WRITE_MAX6675(V) WRITE(MAX6675_SS_PIN, V)
+    #endif
 
-    WRITE(MAX6675_SS, 0); // enable TT_MAX6675
+    WRITE_MAX6675(LOW);  // enable TT_MAX6675
 
     DELAY_NS(100);       // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
-      max6675_temp |= spiRec();
+      max6675_temp |= (
+        #if MB(MIGHTYBOARD_REVE)
+          max6675_spi.receive()
+        #else
+          spiRec()
+        #endif
+      );
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
-    WRITE(MAX6675_SS, 1); // disable TT_MAX6675
+    WRITE_MAX6675(HIGH); // disable TT_MAX6675
 
     if (max6675_temp & MAX6675_ERROR_MASK) {
       SERIAL_ERROR_START();
       SERIAL_ERRORPGM("Temp measurement error! ");
       #if MAX6675_ERROR_MASK == 7
         SERIAL_ERRORPGM("MAX31855 ");
         if (max6675_temp & 1)
           SERIAL_ERRORLNPGM("Open Circuit");
         else if (max6675_temp & 2)
           SERIAL_ERRORLNPGM("Short to GND");
         else if (max6675_temp & 4)
           SERIAL_ERRORLNPGM("Short to VCC");
       #else
         SERIAL_ERRORLNPGM("MAX6675");
       #endif
-      max6675_temp = MAX6675_TMAX * 4; // thermocouple open
+
+      // Thermocouple open
+      max6675_temp = 4 * (
+        #if COUNT_6675 > 1
+          hindex ? HEATER_1_MAX6675_TMAX : HEATER_0_MAX6675_TMAX
+        #elif ENABLED(HEATER_1_USES_MAX6675)
+          HEATER_1_MAX6675_TMAX
+        #else
+          HEATER_0_MAX6675_TMAX
+        #endif
+      );
     }
     else
       max6675_temp >>= MAX6675_DISCARD_BITS;
       #if ENABLED(MAX6675_IS_MAX31855)
         // Support negative temperature
         if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
       #endif
 
-    return (int)max6675_temp;
+    return int(max6675_temp);
   }
 
-#endif // HEATER_0_USES_MAX6675
+#endif // HAS_MAX6675
 
 /**
  * Get raw temperatures
  */
 void Temperature::set_current_temp_raw() {
+
   #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = raw_temp_value[0];
   #endif
+
   #if HAS_TEMP_ADC_1
+
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = raw_temp_value[1];
-    #else
+    #elif DISABLED(HEATER_1_USES_MAX6675)
       current_temperature_raw[1] = raw_temp_value[1];
     #endif
+
     #if HAS_TEMP_ADC_2
       current_temperature_raw[2] = raw_temp_value[2];
       #if HAS_TEMP_ADC_3
         current_temperature_raw[3] = raw_temp_value[3];
         #if HAS_TEMP_ADC_4
           current_temperature_raw[4] = raw_temp_value[4];
           #if HAS_TEMP_ADC_5
             current_temperature_raw[5] = raw_temp_value[5];
           #endif // HAS_TEMP_ADC_5
         #endif // HAS_TEMP_ADC_4
       #endif // HAS_TEMP_ADC_3
     #endif // HAS_TEMP_ADC_2
+
   #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
     current_temperature_bed_raw = raw_temp_bed_value;
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber_raw = raw_temp_chamber_value;
   #endif
   temp_meas_ready = true;
 }
@@ -1764,31 +1817,31 @@ void Temperature::readings_ready() {
           min_temp_error(e);
     }
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       else
         consecutive_low_temperature_error[e] = 0;
     #endif
   }
 
   #if HAS_HEATED_BED
     #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
-      #define GEBED <=
+      #define BEDCMP(A,B) ((A)<=(B))
     #else
-      #define GEBED >=
+      #define BEDCMP(A,B) ((A)>=(B))
     #endif
     const bool bed_on = (target_temperature_bed > 0)
       #if ENABLED(PIDTEMPBED)
         || (soft_pwm_amount_bed > 0)
       #endif
     ;
-    if (current_temperature_bed_raw GEBED bed_maxttemp_raw) max_temp_error(-1);
-    if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
+    if (BEDCMP(current_temperature_bed_raw, bed_maxttemp_raw)) max_temp_error(-1);
+    if (BEDCMP(bed_minttemp_raw, current_temperature_bed_raw) && bed_on) min_temp_error(-1);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *

commit d2bb53702a5b8bc03d6691230f252a21ca3ee375
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 17:33:04 2018 -0600

    Optimize target_extruder, ignore T with mixing (#12432)
    
    * Optimize target_extruder, ignore T with mixing
    * Give G-code Tn parity with tool_change

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 475d38aad9..72abb12f46 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -229,108 +229,92 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 #if HAS_PID_HEATING
 
   inline void say_default_() { SERIAL_PROTOCOLPGM("#define DEFAULT_"); }
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    */
-  void Temperature::PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
+  void Temperature::PID_autotune(const float &target, const int8_t heater, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
     #if HAS_PID_FOR_BOTH
-      #define GHV(B,H) (hotend < 0 ? (B) : (H))
-      #define SHV(S,B,H) do{ if (hotend < 0) S##_bed = B; else S [hotend] = H; }while(0)
-      #define ONHEATINGSTART() (hotend < 0 ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
-      #define ONHEATING(S,C,T) do{ if (hotend < 0) printerEventLEDs.onBedHeating(S,C,T); else printerEventLEDs.onHotendHeating(S,C,T); }while(0)
+      #define GHV(B,H) (heater < 0 ? (B) : (H))
+      #define SHV(S,B,H) do{ if (heater < 0) S##_bed = B; else S [heater] = H; }while(0)
+      #define ONHEATINGSTART() (heater < 0 ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
+      #define ONHEATING(S,C,T) do{ if (heater < 0) printerEventLEDs.onBedHeating(S,C,T); else printerEventLEDs.onHotendHeating(S,C,T); }while(0)
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(S,B,H) (S##_bed = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
-      #define SHV(S,B,H) (S [hotend] = H)
+      #define SHV(S,B,H) (S [heater] = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
 
     #if WATCH_THE_BED || WATCH_HOTENDS
       #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
       #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-        #define GTV(B,H) (hotend < 0 ? (B) : (H))
+        #define GTV(B,H) (heater < 0 ? (B) : (H))
       #elif HAS_TP_BED
         #define GTV(B,H) (B)
       #else
         #define GTV(B,H) (H)
       #endif
       const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
       const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
-    #if ENABLED(PIDTEMP)
-      #define _TOP_HOTEND HOTENDS - 1
-    #else
-      #define _TOP_HOTEND -1
-    #endif
-    #if ENABLED(PIDTEMPBED)
-      #define _BOT_HOTEND -1
-    #else
-      #define _BOT_HOTEND 0
-    #endif
-
-    if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
-      SERIAL_ECHOLNPGM(MSG_PID_BAD_EXTRUDER_NUM);
-      return;
-    }
-
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = GHV(current_temperature_bed, current_temperature[hotend]);
+      const float start_temp = GHV(current_temperature_bed, current_temperature[heater]);
       LEDColor color = ONHEATINGSTART();
     #endif
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current = GHV(current_temperature_bed, current_temperature[hotend]);
+        current = GHV(current_temperature_bed, current_temperature[heater]);
         NOLESS(max, current);
         NOMORE(min, current);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           ONHEATING(start_temp, current, target);
         #endif
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
@@ -405,47 +389,47 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
       if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
-          print_heaterstates();
+          print_heater_states(heater >= 0 ? heater : active_extruder);
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_THE_BED || WATCH_HOTENDS
           if (
             #if WATCH_THE_BED && WATCH_HOTENDS
               true
             #elif WATCH_HOTENDS
-              hotend >= 0
+              heater >= 0
             #else
-              hotend < 0
+              heater < 0
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
                 if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
-                _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, hotend));
+                _temp_error(heater, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, heater));
             }
             else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, hotend));
+              _temp_error(heater, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
@@ -470,29 +454,29 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
           say_default_(); SERIAL_PROTOCOLLNPAIR("bedKd ", tune_pid.Kd);
         #endif
 
         #define _SET_BED_PID() do { \
           bed_pid.Kp = tune_pid.Kp; \
           bed_pid.Ki = scalePID_i(tune_pid.Ki); \
           bed_pid.Kd = scalePID_d(tune_pid.Kd); \
         }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
-          PID_PARAM(Kp, hotend) = tune_pid.Kp; \
-          PID_PARAM(Ki, hotend) = scalePID_i(tune_pid.Ki); \
-          PID_PARAM(Kd, hotend) = scalePID_d(tune_pid.Kd); \
+          PID_PARAM(Kp, heater) = tune_pid.Kp; \
+          PID_PARAM(Ki, heater) = scalePID_i(tune_pid.Ki); \
+          PID_PARAM(Kd, heater) = scalePID_d(tune_pid.Kd); \
           updatePID(); }while(0)
 
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
-            if (hotend < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();
+            if (heater < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onPidTuningDone(color);
         #endif
 
@@ -568,45 +552,45 @@ int Temperature::getHeaterPower(const int heater) {
         SBI(fanDone, bit);
       }
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
-void Temperature::_temp_error(const int8_t e, PGM_P const serial_msg, PGM_P const lcd_msg) {
+void Temperature::_temp_error(const int8_t heater, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;
   if (IsRunning()) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
-    if (e >= 0) SERIAL_ERRORLN((int)e); else SERIAL_ERRORLNPGM(MSG_HEATER_BED);
+    if (heater >= 0) SERIAL_ERRORLN((int)heater); else SERIAL_ERRORLNPGM(MSG_HEATER_BED);
   }
   #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
     if (!killed) {
       Running = false;
       killed = true;
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #endif
 }
 
-void Temperature::max_temp_error(const int8_t e) {
-  _temp_error(e, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, e));
+void Temperature::max_temp_error(const int8_t heater) {
+  _temp_error(heater, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, heater));
 }
 
-void Temperature::min_temp_error(const int8_t e) {
-  _temp_error(e, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, e));
+void Temperature::min_temp_error(const int8_t heater) {
+  _temp_error(heater, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, heater));
 }
 
 float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST true
   #else
     #define _HOTEND_TEST (e == active_extruder)
   #endif
   #if ENABLED(PIDTEMP)
@@ -2339,29 +2323,29 @@ void Temperature::isr() {
     SERIAL_PROTOCOLCHAR_P(port, ':');
     SERIAL_PROTOCOL_P(port, c);
     SERIAL_PROTOCOLPAIR_P(port, " /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_PROTOCOLPAIR_P(port, " (", r / OVERSAMPLENR);
       SERIAL_PROTOCOLCHAR_P(port, ')');
     #endif
     delay(2);
   }
 
-  void Temperature::print_heaterstates(
+  void Temperature::print_heater_states(const uint8_t target_extruder
     #if NUM_SERIAL > 1
-      const int8_t port
+      , const int8_t port
     #endif
   ) {
     #if HAS_TEMP_HOTEND
-      print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
+      print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , rawHotendTemp(gcode.target_extruder)
+          , rawHotendTemp(target_extruder)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
       );
     #endif
     #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
@@ -2385,21 +2369,21 @@ void Temperature::isr() {
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , e
       );
     #endif
     SERIAL_PROTOCOLPGM_P(port, " @:");
-    SERIAL_PROTOCOL_P(port, getHeaterPower(gcode.target_extruder));
+    SERIAL_PROTOCOL_P(port, getHeaterPower(target_extruder));
     #if HAS_HEATED_BED
       SERIAL_PROTOCOLPGM_P(port, " B@:");
       SERIAL_PROTOCOL_P(port, getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
         SERIAL_PROTOCOLPAIR_P(port, " @", e);
         SERIAL_PROTOCOLCHAR_P(port, ':');
         SERIAL_PROTOCOL_P(port, getHeaterPower(e));
       }
@@ -2407,21 +2391,21 @@ void Temperature::isr() {
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-        print_heaterstates();
+        print_heater_states(active_extruder);
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if ENABLED(ULTRA_LCD)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
@@ -2473,23 +2457,23 @@ void Temperature::isr() {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
           target_temp = degTargetHotend(target_extruder);
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
-        if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
+        if (ELAPSED(now, next_temp_ms)) { // Print temp & remaining time every 1s while waiting
           next_temp_ms = now + 1000UL;
-          print_heaterstates();
+          print_heater_states(target_extruder);
           #if TEMP_RESIDENCY_TIME > 0
             SERIAL_PROTOCOLPGM(" W:");
             if (residency_start_ms)
               SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_PROTOCOLCHAR('?');
           #endif
           SERIAL_EOL();
         }
 
@@ -2580,41 +2564,39 @@ void Temperature::isr() {
       float target_temp = -1, old_temp = 9999;
       bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
-      gcode.target_extruder = active_extruder; // for print_heaterstates
-
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
         printerEventLEDs.onBedHeatingStart();
       #endif
 
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetBed()) {
           wants_to_cool = isCoolingBed();
           target_temp = degTargetBed();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
         }
 
         now = millis();
         if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
           next_temp_ms = now + 1000UL;
-          print_heaterstates();
+          print_heater_states(active_extruder);
           #if TEMP_BED_RESIDENCY_TIME > 0
             SERIAL_PROTOCOLPGM(" W:");
             if (residency_start_ms)
               SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
             else
               SERIAL_PROTOCOLCHAR('?');
           #endif
           SERIAL_EOL();
         }
 

commit d82c350de741b6f20a3d4860c9cdc30dae20f746
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 13:13:51 2018 -0600

    Miscellaneous LCD code renaming, reordering (#12430)
    
    * Move special characters to language.h
    * Apply some naming standards
    * Clean up menu item draw functions
    * Rename some Temperature methods
    * UI => ExtUI

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 77ac6f7a73..475d38aad9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -936,21 +936,21 @@ void Temperature::manage_heater() {
     else {                                                             \
       const short v01 = (short)pgm_read_word(&TBL[m-1][1]),            \
                   v11 = (short)pgm_read_word(&TBL[m-0][1]);            \
       return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);  \
     }                                                                  \
   }                                                                    \
 }while(0)
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
-float Temperature::analog2temp(const int raw, const uint8_t e) {
+float Temperature::analog_to_celsius_hotend(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif
     {
       SERIAL_ERROR_START();
       SERIAL_ERROR((int)e);
       SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
       kill();
@@ -1008,37 +1008,37 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
     const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
     SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
   #endif
 
   return 0;
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
-  float Temperature::analog2tempBed(const int raw) {
+  float Temperature::analog_to_celsius_bed(const int raw) {
     #if ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BEDTEMPTABLE, BEDTEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_BED_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
-  float Temperature::analog2tempChamber(const int raw) {
+  float Temperature::analog_to_celsiusChamber(const int raw) {
     #if ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(CHAMBERTEMPTABLE, CHAMBERTEMPTABLE_LEN);
     #elif ENABLED(HEATER_CHAMBER_USES_AD595)
       return TEMP_AD595(raw);
     #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
       return TEMP_AD8495(raw);
     #else
       return 0;
     #endif
   }
@@ -1047,47 +1047,47 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = read_max6675();
   #endif
-  HOTEND_LOOP() current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
+  HOTEND_LOOP() current_temperature[e] = analog_to_celsius_hotend(current_temperature_raw[e], e);
   #if HAS_HEATED_BED
-    current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
+    current_temperature_bed = analog_to_celsius_bed(current_temperature_bed_raw);
   #endif
   #if HAS_TEMP_CHAMBER
-    current_temperature_chamber = Temperature::analog2tempChamber(current_temperature_chamber_raw);
+    current_temperature_chamber = analog_to_celsiusChamber(current_temperature_chamber_raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
+    redundant_temperature = analog_to_celsius_hotend(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    filament_width_meas = analog2widthFil();
+    filament_width_meas = analog_to_mm_fil_width();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();
   #endif
 
   temp_meas_ready = false;
 }
 
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
   // Convert raw Filament Width to millimeters
-  float Temperature::analog2widthFil() {
+  float Temperature::analog_to_mm_fil_width() {
     return current_raw_filwidth * 5.0f * (1.0f / 16383.0f);
   }
 
   /**
    * Convert Filament Width (mm) to a simple ratio
    * and reduce to an 8 bit value.
    *
    * A nominal width of 1.75 and measured width of 1.73
    * gives (100 * 1.75 / 1.73) for a ratio of 101 and
    * a return value of 1.
@@ -1292,29 +1292,29 @@ void Temperature::init() {
     #else
       SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
     #endif
   #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #define TEMP_MIN_ROUTINE(NR) \
     minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
-    while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
+    while (analog_to_celsius_hotend(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
       if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
         minttemp_raw[NR] += OVERSAMPLENR; \
       else \
         minttemp_raw[NR] -= OVERSAMPLENR; \
     }
   #define TEMP_MAX_ROUTINE(NR) \
     maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
-    while (analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
+    while (analog_to_celsius_hotend(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
       if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
         maxttemp_raw[NR] -= OVERSAMPLENR; \
       else \
         maxttemp_raw[NR] += OVERSAMPLENR; \
     }
 
   #ifdef HEATER_0_MINTEMP
     TEMP_MIN_ROUTINE(0);
   #endif
   #ifdef HEATER_0_MAXTEMP
@@ -1356,30 +1356,30 @@ void Temperature::init() {
               TEMP_MAX_ROUTINE(5);
             #endif
           #endif // HOTENDS > 5
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
-      while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
+      while (analog_to_celsius_bed(bed_minttemp_raw) < BED_MINTEMP) {
         #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
           bed_minttemp_raw += OVERSAMPLENR;
         #else
           bed_minttemp_raw -= OVERSAMPLENR;
         #endif
       }
     #endif // BED_MINTEMP
     #ifdef BED_MAXTEMP
-      while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
+      while (analog_to_celsius_bed(bed_maxttemp_raw) > BED_MAXTEMP) {
         #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
           bed_maxttemp_raw -= OVERSAMPLENR;
         #else
           bed_maxttemp_raw += OVERSAMPLENR;
         #endif
       }
     #endif // BED_MAXTEMP
   #endif // HAS_HEATED_BED
 
   #if ENABLED(PROBING_HEATERS_OFF)

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4750b7dcd6..77ac6f7a73 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -491,21 +491,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
           #else
             _SET_BED_PID();
           #endif
         }
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onPidTuningDone(color);
         #endif
 
         return;
       }
-      lcd_update();
+      ui.update();
     }
     disable_all_heaters();
     #if ENABLED(PRINTER_EVENT_LEDS)
       printerEventLEDs.onPidTuningDone(color);
     #endif
   }
 
 #endif // HAS_PID_HEATING
 
 /**
@@ -2116,21 +2116,21 @@ void Temperature::isr() {
         if (state_timer_heater_BED > 0) state_timer_heater_BED--;
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
-  if ((do_buttons ^= true)) lcd_buttons_update();
+  if ((do_buttons ^= true)) ui.update_buttons();
 
   /**
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
@@ -2418,23 +2418,23 @@ void Temperature::isr() {
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
   #if ENABLED(ULTRA_LCD)
     void Temperature::set_heating_message(const uint8_t e) {
       const bool heating = isHeatingHotend(e);
       #if HOTENDS > 1
-        lcd_status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
+        ui.status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
       #else
-        lcd_setstatusPGM(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
+        ui.setstatusPGM(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
       #endif
     }
   #endif
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
@@ -2523,30 +2523,30 @@ void Temperature::isr() {
           // break after MIN_COOLING_SLOPE_TIME seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
-          if (click_to_cancel && use_click()) {
+          if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
-            lcd_quick_feedback();
+            ui.quick_feedback();
           }
         #endif
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
-        lcd_reset_status();
+        ui.reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onHeatingDone();
         #endif
       }
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;
@@ -2648,29 +2648,29 @@ void Temperature::isr() {
           // Break after MIN_COOLING_SLOPE_TIME_BED seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
             old_temp = temp;
           }
         }
 
         #if G26_CLICK_CAN_CANCEL
-          if (click_to_cancel && use_click()) {
+          if (click_to_cancel && ui.use_click()) {
             wait_for_heatup = false;
-            lcd_quick_feedback();
+            ui.quick_feedback();
           }
         #endif
 
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
-      if (wait_for_heatup) lcd_reset_status();
+      if (wait_for_heatup) ui.reset_status();
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_BED
 

commit 6093df11dc91273764d0bf5607fa4314391793a2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 10 18:07:38 2018 -0600

    Allow G26 to use the active extruder (#12387)
    
    * Make lcd_quick_feedback argument optional
    * Add click_to_cancel option to wait_for_hotend/bed
    * Have G26 use the active nozzle and wait_for_hotend/bed
    * Use wait_for_release in UBL G29
    * Add 'T' parameter to G26 for an initial tool-change

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 892379c536..4750b7dcd6 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2434,21 +2434,25 @@ void Temperature::isr() {
 
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60
     #endif
 
-    bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/) {
+    bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/
+      #if G26_CLICK_CAN_CANCEL
+        , const bool click_to_cancel/*=false*/
+      #endif
+    ) {
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
@@ -2518,20 +2522,27 @@ void Temperature::isr() {
         if (wants_to_cool) {
           // break after MIN_COOLING_SLOPE_TIME seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
             old_temp = temp;
           }
         }
 
+        #if G26_CLICK_CAN_CANCEL
+          if (click_to_cancel && use_click()) {
+            wait_for_heatup = false;
+            lcd_quick_feedback();
+          }
+        #endif
+
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         lcd_reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
           printerEventLEDs.onHeatingDone();
         #endif
       }
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
@@ -2545,21 +2556,25 @@ void Temperature::isr() {
 
   #if HAS_HEATED_BED
 
     #ifndef MIN_COOLING_SLOPE_DEG_BED
       #define MIN_COOLING_SLOPE_DEG_BED 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME_BED
       #define MIN_COOLING_SLOPE_TIME_BED 60
     #endif
 
-    void Temperature::wait_for_bed(const bool no_wait_for_cooling) {
+    bool Temperature::wait_for_bed(const bool no_wait_for_cooling
+      #if G26_CLICK_CAN_CANCEL
+        , const bool click_to_cancel/*=false*/
+      #endif
+    ) {
       #if TEMP_BED_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         // Loop until the temperature has stabilized
         #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       float target_temp = -1, old_temp = 9999;
@@ -2632,22 +2647,31 @@ void Temperature::isr() {
         if (wants_to_cool) {
           // Break after MIN_COOLING_SLOPE_TIME_BED seconds
           // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
           if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
             if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
             old_temp = temp;
           }
         }
 
+        #if G26_CLICK_CAN_CANCEL
+          if (click_to_cancel && use_click()) {
+            wait_for_heatup = false;
+            lcd_quick_feedback();
+          }
+        #endif
+
       } while (wait_for_heatup && TEMP_BED_CONDITIONS);
 
       if (wait_for_heatup) lcd_reset_status();
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
+
+      return wait_for_heatup;
     }
 
   #endif // HAS_HEATED_BED
 
 #endif // HAS_TEMP_SENSOR

commit 5ba6607181470006c5903e414c678506ca81b22d
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Nov 3 04:29:32 2018 +0100

    Fix keypad-related compile error (#12306)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 28d4e55064..892379c536 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1824,20 +1824,21 @@ HAL_TEMP_TIMER_ISR {
   HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
 }
 
 void Temperature::isr() {
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
+
   #if ENABLED(ADC_KEYPAD)
     static unsigned int raw_ADCKey_value = 0;
   #endif
 
   // Static members for each heater
   #if ENABLED(SLOW_PWM_HEATERS)
     static uint8_t slow_pwm_count = 0;
     #define ISR_STATICS(n) \
       static uint8_t soft_pwm_count_ ## n, \
                      state_heater_ ## n = 0, \

commit 323c0883564743409ff335f3578d9ee033163571
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Nov 1 23:44:41 2018 +0100

    Restore LED light color after pid tuning (#12082)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 20d7b7c3ab..28d4e55064 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -244,21 +244,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (hotend < 0 ? (B) : (H))
       #define SHV(S,B,H) do{ if (hotend < 0) S##_bed = B; else S [hotend] = H; }while(0)
-      #define ONHEATINGSTART() do{ if (hotend < 0) printerEventLEDs.onBedHeatingStart(); else printerEventLEDs.onHotendHeatingStart(); }while(0)
+      #define ONHEATINGSTART() (hotend < 0 ? printerEventLEDs.onBedHeatingStart() : printerEventLEDs.onHotendHeatingStart())
       #define ONHEATING(S,C,T) do{ if (hotend < 0) printerEventLEDs.onBedHeating(S,C,T); else printerEventLEDs.onHotendHeating(S,C,T); }while(0)
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(S,B,H) (S##_bed = B)
       #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
       #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
       #define SHV(S,B,H) (S [hotend] = H)
       #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
@@ -304,21 +304,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters();
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(current_temperature_bed, current_temperature[hotend]);
-      ONHEATINGSTART();
+      LEDColor color = ONHEATINGSTART();
     #endif
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
@@ -485,27 +485,31 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
             if (hotend < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
+        #if ENABLED(PRINTER_EVENT_LEDS)
+          printerEventLEDs.onPidTuningDone(color);
+        #endif
+
         return;
       }
       lcd_update();
     }
     disable_all_heaters();
     #if ENABLED(PRINTER_EVENT_LEDS)
-      printerEventLEDs.onHeatersOff();
+      printerEventLEDs.onPidTuningDone(color);
     #endif
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
@@ -2518,21 +2522,21 @@ void Temperature::isr() {
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
             old_temp = temp;
           }
         }
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         lcd_reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
-          printerEventLEDs.onHeated();
+          printerEventLEDs.onHeatingDone();
         #endif
       }
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;
     }
 

commit 71e19baf691a5252841cca5871a29d7a65b62e5f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Oct 18 20:20:56 2018 -0600

    Fix kill => disable_all_heaters => print_job_timer.stop (#12146)
    
    - Remove `print_job_timer.stop()` from `disable_all_heaters`
    - Call `print_job_timer.stop()` for relevant `disable_all_heaters()`.
    - Split up `kill()` for watchdog interrupt safety

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 322ba1c978..20d7b7c3ab 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -297,21 +297,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
       #define _BOT_HOTEND 0
     #endif
 
     if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
       SERIAL_ECHOLNPGM(MSG_PID_BAD_EXTRUDER_NUM);
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
-    disable_all_heaters(); // switch off all heaters.
+    disable_all_heaters();
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
     #if ENABLED(PRINTER_EVENT_LEDS)
       const float start_temp = GHV(current_temperature_bed, current_temperature[hotend]);
       ONHEATINGSTART();
     #endif
 
     // PID Tuning loop
@@ -772,21 +772,21 @@ void Temperature::manage_heater() {
       watchdog_reset();
       return;
     }
   #endif
 
   #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
-    if (emergency_parser.killed_by_M112) kill(PSTR(MSG_KILLED));
+    if (emergency_parser.killed_by_M112) kill();
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (current_temperature[0] > MIN(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
     if (current_temperature[0] < MAX(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
@@ -942,21 +942,21 @@ void Temperature::manage_heater() {
 float Temperature::analog2temp(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif
     {
       SERIAL_ERROR_START();
       SERIAL_ERROR((int)e);
       SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
-      kill(PSTR(MSG_KILLED));
+      kill();
       return 0.0;
     }
 
   switch (e) {
     case 0:
       #if ENABLED(HEATER_0_USES_MAX6675)
         return raw * 0.25;
       #elif ENABLED(HEATER_0_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_0_USES_AD8495)
@@ -1544,23 +1544,20 @@ void Temperature::disable_all_heaters() {
 
   #if HAS_HEATED_BED
     setTargetBed(0);
   #endif
 
   // Unpause and reset everything
   #if ENABLED(PROBING_HEATERS_OFF)
     pause(false);
   #endif
 
-  // If all heaters go down then for sure our print job has stopped
-  print_job_timer.stop();
-
   #define DISABLE_HEATER(NR) { \
     setTargetHotend(0, NR); \
     soft_pwm_amount[NR] = 0; \
     WRITE_HEATER_ ##NR (LOW); \
   }
 
   #if HAS_TEMP_HOTEND
     DISABLE_HEATER(0);
     #if HOTENDS > 1
       DISABLE_HEATER(1);

commit d43d4e421977e333f1a7fbff8b939e0288b3616c
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Oct 11 04:25:43 2018 +0200

    Refactor PRINTER_EVENT_LEDS, apply to M303 (#12038)
    
    Co-Authored-By: Giuliano Zaro <gmagician@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 22f21809c5..322ba1c978 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -45,21 +45,21 @@
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
 #if ENABLED(PRINTER_EVENT_LEDS)
-  #include "../feature/leds/leds.h"
+  #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   #endif
@@ -243,27 +243,33 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     PID_t tune_pid = { 0, 0, 0 };
     float max = 0, min = 10000;
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (hotend < 0 ? (B) : (H))
-      #define SHV(S,B,H) if (hotend < 0) S##_bed = B; else S [hotend] = H;
+      #define SHV(S,B,H) do{ if (hotend < 0) S##_bed = B; else S [hotend] = H; }while(0)
+      #define ONHEATINGSTART() do{ if (hotend < 0) printerEventLEDs.onBedHeatingStart(); else printerEventLEDs.onHotendHeatingStart(); }while(0)
+      #define ONHEATING(S,C,T) do{ if (hotend < 0) printerEventLEDs.onBedHeating(S,C,T); else printerEventLEDs.onHotendHeating(S,C,T); }while(0)
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(S,B,H) (S##_bed = B)
+      #define ONHEATINGSTART() printerEventLEDs.onBedHeatingStart()
+      #define ONHEATING(S,C,T) printerEventLEDs.onBedHeating(S,C,T)
     #else
       #define GHV(B,H) H
       #define SHV(S,B,H) (S [hotend] = H)
+      #define ONHEATINGSTART() printerEventLEDs.onHotendHeatingStart()
+      #define ONHEATING(S,C,T) printerEventLEDs.onHotendHeating(S,C,T)
     #endif
 
     #if WATCH_THE_BED || WATCH_HOTENDS
       #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
       #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
         #define GTV(B,H) (hotend < 0 ? (B) : (H))
       #elif HAS_TP_BED
         #define GTV(B,H) (B)
       #else
         #define GTV(B,H) (H)
@@ -296,34 +302,42 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters(); // switch off all heaters.
 
     SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
+    #if ENABLED(PRINTER_EVENT_LEDS)
+      const float start_temp = GHV(current_temperature_bed, current_temperature[hotend]);
+      ONHEATINGSTART();
+    #endif
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
         current = GHV(current_temperature_bed, current_temperature[hotend]);
         NOLESS(max, current);
         NOMORE(min, current);
 
+        #if ENABLED(PRINTER_EVENT_LEDS)
+          ONHEATING(start_temp, current, target);
+        #endif
+
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
         if (heating && current > target) {
           if (ELAPSED(ms, t2 + 5000UL)) {
             heating = false;
@@ -476,20 +490,23 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
         return;
       }
       lcd_update();
     }
     disable_all_heaters();
+    #if ENABLED(PRINTER_EVENT_LEDS)
+      printerEventLEDs.onHeatersOff();
+    #endif
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
@@ -2432,21 +2449,21 @@ void Temperature::isr() {
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degHotend(target_extruder);
-        uint8_t old_blue = 0;
+        printerEventLEDs.onHotendHeatingStart();
       #endif
 
       float target_temp = -1.0, old_temp = 9999.0;
       bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetHotend(target_extruder)) {
           wants_to_cool = isCoolingHotend(target_extruder);
@@ -2470,32 +2487,21 @@ void Temperature::isr() {
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degHotend(target_extruder);
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           // Gradually change LED strip from violet to red as nozzle heats up
-          if (!wants_to_cool) {
-            const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
-            if (blue != old_blue) {
-              old_blue = blue;
-              leds.set_color(
-                MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
-                #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
-                  , true
-                #endif
-              );
-            }
-          }
+          if (!wants_to_cool) printerEventLEDs.onHotendHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
           }
@@ -2515,21 +2521,21 @@ void Temperature::isr() {
             next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
             old_temp = temp;
           }
         }
 
       } while (wait_for_heatup && TEMP_CONDITIONS);
 
       if (wait_for_heatup) {
         lcd_reset_status();
         #if ENABLED(PRINTER_EVENT_LEDS)
-          leds.set_white();
+          printerEventLEDs.onHeated();
         #endif
       }
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         gcode.busy_state = old_busy_state;
       #endif
 
       return wait_for_heatup;
     }
 
@@ -2561,21 +2567,21 @@ void Temperature::isr() {
 
       #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
         const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       gcode.target_extruder = active_extruder; // for print_heaterstates
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
-        uint8_t old_red = 127;
+        printerEventLEDs.onBedHeatingStart();
       #endif
 
       do {
         // Target temperature might be changed during the loop
         if (target_temp != degTargetBed()) {
           wants_to_cool = isCoolingBed();
           target_temp = degTargetBed();
 
           // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
           if (no_wait_for_cooling && wants_to_cool) break;
@@ -2595,32 +2601,21 @@ void Temperature::isr() {
           SERIAL_EOL();
         }
 
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
 
         const float temp = degBed();
 
         #if ENABLED(PRINTER_EVENT_LEDS)
           // Gradually change LED strip from blue to violet as bed heats up
-          if (!wants_to_cool) {
-            const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
-            if (red != old_red) {
-              old_red = red;
-              leds.set_color(
-                MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
-                #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
-                  , true
-                #endif
-              );
-            }
-          }
+          if (!wants_to_cool) printerEventLEDs.onBedHeating(start_temp, temp, target_temp);
         #endif
 
         #if TEMP_BED_RESIDENCY_TIME > 0
 
           const float temp_diff = ABS(target_temp - temp);
 
           if (!residency_start_ms) {
             // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
             if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
           }

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a64db1f013..22f21809c5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -109,56 +109,40 @@ int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
     int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
   #endif
   #ifdef BED_MAXTEMP
     int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
   #endif
   #if WATCH_THE_BED
     uint16_t Temperature::watch_target_bed_temp = 0;
     millis_t Temperature::watch_bed_next_ms = 0;
   #endif
   #if ENABLED(PIDTEMPBED)
-    float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd, // Initialized by settings.load()
-          Temperature::temp_iState_bed = { 0 },
-          Temperature::temp_dState_bed = { 0 },
-          Temperature::pTerm_bed,
-          Temperature::iTerm_bed,
-          Temperature::dTerm_bed,
-          Temperature::pid_error_bed;
+    PID_t Temperature::bed_pid; // Initialized by settings.load()
   #else
     millis_t Temperature::next_bed_check_ms;
   #endif
   uint16_t Temperature::raw_temp_bed_value = 0;
   #if HEATER_IDLE_HANDLER
     millis_t Temperature::bed_idle_timeout_ms = 0;
     bool Temperature::bed_idle_timeout_exceeded = false;
   #endif
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   float Temperature::current_temperature_chamber = 0.0;
   int16_t Temperature::current_temperature_chamber_raw = 0;
   uint16_t Temperature::raw_temp_chamber_value = 0;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
-  #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
-    float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      float Temperature::Kc[HOTENDS];
-    #endif
-  #else
-    float Temperature::Kp, Temperature::Ki, Temperature::Kd;
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      float Temperature::Kc;
-    #endif
-  #endif
+  hotend_pid_t Temperature::pid[HOTENDS];
 #endif
 
 #if ENABLED(BABYSTEPPING)
   volatile int16_t Temperature::babystepsTodo[XYZ] = { 0 };
 #endif
 
 #if WATCH_HOTENDS
   uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
   millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
 #endif
@@ -175,35 +159,25 @@ int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   uint16_t Temperature::redundant_temperature_raw = 0;
   float Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::temp_meas_ready = false;
 
 #if ENABLED(PIDTEMP)
-  float Temperature::temp_iState[HOTENDS] = { 0 },
-        Temperature::temp_dState[HOTENDS] = { 0 },
-        Temperature::pTerm[HOTENDS],
-        Temperature::iTerm[HOTENDS],
-        Temperature::dTerm[HOTENDS];
-
   #if ENABLED(PID_EXTRUSION_SCALING)
-    float Temperature::cTerm[HOTENDS];
     long Temperature::last_e_position;
     long Temperature::lpq[LPQ_MAX_LEN];
     int Temperature::lpq_ptr = 0;
   #endif
-
-  float Temperature::pid_error[HOTENDS];
-  bool Temperature::pid_reset[HOTENDS];
 #endif
 
 uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 };
 
 // Init min and max temp with extreme values to prevent false errors during startup
 int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
         Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
         Temperature::minttemp[HOTENDS] = { 0 },
         Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
 
@@ -247,38 +221,39 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in configuration_store
 #endif
 
 #if HAS_PID_HEATING
 
+  inline void say_default_() { SERIAL_PROTOCOLPGM("#define DEFAULT_"); }
+
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    */
   void Temperature::PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
-    float Ku, Tu,
-          workKp = 0, workKi = 0, workKd = 0,
-          max = 0, min = 10000;
+    PID_t tune_pid = { 0, 0, 0 };
+    float max = 0, min = 10000;
 
     #if HAS_PID_FOR_BOTH
       #define GHV(B,H) (hotend < 0 ? (B) : (H))
       #define SHV(S,B,H) if (hotend < 0) S##_bed = B; else S [hotend] = H;
     #elif ENABLED(PIDTEMPBED)
       #define GHV(B,H) B
       #define SHV(S,B,H) (S##_bed = B)
     #else
       #define GHV(B,H) H
       #define SHV(S,B,H) (S [hotend] = H)
@@ -368,46 +343,46 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
               const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
               SERIAL_PROTOCOLPAIR(MSG_D, d);
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
-                Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f);
-                Tu = ((float)(t_low + t_high) * 0.001f);
+                float Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f),
+                      Tu = ((float)(t_low + t_high) * 0.001f);
                 SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
                 SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
-                workKp = 0.6f * Ku;
-                workKi = 2 * workKp / Tu;
-                workKd = workKp * Tu * 0.125f;
+                tune_pid.Kp = 0.6f * Ku;
+                tune_pid.Ki = 2 * tune_pid.Kp / Tu;
+                tune_pid.Kd = tune_pid.Kp * Tu * 0.125f;
                 SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
-                SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
-                SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
-                SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
+                SERIAL_PROTOCOLPAIR(MSG_KP, tune_pid.Kp);
+                SERIAL_PROTOCOLPAIR(MSG_KI, tune_pid.Ki);
+                SERIAL_PROTOCOLLNPAIR(MSG_KD, tune_pid.Kd);
                 /**
-                workKp = 0.33*Ku;
-                workKi = workKp/Tu;
-                workKd = workKp*Tu/3;
+                tune_pid.Kp = 0.33*Ku;
+                tune_pid.Ki = tune_pid.Kp/Tu;
+                tune_pid.Kd = tune_pid.Kp*Tu/3;
                 SERIAL_PROTOCOLLNPGM(" Some overshoot");
-                SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
-                SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
-                SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
-                workKp = 0.2*Ku;
-                workKi = 2*workKp/Tu;
-                workKd = workKp*Tu/3;
+                SERIAL_PROTOCOLPAIR(" Kp: ", tune_pid.Kp);
+                SERIAL_PROTOCOLPAIR(" Ki: ", tune_pid.Ki);
+                SERIAL_PROTOCOLPAIR(" Kd: ", tune_pid.Kd);
+                tune_pid.Kp = 0.2*Ku;
+                tune_pid.Ki = 2*tune_pid.Kp/Tu;
+                tune_pid.Kd = tune_pid.Kp*Tu/3;
                 SERIAL_PROTOCOLLNPGM(" No overshoot");
-                SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
-                SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
-                SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
+                SERIAL_PROTOCOLPAIR(" Kp: ", tune_pid.Kp);
+                SERIAL_PROTOCOLPAIR(" Ki: ", tune_pid.Ki);
+                SERIAL_PROTOCOLPAIR(" Kd: ", tune_pid.Kd);
                 */
               }
             }
             SHV(soft_pwm_amount, (bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             min = target;
           }
         }
       }
 
@@ -460,53 +435,50 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
-          const char* estring = GHV("bed", "");
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
+          const char * const estring = GHV(PSTR("bed"), PSTR(""));
+          say_default_(); serialprintPGM(estring); SERIAL_PROTOCOLLNPAIR("Kp ", tune_pid.Kp);
+          say_default_(); serialprintPGM(estring); SERIAL_PROTOCOLLNPAIR("Ki ", tune_pid.Ki);
+          say_default_(); serialprintPGM(estring); SERIAL_PROTOCOLLNPAIR("Kd ", tune_pid.Kd);
         #elif ENABLED(PIDTEMP)
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_Kp ", workKp); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_Ki ", workKi); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_Kd ", workKd); SERIAL_EOL();
+          say_default_(); SERIAL_PROTOCOLLNPAIR("Kp ", tune_pid.Kp);
+          say_default_(); SERIAL_PROTOCOLLNPAIR("Ki ", tune_pid.Ki);
+          say_default_(); SERIAL_PROTOCOLLNPAIR("Kd ", tune_pid.Kd);
         #else
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKp ", workKp); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKi ", workKi); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKd ", workKd); SERIAL_EOL();
+          say_default_(); SERIAL_PROTOCOLLNPAIR("bedKp ", tune_pid.Kp);
+          say_default_(); SERIAL_PROTOCOLLNPAIR("bedKi ", tune_pid.Ki);
+          say_default_(); SERIAL_PROTOCOLLNPAIR("bedKd ", tune_pid.Kd);
         #endif
 
         #define _SET_BED_PID() do { \
-          bedKp = workKp; \
-          bedKi = scalePID_i(workKi); \
-          bedKd = scalePID_d(workKd); \
+          bed_pid.Kp = tune_pid.Kp; \
+          bed_pid.Ki = scalePID_i(tune_pid.Ki); \
+          bed_pid.Kd = scalePID_d(tune_pid.Kd); \
         }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
-          PID_PARAM(Kp, hotend) = workKp; \
-          PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
-          PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
+          PID_PARAM(Kp, hotend) = tune_pid.Kp; \
+          PID_PARAM(Ki, hotend) = scalePID_i(tune_pid.Ki); \
+          PID_PARAM(Kd, hotend) = scalePID_d(tune_pid.Kd); \
           updatePID(); }while(0)
 
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
-            if (hotend < 0)
-              _SET_BED_PID();
-            else
-              _SET_EXTRUDER_PID();
+            if (hotend < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
         return;
       }
       lcd_update();
     }
@@ -605,158 +577,172 @@ void Temperature::max_temp_error(const int8_t e) {
   _temp_error(e, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, e));
 }
 
 void Temperature::min_temp_error(const int8_t e) {
   _temp_error(e, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, e));
 }
 
 float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
-    #define _HOTEND_TEST     true
+    #define _HOTEND_TEST true
   #else
-    #define _HOTEND_TEST     e == active_extruder
+    #define _HOTEND_TEST (e == active_extruder)
   #endif
-  float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
-      pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
-      dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + float(PID_K1) * dTerm[HOTEND_INDEX];
+      static hotend_pid_t work_pid[HOTENDS];
+      static float temp_iState[HOTENDS] = { 0 },
+                   temp_dState[HOTENDS] = { 0 };
+      static bool pid_reset[HOTENDS] = { false };
+      float pid_output,
+            pid_error = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
+      work_pid[HOTEND_INDEX].Kd = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + float(PID_K1) * work_pid[HOTEND_INDEX].Kd;
       temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
       #if HEATER_IDLE_HANDLER
         if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
           pid_output = 0;
           pid_reset[HOTEND_INDEX] = true;
         }
         else
       #endif
-      if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
-        pid_output = BANG_MAX;
-        pid_reset[HOTEND_INDEX] = true;
-      }
-      else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
-        #if HEATER_IDLE_HANDLER
-          || heater_idle_timeout_exceeded[HOTEND_INDEX]
-        #endif
-        ) {
-        pid_output = 0;
-        pid_reset[HOTEND_INDEX] = true;
-      }
-      else {
-        if (pid_reset[HOTEND_INDEX]) {
-          temp_iState[HOTEND_INDEX] = 0.0;
-          pid_reset[HOTEND_INDEX] = false;
-        }
-        pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
-        temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
-        iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
-
-        pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
-
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          cTerm[HOTEND_INDEX] = 0;
-          if (_HOTEND_TEST) {
-            const long e_position = stepper.position(E_AXIS);
-            if (e_position > last_e_position) {
-              lpq[lpq_ptr] = e_position - last_e_position;
-              last_e_position = e_position;
+          if (pid_error > PID_FUNCTIONAL_RANGE) {
+            pid_output = BANG_MAX;
+            pid_reset[HOTEND_INDEX] = true;
+          }
+          else if (pid_error < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
+            #if HEATER_IDLE_HANDLER
+              || heater_idle_timeout_exceeded[HOTEND_INDEX]
+            #endif
+          ) {
+            pid_output = 0;
+            pid_reset[HOTEND_INDEX] = true;
+          }
+          else {
+            if (pid_reset[HOTEND_INDEX]) {
+              temp_iState[HOTEND_INDEX] = 0.0;
+              pid_reset[HOTEND_INDEX] = false;
             }
-            else
-              lpq[lpq_ptr] = 0;
+            temp_iState[HOTEND_INDEX] += pid_error;
+            work_pid[HOTEND_INDEX].Kp = PID_PARAM(Kp, HOTEND_INDEX) * pid_error;
+            work_pid[HOTEND_INDEX].Ki = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
+
+            pid_output = work_pid[HOTEND_INDEX].Kp + work_pid[HOTEND_INDEX].Ki - work_pid[HOTEND_INDEX].Kd;
+
+            #if ENABLED(PID_EXTRUSION_SCALING)
+              work_pid[HOTEND_INDEX].Kc = 0;
+              if (_HOTEND_TEST) {
+                const long e_position = stepper.position(E_AXIS);
+                if (e_position > last_e_position) {
+                  lpq[lpq_ptr] = e_position - last_e_position;
+                  last_e_position = e_position;
+                }
+                else
+                  lpq[lpq_ptr] = 0;
+
+                if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
+                work_pid[HOTEND_INDEX].Kc = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
+                pid_output += work_pid[HOTEND_INDEX].Kc;
+              }
+            #endif // PID_EXTRUSION_SCALING
 
-            if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
-            cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
-            pid_output += cTerm[HOTEND_INDEX];
+            if (pid_output > PID_MAX) {
+              if (pid_error > 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
+              pid_output = PID_MAX;
+            }
+            else if (pid_output < 0) {
+              if (pid_error < 0) temp_iState[HOTEND_INDEX] -= pid_error; // conditional un-integration
+              pid_output = 0;
+            }
           }
-        #endif // PID_EXTRUSION_SCALING
 
-        if (pid_output > PID_MAX) {
-          if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
-          pid_output = PID_MAX;
-        }
-        else if (pid_output < 0) {
-          if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
-          pid_output = 0;
-        }
-      }
-    #else
-      pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
+    #else // PID_OPENLOOP
+
+      const float pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
+
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_DEBUG)
       SERIAL_ECHO_START();
       SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
       SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
       SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
-      SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
-      SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
-      SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
+      #if DISABLED(PID_OPENLOOP)
+        SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, work_pid[HOTEND_INDEX].Kp);
+        SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, work_pid[HOTEND_INDEX].Ki);
+        SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, work_pid[HOTEND_INDEX].Kd);
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, work_pid[HOTEND_INDEX].Kc);
+        #endif
       #endif
       SERIAL_EOL();
     #endif // PID_DEBUG
 
   #else /* PID off */
     #if HEATER_IDLE_HANDLER
       if (heater_idle_timeout_exceeded[HOTEND_INDEX])
         pid_output = 0;
       else
     #endif
     pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
   #endif
 
   return pid_output;
 }
 
 #if ENABLED(PIDTEMPBED)
+
   float Temperature::get_pid_output_bed() {
-    float pid_output;
+
     #if DISABLED(PID_OPENLOOP)
-      pid_error_bed = target_temperature_bed - current_temperature_bed;
-      pTerm_bed = bedKp * pid_error_bed;
-      temp_iState_bed += pid_error_bed;
-      iTerm_bed = bedKi * temp_iState_bed;
 
-      dTerm_bed = PID_K2 * bedKd * (current_temperature_bed - temp_dState_bed) + PID_K1 * dTerm_bed;
-      temp_dState_bed = current_temperature_bed;
+      static PID_t work_pid = { 0 };
+      static float temp_iState = 0, temp_dState = 0;
+
+      float pid_error = target_temperature_bed - current_temperature_bed;
+      temp_iState += pid_error;
+      work_pid.Kp = bed_pid.Kp * pid_error;
+      work_pid.Ki = bed_pid.Ki * temp_iState;
+      work_pid.Kd = PID_K2 * bed_pid.Kd * (current_temperature_bed - temp_dState) + PID_K1 * work_pid.Kd;
 
-      pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
+      temp_dState = current_temperature_bed;
+
+      float pid_output = work_pid.Kp + work_pid.Ki - work_pid.Kd;
       if (pid_output > MAX_BED_POWER) {
-        if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
+        if (pid_error > 0) temp_iState -= pid_error; // conditional un-integration
         pid_output = MAX_BED_POWER;
       }
       else if (pid_output < 0) {
-        if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
+        if (pid_error < 0) temp_iState -= pid_error; // conditional un-integration
         pid_output = 0;
       }
-    #else
-      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
+
+    #else // PID_OPENLOOP
+
+      const float pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
+
     #endif // PID_OPENLOOP
 
     #if ENABLED(PID_BED_DEBUG)
       SERIAL_ECHO_START();
-      SERIAL_ECHOPGM(" PID_BED_DEBUG ");
-      SERIAL_ECHOPGM(": Input ");
-      SERIAL_ECHO(current_temperature_bed);
-      SERIAL_ECHOPGM(" Output ");
-      SERIAL_ECHO(pid_output);
-      SERIAL_ECHOPGM(" pTerm ");
-      SERIAL_ECHO(pTerm_bed);
-      SERIAL_ECHOPGM(" iTerm ");
-      SERIAL_ECHO(iTerm_bed);
-      SERIAL_ECHOPGM(" dTerm ");
-      SERIAL_ECHOLN(dTerm_bed);
-    #endif // PID_BED_DEBUG
+      SERIAL_ECHOPAIR(" PID_BED_DEBUG : Input ", current_temperature_bed);
+      SERIAL_ECHOPAIR(" Output ", pid_output);
+      #if DISABLED(PID_OPENLOOP)
+        SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, work_pid.Kp);
+        SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, work_pid.Ki);
+        SERIAL_ECHOLNPAIR(MSG_PID_DEBUG_DTERM, work_pid.Kd);
+      #endif
+    #endif
 
     return pid_output;
   }
+
 #endif // PIDTEMPBED
 
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value

commit 74cd6cb4fc90e4c483e7a97a313c0257790f1375
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 7 18:06:14 2018 -0400

    Single nozzle filament change (#11994)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1f49cae90c..a64db1f013 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2409,20 +2409,31 @@ void Temperature::isr() {
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         print_heaterstates();
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
+  #if ENABLED(ULTRA_LCD)
+    void Temperature::set_heating_message(const uint8_t e) {
+      const bool heating = isHeatingHotend(e);
+      #if HOTENDS > 1
+        lcd_status_printf_P(0, heating ? PSTR("E%i " MSG_HEATING) : PSTR("E%i " MSG_COOLING), int(e + 1));
+      #else
+        lcd_setstatusPGM(heating ? PSTR("E " MSG_HEATING) : PSTR("E " MSG_COOLING));
+      #endif
+    }
+  #endif
+
   #if HAS_TEMP_HOTEND
 
     #ifndef MIN_COOLING_SLOPE_DEG
       #define MIN_COOLING_SLOPE_DEG 1.50
     #endif
     #ifndef MIN_COOLING_SLOPE_TIME
       #define MIN_COOLING_SLOPE_TIME 60
     #endif
 
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/) {

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b4f5beb722..1f49cae90c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -90,21 +90,21 @@ Temperature thermalManager;
     PSTR(MSG_E1 " " MSG)
 #endif
 
 // public:
 
 float Temperature::current_temperature[HOTENDS] = { 0.0 };
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
         Temperature::target_temperature[HOTENDS] = { 0 };
 
 #if ENABLED(AUTO_POWER_E_FANS)
-  int16_t Temperature::autofan_speed[HOTENDS] = { 0 };
+  uint8_t Temperature::autofan_speed[HOTENDS] = { 0 };
 #endif
 
 #if HAS_HEATED_BED
   float Temperature::current_temperature_bed = 0.0;
   int16_t Temperature::current_temperature_bed_raw = 0,
           Temperature::target_temperature_bed = 0;
   uint8_t Temperature::soft_pwm_amount_bed;
   #ifdef BED_MINTEMP
     int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
   #endif

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8fcfc11191..b4f5beb722 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -575,21 +575,21 @@ int Temperature::getHeaterPower(const int heater) {
         SBI(fanDone, bit);
       }
     }
   }
 
 #endif // HAS_AUTO_FAN
 
 //
 // Temperature Error Handlers
 //
-void Temperature::_temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg) {
+void Temperature::_temp_error(const int8_t e, PGM_P const serial_msg, PGM_P const lcd_msg) {
   static bool killed = false;
   if (IsRunning()) {
     SERIAL_ERROR_START();
     serialprintPGM(serial_msg);
     SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
     if (e >= 0) SERIAL_ERRORLN((int)e); else SERIAL_ERRORLNPGM(MSG_HEATER_BED);
   }
   #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
     if (!killed) {
       Running = false;

commit d89d8fe852f129ff1fe9a17b6c9b3c8cecf364f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 29 17:03:23 2018 -0500

    Fix Busy State in temperature.cpp
    
    Fix #11954

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 890efe82f7..8fcfc11191 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2428,24 +2428,22 @@ void Temperature::isr() {
     bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/) {
       #if TEMP_RESIDENCY_TIME > 0
         millis_t residency_start_ms = 0;
         // Loop until the temperature has stabilized
         #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
       #else
         // Loop until the temperature is very close target
         #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
       #endif
 
-      #if DISABLED(BUSY_WHILE_HEATING)
-        #if ENABLED(HOST_KEEPALIVE_FEATURE)
-          const MarlinBusyState old_busy_state = gcode.busy_state;
-        #endif
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degHotend(target_extruder);
         uint8_t old_blue = 0;
       #endif
 
       float target_temp = -1.0, old_temp = 9999.0;
       bool wants_to_cool = false;
@@ -2557,24 +2555,22 @@ void Temperature::isr() {
       #else
         // Loop until the temperature is very close target
         #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
       #endif
 
       float target_temp = -1, old_temp = 9999;
       bool wants_to_cool = false;
       wait_for_heatup = true;
       millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
 
-      #if DISABLED(BUSY_WHILE_HEATING)
-        #if ENABLED(HOST_KEEPALIVE_FEATURE)
-          const MarlinBusyState old_busy_state = gcode.busy_state;
-        #endif
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        const GcodeSuite::MarlinBusyState old_busy_state = gcode.busy_state;
         KEEPALIVE_STATE(NOT_BUSY);
       #endif
 
       gcode.target_extruder = active_extruder; // for print_heaterstates
 
       #if ENABLED(PRINTER_EVENT_LEDS)
         const float start_temp = degBed();
         uint8_t old_red = 127;
       #endif
 

commit e4389f7d2308a8c3df2a961a511724513b519a4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 29 01:44:47 2018 -0500

    Standard methods to wait for heating (#11949)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6a91f8a1b9..890efe82f7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -44,20 +44,24 @@
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
+#if ENABLED(PRINTER_EVENT_LEDS)
+  #include "../feature/leds/leds.h"
+#endif
+
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   #endif
 #endif
 
@@ -2405,11 +2409,255 @@ void Temperature::isr() {
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         print_heaterstates();
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
+  #if HAS_TEMP_HOTEND
+
+    #ifndef MIN_COOLING_SLOPE_DEG
+      #define MIN_COOLING_SLOPE_DEG 1.50
+    #endif
+    #ifndef MIN_COOLING_SLOPE_TIME
+      #define MIN_COOLING_SLOPE_TIME 60
+    #endif
+
+    bool Temperature::wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling/*=true*/) {
+      #if TEMP_RESIDENCY_TIME > 0
+        millis_t residency_start_ms = 0;
+        // Loop until the temperature has stabilized
+        #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
+      #else
+        // Loop until the temperature is very close target
+        #define TEMP_CONDITIONS (wants_to_cool ? isCoolingHotend(target_extruder) : isHeatingHotend(target_extruder))
+      #endif
+
+      #if DISABLED(BUSY_WHILE_HEATING)
+        #if ENABLED(HOST_KEEPALIVE_FEATURE)
+          const MarlinBusyState old_busy_state = gcode.busy_state;
+        #endif
+        KEEPALIVE_STATE(NOT_BUSY);
+      #endif
+
+      #if ENABLED(PRINTER_EVENT_LEDS)
+        const float start_temp = degHotend(target_extruder);
+        uint8_t old_blue = 0;
+      #endif
+
+      float target_temp = -1.0, old_temp = 9999.0;
+      bool wants_to_cool = false;
+      wait_for_heatup = true;
+      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+      do {
+        // Target temperature might be changed during the loop
+        if (target_temp != degTargetHotend(target_extruder)) {
+          wants_to_cool = isCoolingHotend(target_extruder);
+          target_temp = degTargetHotend(target_extruder);
+
+          // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
+          if (no_wait_for_cooling && wants_to_cool) break;
+        }
+
+        now = millis();
+        if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
+          next_temp_ms = now + 1000UL;
+          print_heaterstates();
+          #if TEMP_RESIDENCY_TIME > 0
+            SERIAL_PROTOCOLPGM(" W:");
+            if (residency_start_ms)
+              SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+            else
+              SERIAL_PROTOCOLCHAR('?');
+          #endif
+          SERIAL_EOL();
+        }
+
+        idle();
+        gcode.reset_stepper_timeout(); // Keep steppers powered
+
+        const float temp = degHotend(target_extruder);
+
+        #if ENABLED(PRINTER_EVENT_LEDS)
+          // Gradually change LED strip from violet to red as nozzle heats up
+          if (!wants_to_cool) {
+            const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
+            if (blue != old_blue) {
+              old_blue = blue;
+              leds.set_color(
+                MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
+                #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
+                  , true
+                #endif
+              );
+            }
+          }
+        #endif
+
+        #if TEMP_RESIDENCY_TIME > 0
+
+          const float temp_diff = ABS(target_temp - temp);
+
+          if (!residency_start_ms) {
+            // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
+            if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
+          }
+          else if (temp_diff > TEMP_HYSTERESIS) {
+            // Restart the timer whenever the temperature falls outside the hysteresis.
+            residency_start_ms = now;
+          }
+
+        #endif
+
+        // Prevent a wait-forever situation if R is misused i.e. M109 R0
+        if (wants_to_cool) {
+          // break after MIN_COOLING_SLOPE_TIME seconds
+          // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
+          if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+            if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG)) break;
+            next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
+            old_temp = temp;
+          }
+        }
+
+      } while (wait_for_heatup && TEMP_CONDITIONS);
+
+      if (wait_for_heatup) {
+        lcd_reset_status();
+        #if ENABLED(PRINTER_EVENT_LEDS)
+          leds.set_white();
+        #endif
+      }
+
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        gcode.busy_state = old_busy_state;
+      #endif
+
+      return wait_for_heatup;
+    }
+
+  #endif // HAS_TEMP_HOTEND
+
+  #if HAS_HEATED_BED
+
+    #ifndef MIN_COOLING_SLOPE_DEG_BED
+      #define MIN_COOLING_SLOPE_DEG_BED 1.50
+    #endif
+    #ifndef MIN_COOLING_SLOPE_TIME_BED
+      #define MIN_COOLING_SLOPE_TIME_BED 60
+    #endif
+
+    void Temperature::wait_for_bed(const bool no_wait_for_cooling) {
+      #if TEMP_BED_RESIDENCY_TIME > 0
+        millis_t residency_start_ms = 0;
+        // Loop until the temperature has stabilized
+        #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
+      #else
+        // Loop until the temperature is very close target
+        #define TEMP_BED_CONDITIONS (wants_to_cool ? isCoolingBed() : isHeatingBed())
+      #endif
+
+      float target_temp = -1, old_temp = 9999;
+      bool wants_to_cool = false;
+      wait_for_heatup = true;
+      millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+
+      #if DISABLED(BUSY_WHILE_HEATING)
+        #if ENABLED(HOST_KEEPALIVE_FEATURE)
+          const MarlinBusyState old_busy_state = gcode.busy_state;
+        #endif
+        KEEPALIVE_STATE(NOT_BUSY);
+      #endif
+
+      gcode.target_extruder = active_extruder; // for print_heaterstates
+
+      #if ENABLED(PRINTER_EVENT_LEDS)
+        const float start_temp = degBed();
+        uint8_t old_red = 127;
+      #endif
+
+      do {
+        // Target temperature might be changed during the loop
+        if (target_temp != degTargetBed()) {
+          wants_to_cool = isCoolingBed();
+          target_temp = degTargetBed();
+
+          // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
+          if (no_wait_for_cooling && wants_to_cool) break;
+        }
+
+        now = millis();
+        if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
+          next_temp_ms = now + 1000UL;
+          print_heaterstates();
+          #if TEMP_BED_RESIDENCY_TIME > 0
+            SERIAL_PROTOCOLPGM(" W:");
+            if (residency_start_ms)
+              SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+            else
+              SERIAL_PROTOCOLCHAR('?');
+          #endif
+          SERIAL_EOL();
+        }
+
+        idle();
+        gcode.reset_stepper_timeout(); // Keep steppers powered
+
+        const float temp = degBed();
+
+        #if ENABLED(PRINTER_EVENT_LEDS)
+          // Gradually change LED strip from blue to violet as bed heats up
+          if (!wants_to_cool) {
+            const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
+            if (red != old_red) {
+              old_red = red;
+              leds.set_color(
+                MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
+                #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
+                  , true
+                #endif
+              );
+            }
+          }
+        #endif
+
+        #if TEMP_BED_RESIDENCY_TIME > 0
+
+          const float temp_diff = ABS(target_temp - temp);
+
+          if (!residency_start_ms) {
+            // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
+            if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
+          }
+          else if (temp_diff > TEMP_BED_HYSTERESIS) {
+            // Restart the timer whenever the temperature falls outside the hysteresis.
+            residency_start_ms = now;
+          }
+
+        #endif // TEMP_BED_RESIDENCY_TIME > 0
+
+        // Prevent a wait-forever situation if R is misused i.e. M190 R0
+        if (wants_to_cool) {
+          // Break after MIN_COOLING_SLOPE_TIME_BED seconds
+          // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
+          if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+            if (old_temp - temp < float(MIN_COOLING_SLOPE_DEG_BED)) break;
+            next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
+            old_temp = temp;
+          }
+        }
+
+      } while (wait_for_heatup && TEMP_BED_CONDITIONS);
+
+      if (wait_for_heatup) lcd_reset_status();
+
+      #if DISABLED(BUSY_WHILE_HEATING) && ENABLED(HOST_KEEPALIVE_FEATURE)
+        gcode.busy_state = old_busy_state;
+      #endif
+    }
+
+  #endif // HAS_HEATED_BED
+
 #endif // HAS_TEMP_SENSOR

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 67c30d0c05..6a91f8a1b9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -67,27 +67,29 @@ Temperature thermalManager;
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 #if HAS_HEATED_BED
   #define TEMP_ERR_PSTR(MSG, E) \
     (E) == -1 ? PSTR(MSG ## _BED) : \
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
+    (HOTENDS > 5 && (E) == 5) ? PSTR(MSG_E6 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #else
   #define TEMP_ERR_PSTR(MSG, E) \
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
+    (HOTENDS > 5 && (E) == 5) ? PSTR(MSG_E6 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #endif
 
 // public:
 
 float Temperature::current_temperature[HOTENDS] = { 0.0 };
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
         Temperature::target_temperature[HOTENDS] = { 0 };
 
 #if ENABLED(AUTO_POWER_E_FANS)
@@ -142,21 +144,21 @@ int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
     #endif
   #else
     float Temperature::Kp, Temperature::Ki, Temperature::Kd;
     #if ENABLED(PID_EXTRUSION_SCALING)
       float Temperature::Kc;
     #endif
   #endif
 #endif
 
 #if ENABLED(BABYSTEPPING)
-  volatile int Temperature::babystepsTodo[XYZ] = { 0 };
+  volatile int16_t Temperature::babystepsTodo[XYZ] = { 0 };
 #endif
 
 #if WATCH_HOTENDS
   uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
   millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
@@ -520,27 +522,28 @@ int Temperature::getHeaterPower(const int heater) {
     #if HAS_HEATED_BED
       heater < 0 ? soft_pwm_amount_bed :
     #endif
     soft_pwm_amount[heater]
   );
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
-    static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN, CHAMBER_AUTO_FAN_PIN };
+    static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN, E5_AUTO_FAN_PIN, CHAMBER_AUTO_FAN_PIN };
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
-      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4,
+      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 :                   4,
+      AUTO_5_IS_0 ? 0 : AUTO_5_IS_1 ? 1 : AUTO_5_IS_2 ? 2 : AUTO_5_IS_3 ? 3 : AUTO_5_IS_4 ? 4 : 5,
       AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : 5
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
       if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
@@ -1186,20 +1189,23 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_ADC_2
     HAL_ANALOG_SELECT(TEMP_2_PIN);
   #endif
   #if HAS_TEMP_ADC_3
     HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_ADC_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
+  #if HAS_TEMP_ADC_5
+    HAL_ANALOG_SELECT(TEMP_5_PIN);
+  #endif
   #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
@@ -1219,51 +1225,61 @@ void Temperature::init() {
   #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
     #if E1_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E1_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E1_AUTO_FAN_PIN);
     #endif
   #endif
-  #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
+  #if HAS_AUTO_FAN_2 && !(AUTO_2_IS_0 || AUTO_2_IS_1)
     #if E2_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E2_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E2_AUTO_FAN_PIN);
     #endif
   #endif
-  #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
+  #if HAS_AUTO_FAN_3 && !(AUTO_3_IS_0 || AUTO_3_IS_1 || AUTO_3_IS_2)
     #if E3_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E3_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E3_AUTO_FAN_PIN);
     #endif
   #endif
-  #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
+  #if HAS_AUTO_FAN_4 && !(AUTO_4_IS_0 || AUTO_4_IS_1 || AUTO_4_IS_2 || AUTO_4_IS_3)
     #if E4_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E4_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E4_AUTO_FAN_PIN);
     #endif
   #endif
-  #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_0 && !AUTO_CHAMBER_IS_1 && !AUTO_CHAMBER_IS_2 && !AUTO_CHAMBER_IS_3 && ! AUTO_CHAMBER_IS_4
+  #if HAS_AUTO_FAN_5 && !(AUTO_5_IS_0 || AUTO_5_IS_1 || AUTO_5_IS_2 || AUTO_5_IS_3 || AUTO_5_IS_4)
+    #if E5_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E5_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(E5_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(E5_AUTO_FAN_PIN);
+    #endif
+  #endif
+  #if HAS_AUTO_CHAMBER_FAN && !(AUTO_CHAMBER_IS_0 || AUTO_CHAMBER_IS_1 || AUTO_CHAMBER_IS_2 || AUTO_CHAMBER_IS_3 || AUTO_CHAMBER_IS_4 || AUTO_CHAMBER_IS_5)
     #if CHAMBER_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(CHAMBER_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
     #endif
   #endif
 
@@ -1314,20 +1330,28 @@ void Temperature::init() {
         #ifdef HEATER_3_MAXTEMP
           TEMP_MAX_ROUTINE(3);
         #endif
         #if HOTENDS > 4
           #ifdef HEATER_4_MINTEMP
             TEMP_MIN_ROUTINE(4);
           #endif
           #ifdef HEATER_4_MAXTEMP
             TEMP_MAX_ROUTINE(4);
           #endif
+          #if HOTENDS > 5
+            #ifdef HEATER_5_MINTEMP
+              TEMP_MIN_ROUTINE(5);
+            #endif
+            #ifdef HEATER_5_MAXTEMP
+              TEMP_MAX_ROUTINE(5);
+            #endif
+          #endif // HOTENDS > 5
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
 
   #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
         #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
           bed_minttemp_raw += OVERSAMPLENR;
@@ -1532,20 +1556,23 @@ void Temperature::disable_all_heaters() {
   #if HAS_TEMP_HOTEND
     DISABLE_HEATER(0);
     #if HOTENDS > 1
       DISABLE_HEATER(1);
       #if HOTENDS > 2
         DISABLE_HEATER(2);
         #if HOTENDS > 3
           DISABLE_HEATER(3);
           #if HOTENDS > 4
             DISABLE_HEATER(4);
+            #if HOTENDS > 5
+              DISABLE_HEATER(5);
+            #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   #endif
 
   #if HAS_HEATED_BED
     target_temperature_bed = 0;
     soft_pwm_amount_bed = 0;
     #if HAS_HEATED_BED
@@ -1658,24 +1685,27 @@ void Temperature::set_current_temp_raw() {
       redundant_temperature_raw = raw_temp_value[1];
     #else
       current_temperature_raw[1] = raw_temp_value[1];
     #endif
     #if HAS_TEMP_ADC_2
       current_temperature_raw[2] = raw_temp_value[2];
       #if HAS_TEMP_ADC_3
         current_temperature_raw[3] = raw_temp_value[3];
         #if HAS_TEMP_ADC_4
           current_temperature_raw[4] = raw_temp_value[4];
-        #endif
-      #endif
-    #endif
-  #endif
+          #if HAS_TEMP_ADC_5
+            current_temperature_raw[5] = raw_temp_value[5];
+          #endif // HAS_TEMP_ADC_5
+        #endif // HAS_TEMP_ADC_4
+      #endif // HAS_TEMP_ADC_3
+    #endif // HAS_TEMP_ADC_2
+  #endif // HAS_TEMP_ADC_1
 
   #if HAS_HEATED_BED
     current_temperature_bed_raw = raw_temp_bed_value;
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber_raw = raw_temp_chamber_value;
   #endif
   temp_meas_ready = true;
 }
 
@@ -1711,20 +1741,23 @@ void Temperature::readings_ready() {
       TEMPDIR(0)
     #endif
     #if HOTENDS > 1
       , TEMPDIR(1)
       #if HOTENDS > 2
         , TEMPDIR(2)
         #if HOTENDS > 3
           , TEMPDIR(3)
           #if HOTENDS > 4
             , TEMPDIR(4)
+            #if HOTENDS > 5
+              , TEMPDIR(5)
+            #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   };
 
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
     const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
     const bool heater_on = (target_temperature[e] > 0)
       #if ENABLED(PIDTEMP)
@@ -1808,20 +1841,23 @@ void Temperature::isr() {
   // Statics per heater
   ISR_STATICS(0);
   #if HOTENDS > 1
     ISR_STATICS(1);
     #if HOTENDS > 2
       ISR_STATICS(2);
       #if HOTENDS > 3
         ISR_STATICS(3);
         #if HOTENDS > 4
           ISR_STATICS(4);
+          #if HOTENDS > 5
+            ISR_STATICS(5);
+          #endif // HOTENDS > 5
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
   #if HAS_HEATED_BED
     ISR_STATICS(BED);
   #endif
 
   #if DISABLED(SLOW_PWM_HEATERS)
     constexpr uint8_t pwm_mask =
@@ -1844,20 +1880,24 @@ void Temperature::isr() {
         WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
         #if HOTENDS > 2
           soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
           WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
           #if HOTENDS > 3
             soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
             WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
             #if HOTENDS > 4
               soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
               WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
+              #if HOTENDS > 5
+                soft_pwm_count_5 = (soft_pwm_count_5 & pwm_mask) + soft_pwm_amount[5];
+                WRITE_HEATER_5(soft_pwm_count_5 > pwm_mask ? HIGH : LOW);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
       #if HAS_HEATED_BED
         soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
         WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
       #endif
 
@@ -1879,20 +1919,23 @@ void Temperature::isr() {
     else {
       if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
       #if HOTENDS > 1
         if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
         #if HOTENDS > 2
           if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
           #if HOTENDS > 3
             if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
             #if HOTENDS > 4
               if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
+              #if HOTENDS > 5
+                if (soft_pwm_count_5 <= pwm_count_tmp) WRITE_HEATER_5(LOW);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
       #if HAS_HEATED_BED
         if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
@@ -1961,39 +2004,45 @@ void Temperature::isr() {
 
       SLOW_PWM_ROUTINE(0);
       #if HOTENDS > 1
         SLOW_PWM_ROUTINE(1);
         #if HOTENDS > 2
           SLOW_PWM_ROUTINE(2);
           #if HOTENDS > 3
             SLOW_PWM_ROUTINE(3);
             #if HOTENDS > 4
               SLOW_PWM_ROUTINE(4);
+              #if HOTENDS > 5
+                SLOW_PWM_ROUTINE(5);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
       #endif
 
     } // slow_pwm_count == 0
 
     PWM_OFF_ROUTINE(0);
     #if HOTENDS > 1
       PWM_OFF_ROUTINE(1);
       #if HOTENDS > 2
         PWM_OFF_ROUTINE(2);
         #if HOTENDS > 3
           PWM_OFF_ROUTINE(3);
           #if HOTENDS > 4
             PWM_OFF_ROUTINE(4);
+            #if HOTENDS > 5
+              PWM_OFF_ROUTINE(5);
+            #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
     #if HAS_HEATED_BED
       PWM_OFF_ROUTINE(BED); // BED
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
@@ -2040,20 +2089,23 @@ void Temperature::isr() {
 
       if (state_timer_heater_0 > 0) state_timer_heater_0--;
       #if HOTENDS > 1
         if (state_timer_heater_1 > 0) state_timer_heater_1--;
         #if HOTENDS > 2
           if (state_timer_heater_2 > 0) state_timer_heater_2--;
           #if HOTENDS > 3
             if (state_timer_heater_3 > 0) state_timer_heater_3--;
             #if HOTENDS > 4
               if (state_timer_heater_4 > 0) state_timer_heater_4--;
+              #if HOTENDS > 5
+                if (state_timer_heater_5 > 0) state_timer_heater_5--;
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         if (state_timer_heater_BED > 0) state_timer_heater_BED--;
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
@@ -2162,20 +2214,29 @@ void Temperature::isr() {
 
     #if HAS_TEMP_ADC_4
       case PrepareTemp_4:
         HAL_START_ADC(TEMP_4_PIN);
         break;
       case MeasureTemp_4:
         ACCUMULATE_ADC(raw_temp_value[4]);
         break;
     #endif
 
+    #if HAS_TEMP_ADC_5
+      case PrepareTemp_5:
+        HAL_START_ADC(TEMP_5_PIN);
+        break;
+      case MeasureTemp_5:
+        ACCUMULATE_ADC(raw_temp_value[5]);
+        break;
+    #endif
+
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH:
         HAL_START_ADC(FILWIDTH_PIN);
       break;
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
           raw_filwidth_value -= raw_filwidth_value >> 7; // Subtract 1/128th of the raw_filwidth_value
           raw_filwidth_value += uint32_t(HAL_READ_ADC()) << 7; // Add new ADC reading, scaled by 128
@@ -2211,21 +2272,21 @@ void Temperature::isr() {
 
   // Go to the next state
   adc_sensor_state = next_sensor_state;
 
   //
   // Additional ~1KHz Tasks
   //
 
   #if ENABLED(BABYSTEPPING)
     LOOP_XYZ(axis) {
-      const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
+      const int16_t curTodo = babystepsTodo[axis]; // get rid of volatile for performance
       if (curTodo) {
         stepper.babystep((AxisEnum)axis, curTodo > 0);
         if (curTodo > 0) babystepsTodo[axis]--;
                     else babystepsTodo[axis]++;
       }
     }
   #endif // BABYSTEPPING
 
   // Poll endstops state, if required
   endstops.poll();

commit b220a825a769955f8df0a929f4a1d582e461fffa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 12 04:29:18 2018 -0500

    Fix raw_filwidth_value error

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1c4d101e99..67c30d0c05 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1672,20 +1672,24 @@ void Temperature::set_current_temp_raw() {
 
   #if HAS_HEATED_BED
     current_temperature_bed_raw = raw_temp_bed_value;
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber_raw = raw_temp_chamber_value;
   #endif
   temp_meas_ready = true;
 }
 
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  uint32_t raw_filwidth_value; // = 0
+#endif
+
 void Temperature::readings_ready() {
   // Update the raw values if they've been read. Else we could be updating them during reading.
   if (!temp_meas_ready) set_current_temp_raw();
 
   // Filament Sensor - can be read any time since IIR filtering is used
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   #endif
 
   ZERO(raw_temp_value);
@@ -1812,24 +1816,20 @@ void Temperature::isr() {
         #if HOTENDS > 4
           ISR_STATICS(4);
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
   #if HAS_HEATED_BED
     ISR_STATICS(BED);
   #endif
 
-  #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    static unsigned long raw_filwidth_value = 0;
-  #endif
-
   #if DISABLED(SLOW_PWM_HEATERS)
     constexpr uint8_t pwm_mask =
       #if ENABLED(SOFT_PWM_DITHER)
         _BV(SOFT_PWM_SCALE) - 1
       #else
         0
       #endif
     ;
 
     /**
@@ -2170,22 +2170,22 @@ void Temperature::isr() {
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH:
         HAL_START_ADC(FILWIDTH_PIN);
       break;
       case Measure_FILWIDTH:
         if (!HAL_ADC_READY())
           next_sensor_state = adc_sensor_state; // redo this state
         else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
-          raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
-          raw_filwidth_value += ((unsigned long)HAL_READ_ADC() << 7); // Add new ADC reading, scaled by 128
+          raw_filwidth_value -= raw_filwidth_value >> 7; // Subtract 1/128th of the raw_filwidth_value
+          raw_filwidth_value += uint32_t(HAL_READ_ADC()) << 7; // Add new ADC reading, scaled by 128
         }
       break;
     #endif
 
     #if ENABLED(ADC_KEYPAD)
       case Prepare_ADC_KEY:
         HAL_START_ADC(ADC_KEYPAD_PIN);
         break;
       case Measure_ADC_KEY:
         if (!HAL_ADC_READY())

commit 530a13ab6cb681d0b14bbd9d73813f568c5ed68b
Author: AnHardt <github@kitelab.de>
Date:   Wed Sep 5 08:41:45 2018 +0200

    [2.0.x] SECURITYFIX missing max temp error when PID is used (#11717)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 6156545ef4..1c4d101e99 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1715,54 +1715,50 @@ void Temperature::readings_ready() {
           #if HOTENDS > 4
             , TEMPDIR(4)
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   };
 
   for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
     const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
-    const bool heater_on = 0 <
+    const bool heater_on = (target_temperature[e] > 0)
       #if ENABLED(PIDTEMP)
-        soft_pwm_amount[e]
-      #else
-        target_temperature[e]
+        || (soft_pwm_amount[e] > 0)
       #endif
     ;
-    if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
+    if (rawtemp > maxttemp_raw[e] * tdir) max_temp_error(e);
     if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
       #endif
           min_temp_error(e);
     }
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       else
         consecutive_low_temperature_error[e] = 0;
     #endif
   }
 
   #if HAS_HEATED_BED
     #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
       #define GEBED <=
     #else
       #define GEBED >=
     #endif
-    const bool bed_on = 0 <
+    const bool bed_on = (target_temperature_bed > 0)
       #if ENABLED(PIDTEMPBED)
-        soft_pwm_amount_bed
-      #else
-        target_temperature_bed
+        || (soft_pwm_amount_bed > 0)
       #endif
     ;
-    if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
+    if (current_temperature_bed_raw GEBED bed_maxttemp_raw) max_temp_error(-1);
     if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
   #endif
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).

commit c64199941e058abb18a06be90002f5f03009347b
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Tue Aug 14 01:28:52 2018 -0700

    Compile only selected PIO environment (#11519)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c483fd0903..6156545ef4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -24,21 +24,21 @@
  * temperature.cpp - temperature control
  */
 
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
-#include "../HAL/Delay.h"
+#include "../HAL/shared/Delay.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) || ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #include "printcounter.h"

commit 624986d42315cd685b29cad7cea3d1a9281c48df
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Thu Jul 26 09:59:19 2018 +0100

    Ensure ADC conversion is complete before reading (#11336)
    
    The current Marlin implementation relies on a timer interrupt to start the ADC conversion and read it. However in some circumstances the interrupt can be delayed resulting in insufficient time being available for the ADC conversion. This results in a bad reading and false temperature fluctuations. These changes make sure that the conversion is complete (by checking the ADC hardware via the HAL) before reading a value.
    
    See: https://github.com/MarlinFirmware/Marlin/issues/11323

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9d420adb2a..c483fd0903 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1672,20 +1672,101 @@ void Temperature::set_current_temp_raw() {
 
   #if HAS_HEATED_BED
     current_temperature_bed_raw = raw_temp_bed_value;
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber_raw = raw_temp_chamber_value;
   #endif
   temp_meas_ready = true;
 }
 
+void Temperature::readings_ready() {
+  // Update the raw values if they've been read. Else we could be updating them during reading.
+  if (!temp_meas_ready) set_current_temp_raw();
+
+  // Filament Sensor - can be read any time since IIR filtering is used
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
+  #endif
+
+  ZERO(raw_temp_value);
+
+  #if HAS_HEATED_BED
+    raw_temp_bed_value = 0;
+  #endif
+
+  #if HAS_TEMP_CHAMBER
+    raw_temp_chamber_value = 0;
+  #endif
+
+  #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
+
+  int constexpr temp_dir[] = {
+    #if ENABLED(HEATER_0_USES_MAX6675)
+       0
+    #else
+      TEMPDIR(0)
+    #endif
+    #if HOTENDS > 1
+      , TEMPDIR(1)
+      #if HOTENDS > 2
+        , TEMPDIR(2)
+        #if HOTENDS > 3
+          , TEMPDIR(3)
+          #if HOTENDS > 4
+            , TEMPDIR(4)
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+  };
+
+  for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
+    const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
+    const bool heater_on = 0 <
+      #if ENABLED(PIDTEMP)
+        soft_pwm_amount[e]
+      #else
+        target_temperature[e]
+      #endif
+    ;
+    if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
+    if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
+      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+        if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+      #endif
+          min_temp_error(e);
+    }
+    #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+      else
+        consecutive_low_temperature_error[e] = 0;
+    #endif
+  }
+
+  #if HAS_HEATED_BED
+    #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
+      #define GEBED <=
+    #else
+      #define GEBED >=
+    #endif
+    const bool bed_on = 0 <
+      #if ENABLED(PIDTEMPBED)
+        soft_pwm_amount_bed
+      #else
+        target_temperature_bed
+      #endif
+    ;
+    if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
+    if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
+  #endif
+}
+
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
@@ -1989,225 +2070,162 @@ void Temperature::isr() {
 
   /**
    * One sensor is sampled on every other call of the ISR.
    * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
    *
    * On each Prepare pass, ADC is started for a sensor pin.
    * On the next pass, the ADC value is read and accumulated.
    *
    * This gives each ADC 0.9765ms to charge up.
    */
+  #define ACCUMULATE_ADC(var) do{ \
+    if (!HAL_ADC_READY()) next_sensor_state = adc_sensor_state; \
+    else var += HAL_READ_ADC(); \
+  }while(0)
+
+  ADCSensorState next_sensor_state = adc_sensor_state < SensorsReady ? (ADCSensorState)(int(adc_sensor_state) + 1) : StartSampling;
 
   switch (adc_sensor_state) {
 
     case SensorsReady: {
       // All sensors have been read. Stay in this state for a few
       // ISRs to save on calls to temp update/checking code below.
       constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
       static uint8_t delay_count = 0;
       if (extra_loops > 0) {
-        if (delay_count == 0) delay_count = extra_loops;   // Init this delay
-        if (--delay_count)                                 // While delaying...
-          adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
+        if (delay_count == 0) delay_count = extra_loops;  // Init this delay
+        if (--delay_count)                                // While delaying...
+          next_sensor_state = SensorsReady;               // retain this state (else, next state will be 0)
         break;
       }
-      else
-        adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
+      else {
+        adc_sensor_state = StartSampling;                 // Fall-through to start sampling
+        next_sensor_state = (ADCSensorState)(int(StartSampling) + 1);
+      }
     }
 
+    case StartSampling:                                   // Start of sampling loops. Do updates/checks.
+      if (++temp_count >= OVERSAMPLENR) {                 // 10 * 16 * 1/(16000000/64/256)  = 164ms.
+        temp_count = 0;
+        readings_ready();
+      }
+      break;
+
     #if HAS_TEMP_ADC_0
       case PrepareTemp_0:
         HAL_START_ADC(TEMP_0_PIN);
         break;
       case MeasureTemp_0:
-        raw_temp_value[0] += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_value[0]);
         break;
     #endif
 
     #if HAS_HEATED_BED
       case PrepareTemp_BED:
         HAL_START_ADC(TEMP_BED_PIN);
         break;
       case MeasureTemp_BED:
-        raw_temp_bed_value += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_bed_value);
         break;
     #endif
 
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER:
         HAL_START_ADC(TEMP_CHAMBER_PIN);
         break;
       case MeasureTemp_CHAMBER:
-        raw_temp_chamber_value += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_chamber_value);
         break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1:
         HAL_START_ADC(TEMP_1_PIN);
         break;
       case MeasureTemp_1:
-        raw_temp_value[1] += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_value[1]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_2
       case PrepareTemp_2:
         HAL_START_ADC(TEMP_2_PIN);
         break;
       case MeasureTemp_2:
-        raw_temp_value[2] += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_value[2]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_3
       case PrepareTemp_3:
         HAL_START_ADC(TEMP_3_PIN);
         break;
       case MeasureTemp_3:
-        raw_temp_value[3] += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_value[3]);
         break;
     #endif
 
     #if HAS_TEMP_ADC_4
       case PrepareTemp_4:
         HAL_START_ADC(TEMP_4_PIN);
         break;
       case MeasureTemp_4:
-        raw_temp_value[4] += HAL_READ_ADC;
+        ACCUMULATE_ADC(raw_temp_value[4]);
         break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH:
         HAL_START_ADC(FILWIDTH_PIN);
       break;
       case Measure_FILWIDTH:
-        if (HAL_READ_ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
+        if (!HAL_ADC_READY())
+          next_sensor_state = adc_sensor_state; // redo this state
+        else if (HAL_READ_ADC() > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
           raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
-          raw_filwidth_value += ((unsigned long)HAL_READ_ADC << 7); // Add new ADC reading, scaled by 128
+          raw_filwidth_value += ((unsigned long)HAL_READ_ADC() << 7); // Add new ADC reading, scaled by 128
         }
       break;
     #endif
 
     #if ENABLED(ADC_KEYPAD)
       case Prepare_ADC_KEY:
         HAL_START_ADC(ADC_KEYPAD_PIN);
         break;
       case Measure_ADC_KEY:
-        if (ADCKey_count < 16) {
-          raw_ADCKey_value = HAL_READ_ADC;
+        if (!HAL_ADC_READY())
+          next_sensor_state = adc_sensor_state; // redo this state
+        else if (ADCKey_count < 16) {
+          raw_ADCKey_value = HAL_READ_ADC();
           if (raw_ADCKey_value > 900) {
             //ADC Key release
             ADCKey_count = 0;
             current_ADCKey_raw = 0;
           }
           else {
             current_ADCKey_raw += raw_ADCKey_value;
             ADCKey_count++;
           }
         }
         break;
     #endif // ADC_KEYPAD
 
     case StartupDelay: break;
 
   } // switch(adc_sensor_state)
 
-  if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
-
-    temp_count = 0;
-
-    // Update the raw values if they've been read. Else we could be updating them during reading.
-    if (!temp_meas_ready) set_current_temp_raw();
-
-    // Filament Sensor - can be read any time since IIR filtering is used
-    #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
-    #endif
-
-    ZERO(raw_temp_value);
-
-    #if HAS_HEATED_BED
-      raw_temp_bed_value = 0;
-    #endif
-
-    #if HAS_TEMP_CHAMBER
-      raw_temp_chamber_value = 0;
-    #endif
-
-    #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
-
-    int constexpr temp_dir[] = {
-      #if ENABLED(HEATER_0_USES_MAX6675)
-         0
-      #else
-        TEMPDIR(0)
-      #endif
-      #if HOTENDS > 1
-        , TEMPDIR(1)
-        #if HOTENDS > 2
-          , TEMPDIR(2)
-          #if HOTENDS > 3
-            , TEMPDIR(3)
-            #if HOTENDS > 4
-              , TEMPDIR(4)
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
-    };
-
-    for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
-      const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
-      const bool heater_on = 0 <
-        #if ENABLED(PIDTEMP)
-          soft_pwm_amount[e]
-        #else
-          target_temperature[e]
-        #endif
-      ;
-      if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
-      if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
-        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
-        #endif
-            min_temp_error(e);
-      }
-      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-        else
-          consecutive_low_temperature_error[e] = 0;
-      #endif
-    }
-
-    #if HAS_HEATED_BED
-      #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
-        #define GEBED <=
-      #else
-        #define GEBED >=
-      #endif
-      const bool bed_on = 0 <
-        #if ENABLED(PIDTEMPBED)
-          soft_pwm_amount_bed
-        #else
-          target_temperature_bed
-        #endif
-      ;
-      if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
-      if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
-    #endif
-
-  } // temp_count >= OVERSAMPLENR
+  // Go to the next state
+  adc_sensor_state = next_sensor_state;
 
-  // Go to the next state, up to SensorsReady
-  adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
-  if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
+  //
+  // Additional ~1KHz Tasks
+  //
 
   #if ENABLED(BABYSTEPPING)
     LOOP_XYZ(axis) {
       const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
       if (curTodo) {
         stepper.babystep((AxisEnum)axis, curTodo > 0);
         if (curTodo > 0) babystepsTodo[axis]--;
                     else babystepsTodo[axis]++;
       }
     }

commit 22ebbc091f4d2864e5c530642abe5179515aa157
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 15 16:07:31 2018 -0500

    Tweak some SoftPWM code

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 78e0b0e204..9d420adb2a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -260,33 +260,43 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     float Ku, Tu,
           workKp = 0, workKi = 0, workKd = 0,
           max = 0, min = 10000;
 
-    #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
-    #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-      #define TV(B,H) (hotend < 0 ? (B) : (H))
-    #elif HAS_TP_BED
-      #define TV(B,H) (B)
+    #if HAS_PID_FOR_BOTH
+      #define GHV(B,H) (hotend < 0 ? (B) : (H))
+      #define SHV(S,B,H) if (hotend < 0) S##_bed = B; else S [hotend] = H;
+    #elif ENABLED(PIDTEMPBED)
+      #define GHV(B,H) B
+      #define SHV(S,B,H) (S##_bed = B)
     #else
-      #define TV(B,H) (H)
+      #define GHV(B,H) H
+      #define SHV(S,B,H) (S [hotend] = H)
     #endif
 
     #if WATCH_THE_BED || WATCH_HOTENDS
-      const uint16_t watch_temp_period = TV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
-      const uint8_t watch_temp_increase = TV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
-      const float watch_temp_target = target - float(watch_temp_increase + TV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
+      #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
+      #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
+        #define GTV(B,H) (hotend < 0 ? (B) : (H))
+      #elif HAS_TP_BED
+        #define GTV(B,H) (B)
+      #else
+        #define GTV(B,H) (H)
+      #endif
+      const uint16_t watch_temp_period = GTV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
+      const uint8_t watch_temp_increase = GTV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
+      const float watch_temp_target = target - float(watch_temp_increase + GTV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     #if ENABLED(PIDTEMP)
@@ -302,95 +312,61 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
     if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
       SERIAL_ECHOLNPGM(MSG_PID_BAD_EXTRUDER_NUM);
       return;
     }
 
     SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters(); // switch off all heaters.
 
-    #if HAS_PID_FOR_BOTH
-      if (hotend < 0)
-        soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
-      else
-        soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
-    #elif ENABLED(PIDTEMP)
-      soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
-    #else
-      soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
-    #endif
+    SHV(soft_pwm_amount, bias = d = (MAX_BED_POWER) >> 1, bias = d = (PID_MAX) >> 1);
 
     wait_for_heatup = true; // Can be interrupted with M108
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         // Get the current temperature and constrain it
-        current =
-          #if HAS_PID_FOR_BOTH
-            hotend < 0 ? current_temperature_bed : current_temperature[hotend]
-          #elif ENABLED(PIDTEMP)
-            current_temperature[hotend]
-          #else
-            current_temperature_bed
-          #endif
-        ;
+        current = GHV(current_temperature_bed, current_temperature[hotend]);
         NOLESS(max, current);
         NOMORE(min, current);
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
         if (heating && current > target) {
           if (ELAPSED(ms, t2 + 5000UL)) {
             heating = false;
-            #if HAS_PID_FOR_BOTH
-              if (hotend < 0)
-                soft_pwm_amount_bed = (bias - d) >> 1;
-              else
-                soft_pwm_amount[hotend] = (bias - d) >> 1;
-            #elif ENABLED(PIDTEMP)
-              soft_pwm_amount[hotend] = (bias - d) >> 1;
-            #elif ENABLED(PIDTEMPBED)
-              soft_pwm_amount_bed = (bias - d) >> 1;
-            #endif
+            SHV(soft_pwm_amount, (bias - d) >> 1, (bias - d) >> 1);
             t1 = ms;
             t_high = t1 - t2;
             max = target;
           }
         }
 
         if (!heating && current < target) {
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
-              long max_pow =
-                #if HAS_PID_FOR_BOTH
-                  hotend < 0 ? MAX_BED_POWER : PID_MAX
-                #elif ENABLED(PIDTEMP)
-                  PID_MAX
-                #else
-                  MAX_BED_POWER
-                #endif
-              ;
+              const long max_pow = GHV(MAX_BED_POWER, PID_MAX);
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
               SERIAL_PROTOCOLPAIR(MSG_D, d);
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
                 Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f);
@@ -415,30 +391,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
                 workKp = 0.2*Ku;
                 workKi = 2*workKp/Tu;
                 workKd = workKp*Tu/3;
                 SERIAL_PROTOCOLLNPGM(" No overshoot");
                 SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
                 SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
                 SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
                 */
               }
             }
-            #if HAS_PID_FOR_BOTH
-              if (hotend < 0)
-                soft_pwm_amount_bed = (bias + d) >> 1;
-              else
-                soft_pwm_amount[hotend] = (bias + d) >> 1;
-            #elif ENABLED(PIDTEMP)
-              soft_pwm_amount[hotend] = (bias + d) >> 1;
-            #else
-              soft_pwm_amount_bed = (bias + d) >> 1;
-            #endif
+            SHV(soft_pwm_amount, (bias + d) >> 1, (bias + d) >> 1);
             cycles++;
             min = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
       #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
         #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       #endif
@@ -453,24 +420,24 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
           print_heaterstates();
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_THE_BED || WATCH_HOTENDS
           if (
             #if WATCH_THE_BED && WATCH_HOTENDS
               true
-            #elif WATCH_THE_BED
-              hotend < 0
-            #else
+            #elif WATCH_HOTENDS
               hotend >= 0
+            #else
+              hotend < 0
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
                 if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
                 _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, hotend));
@@ -487,21 +454,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
-          const char* estring = hotend < 0 ? "bed" : "";
+          const char* estring = GHV("bed", "");
           SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
         #elif ENABLED(PIDTEMP)
           SERIAL_PROTOCOLPAIR("#define DEFAULT_Kp ", workKp); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define DEFAULT_Ki ", workKi); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define DEFAULT_Kd ", workKd); SERIAL_EOL();
         #else
           SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKp ", workKp); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKi ", workKi); SERIAL_EOL();
@@ -575,25 +542,27 @@ int Temperature::getHeaterPower(const int heater) {
       if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     #if HAS_TEMP_CHAMBER
       if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[5]));
     #endif
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanPin); f++) {
-      #ifdef ARDUINO
-        pin_t pin = pgm_read_byte(&fanPin[f]);
-      #else
-        pin_t pin = fanPin[f];
-      #endif
+      const pin_t pin =
+        #ifdef ARDUINO
+          pgm_read_byte(&fanPin[f])
+        #else
+          fanPin[f]
+        #endif
+      ;
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (pin >= 0 && !TEST(fanDone, bit)) {
         uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
         #if ENABLED(AUTO_POWER_E_FANS)
           autofan_speed[f] = newFanSpeed;
         #endif
         // this idiom allows both digital and PWM fan outputs (see M42 handling).
         digitalWrite(pin, newFanSpeed);
         analogWrite(pin, newFanSpeed);
         SBI(fanDone, bit);

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 925032a9ec..78e0b0e204 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -386,27 +386,27 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
               ;
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
               SERIAL_PROTOCOLPAIR(MSG_D, d);
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
-                Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
-                Tu = ((float)(t_low + t_high) * 0.001);
+                Ku = (4.0f * d) / (float(M_PI) * (max - min) * 0.5f);
+                Tu = ((float)(t_low + t_high) * 0.001f);
                 SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
                 SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
-                workKp = 0.6 * Ku;
+                workKp = 0.6f * Ku;
                 workKi = 2 * workKp / Tu;
-                workKd = workKp * Tu * 0.125;
+                workKd = workKp * Tu * 0.125f;
                 SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
                 SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
                 SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
                 SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
                 /**
                 workKp = 0.33*Ku;
                 workKi = workKp/Tu;
                 workKd = workKp*Tu/3;
                 SERIAL_PROTOCOLLNPGM(" Some overshoot");
                 SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
@@ -637,21 +637,21 @@ float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST     true
   #else
     #define _HOTEND_TEST     e == active_extruder
   #endif
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
-      dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + PID_K1 * dTerm[HOTEND_INDEX];
+      dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + float(PID_K1) * dTerm[HOTEND_INDEX];
       temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
       #if HEATER_IDLE_HANDLER
         if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
           pid_output = 0;
           pid_reset[HOTEND_INDEX] = true;
         }
         else
       #endif
       if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
         pid_output = BANG_MAX;
@@ -1091,34 +1091,34 @@ void Temperature::updateTemperaturesFromRawValues() {
   #endif
 
   temp_meas_ready = false;
 }
 
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
   // Convert raw Filament Width to millimeters
   float Temperature::analog2widthFil() {
-    return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
+    return current_raw_filwidth * 5.0f * (1.0f / 16383.0f);
   }
 
   /**
    * Convert Filament Width (mm) to a simple ratio
    * and reduce to an 8 bit value.
    *
    * A nominal width of 1.75 and measured width of 1.73
    * gives (100 * 1.75 / 1.73) for a ratio of 101 and
    * a return value of 1.
    */
   int8_t Temperature::widthFil_to_size_ratio() {
     if (ABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
-      return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
+      return int(100.0f * filament_width_nominal / filament_width_meas) - 100;
     return 0;
   }
 
 #endif
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #ifndef MAX6675_SCK_PIN
     #define MAX6675_SCK_PIN SCK_PIN
   #endif
   #ifndef MAX6675_DO_PIN

commit 3fd1f32b7314d3efed6d4948ed5a7f0dfd8f7f9e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 10 20:11:40 2018 -0500

    Fix ADC key and chamber temp

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a195c86e5d..925032a9ec 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2061,21 +2061,21 @@ void Temperature::isr() {
       case MeasureTemp_BED:
         raw_temp_bed_value += HAL_READ_ADC;
         break;
     #endif
 
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER:
         HAL_START_ADC(TEMP_CHAMBER_PIN);
         break;
       case MeasureTemp_CHAMBER:
-        raw_temp_chamber_value += ADC;
+        raw_temp_chamber_value += HAL_READ_ADC;
         break;
     #endif
 
     #if HAS_TEMP_ADC_1
       case PrepareTemp_1:
         HAL_START_ADC(TEMP_1_PIN);
         break;
       case MeasureTemp_1:
         raw_temp_value[1] += HAL_READ_ADC;
         break;
@@ -2119,21 +2119,21 @@ void Temperature::isr() {
         }
       break;
     #endif
 
     #if ENABLED(ADC_KEYPAD)
       case Prepare_ADC_KEY:
         HAL_START_ADC(ADC_KEYPAD_PIN);
         break;
       case Measure_ADC_KEY:
         if (ADCKey_count < 16) {
-          raw_ADCKey_value = ADC;
+          raw_ADCKey_value = HAL_READ_ADC;
           if (raw_ADCKey_value > 900) {
             //ADC Key release
             ADCKey_count = 0;
             current_ADCKey_raw = 0;
           }
           else {
             current_ADCKey_raw += raw_ADCKey_value;
             ADCKey_count++;
           }
         }

commit 3701869e6cdf3fe24b44da8a606575cf4764f872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 3 01:43:00 2018 -0500

    Add HAL_timer_start for AVR, use stepper timer to time pulses

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bb45dcafd3..a195c86e5d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1227,28 +1227,21 @@ void Temperature::init() {
   #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
-  // todo: HAL: fix abstraction
-  #ifdef __AVR__
-    // Use timer0 for temperature measurement
-    // Interleave temperature interrupt with millies interrupt
-    OCR0B = 128;
-  #else
-    HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
-  #endif
+  HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     #if E0_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E0_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E0_AUTO_FAN_PIN);

commit 853a9056acdeae8f6a641506d004e982d1d54bd4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 28 06:18:11 2018 -0500

    Long thermistor tables need special consideration

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bcd1585177..bb45dcafd3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -47,24 +47,24 @@
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
 #if HOTEND_USES_THERMISTOR
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
-    static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
+    static constexpr uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
   #else
     static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
-    static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
+    static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   #endif
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 #if HAS_HEATED_BED

commit 1ce97f1f6d025c98036de097113167c10c4a6ba3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 27 23:27:51 2018 -0500

    Faster (bisect) search in thermistor tables (#10883)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1abcfb0dc8..bcd1585177 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -930,31 +930,39 @@ void Temperature::manage_heater() {
           WRITE_HEATER_BED(LOW);
         }
       #endif
     }
   #endif // HAS_HEATED_BED
 }
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
 
-#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                          \
-  for (uint8_t i = 1; i < LEN; i++) {                               \
-    const short entry10 = (short)pgm_read_word(&TBL[i][0]);         \
-    if (entry10 > raw) {                                            \
-      const short entry00 = (short)pgm_read_word(&TBL[i-1][0]),     \
-                  entry01 = (short)pgm_read_word(&TBL[i-1][1]),     \
-                  entry11 = (short)pgm_read_word(&TBL[i][1]);       \
-      return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00); \
-    }                                                               \
-  }                                                                 \
-  return (short)pgm_read_word(&TBL[LEN-1][1]);                      \
+/**
+ * Bisect search for the range of the 'raw' value, then interpolate
+ * proportionally between the under and over values.
+ */
+#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                             \
+  uint8_t l = 0, r = LEN, m;                                           \
+  for (;;) {                                                           \
+    m = (l + r) >> 1;                                                  \
+    if (m == l || m == r) return (short)pgm_read_word(&TBL[LEN-1][1]); \
+    short v00 = pgm_read_word(&TBL[m-1][0]),                           \
+          v10 = pgm_read_word(&TBL[m-0][0]);                           \
+         if (raw < v00) r = m;                                         \
+    else if (raw > v10) l = m;                                         \
+    else {                                                             \
+      const short v01 = (short)pgm_read_word(&TBL[m-1][1]),            \
+                  v11 = (short)pgm_read_word(&TBL[m-0][1]);            \
+      return v01 + (raw - v00) * float(v11 - v01) / float(v10 - v00);  \
+    }                                                                  \
+  }                                                                    \
 }while(0)
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog2temp(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif

commit d557c84a711b0c783e4524fc8fbaf8b58879bdba
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun May 20 11:37:55 2018 -0500

    [2.0.x] Error for FAST_PWM_FAN with 32 bit CPU (#10798)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a32ed91293..1abcfb0dc8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1378,21 +1378,21 @@ void Temperature::init() {
   #endif // HAS_HEATED_BED
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
 #if ENABLED(FAST_PWM_FAN)
 
   void Temperature::setPwmFrequency(const pin_t pin, int val) {
-    #ifdef ARDUINO
+    #if defined(ARDUINO) && !defined(ARDUINO_ARCH_SAM)
       val &= 0x07;
       switch (digitalPinToTimer(pin)) {
         #ifdef TCCR0A
           #if !AVR_AT90USB1286_FAMILY
             case TIMER0A:
           #endif
           case TIMER0B:                           //_SET_CS(0, val);
                                                     break;
         #endif
         #ifdef TCCR1A

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4ca119abd8..a32ed91293 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -34,24 +34,20 @@
 #include "../HAL/Delay.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING) || ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
-#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(PINS_DEBUGGING)
-  #include "endstops.h"
-#endif
-
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
@@ -2240,34 +2236,22 @@ void Temperature::isr() {
     LOOP_XYZ(axis) {
       const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
       if (curTodo) {
         stepper.babystep((AxisEnum)axis, curTodo > 0);
         if (curTodo > 0) babystepsTodo[axis]--;
                     else babystepsTodo[axis]++;
       }
     }
   #endif // BABYSTEPPING
 
-  #if ENABLED(PINS_DEBUGGING)
-    endstops.run_monitor();  // report changes in endstop status
-  #endif
-
-  // Update endstops state, if enabled
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    extern volatile uint8_t e_hit;
-    if (e_hit && ENDSTOPS_ENABLED) {
-      endstops.update();
-      e_hit--;
-    }
-  #else
-    if (ENDSTOPS_ENABLED) endstops.update();
-  #endif
+  // Poll endstops state, if required
+  endstops.poll();
 
   // Periodically call the planner timer
   planner.tick();
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8e5460f6bb..4ca119abd8 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -18,20 +18,21 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
 #include "temperature.h"
+#include "endstops.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/Delay.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #include "../libs/private_spi.h"
 #endif
@@ -1718,20 +1719,21 @@ void Temperature::set_current_temp_raw() {
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
+ *  - Call planner.tick to count down its "ignore" time
  */
 HAL_TEMP_TIMER_ISR {
   HAL_timer_isr_prologue(TEMP_TIMER_NUM);
 
   Temperature::isr();
 
   HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
 }
 
 void Temperature::isr() {
@@ -2242,29 +2244,33 @@ void Temperature::isr() {
         if (curTodo > 0) babystepsTodo[axis]--;
                     else babystepsTodo[axis]++;
       }
     }
   #endif // BABYSTEPPING
 
   #if ENABLED(PINS_DEBUGGING)
     endstops.run_monitor();  // report changes in endstop status
   #endif
 
+  // Update endstops state, if enabled
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-
     extern volatile uint8_t e_hit;
-
     if (e_hit && ENDSTOPS_ENABLED) {
-      endstops.update();  // call endstop update routine
+      endstops.update();
       e_hit--;
     }
+  #else
+    if (ENDSTOPS_ENABLED) endstops.update();
   #endif
+
+  // Periodically call the planner timer
+  planner.tick();
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif

commit 0566badcefda3146fbccebade4a9131cde5e6f20
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 16:38:17 2018 -0300

    Add memory barrier, optimal interrupt on-off
    
    Disabling an ISR on ARM has 3 instructions of latency. A Memory barrier is REQUIRED to ensure proper and predictable disabling. Memory barriers are expensive, so avoid disabling if already disabled (See https://mcuoneclipse.com/2015/10/16/nvic-disabling-interrupts-on-arm-cortex-m-and-the-need-for-a-memory-barrier-instruction/)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ad944476e3..8e5460f6bb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1078,23 +1078,21 @@ void Temperature::updateTemperaturesFromRawValues() {
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog2widthFil();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();
   #endif
 
-  CRITICAL_SECTION_START;
   temp_meas_ready = false;
-  CRITICAL_SECTION_END;
 }
 
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
   // Convert raw Filament Width to millimeters
   float Temperature::analog2widthFil() {
     return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
   }
 

commit e1d9046efc6a3e8f2b90ef29cd7b45dd318e1fa3
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sat May 19 22:39:36 2018 +0200

    [2.0.x] Temperature reading fix (#10774)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4cbcf791dc..ad944476e3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -970,44 +970,54 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
     }
 
   switch (e) {
     case 0:
       #if ENABLED(HEATER_0_USES_MAX6675)
         return raw * 0.25;
       #elif ENABLED(HEATER_0_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_0_USES_AD8495)
         return TEMP_AD8495(raw);
+      #else
+        break;
       #endif
     case 1:
       #if ENABLED(HEATER_1_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_1_USES_AD8495)
         return TEMP_AD8495(raw);
+      #else
+        break;
       #endif
     case 2:
       #if ENABLED(HEATER_2_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_2_USES_AD8495)
         return TEMP_AD8495(raw);
+      #else
+        break;
       #endif
     case 3:
       #if ENABLED(HEATER_3_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_3_USES_AD8495)
         return TEMP_AD8495(raw);
+      #else
+        break;
       #endif
     case 4:
       #if ENABLED(HEATER_4_USES_AD595)
         return TEMP_AD595(raw);
       #elif ENABLED(HEATER_4_USES_AD8495)
         return TEMP_AD8495(raw);
+      #else
+        break;
       #endif
     default: break;
   }
 
   #if HOTEND_USES_THERMISTOR
     // Thermistor with conversion table?
     const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
     SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
   #endif
 

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1b584ce065..4cbcf791dc 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -804,22 +804,22 @@ void Temperature::manage_heater() {
 
   #if ENABLED(EMERGENCY_PARSER)
     if (emergency_parser.killed_by_M112) kill(PSTR(MSG_KILLED));
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
-    if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
+    if (current_temperature[0] > MIN(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
+    if (current_temperature[0] < MAX(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
 
   #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
     millis_t ms = millis();
   #endif
 
   HOTEND_LOOP() {
 
     #if HEATER_IDLE_HANDLER
       if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
@@ -838,21 +838,21 @@ void Temperature::manage_heater() {
       if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
         if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
           _temp_error(e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
         else                                                                 // Start again if the target is still far off
           start_watching_heater(e);
       }
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       // Make sure measured temperatures are close together
-      if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
+      if (ABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
         _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
     #endif
 
   } // HOTEND_LOOP
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
@@ -1090,21 +1090,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 
   /**
    * Convert Filament Width (mm) to a simple ratio
    * and reduce to an 8 bit value.
    *
    * A nominal width of 1.75 and measured width of 1.73
    * gives (100 * 1.75 / 1.73) for a ratio of 101 and
    * a return value of 1.
    */
   int8_t Temperature::widthFil_to_size_ratio() {
-    if (FABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
+    if (ABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
       return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
     return 0;
   }
 
 #endif
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #ifndef MAX6675_SCK_PIN
     #define MAX6675_SCK_PIN SCK_PIN
   #endif

commit 083ec9963e2ab37d9fbe3640d83fe3fdac6ac613
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:08:55 2018 -0500

    Tweaks to heater / lcd conditions

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a55c803ebb..1b584ce065 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1119,21 +1119,23 @@ void Temperature::updateTemperaturesFromRawValues() {
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
-  #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1 || TEMP_SENSOR_CHAMBER == -1)
+  #if MB(RUMBA) && ( \
+       ENABLED(HEATER_0_USES_AD595)  || ENABLED(HEATER_1_USES_AD595)  || ENABLED(HEATER_2_USES_AD595)  || ENABLED(HEATER_3_USES_AD595)  || ENABLED(HEATER_4_USES_AD595)  || ENABLED(HEATER_BED_USES_AD595)  || ENABLED(HEATER_CHAMBER_USES_AD595) \
+    || ENABLED(HEATER_0_USES_AD8495) || ENABLED(HEATER_1_USES_AD8495) || ENABLED(HEATER_2_USES_AD8495) || ENABLED(HEATER_3_USES_AD8495) || ENABLED(HEATER_4_USES_AD8495) || ENABLED(HEATER_BED_USES_AD8495) || ENABLED(HEATER_CHAMBER_USES_AD8495))
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     MCUCR = _BV(JTD);
     MCUCR = _BV(JTD);
   #endif
 
   // Finish init of mult hotend arrays
   HOTEND_LOOP() maxttemp[e] = maxttemp[0];
 
   #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
     last_e_position = 0;

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 46f3dc58c3..a55c803ebb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -29,21 +29,21 @@
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
 #include "../HAL/Delay.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #include "../libs/private_spi.h"
 #endif
 
-#if ENABLED(BABYSTEPPING)
+#if ENABLED(BABYSTEPPING) || ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(PINS_DEBUGGING)
   #include "endstops.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)

commit a1062eec5b6afe38d6769beea89bb14017c3f260
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 08:34:04 2018 -0500

    Better handling of DELAY_NS and DELAY_US (#10716)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0060050243..46f3dc58c3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -23,20 +23,21 @@
 /**
  * temperature.cpp - temperature control
  */
 
 #include "temperature.h"
 
 #include "../Marlin.h"
 #include "../lcd/ultralcd.h"
 #include "planner.h"
 #include "../core/language.h"
+#include "../HAL/Delay.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(PINS_DEBUGGING)
@@ -674,28 +675,28 @@ float Temperature::get_pid_output(const int8_t e) {
         }
         pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
         temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
         iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
 
         pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
 
         #if ENABLED(PID_EXTRUSION_SCALING)
           cTerm[HOTEND_INDEX] = 0;
           if (_HOTEND_TEST) {
-            long e_position = stepper.position(E_AXIS);
+            const long e_position = stepper.position(E_AXIS);
             if (e_position > last_e_position) {
               lpq[lpq_ptr] = e_position - last_e_position;
               last_e_position = e_position;
             }
-            else {
+            else
               lpq[lpq_ptr] = 0;
-            }
+
             if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
             cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
             pid_output += cTerm[HOTEND_INDEX];
           }
         #endif // PID_EXTRUSION_SCALING
 
         if (pid_output > PID_MAX) {
           if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
           pid_output = PID_MAX;
         }
@@ -1622,21 +1623,21 @@ void Temperature::disable_all_heaters() {
 
     if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
 
     next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
 
     spiBegin();
     spiInit(MAX6675_SPEED_BITS);
 
     WRITE(MAX6675_SS, 0); // enable TT_MAX6675
 
-    DELAY_100NS;          // Ensure 100ns delay
+    DELAY_NS(100);       // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
       max6675_temp |= spiRec();
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     WRITE(MAX6675_SS, 1); // disable TT_MAX6675
 

commit f5aaa2d6c0e4b543ab9047b48c592081921c903a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 12 05:27:51 2018 -0500

    Fix some compiler warnings

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d60da8c4de..0060050243 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1002,20 +1002,22 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
         return TEMP_AD8495(raw);
       #endif
     default: break;
   }
 
   #if HOTEND_USES_THERMISTOR
     // Thermistor with conversion table?
     const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
     SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
   #endif
+
+  return 0;
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog2tempBed(const int raw) {
     #if ENABLED(HEATER_BED_USES_THERMISTOR)
       SCAN_THERMISTOR_TABLE(BEDTEMPTABLE, BEDTEMPTABLE_LEN);
     #elif ENABLED(HEATER_BED_USES_AD595)
       return TEMP_AD595(raw);

commit 625035a9cefde67da3f9f5933a2ba9e636cef5bb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 02:13:40 2018 -0500

    Fix M301 access to lpq_len (#10714)
    
    Co-Authored-By: Zwaubel

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 9039de075e..d60da8c4de 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -237,20 +237,24 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS];
 #if HEATER_IDLE_HANDLER
   millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
   bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
 #endif
 
 #if ENABLED(ADC_KEYPAD)
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
+#if ENABLED(PID_EXTRUSION_SCALING)
+  int16_t Temperature::lpq_len; // Initialized in configuration_store
+#endif
+
 #if HAS_PID_HEATING
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    */
   void Temperature::PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
     float current = 0.0;

commit 325bbbc8c2a65218ed6a0abc671e74fb41e6fc27
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 11 01:01:51 2018 -0500

    [2.0.x] Enable AD595 and AD8495 in concert (#10693)
    
    * Allow both AD595 and AD8495 in concert
    * General temperature code tweaks

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a27930ae50..9039de075e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -46,26 +46,28 @@
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../feature/emergency_parser.h"
 #endif
 
-#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-  static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
-  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
-#else
-  static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
-  static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
+#if HOTEND_USES_THERMISTOR
+  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+    static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
+    static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
+  #else
+    static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
+    static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
+  #endif
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 #if HAS_HEATED_BED
   #define TEMP_ERR_PSTR(MSG, E) \
@@ -923,151 +925,138 @@ void Temperature::manage_heater() {
         }
         else {
           soft_pwm_amount_bed = 0;
           WRITE_HEATER_BED(LOW);
         }
       #endif
     }
   #endif // HAS_HEATED_BED
 }
 
-#define PGM_RD_W(x)   (short)pgm_read_word(&x)
+#define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
+#define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
+
+#define SCAN_THERMISTOR_TABLE(TBL,LEN) do{                          \
+  for (uint8_t i = 1; i < LEN; i++) {                               \
+    const short entry10 = (short)pgm_read_word(&TBL[i][0]);         \
+    if (entry10 > raw) {                                            \
+      const short entry00 = (short)pgm_read_word(&TBL[i-1][0]),     \
+                  entry01 = (short)pgm_read_word(&TBL[i-1][1]),     \
+                  entry11 = (short)pgm_read_word(&TBL[i][1]);       \
+      return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00); \
+    }                                                               \
+  }                                                                 \
+  return (short)pgm_read_word(&TBL[LEN-1][1]);                      \
+}while(0)
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog2temp(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif
     {
       SERIAL_ERROR_START();
       SERIAL_ERROR((int)e);
       SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
       kill(PSTR(MSG_KILLED));
       return 0.0;
     }
 
-  #if ENABLED(HEATER_0_USES_MAX6675)
-    if (e == 0) return 0.25 * raw;
-  #endif
-
-  // Thermistor with conversion table?
-  if (heater_ttbl_map[e] != NULL) {
-    short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
-    for (uint8_t i = 1; i < heater_ttbllen_map[e]; i++) {
-      const short entry10 = PGM_RD_W((*tt)[i][0]);
-      if (entry10 > raw) {
-        const short entry00 = PGM_RD_W((*tt)[i - 1][0]),
-                    entry01 = PGM_RD_W((*tt)[i - 1][1]),
-                    entry11 = PGM_RD_W((*tt)[i][1]);
-        return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00);
-      }
-    }
-    return PGM_RD_W((*tt)[heater_ttbllen_map[e] - 1][1]); // Overflow: Return last value in the table
+  switch (e) {
+    case 0:
+      #if ENABLED(HEATER_0_USES_MAX6675)
+        return raw * 0.25;
+      #elif ENABLED(HEATER_0_USES_AD595)
+        return TEMP_AD595(raw);
+      #elif ENABLED(HEATER_0_USES_AD8495)
+        return TEMP_AD8495(raw);
+      #endif
+    case 1:
+      #if ENABLED(HEATER_1_USES_AD595)
+        return TEMP_AD595(raw);
+      #elif ENABLED(HEATER_1_USES_AD8495)
+        return TEMP_AD8495(raw);
+      #endif
+    case 2:
+      #if ENABLED(HEATER_2_USES_AD595)
+        return TEMP_AD595(raw);
+      #elif ENABLED(HEATER_2_USES_AD8495)
+        return TEMP_AD8495(raw);
+      #endif
+    case 3:
+      #if ENABLED(HEATER_3_USES_AD595)
+        return TEMP_AD595(raw);
+      #elif ENABLED(HEATER_3_USES_AD8495)
+        return TEMP_AD8495(raw);
+      #endif
+    case 4:
+      #if ENABLED(HEATER_4_USES_AD595)
+        return TEMP_AD595(raw);
+      #elif ENABLED(HEATER_4_USES_AD8495)
+        return TEMP_AD8495(raw);
+      #endif
+    default: break;
   }
 
-  // Thermocouple with amplifier ADC interface
-  return (raw *
-    #if HEATER_USES_AD8495
-      660.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET
-    #elif HEATER_USES_AD595
-      5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET
-    #else
-      0
-    #endif
-  );
+  #if HOTEND_USES_THERMISTOR
+    // Thermistor with conversion table?
+    const short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
+    SCAN_THERMISTOR_TABLE((*tt), heater_ttbllen_map[e]);
+  #endif
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog2tempBed(const int raw) {
-    #if ENABLED(BED_USES_THERMISTOR)
-
-      // Thermistor with conversion table
-      for (uint8_t i = 1; i < BEDTEMPTABLE_LEN; i++) {
-        const short entry10 = PGM_RD_W(BEDTEMPTABLE[i][0]);
-        if (entry10 > raw) {
-          const short entry00 = PGM_RD_W(BEDTEMPTABLE[i - 1][0]),
-                      entry01 = PGM_RD_W(BEDTEMPTABLE[i - 1][1]),
-                      entry11 = PGM_RD_W(BEDTEMPTABLE[i][1]);
-          return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00);
-        }
-      }
-      return PGM_RD_W(BEDTEMPTABLE[BEDTEMPTABLE_LEN - 1][1]); // Overflow: Return last value in the table
-
+    #if ENABLED(HEATER_BED_USES_THERMISTOR)
+      SCAN_THERMISTOR_TABLE(BEDTEMPTABLE, BEDTEMPTABLE_LEN);
+    #elif ENABLED(HEATER_BED_USES_AD595)
+      return TEMP_AD595(raw);
+    #elif ENABLED(HEATER_BED_USES_AD8495)
+      return TEMP_AD8495(raw);
     #else
-
-      // Thermocouple with amplifier ADC interface
-      return (raw *
-        #if ENABLED(BED_USES_AD595)
-          5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET
-        #elif ENABLED(BED_USES_AD8495)
-          660.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET
-        #else
-          0
-        #endif
-      );
-
+      return 0;
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog2tempChamber(const int raw) {
-    #if ENABLED(CHAMBER_USES_THERMISTOR)
-
-      // Thermistor with conversion table
-      for (uint8_t i = 1; i < CHAMBERTEMPTABLE_LEN; i++) {
-        const short entry10 = PGM_RD_W(CHAMBERTEMPTABLE[i][0]);
-        if (entry10 > raw) {
-          const short entry00 = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][0]),
-                      entry01 = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]),
-                      entry11 = PGM_RD_W(CHAMBERTEMPTABLE[i][1]);
-          return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00);
-        }
-      }
-      return PGM_RD_W(CHAMBERTEMPTABLE[CHAMBERTEMPTABLE_LEN - 1][1]); // Overflow: Return last value in the table
-
+    #if ENABLED(HEATER_CHAMBER_USES_THERMISTOR)
+      SCAN_THERMISTOR_TABLE(CHAMBERTEMPTABLE, CHAMBERTEMPTABLE_LEN);
+    #elif ENABLED(HEATER_CHAMBER_USES_AD595)
+      return TEMP_AD595(raw);
+    #elif ENABLED(HEATER_CHAMBER_USES_AD8495)
+      return TEMP_AD8495(raw);
     #else
-
-      // Thermocouple with amplifier ADC interface
-      return (raw *
-        #if ENABLED(CHAMBER_USES_AD595)
-          5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET
-        #elif ENABLED(CHAMBER_USES_AD8495)
-          660.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET
-        #else
-          0
-        #endif
-      );
-
+      return 0;
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = read_max6675();
   #endif
-  HOTEND_LOOP()
-    current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
+  HOTEND_LOOP() current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   #if HAS_HEATED_BED
     current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber = Temperature::analog2tempChamber(current_temperature_chamber_raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)

commit 81b632c2558257c31b2f762e9bf8237c03638e07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 19:33:41 2018 -0500

    Additional temp-oriented improvements

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b55fc1c73a..a27930ae50 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -945,122 +945,112 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
       SERIAL_ERROR((int)e);
       SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
       kill(PSTR(MSG_KILLED));
       return 0.0;
     }
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (e == 0) return 0.25 * raw;
   #endif
 
+  // Thermistor with conversion table?
   if (heater_ttbl_map[e] != NULL) {
-    float celsius = 0;
-    uint8_t i;
     short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
-
-    for (i = 1; i < heater_ttbllen_map[e]; i++) {
-      if (PGM_RD_W((*tt)[i][0]) > raw) {
-        celsius = PGM_RD_W((*tt)[i - 1][1]) +
-                  (raw - PGM_RD_W((*tt)[i - 1][0])) *
-                  (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
-                  (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
-        break;
+    for (uint8_t i = 1; i < heater_ttbllen_map[e]; i++) {
+      const short entry10 = PGM_RD_W((*tt)[i][0]);
+      if (entry10 > raw) {
+        const short entry00 = PGM_RD_W((*tt)[i - 1][0]),
+                    entry01 = PGM_RD_W((*tt)[i - 1][1]),
+                    entry11 = PGM_RD_W((*tt)[i][1]);
+        return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00);
       }
     }
-
-    // Overflow: Set to last value in the table
-    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
-
-    return celsius;
+    return PGM_RD_W((*tt)[heater_ttbllen_map[e] - 1][1]); // Overflow: Return last value in the table
   }
-  #if defined(HEATER_USES_AD8495)
-  return ((raw * (660.0 / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN)) + TEMP_SENSOR_AD8495_OFFSET;
-  #else
-  return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
-  #endif  
+
+  // Thermocouple with amplifier ADC interface
+  return (raw *
+    #if HEATER_USES_AD8495
+      660.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET
+    #elif HEATER_USES_AD595
+      5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET
+    #else
+      0
+    #endif
+  );
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog2tempBed(const int raw) {
     #if ENABLED(BED_USES_THERMISTOR)
-      float celsius = 0;
-      byte i;
-
-      for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
-        if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
-          celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
-                     (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
-                     (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
-                     (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
-          break;
+
+      // Thermistor with conversion table
+      for (uint8_t i = 1; i < BEDTEMPTABLE_LEN; i++) {
+        const short entry10 = PGM_RD_W(BEDTEMPTABLE[i][0]);
+        if (entry10 > raw) {
+          const short entry00 = PGM_RD_W(BEDTEMPTABLE[i - 1][0]),
+                      entry01 = PGM_RD_W(BEDTEMPTABLE[i - 1][1]),
+                      entry11 = PGM_RD_W(BEDTEMPTABLE[i][1]);
+          return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00);
         }
       }
-
-      // Overflow: Set to last value in the table
-      if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
-
-      return celsius;
-
-    #elif defined(BED_USES_AD595)
-
-      return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
-
-	#elif defined(BED_USES_AD8495)
-
-      return ((raw * (660.0 / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN)) + TEMP_SENSOR_AD8495_OFFSET;
+      return PGM_RD_W(BEDTEMPTABLE[BEDTEMPTABLE_LEN - 1][1]); // Overflow: Return last value in the table
 
     #else
 
-      UNUSED(raw);
-      return 0;
+      // Thermocouple with amplifier ADC interface
+      return (raw *
+        #if ENABLED(BED_USES_AD595)
+          5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET
+        #elif ENABLED(BED_USES_AD8495)
+          660.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET
+        #else
+          0
+        #endif
+      );
 
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog2tempChamber(const int raw) {
     #if ENABLED(CHAMBER_USES_THERMISTOR)
-      float celsius = 0;
-      byte i;
-
-      for (i = 1; i < CHAMBERTEMPTABLE_LEN; i++) {
-        if (PGM_RD_W(CHAMBERTEMPTABLE[i][0]) > raw) {
-          celsius  = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]) +
-                     (raw - PGM_RD_W(CHAMBERTEMPTABLE[i - 1][0])) *
-                     (float)(PGM_RD_W(CHAMBERTEMPTABLE[i][1]) - PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1])) /
-                     (float)(PGM_RD_W(CHAMBERTEMPTABLE[i][0]) - PGM_RD_W(CHAMBERTEMPTABLE[i - 1][0]));
-          break;
+
+      // Thermistor with conversion table
+      for (uint8_t i = 1; i < CHAMBERTEMPTABLE_LEN; i++) {
+        const short entry10 = PGM_RD_W(CHAMBERTEMPTABLE[i][0]);
+        if (entry10 > raw) {
+          const short entry00 = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][0]),
+                      entry01 = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]),
+                      entry11 = PGM_RD_W(CHAMBERTEMPTABLE[i][1]);
+          return entry01 + (raw - entry00) * float(entry11 - entry01) / float(entry10 - entry00);
         }
       }
+      return PGM_RD_W(CHAMBERTEMPTABLE[CHAMBERTEMPTABLE_LEN - 1][1]); // Overflow: Return last value in the table
 
-      // Overflow: Set to last value in the table
-      if (i == CHAMBERTEMPTABLE_LEN) celsius = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]);
-
-      return celsius;
-
-    #elif defined(CHAMBER_USES_AD595)
-
-      return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
-
-    #elif defined(CHAMBER_USES_AD8495)
-
-      return ((raw * (660.0 / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN)) + TEMP_SENSOR_AD8495_OFFSET;
-	  
     #else
 
-      UNUSED(raw);
-      return 0;
+      // Thermocouple with amplifier ADC interface
+      return (raw *
+        #if ENABLED(CHAMBER_USES_AD595)
+          5.0 * 100.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET
+        #elif ENABLED(CHAMBER_USES_AD8495)
+          660.0 / 1024.0 / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET
+        #else
+          0
+        #endif
+      );
 
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
@@ -1201,33 +1191,33 @@ void Temperature::init() {
 
     max6675_spi.init();
 
     OUT_WRITE(SS_PIN, HIGH);
     OUT_WRITE(MAX6675_SS, HIGH);
 
   #endif // HEATER_0_USES_MAX6675
 
   HAL_adc_init();
 
-  #if HAS_TEMP_0
+  #if HAS_TEMP_ADC_0
     HAL_ANALOG_SELECT(TEMP_0_PIN);
   #endif
-  #if HAS_TEMP_1
+  #if HAS_TEMP_ADC_1
     HAL_ANALOG_SELECT(TEMP_1_PIN);
   #endif
-  #if HAS_TEMP_2
+  #if HAS_TEMP_ADC_2
     HAL_ANALOG_SELECT(TEMP_2_PIN);
   #endif
-  #if HAS_TEMP_3
+  #if HAS_TEMP_ADC_3
     HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
-  #if HAS_TEMP_4
+  #if HAS_TEMP_ADC_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
@@ -1680,34 +1670,34 @@ void Temperature::disable_all_heaters() {
 
     return (int)max6675_temp;
   }
 
 #endif // HEATER_0_USES_MAX6675
 
 /**
  * Get raw temperatures
  */
 void Temperature::set_current_temp_raw() {
-  #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
+  #if HAS_TEMP_ADC_0 && DISABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = raw_temp_value[0];
   #endif
-  #if HAS_TEMP_1
+  #if HAS_TEMP_ADC_1
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       redundant_temperature_raw = raw_temp_value[1];
     #else
       current_temperature_raw[1] = raw_temp_value[1];
     #endif
-    #if HAS_TEMP_2
+    #if HAS_TEMP_ADC_2
       current_temperature_raw[2] = raw_temp_value[2];
-      #if HAS_TEMP_3
+      #if HAS_TEMP_ADC_3
         current_temperature_raw[3] = raw_temp_value[3];
-        #if HAS_TEMP_4
+        #if HAS_TEMP_ADC_4
           current_temperature_raw[4] = raw_temp_value[4];
         #endif
       #endif
     #endif
   #endif
 
   #if HAS_HEATED_BED
     current_temperature_bed_raw = raw_temp_bed_value;
   #endif
   #if HAS_TEMP_CHAMBER
@@ -2043,21 +2033,21 @@ void Temperature::isr() {
       if (extra_loops > 0) {
         if (delay_count == 0) delay_count = extra_loops;   // Init this delay
         if (--delay_count)                                 // While delaying...
           adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
         break;
       }
       else
         adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
     }
 
-    #if HAS_TEMP_0
+    #if HAS_TEMP_ADC_0
       case PrepareTemp_0:
         HAL_START_ADC(TEMP_0_PIN);
         break;
       case MeasureTemp_0:
         raw_temp_value[0] += HAL_READ_ADC;
         break;
     #endif
 
     #if HAS_HEATED_BED
       case PrepareTemp_BED:
@@ -2070,48 +2060,48 @@ void Temperature::isr() {
 
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER:
         HAL_START_ADC(TEMP_CHAMBER_PIN);
         break;
       case MeasureTemp_CHAMBER:
         raw_temp_chamber_value += ADC;
         break;
     #endif
 
-    #if HAS_TEMP_1
+    #if HAS_TEMP_ADC_1
       case PrepareTemp_1:
         HAL_START_ADC(TEMP_1_PIN);
         break;
       case MeasureTemp_1:
         raw_temp_value[1] += HAL_READ_ADC;
         break;
     #endif
 
-    #if HAS_TEMP_2
+    #if HAS_TEMP_ADC_2
       case PrepareTemp_2:
         HAL_START_ADC(TEMP_2_PIN);
         break;
       case MeasureTemp_2:
         raw_temp_value[2] += HAL_READ_ADC;
         break;
     #endif
 
-    #if HAS_TEMP_3
+    #if HAS_TEMP_ADC_3
       case PrepareTemp_3:
         HAL_START_ADC(TEMP_3_PIN);
         break;
       case MeasureTemp_3:
         raw_temp_value[3] += HAL_READ_ADC;
         break;
     #endif
 
-    #if HAS_TEMP_4
+    #if HAS_TEMP_ADC_4
       case PrepareTemp_4:
         HAL_START_ADC(TEMP_4_PIN);
         break;
       case MeasureTemp_4:
         raw_temp_value[4] += HAL_READ_ADC;
         break;
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       case Prepare_FILWIDTH:

commit e911635fb1604b7ab2c2bd9f829446c2718697d8
Author: nightdemonx <demonx@demonx.ru>
Date:   Wed May 2 01:24:45 2018 +0500

    Add thermocouple with AD8495 support

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ad40433f87..b55fc1c73a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -965,21 +965,25 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
                   (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
         break;
       }
     }
 
     // Overflow: Set to last value in the table
     if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
 
     return celsius;
   }
+  #if defined(HEATER_USES_AD8495)
+  return ((raw * (660.0 / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN)) + TEMP_SENSOR_AD8495_OFFSET;
+  #else
   return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
+  #endif  
 }
 
 #if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog2tempBed(const int raw) {
     #if ENABLED(BED_USES_THERMISTOR)
       float celsius = 0;
       byte i;
 
@@ -995,20 +999,24 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
 
       // Overflow: Set to last value in the table
       if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
 
       return celsius;
 
     #elif defined(BED_USES_AD595)
 
       return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
 
+	#elif defined(BED_USES_AD8495)
+
+      return ((raw * (660.0 / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN)) + TEMP_SENSOR_AD8495_OFFSET;
+
     #else
 
       UNUSED(raw);
       return 0;
 
     #endif
   }
 #endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
@@ -1031,20 +1039,24 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
 
       // Overflow: Set to last value in the table
       if (i == CHAMBERTEMPTABLE_LEN) celsius = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]);
 
       return celsius;
 
     #elif defined(CHAMBER_USES_AD595)
 
       return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
 
+    #elif defined(CHAMBER_USES_AD8495)
+
+      return ((raw * (660.0 / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN)) + TEMP_SENSOR_AD8495_OFFSET;
+	  
     #else
 
       UNUSED(raw);
       return 0;
 
     #endif
   }
 #endif // HAS_TEMP_CHAMBER
 
 /**

commit 5ac226aa93b9e57c7e66d885b02b40e1e399cad0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 27 19:20:22 2018 -0500

    Further cleanup of inline delays

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index de5812dfd4..ad40433f87 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1625,23 +1625,21 @@ void Temperature::disable_all_heaters() {
 
     if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
 
     next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
 
     spiBegin();
     spiInit(MAX6675_SPEED_BITS);
 
     WRITE(MAX6675_SS, 0); // enable TT_MAX6675
 
-    // ensure 100ns delay - a bit extra is fine
-    asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
-    asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
+    DELAY_100NS;          // Ensure 100ns delay
 
     // Read a big-endian temperature value
     max6675_temp = 0;
     for (uint8_t i = sizeof(max6675_temp); i--;) {
       max6675_temp |= spiRec();
       if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
     }
 
     WRITE(MAX6675_SS, 1); // disable TT_MAX6675
 

commit 2242b98248a50a2a3a8a29c9ec4f40308a2a0450
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Wed Apr 25 12:44:26 2018 +0100

    [LPC176x] Emergency Parser Feature (#10516)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d5da6e4eb7..de5812dfd4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -42,20 +42,24 @@
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(PINS_DEBUGGING)
   #include "endstops.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
+#if ENABLED(EMERGENCY_PARSER)
+  #include "../feature/emergency_parser.h"
+#endif
+
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
   static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
 #else
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
 #endif
 
 Temperature thermalManager;
 
@@ -785,21 +789,21 @@ void Temperature::manage_heater() {
       watchdog_reset();
       return;
     }
   #endif
 
   #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
-    if (killed_by_M112) kill(PSTR(MSG_KILLED));
+    if (emergency_parser.killed_by_M112) kill(PSTR(MSG_KILLED));
   #endif
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
     if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   #endif

commit 9789c1c719ac1bef616ee525a261c56350846bfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 24 07:55:58 2018 -0500

    Fix current_temperature_chamber compile error
    
    Fix #10505

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1b7ee86a57..d5da6e4eb7 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -559,22 +559,25 @@ int Temperature::getHeaterPower(const int heater) {
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
       AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4,
       AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : 5
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
-    if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
-      SBI(fanState, pgm_read_byte(&fanBit[5]));
+
+    #if HAS_TEMP_CHAMBER
+      if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
+        SBI(fanState, pgm_read_byte(&fanBit[5]));
+    #endif
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanPin); f++) {
       #ifdef ARDUINO
         pin_t pin = pgm_read_byte(&fanPin[f]);
       #else
         pin_t pin = fanPin[f];
       #endif
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (pin >= 0 && !TEST(fanDone, bit)) {

commit 0c428a66d92ab3db49c76cfedde5b239db16195d
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Tue Apr 24 00:05:07 2018 -0300

    Proper AVR preemptive interrupt handling (#10496)
    
    Also simplify logic on all ARM-based interrupts. Now, it is REQUIRED to properly configure interrupt priority. USART should have highest priority, followed by Stepper, and then all others.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index f383c3406e..1b7ee86a57 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1212,25 +1212,24 @@ void Temperature::init() {
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   // todo: HAL: fix abstraction
   #ifdef __AVR__
     // Use timer0 for temperature measurement
     // Interleave temperature interrupt with millies interrupt
     OCR0B = 128;
-    SBI(TIMSK0, OCIE0B);
   #else
     HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
-    HAL_timer_enable_interrupt(TEMP_TIMER_NUM);
   #endif
+  ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
     #if E0_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E0_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E0_AUTO_FAN_PIN);
     #endif
@@ -1709,36 +1708,27 @@ void Temperature::set_current_temp_raw() {
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
  */
 HAL_TEMP_TIMER_ISR {
   HAL_timer_isr_prologue(TEMP_TIMER_NUM);
+
   Temperature::isr();
-}
 
-volatile bool Temperature::in_temp_isr = false;
+  HAL_timer_isr_epilogue(TEMP_TIMER_NUM);
+}
 
 void Temperature::isr() {
-  // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
-  // at the end of its run, potentially causing re-entry. This flag prevents it.
-  if (in_temp_isr) return;
-  in_temp_isr = true;
-
-  // Allow UART and stepper ISRs
-  DISABLE_TEMPERATURE_INTERRUPT(); //Disable Temperature ISR
-  #ifndef CPU_32_BIT
-    sei();
-  #endif
 
   static int8_t temp_count = -1;
   static ADCSensorState adc_sensor_state = StartupDelay;
   static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   // avoid multiple loads of pwm_count
   uint8_t pwm_count_tmp = pwm_count;
   #if ENABLED(ADC_KEYPAD)
     static unsigned int raw_ADCKey_value = 0;
   #endif
 
@@ -2248,26 +2238,20 @@ void Temperature::isr() {
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
 
     extern volatile uint8_t e_hit;
 
     if (e_hit && ENDSTOPS_ENABLED) {
       endstops.update();  // call endstop update routine
       e_hit--;
     }
   #endif
-
-  #ifndef CPU_32_BIT
-    cli();
-  #endif
-  in_temp_isr = false;
-  ENABLE_TEMPERATURE_INTERRUPT(); //re-enable Temperature ISR
 }
 
 #if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif

commit cb46cb8480c33ffc9f6361b96ed200986a3bd9ac
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 23 17:13:01 2018 -0500

    Add HAS_HEATED_BED conditional (#10495)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 046c1cf4f9..f383c3406e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -56,90 +56,110 @@
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
-#if HAS_TEMP_BED
+#if HAS_HEATED_BED
   #define TEMP_ERR_PSTR(MSG, E) \
     (E) == -1 ? PSTR(MSG ## _BED) : \
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #else
   #define TEMP_ERR_PSTR(MSG, E) \
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #endif
 
 // public:
 
-float Temperature::current_temperature[HOTENDS] = { 0.0 },
-      Temperature::current_temperature_chamber = 0.0,
-      Temperature::current_temperature_bed = 0.0;
-
+float Temperature::current_temperature[HOTENDS] = { 0.0 };
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
-        Temperature::target_temperature[HOTENDS] = { 0 },
-        Temperature::current_temperature_chamber_raw = 0,
-        Temperature::current_temperature_bed_raw = 0;
+        Temperature::target_temperature[HOTENDS] = { 0 };
 
 #if ENABLED(AUTO_POWER_E_FANS)
   int16_t Temperature::autofan_speed[HOTENDS] = { 0 };
 #endif
 
-#if HAS_HEATER_BED
-  int16_t Temperature::target_temperature_bed = 0;
+#if HAS_HEATED_BED
+  float Temperature::current_temperature_bed = 0.0;
+  int16_t Temperature::current_temperature_bed_raw = 0,
+          Temperature::target_temperature_bed = 0;
+  uint8_t Temperature::soft_pwm_amount_bed;
+  #ifdef BED_MINTEMP
+    int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
+  #endif
+  #ifdef BED_MAXTEMP
+    int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
+  #endif
+  #if WATCH_THE_BED
+    uint16_t Temperature::watch_target_bed_temp = 0;
+    millis_t Temperature::watch_bed_next_ms = 0;
+  #endif
+  #if ENABLED(PIDTEMPBED)
+    float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd, // Initialized by settings.load()
+          Temperature::temp_iState_bed = { 0 },
+          Temperature::temp_dState_bed = { 0 },
+          Temperature::pTerm_bed,
+          Temperature::iTerm_bed,
+          Temperature::dTerm_bed,
+          Temperature::pid_error_bed;
+  #else
+    millis_t Temperature::next_bed_check_ms;
+  #endif
+  uint16_t Temperature::raw_temp_bed_value = 0;
+  #if HEATER_IDLE_HANDLER
+    millis_t Temperature::bed_idle_timeout_ms = 0;
+    bool Temperature::bed_idle_timeout_exceeded = false;
+  #endif
+#endif // HAS_HEATED_BED
+
+#if HAS_TEMP_CHAMBER
+  float Temperature::current_temperature_chamber = 0.0;
+  int16_t Temperature::current_temperature_chamber_raw = 0;
+  uint16_t Temperature::raw_temp_chamber_value = 0;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
     #if ENABLED(PID_EXTRUSION_SCALING)
       float Temperature::Kc[HOTENDS];
     #endif
   #else
     float Temperature::Kp, Temperature::Ki, Temperature::Kd;
     #if ENABLED(PID_EXTRUSION_SCALING)
       float Temperature::Kc;
     #endif
   #endif
 #endif
 
-// Initialized by settings.load()
-#if ENABLED(PIDTEMPBED)
-  float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd;
-#endif
-
 #if ENABLED(BABYSTEPPING)
   volatile int Temperature::babystepsTodo[XYZ] = { 0 };
 #endif
 
 #if WATCH_HOTENDS
   uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
   millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
 #endif
 
-#if WATCH_THE_BED
-  uint16_t Temperature::watch_target_bed_temp = 0;
-  millis_t Temperature::watch_bed_next_ms = 0;
-#endif
-
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
 #if EARLY_WATCHDOG
   bool Temperature::inited = false;
 #endif
@@ -162,88 +182,62 @@ volatile bool Temperature::temp_meas_ready = false;
     float Temperature::cTerm[HOTENDS];
     long Temperature::last_e_position;
     long Temperature::lpq[LPQ_MAX_LEN];
     int Temperature::lpq_ptr = 0;
   #endif
 
   float Temperature::pid_error[HOTENDS];
   bool Temperature::pid_reset[HOTENDS];
 #endif
 
-#if ENABLED(PIDTEMPBED)
-  float Temperature::temp_iState_bed = { 0 },
-        Temperature::temp_dState_bed = { 0 },
-        Temperature::pTerm_bed,
-        Temperature::iTerm_bed,
-        Temperature::dTerm_bed,
-        Temperature::pid_error_bed;
-#else
-  millis_t Temperature::next_bed_check_ms;
-#endif
-
-uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
-         Temperature::raw_temp_chamber_value = 0,
-         Temperature::raw_temp_bed_value = 0;
+uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 };
 
 // Init min and max temp with extreme values to prevent false errors during startup
 int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
         Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
         Temperature::minttemp[HOTENDS] = { 0 },
         Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
 #endif
 
 #ifdef MILLISECONDS_PREHEAT_TIME
   millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
 #endif
 
-#ifdef BED_MINTEMP
-  int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
-#endif
-
-#ifdef BED_MAXTEMP
-  int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
-#endif
-
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
 #endif
 
 #if HAS_AUTO_FAN
   millis_t Temperature::next_auto_fan_check_ms = 0;
 #endif
 
-uint8_t Temperature::soft_pwm_amount[HOTENDS],
-        Temperature::soft_pwm_amount_bed;
+uint8_t Temperature::soft_pwm_amount[HOTENDS];
 
 #if ENABLED(FAN_SOFT_PWM)
   uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
           Temperature::soft_pwm_count_fan[FAN_COUNT];
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
 #endif
 
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused;
 #endif
 
 #if HEATER_IDLE_HANDLER
   millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
   bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
-  #if HAS_TEMP_BED
-    millis_t Temperature::bed_idle_timeout_ms = 0;
-    bool Temperature::bed_idle_timeout_exceeded = false;
-  #endif
 #endif
 
 #if ENABLED(ADC_KEYPAD)
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if HAS_PID_HEATING
 
   /**
@@ -539,22 +533,27 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
-int Temperature::getHeaterPower(int heater) {
-  return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
+int Temperature::getHeaterPower(const int heater) {
+  return (
+    #if HAS_HEATED_BED
+      heater < 0 ? soft_pwm_amount_bed :
+    #endif
+    soft_pwm_amount[heater]
+  );
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
     static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN, CHAMBER_AUTO_FAN_PIN };
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
@@ -611,20 +610,21 @@ void Temperature::_temp_error(const int8_t e, const char * const serial_msg, con
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #endif
 }
 
 void Temperature::max_temp_error(const int8_t e) {
   _temp_error(e, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, e));
 }
+
 void Temperature::min_temp_error(const int8_t e) {
   _temp_error(e, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, e));
 }
 
 float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST     true
   #else
     #define _HOTEND_TEST     e == active_extruder
@@ -850,43 +850,43 @@ void Temperature::manage_heater() {
      * based on a delayed measurement of the filament diameter.
      */
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
-  #if WATCH_THE_BED
-    // Make sure temperature is increasing
-    if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
-      if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
-        _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
-      else                                                            // Start again if the target is still far off
-        start_watching_bed();
-    }
-  #endif // WATCH_THE_BED
+  #if HAS_HEATED_BED
+
+    #if WATCH_THE_BED
+      // Make sure temperature is increasing
+      if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
+        if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
+          _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
+        else                                                            // Start again if the target is still far off
+          start_watching_bed();
+      }
+    #endif // WATCH_THE_BED
 
-  #if DISABLED(PIDTEMPBED)
-    if (PENDING(ms, next_bed_check_ms)
+    #if DISABLED(PIDTEMPBED)
+      if (PENDING(ms, next_bed_check_ms)
+        #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+          && paused == last_pause_state
+        #endif
+      ) return;
+      next_bed_check_ms = ms + BED_CHECK_INTERVAL;
       #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
-        && paused == last_pause_state
+        last_pause_state = paused;
       #endif
-    ) return;
-    next_bed_check_ms = ms + BED_CHECK_INTERVAL;
-    #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
-      last_pause_state = paused;
     #endif
-  #endif
-
-  #if HAS_TEMP_BED
 
     #if HEATER_IDLE_HANDLER
       if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
         bed_idle_timeout_exceeded = true;
     #endif
 
     #if HAS_THERMALLY_PROTECTED_BED
       thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
     #endif
 
@@ -913,21 +913,21 @@ void Temperature::manage_heater() {
           #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
             soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
           #endif
         }
         else {
           soft_pwm_amount_bed = 0;
           WRITE_HEATER_BED(LOW);
         }
       #endif
     }
-  #endif // HAS_TEMP_BED
+  #endif // HAS_HEATED_BED
 }
 
 #define PGM_RD_W(x)   (short)pgm_read_word(&x)
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 float Temperature::analog2temp(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
@@ -961,21 +961,21 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
     }
 
     // Overflow: Set to last value in the table
     if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
 
     return celsius;
   }
   return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
 }
 
-#if HAS_TEMP_BED
+#if HAS_HEATED_BED
   // Derived from RepRap FiveD extruder::getTemperature()
   // For bed temperature measurement.
   float Temperature::analog2tempBed(const int raw) {
     #if ENABLED(BED_USES_THERMISTOR)
       float celsius = 0;
       byte i;
 
       for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
         if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
           celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
@@ -995,21 +995,21 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
 
       return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
 
     #else
 
       UNUSED(raw);
       return 0;
 
     #endif
   }
-#endif // HAS_TEMP_BED
+#endif // HAS_HEATED_BED
 
 #if HAS_TEMP_CHAMBER
   // Derived from RepRap FiveD extruder::getTemperature()
   // For chamber temperature measurement.
   float Temperature::analog2tempChamber(const int raw) {
     #if ENABLED(CHAMBER_USES_THERMISTOR)
       float celsius = 0;
       byte i;
 
       for (i = 1; i < CHAMBERTEMPTABLE_LEN; i++) {
@@ -1045,21 +1045,21 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = read_max6675();
   #endif
   HOTEND_LOOP()
     current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
-  #if HAS_TEMP_BED
+  #if HAS_HEATED_BED
     current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
   #endif
   #if HAS_TEMP_CHAMBER
     current_temperature_chamber = Temperature::analog2tempChamber(current_temperature_chamber_raw);
   #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog2widthFil();
@@ -1142,21 +1142,21 @@ void Temperature::init() {
   #endif
   #if HAS_HEATER_2
     OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
   #endif
   #if HAS_HEATER_3
     OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
     OUT_WRITE(HEATER_3_PIN, HEATER_4_INVERTING);
   #endif
-  #if HAS_HEATER_BED
+  #if HAS_HEATED_BED
     OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
   #endif
 
   #if HAS_FAN0
     SET_OUTPUT(FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
       setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
   #endif
 
@@ -1197,21 +1197,21 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_2
     HAL_ANALOG_SELECT(TEMP_2_PIN);
   #endif
   #if HAS_TEMP_3
     HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
-  #if HAS_TEMP_BED
+  #if HAS_HEATED_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if HAS_TEMP_CHAMBER
     HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   // todo: HAL: fix abstraction
@@ -1338,40 +1338,40 @@ void Temperature::init() {
             TEMP_MIN_ROUTINE(4);
           #endif
           #ifdef HEATER_4_MAXTEMP
             TEMP_MAX_ROUTINE(4);
           #endif
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
 
-  #if HAS_TEMP_BED
+  #if HAS_HEATED_BED
     #ifdef BED_MINTEMP
       while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
         #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
           bed_minttemp_raw += OVERSAMPLENR;
         #else
           bed_minttemp_raw -= OVERSAMPLENR;
         #endif
       }
     #endif // BED_MINTEMP
     #ifdef BED_MAXTEMP
       while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
         #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
           bed_maxttemp_raw -= OVERSAMPLENR;
         #else
           bed_maxttemp_raw += OVERSAMPLENR;
         #endif
       }
     #endif // BED_MAXTEMP
-  #endif // HAS_TEMP_BED
+  #endif // HAS_HEATED_BED
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
 #if ENABLED(FAST_PWM_FAN)
 
   void Temperature::setPwmFrequency(const pin_t pin, int val) {
     #ifdef ARDUINO
@@ -1476,21 +1476,21 @@ void Temperature::init() {
         else
           SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
         SERIAL_EOL();
     */
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
       if ((heater_id >= 0 && heater_idle_timeout_exceeded[heater_id])
-        #if HAS_TEMP_BED
+        #if HAS_HEATED_BED
           || (heater_id < 0 && bed_idle_timeout_exceeded)
         #endif
       ) {
         *state = TRInactive;
         tr_target_temperature[heater_index] = 0;
       }
       else
     #endif
     {
       // If the target temperature changes, restart
@@ -1522,21 +1522,24 @@ void Temperature::init() {
 
 #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif
 
   HOTEND_LOOP() setTargetHotend(0, e);
-  setTargetBed(0);
+
+  #if HAS_HEATED_BED
+    setTargetBed(0);
+  #endif
 
   // Unpause and reset everything
   #if ENABLED(PROBING_HEATERS_OFF)
     pause(false);
   #endif
 
   // If all heaters go down then for sure our print job has stopped
   print_job_timer.stop();
 
   #define DISABLE_HEATER(NR) { \
@@ -1554,43 +1557,43 @@ void Temperature::disable_all_heaters() {
         #if HOTENDS > 3
           DISABLE_HEATER(3);
           #if HOTENDS > 4
             DISABLE_HEATER(4);
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   #endif
 
-  #if HAS_TEMP_BED
+  #if HAS_HEATED_BED
     target_temperature_bed = 0;
     soft_pwm_amount_bed = 0;
-    #if HAS_HEATER_BED
+    #if HAS_HEATED_BED
       WRITE_HEATER_BED(LOW);
     #endif
   #endif
 }
 
 #if ENABLED(PROBING_HEATERS_OFF)
 
   void Temperature::pause(const bool p) {
     if (p != paused) {
       paused = p;
       if (p) {
         HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
-        #if HAS_TEMP_BED
+        #if HAS_HEATED_BED
           start_bed_idle_timer(0); // timeout immediately
         #endif
       }
       else {
         HOTEND_LOOP() reset_heater_idle_timer(e);
-        #if HAS_TEMP_BED
+        #if HAS_HEATED_BED
           reset_bed_idle_timer();
         #endif
       }
     }
   }
 
 #endif // PROBING_HEATERS_OFF
 
 #if ENABLED(HEATER_0_USES_MAX6675)
 
@@ -1680,22 +1683,27 @@ void Temperature::set_current_temp_raw() {
     #if HAS_TEMP_2
       current_temperature_raw[2] = raw_temp_value[2];
       #if HAS_TEMP_3
         current_temperature_raw[3] = raw_temp_value[3];
         #if HAS_TEMP_4
           current_temperature_raw[4] = raw_temp_value[4];
         #endif
       #endif
     #endif
   #endif
-  current_temperature_bed_raw = raw_temp_bed_value;
-  current_temperature_chamber_raw = raw_temp_chamber_value;
+
+  #if HAS_HEATED_BED
+    current_temperature_bed_raw = raw_temp_bed_value;
+  #endif
+  #if HAS_TEMP_CHAMBER
+    current_temperature_chamber_raw = raw_temp_chamber_value;
+  #endif
   temp_meas_ready = true;
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
@@ -1752,21 +1760,21 @@ void Temperature::isr() {
     #if HOTENDS > 2
       ISR_STATICS(2);
       #if HOTENDS > 3
         ISR_STATICS(3);
         #if HOTENDS > 4
           ISR_STATICS(4);
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
-  #if HAS_HEATER_BED
+  #if HAS_HEATED_BED
     ISR_STATICS(BED);
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static unsigned long raw_filwidth_value = 0;
   #endif
 
   #if DISABLED(SLOW_PWM_HEATERS)
     constexpr uint8_t pwm_mask =
       #if ENABLED(SOFT_PWM_DITHER)
@@ -1793,21 +1801,21 @@ void Temperature::isr() {
             soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
             WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
             #if HOTENDS > 4
               soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
               WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
-      #if HAS_HEATER_BED
+      #if HAS_HEATED_BED
         soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
         WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
           soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
           WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
         #endif
         #if HAS_FAN1
@@ -1828,21 +1836,21 @@ void Temperature::isr() {
           if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
           #if HOTENDS > 3
             if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
             #if HOTENDS > 4
               if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
-      #if HAS_HEATER_BED
+      #if HAS_HEATED_BED
         if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
           if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
         #endif
         #if HAS_FAN1
           if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
         #endif
@@ -1909,40 +1917,40 @@ void Temperature::isr() {
         #if HOTENDS > 2
           SLOW_PWM_ROUTINE(2);
           #if HOTENDS > 3
             SLOW_PWM_ROUTINE(3);
             #if HOTENDS > 4
               SLOW_PWM_ROUTINE(4);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
-      #if HAS_HEATER_BED
+      #if HAS_HEATED_BED
         _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
       #endif
 
     } // slow_pwm_count == 0
 
     PWM_OFF_ROUTINE(0);
     #if HOTENDS > 1
       PWM_OFF_ROUTINE(1);
       #if HOTENDS > 2
         PWM_OFF_ROUTINE(2);
         #if HOTENDS > 3
           PWM_OFF_ROUTINE(3);
           #if HOTENDS > 4
             PWM_OFF_ROUTINE(4);
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
-    #if HAS_HEATER_BED
+    #if HAS_HEATED_BED
       PWM_OFF_ROUTINE(BED); // BED
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count_tmp >= 127) {
         pwm_count_tmp = 0;
         #if HAS_FAN0
           soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
           WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
         #endif
@@ -1988,21 +1996,21 @@ void Temperature::isr() {
         #if HOTENDS > 2
           if (state_timer_heater_2 > 0) state_timer_heater_2--;
           #if HOTENDS > 3
             if (state_timer_heater_3 > 0) state_timer_heater_3--;
             #if HOTENDS > 4
               if (state_timer_heater_4 > 0) state_timer_heater_4--;
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
-      #if HAS_HEATER_BED
+      #if HAS_HEATED_BED
         if (state_timer_heater_BED > 0) state_timer_heater_BED--;
       #endif
     } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
 
   #endif // SLOW_PWM_HEATERS
 
   //
   // Update lcd buttons 488 times per second
   //
   static bool do_buttons;
@@ -2037,21 +2045,21 @@ void Temperature::isr() {
 
     #if HAS_TEMP_0
       case PrepareTemp_0:
         HAL_START_ADC(TEMP_0_PIN);
         break;
       case MeasureTemp_0:
         raw_temp_value[0] += HAL_READ_ADC;
         break;
     #endif
 
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       case PrepareTemp_BED:
         HAL_START_ADC(TEMP_BED_PIN);
         break;
       case MeasureTemp_BED:
         raw_temp_bed_value += HAL_READ_ADC;
         break;
     #endif
 
     #if HAS_TEMP_CHAMBER
       case PrepareTemp_CHAMBER:
@@ -2140,22 +2148,28 @@ void Temperature::isr() {
 
     // Update the raw values if they've been read. Else we could be updating them during reading.
     if (!temp_meas_ready) set_current_temp_raw();
 
     // Filament Sensor - can be read any time since IIR filtering is used
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
     #endif
 
     ZERO(raw_temp_value);
-    raw_temp_bed_value = 0;
-    raw_temp_chamber_value = 0;
+
+    #if HAS_HEATED_BED
+      raw_temp_bed_value = 0;
+    #endif
+
+    #if HAS_TEMP_CHAMBER
+      raw_temp_chamber_value = 0;
+    #endif
 
     #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
 
     int constexpr temp_dir[] = {
       #if ENABLED(HEATER_0_USES_MAX6675)
          0
       #else
         TEMPDIR(0)
       #endif
       #if HOTENDS > 1
@@ -2187,21 +2201,21 @@ void Temperature::isr() {
           if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
         #endif
             min_temp_error(e);
       }
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         else
           consecutive_low_temperature_error[e] = 0;
       #endif
     }
 
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
         #define GEBED <=
       #else
         #define GEBED >=
       #endif
       const bool bed_on = 0 <
         #if ENABLED(PIDTEMPBED)
           soft_pwm_amount_bed
         #else
           target_temperature_bed
@@ -2255,29 +2269,29 @@ void Temperature::isr() {
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     #if NUM_SERIAL > 1
       , const int8_t port=-1
     #endif
     , const int8_t e=-3
   ) {
-    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND && HAS_TEMP_CHAMBER) && HOTENDS <= 1
+    #if !(HAS_HEATED_BED && HAS_TEMP_HOTEND && HAS_TEMP_CHAMBER) && HOTENDS <= 1
       UNUSED(e);
     #endif
 
     SERIAL_PROTOCOLCHAR_P(port, ' ');
     SERIAL_PROTOCOLCHAR_P(port,
-      #if HAS_TEMP_CHAMBER && HAS_TEMP_BED && HAS_TEMP_HOTEND
+      #if HAS_TEMP_CHAMBER && HAS_HEATED_BED && HAS_TEMP_HOTEND
         e == -2 ? 'C' : e == -1 ? 'B' : 'T'
-      #elif HAS_TEMP_BED && HAS_TEMP_HOTEND
+      #elif HAS_HEATED_BED && HAS_TEMP_HOTEND
         e == -1 ? 'B' : 'T'
       #elif HAS_TEMP_HOTEND
         'T'
       #else
         'B'
       #endif
     );
     #if HOTENDS > 1
       if (e >= 0) SERIAL_PROTOCOLCHAR_P(port, '0' + e);
     #endif
@@ -2299,21 +2313,21 @@ void Temperature::isr() {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(gcode.target_extruder)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
       );
     #endif
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , -1 // BED
       );
     #endif
@@ -2331,21 +2345,21 @@ void Temperature::isr() {
           , rawHotendTemp(e)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , e
       );
     #endif
     SERIAL_PROTOCOLPGM_P(port, " @:");
     SERIAL_PROTOCOL_P(port, getHeaterPower(gcode.target_extruder));
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       SERIAL_PROTOCOLPGM_P(port, " B@:");
       SERIAL_PROTOCOL_P(port, getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
         SERIAL_PROTOCOLPAIR_P(port, " @", e);
         SERIAL_PROTOCOLCHAR_P(port, ':');
         SERIAL_PROTOCOL_P(port, getHeaterPower(e));
       }
     #endif

commit 0e8242180d8cf59f609fe3e775d2c41b1ef8272c
Author: Lenbok <lenbok@gmail.com>
Date:   Sat Feb 24 19:38:58 2018 +1300

    Chamber temperature monitoring and auto fan control.
    
    This is an initial cut for feedback, updated for 2.0.x.
    
    Chamber temperature is currently reported along with hot end and bed
    temperatures to serial. The format is just like that used for hot end
    and bed temperatures, but using 'C' prefix. As there is no heater,
    target is always 0. Is this appropriate, is there a better way to report
    chamber temperatures?
    
    Chamber temperatures are not reported on the LCD in any way.
    
    When auto chamber fan is enabled, it currently just uses the same
    temperature threshold as the other auto controlled fans.
    
    As the chamber temperature is not connected to any heater, it doesn't
    undergo mintemp/maxtemp monitoring. This would need to change in the
    future if chamber heating became a feature.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e2814d32b9..046c1cf4f9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -76,24 +76,26 @@ Temperature thermalManager;
     (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
     (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
     (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
     (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
     PSTR(MSG_E1 " " MSG)
 #endif
 
 // public:
 
 float Temperature::current_temperature[HOTENDS] = { 0.0 },
+      Temperature::current_temperature_chamber = 0.0,
       Temperature::current_temperature_bed = 0.0;
 
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
         Temperature::target_temperature[HOTENDS] = { 0 },
+        Temperature::current_temperature_chamber_raw = 0,
         Temperature::current_temperature_bed_raw = 0;
 
 #if ENABLED(AUTO_POWER_E_FANS)
   int16_t Temperature::autofan_speed[HOTENDS] = { 0 };
 #endif
 
 #if HAS_HEATER_BED
   int16_t Temperature::target_temperature_bed = 0;
 #endif
 
@@ -172,20 +174,21 @@ volatile bool Temperature::temp_meas_ready = false;
         Temperature::temp_dState_bed = { 0 },
         Temperature::pTerm_bed,
         Temperature::iTerm_bed,
         Temperature::dTerm_bed,
         Temperature::pid_error_bed;
 #else
   millis_t Temperature::next_bed_check_ms;
 #endif
 
 uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
+         Temperature::raw_temp_chamber_value = 0,
          Temperature::raw_temp_bed_value = 0;
 
 // Init min and max temp with extreme values to prevent false errors during startup
 int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
         Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
         Temperature::minttemp[HOTENDS] = { 0 },
         Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
@@ -543,33 +546,36 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
 
 Temperature::Temperature() { }
 
 int Temperature::getHeaterPower(int heater) {
   return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
-    static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
+    static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN, CHAMBER_AUTO_FAN_PIN };
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
-      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
+      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4,
+      AUTO_CHAMBER_IS_0 ? 0 : AUTO_CHAMBER_IS_1 ? 1 : AUTO_CHAMBER_IS_2 ? 2 : AUTO_CHAMBER_IS_3 ? 3 : AUTO_CHAMBER_IS_4 ? 4 : 5
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
+    if (current_temperature_chamber > EXTRUDER_AUTO_FAN_TEMPERATURE)
+      SBI(fanState, pgm_read_byte(&fanBit[5]));
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanPin); f++) {
       #ifdef ARDUINO
         pin_t pin = pgm_read_byte(&fanPin[f]);
       #else
         pin_t pin = fanPin[f];
       #endif
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (pin >= 0 && !TEST(fanDone, bit)) {
@@ -991,35 +997,74 @@ float Temperature::analog2temp(const int raw, const uint8_t e) {
 
     #else
 
       UNUSED(raw);
       return 0;
 
     #endif
   }
 #endif // HAS_TEMP_BED
 
+#if HAS_TEMP_CHAMBER
+  // Derived from RepRap FiveD extruder::getTemperature()
+  // For chamber temperature measurement.
+  float Temperature::analog2tempChamber(const int raw) {
+    #if ENABLED(CHAMBER_USES_THERMISTOR)
+      float celsius = 0;
+      byte i;
+
+      for (i = 1; i < CHAMBERTEMPTABLE_LEN; i++) {
+        if (PGM_RD_W(CHAMBERTEMPTABLE[i][0]) > raw) {
+          celsius  = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]) +
+                     (raw - PGM_RD_W(CHAMBERTEMPTABLE[i - 1][0])) *
+                     (float)(PGM_RD_W(CHAMBERTEMPTABLE[i][1]) - PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1])) /
+                     (float)(PGM_RD_W(CHAMBERTEMPTABLE[i][0]) - PGM_RD_W(CHAMBERTEMPTABLE[i - 1][0]));
+          break;
+        }
+      }
+
+      // Overflow: Set to last value in the table
+      if (i == CHAMBERTEMPTABLE_LEN) celsius = PGM_RD_W(CHAMBERTEMPTABLE[i - 1][1]);
+
+      return celsius;
+
+    #elif defined(CHAMBER_USES_AD595)
+
+      return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
+
+    #else
+
+      UNUSED(raw);
+      return 0;
+
+    #endif
+  }
+#endif // HAS_TEMP_CHAMBER
+
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = read_max6675();
   #endif
   HOTEND_LOOP()
     current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   #if HAS_TEMP_BED
     current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
   #endif
+  #if HAS_TEMP_CHAMBER
+    current_temperature_chamber = Temperature::analog2tempChamber(current_temperature_chamber_raw);
+  #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog2widthFil();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();
@@ -1069,21 +1114,21 @@ void Temperature::updateTemperaturesFromRawValues() {
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if EARLY_WATCHDOG
     // Flag that the thermalManager should be running
     if (inited) return;
     inited = true;
   #endif
 
-  #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
+  #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1 || TEMP_SENSOR_CHAMBER == -1)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     MCUCR = _BV(JTD);
     MCUCR = _BV(JTD);
   #endif
 
   // Finish init of mult hotend arrays
   HOTEND_LOOP() maxttemp[e] = maxttemp[0];
 
   #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
     last_e_position = 0;
@@ -1155,20 +1200,23 @@ void Temperature::init() {
   #endif
   #if HAS_TEMP_3
     HAL_ANALOG_SELECT(TEMP_3_PIN);
   #endif
   #if HAS_TEMP_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
+  #if HAS_TEMP_CHAMBER
+    HAL_ANALOG_SELECT(TEMP_CHAMBER_PIN);
+  #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   // todo: HAL: fix abstraction
   #ifdef __AVR__
     // Use timer0 for temperature measurement
     // Interleave temperature interrupt with millies interrupt
     OCR0B = 128;
     SBI(TIMSK0, OCIE0B);
@@ -1220,20 +1268,30 @@ void Temperature::init() {
   #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
     #if E4_AUTO_FAN_PIN == FAN1_PIN
       SET_OUTPUT(E4_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
         setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
       SET_OUTPUT(E4_AUTO_FAN_PIN);
     #endif
   #endif
+  #if HAS_AUTO_CHAMBER_FAN && !AUTO_CHAMBER_IS_0 && !AUTO_CHAMBER_IS_1 && !AUTO_CHAMBER_IS_2 && !AUTO_CHAMBER_IS_3 && ! AUTO_CHAMBER_IS_4
+    #if CHAMBER_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(CHAMBER_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(CHAMBER_AUTO_FAN_PIN);
+    #endif
+  #endif
 
   // Wait for temperature measurement to settle
   delay(250);
 
   #define TEMP_MIN_ROUTINE(NR) \
     minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
     while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
       if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
         minttemp_raw[NR] += OVERSAMPLENR; \
       else \
@@ -1623,20 +1681,21 @@ void Temperature::set_current_temp_raw() {
       current_temperature_raw[2] = raw_temp_value[2];
       #if HAS_TEMP_3
         current_temperature_raw[3] = raw_temp_value[3];
         #if HAS_TEMP_4
           current_temperature_raw[4] = raw_temp_value[4];
         #endif
       #endif
     #endif
   #endif
   current_temperature_bed_raw = raw_temp_bed_value;
+  current_temperature_chamber_raw = raw_temp_chamber_value;
   temp_meas_ready = true;
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
@@ -1987,20 +2046,29 @@ void Temperature::isr() {
 
     #if HAS_TEMP_BED
       case PrepareTemp_BED:
         HAL_START_ADC(TEMP_BED_PIN);
         break;
       case MeasureTemp_BED:
         raw_temp_bed_value += HAL_READ_ADC;
         break;
     #endif
 
+    #if HAS_TEMP_CHAMBER
+      case PrepareTemp_CHAMBER:
+        HAL_START_ADC(TEMP_CHAMBER_PIN);
+        break;
+      case MeasureTemp_CHAMBER:
+        raw_temp_chamber_value += ADC;
+        break;
+    #endif
+
     #if HAS_TEMP_1
       case PrepareTemp_1:
         HAL_START_ADC(TEMP_1_PIN);
         break;
       case MeasureTemp_1:
         raw_temp_value[1] += HAL_READ_ADC;
         break;
     #endif
 
     #if HAS_TEMP_2
@@ -2073,20 +2141,21 @@ void Temperature::isr() {
     // Update the raw values if they've been read. Else we could be updating them during reading.
     if (!temp_meas_ready) set_current_temp_raw();
 
     // Filament Sensor - can be read any time since IIR filtering is used
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
     #endif
 
     ZERO(raw_temp_value);
     raw_temp_bed_value = 0;
+    raw_temp_chamber_value = 0;
 
     #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
 
     int constexpr temp_dir[] = {
       #if ENABLED(HEATER_0_USES_MAX6675)
          0
       #else
         TEMPDIR(0)
       #endif
       #if HOTENDS > 1
@@ -2184,29 +2253,31 @@ void Temperature::isr() {
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     #if NUM_SERIAL > 1
       , const int8_t port=-1
     #endif
-    , const int8_t e=-2
+    , const int8_t e=-3
   ) {
-    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
+    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND && HAS_TEMP_CHAMBER) && HOTENDS <= 1
       UNUSED(e);
     #endif
 
     SERIAL_PROTOCOLCHAR_P(port, ' ');
     SERIAL_PROTOCOLCHAR_P(port,
-      #if HAS_TEMP_BED && HAS_TEMP_HOTEND
+      #if HAS_TEMP_CHAMBER && HAS_TEMP_BED && HAS_TEMP_HOTEND
+        e == -2 ? 'C' : e == -1 ? 'B' : 'T'
+      #elif HAS_TEMP_BED && HAS_TEMP_HOTEND
         e == -1 ? 'B' : 'T'
       #elif HAS_TEMP_HOTEND
         'T'
       #else
         'B'
       #endif
     );
     #if HOTENDS > 1
       if (e >= 0) SERIAL_PROTOCOLCHAR_P(port, '0' + e);
     #endif
@@ -2239,20 +2310,28 @@ void Temperature::isr() {
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , -1 // BED
       );
     #endif
+    #if HAS_TEMP_CHAMBER
+      print_heater_state(degChamber(), 0
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , rawChamberTemp()
+        #endif
+        , -2 // CHAMBER
+      );
+    #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
         #if NUM_SERIAL > 1
           , port
         #endif
         , e
       );

commit 1c36606886104281e9f37774373c95141d59107b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 4 18:53:37 2018 -0500

    Fix MSG_HEATING_FAILED_LCD_BED macro evaluation

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b40ea8f225..e2814d32b9 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -57,33 +57,36 @@
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
 #endif
 
 Temperature thermalManager;
 
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
  */
 #if HAS_TEMP_BED
-  #define _BED_ERR_PSTR(MSG, E) (E) == -1 ? PSTR(MSG ## _BED) :
+  #define TEMP_ERR_PSTR(MSG, E) \
+    (E) == -1 ? PSTR(MSG ## _BED) : \
+    (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
+    (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
+    (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
+    (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
+    PSTR(MSG_E1 " " MSG)
 #else
-  #define _BED_ERR_PSTR(MSG, E)
+  #define TEMP_ERR_PSTR(MSG, E) \
+    (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
+    (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
+    (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
+    (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
+    PSTR(MSG_E1 " " MSG)
 #endif
 
-#define TEMP_ERR_PSTR(MSG, E) \
-  _BED_ERR_PSTR(MSG, E) \
-  (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
-  (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
-  (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
-  (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
-  PSTR(MSG_E1 " " MSG)
-
 // public:
 
 float Temperature::current_temperature[HOTENDS] = { 0.0 },
       Temperature::current_temperature_bed = 0.0;
 
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
         Temperature::target_temperature[HOTENDS] = { 0 },
         Temperature::current_temperature_bed_raw = 0;
 
 #if ENABLED(AUTO_POWER_E_FANS)

commit 8bc93c6f2bc3acfe04890bf5cc187b42e27edd7c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Apr 4 17:29:27 2018 -0600

    Improve heating/cooling LCD messages (#10293)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ccc933b54a..b40ea8f225 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -52,20 +52,38 @@
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
   static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
 #else
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
 #endif
 
 Temperature thermalManager;
 
+/**
+ * Macros to include the heater id in temp errors. The compiler's dead-code
+ * elimination should (hopefully) optimize out the unused strings.
+ */
+#if HAS_TEMP_BED
+  #define _BED_ERR_PSTR(MSG, E) (E) == -1 ? PSTR(MSG ## _BED) :
+#else
+  #define _BED_ERR_PSTR(MSG, E)
+#endif
+
+#define TEMP_ERR_PSTR(MSG, E) \
+  _BED_ERR_PSTR(MSG, E) \
+  (HOTENDS > 1 && (E) == 1) ? PSTR(MSG_E2 " " MSG) : \
+  (HOTENDS > 2 && (E) == 2) ? PSTR(MSG_E3 " " MSG) : \
+  (HOTENDS > 3 && (E) == 3) ? PSTR(MSG_E4 " " MSG) : \
+  (HOTENDS > 4 && (E) == 4) ? PSTR(MSG_E5 " " MSG) : \
+  PSTR(MSG_E1 " " MSG)
+
 // public:
 
 float Temperature::current_temperature[HOTENDS] = { 0.0 },
       Temperature::current_temperature_bed = 0.0;
 
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
         Temperature::target_temperature[HOTENDS] = { 0 },
         Temperature::current_temperature_bed_raw = 0;
 
 #if ENABLED(AUTO_POWER_E_FANS)
@@ -440,26 +458,24 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
               hotend >= 0
             #endif
           ) {
             if (!heated) {                                          // If not yet reached target...
               if (current > next_watch_temp) {                      // Over the watch temp?
                 next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
                 temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
                 if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
               }
               else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
-                _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+                _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, hotend));
             }
             else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-              _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY),
-                hotend >= 0 ? PSTR(MSG_THERMAL_RUNAWAY) : PSTR(MSG_THERMAL_RUNAWAY_BED)
-              );
+              _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, hotend));
           }
         #endif
       } // every 2 seconds
 
       // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
       #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
         #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
       #endif
       if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
@@ -584,38 +600,24 @@ void Temperature::_temp_error(const int8_t e, const char * const serial_msg, con
       Running = false;
       killed = true;
       kill(lcd_msg);
     }
     else
       disable_all_heaters(); // paranoia
   #endif
 }
 
 void Temperature::max_temp_error(const int8_t e) {
-  #if HAS_TEMP_BED
-    _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
-  #else
-    _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
-    #if HOTENDS == 1
-      UNUSED(e);
-    #endif
-  #endif
+  _temp_error(e, PSTR(MSG_T_MAXTEMP), TEMP_ERR_PSTR(MSG_ERR_MAXTEMP, e));
 }
 void Temperature::min_temp_error(const int8_t e) {
-  #if HAS_TEMP_BED
-    _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
-  #else
-    _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
-    #if HOTENDS == 1
-      UNUSED(e);
-    #endif
-  #endif
+  _temp_error(e, PSTR(MSG_T_MINTEMP), TEMP_ERR_PSTR(MSG_ERR_MINTEMP, e));
 }
 
 float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST     true
   #else
     #define _HOTEND_TEST     e == active_extruder
   #endif
   float pid_output;
@@ -805,21 +807,21 @@ void Temperature::manage_heater() {
       // Check for thermal runaway
       thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
     #endif
 
     soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
 
     #if WATCH_HOTENDS
       // Make sure temperature is increasing
       if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
         if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
-          _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+          _temp_error(e, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, e));
         else                                                                 // Start again if the target is still far off
           start_watching_heater(e);
       }
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       // Make sure measured temperatures are close together
       if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
         _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
     #endif
@@ -843,21 +845,21 @@ void Temperature::manage_heater() {
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
       planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if WATCH_THE_BED
     // Make sure temperature is increasing
     if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
       if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
-        _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+        _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), TEMP_ERR_PSTR(MSG_HEATING_FAILED_LCD, -1));
       else                                                            // Start again if the target is still far off
         start_watching_bed();
     }
   #endif // WATCH_THE_BED
 
   #if DISABLED(PIDTEMPBED)
     if (PENDING(ms, next_bed_check_ms)
       #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
         && paused == last_pause_state
       #endif
@@ -1446,23 +1448,21 @@ void Temperature::init() {
         *state = TRStable;
       // While the temperature is stable watch for a bad temperature
       case TRStable:
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
           *timer = millis() + period_seconds * 1000UL;
           break;
         }
         else if (PENDING(millis(), *timer)) break;
         *state = TRRunaway;
       case TRRunaway:
-        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY),
-          heater_id >= 0 ? PSTR(MSG_THERMAL_RUNAWAY) : PSTR(MSG_THERMAL_RUNAWAY_BED)
-        );
+        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), TEMP_ERR_PSTR(MSG_THERMAL_RUNAWAY, heater_id));
     }
   }
 
 #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif

commit 7cbbc2af7a86f16588cc30936ec4d501b6bcf80d
Author: Karl Andersson <karl@iaccess.se>
Date:   Tue Apr 3 02:37:41 2018 +0200

    [2.0.x] Optional heater signal inversion (#10260)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 68feb8bd09..ccc933b54a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1078,36 +1078,36 @@ void Temperature::init() {
   #endif
 
   // Finish init of mult hotend arrays
   HOTEND_LOOP() maxttemp[e] = maxttemp[0];
 
   #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
     last_e_position = 0;
   #endif
 
   #if HAS_HEATER_0
-    SET_OUTPUT(HEATER_0_PIN);
+    OUT_WRITE(HEATER_0_PIN, HEATER_0_INVERTING);
   #endif
   #if HAS_HEATER_1
-    SET_OUTPUT(HEATER_1_PIN);
+    OUT_WRITE(HEATER_1_PIN, HEATER_1_INVERTING);
   #endif
   #if HAS_HEATER_2
-    SET_OUTPUT(HEATER_2_PIN);
+    OUT_WRITE(HEATER_2_PIN, HEATER_2_INVERTING);
   #endif
   #if HAS_HEATER_3
-    SET_OUTPUT(HEATER_3_PIN);
+    OUT_WRITE(HEATER_3_PIN, HEATER_3_INVERTING);
   #endif
   #if HAS_HEATER_4
-    SET_OUTPUT(HEATER_3_PIN);
+    OUT_WRITE(HEATER_3_PIN, HEATER_4_INVERTING);
   #endif
   #if HAS_HEATER_BED
-    SET_OUTPUT(HEATER_BED_PIN);
+    OUT_WRITE(HEATER_BED_PIN, HEATER_BED_INVERTING);
   #endif
 
   #if HAS_FAN0
     SET_OUTPUT(FAN_PIN);
     #if ENABLED(FAST_PWM_FAN)
       setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
   #endif
 
   #if HAS_FAN1

commit 97e8a6ebd972ce0ad5b4e27aa139b9bb074ff44e
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Mar 21 21:04:45 2018 -0300

    Various fixes for DUE... (#10152)
    
    - Watchdog reset during SD Card initialization.
    - Move `DebugMonitor` to `DebugMonitor_Due.cpp`.
    - Since the watchdog is enabled on boot do extra resets during init.
    - Have `thermalManager` do watchdog reset before its ISR starts to prevent reset.
    - Ensure that timers are stopped before reprogramming them to address tone issues.
    - Improve SAM3XE reset when reflashed through the native port.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1f7089adc1..68feb8bd09 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -110,20 +110,24 @@ int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
   millis_t Temperature::watch_bed_next_ms = 0;
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   bool Temperature::allow_cold_extrude = false;
   int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
 // private:
 
+#if EARLY_WATCHDOG
+  bool Temperature::inited = false;
+#endif
+
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   uint16_t Temperature::redundant_temperature_raw = 0;
   float Temperature::redundant_temperature = 0.0;
 #endif
 
 volatile bool Temperature::temp_meas_ready = false;
 
 #if ENABLED(PIDTEMP)
   float Temperature::temp_iState[HOTENDS] = { 0 },
         Temperature::temp_dState[HOTENDS] = { 0 },
@@ -754,20 +758,28 @@ float Temperature::get_pid_output(const int8_t e) {
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
+  #if EARLY_WATCHDOG
+    // If thermal manager is still not running, make sure to at least reset the watchdog!
+    if (!inited) {
+      watchdog_reset();
+      return;
+    }
+  #endif
+
   #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
   #if ENABLED(EMERGENCY_PARSER)
     if (killed_by_M112) kill(PSTR(MSG_KILLED));
   #endif
 
   if (!temp_meas_ready) return;
 
@@ -1046,20 +1058,26 @@ void Temperature::updateTemperaturesFromRawValues() {
   #endif
   SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
+  #if EARLY_WATCHDOG
+    // Flag that the thermalManager should be running
+    if (inited) return;
+    inited = true;
+  #endif
+
   #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
     MCUCR = _BV(JTD);
     MCUCR = _BV(JTD);
   #endif
 
   // Finish init of mult hotend arrays
   HOTEND_LOOP() maxttemp[e] = maxttemp[0];
 
   #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)

commit 837ac2fdbd9ab57cbf360baa92886d09ddd695fd
Author: AnHardt <github@kitelab.de>
Date:   Tue Mar 20 22:48:36 2018 +0100

    [2.0.x] Fix_Autotune_THERMAL_PROTECTION_BED_off (#10166)
    
    - Fix Autotune Thermal Protection
    - Make 2 constants in autotune configurable

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7f3099da8a..1f7089adc1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -402,54 +402,69 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
             #else
               soft_pwm_amount_bed = (bias + d) >> 1;
             #endif
             cycles++;
             min = target;
           }
         }
       }
 
       // Did the temperature overshoot very far?
-      #define MAX_OVERSHOOT_PID_AUTOTUNE 20
+      #ifndef MAX_OVERSHOOT_PID_AUTOTUNE
+        #define MAX_OVERSHOOT_PID_AUTOTUNE 20
+      #endif
       if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_SENSOR
           print_heaterstates();
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_THE_BED || WATCH_HOTENDS
-          if (!heated) {                                          // If not yet reached target...
-            if (current > next_watch_temp) {                      // Over the watch temp?
-              next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
-              temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
-              if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
+          if (
+            #if WATCH_THE_BED && WATCH_HOTENDS
+              true
+            #elif WATCH_THE_BED
+              hotend < 0
+            #else
+              hotend >= 0
+            #endif
+          ) {
+            if (!heated) {                                          // If not yet reached target...
+              if (current > next_watch_temp) {                      // Over the watch temp?
+                next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
+                temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
+                if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
+              }
+              else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
+                _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
             }
-            else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
-              _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+            else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
+              _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY),
+                hotend >= 0 ? PSTR(MSG_THERMAL_RUNAWAY) : PSTR(MSG_THERMAL_RUNAWAY_BED)
+              );
           }
-          else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-            _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY),
-              hotend >= 0 ? PSTR(MSG_THERMAL_RUNAWAY) : PSTR(MSG_THERMAL_RUNAWAY_BED)
-            );
         #endif
       } // every 2 seconds
 
-      // Timeout after 20 minutes since the last undershoot/overshoot cycle
-      if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
+      // Timeout after MAX_CYCLE_TIME_PID_AUTOTUNE minutes since the last undershoot/overshoot cycle
+      #ifndef MAX_CYCLE_TIME_PID_AUTOTUNE
+        #define MAX_CYCLE_TIME_PID_AUTOTUNE 20L
+      #endif
+      if (((ms - t1) + (ms - t2)) > (MAX_CYCLE_TIME_PID_AUTOTUNE * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char* estring = hotend < 0 ? "bed" : "";
           SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();

commit c6ff39cc14fd2dbc656e41736712a37f755499ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 17 16:49:08 2018 -0500

    Spacing cleanup

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index fdefeeff04..7f3099da8a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -445,31 +445,31 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
       if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char* estring = hotend < 0 ? "bed" : "";
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
         #elif ENABLED(PIDTEMP)
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_Kp ", workKp); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_Ki ", workKi); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_Kd ", workKd); SERIAL_EOL();
         #else
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
-          SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKp ", workKp); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKi ", workKi); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define DEFAULT_bedKd ", workKd); SERIAL_EOL();
         #endif
 
         #define _SET_BED_PID() do { \
           bedKp = workKp; \
           bedKi = scalePID_i(workKi); \
           bedKd = scalePID_d(workKd); \
         }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
           PID_PARAM(Kp, hotend) = workKp; \

commit ffbf63e6afb7728849d434ccfda89e3fd8b37094
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 01:53:50 2018 -0600

    Add HAS_TEMP_SENSOR conditional

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index bdee6e6bb0..fdefeeff04 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -410,21 +410,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
 
       // Did the temperature overshoot very far?
       #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
 
       // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
-        #if HAS_TEMP_HOTEND || HAS_TEMP_BED
+        #if HAS_TEMP_SENSOR
           print_heaterstates();
           SERIAL_EOL();
         #endif
         next_temp_ms = ms + 2000UL;
 
         // Make sure heating is actually working
         #if WATCH_THE_BED || WATCH_HOTENDS
           if (!heated) {                                          // If not yet reached target...
             if (current > next_watch_temp) {                      // Over the watch temp?
               next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
@@ -2137,21 +2137,21 @@ void Temperature::isr() {
     }
   #endif
 
   #ifndef CPU_32_BIT
     cli();
   #endif
   in_temp_isr = false;
   ENABLE_TEMPERATURE_INTERRUPT(); //re-enable Temperature ISR
 }
 
-#if HAS_TEMP_HOTEND || HAS_TEMP_BED
+#if HAS_TEMP_SENSOR
 
   #include "../gcode/gcode.h"
 
   static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       , const float r
     #endif
     #if NUM_SERIAL > 1
       , const int8_t port=-1
     #endif
@@ -2244,11 +2244,11 @@ void Temperature::isr() {
     void Temperature::auto_report_temperatures() {
       if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
         next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
         print_heaterstates();
         SERIAL_EOL();
       }
     }
 
   #endif // AUTO_REPORT_TEMPERATURES
 
-#endif // HAS_TEMP_HOTEND || HAS_TEMP_BED
+#endif // HAS_TEMP_SENSOR

commit 649f3754945390f55e8a14551560271badd26352
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 3 23:14:01 2018 -0600

    Fix: M112 calling kill from interrupt (#9923)
    
    Fix #9906

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index ec3797e6a1..bdee6e6bb0 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -743,20 +743,24 @@ float Temperature::get_pid_output(const int8_t e) {
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
   #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
     static bool last_pause_state;
   #endif
 
+  #if ENABLED(EMERGENCY_PARSER)
+    if (killed_by_M112) kill(PSTR(MSG_KILLED));
+  #endif
+
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
     if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
 
   #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER

commit 83d7e95de0534061ca6887a711bc611d209a628a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 18 02:23:55 2018 -0600

    Add MSG_THERMAL_RUNAWAY_BED (#9691)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 975e8892fb..ec3797e6a1 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -428,21 +428,23 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
           if (!heated) {                                          // If not yet reached target...
             if (current > next_watch_temp) {                      // Over the watch temp?
               next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
               temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
               if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
             }
             else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
               _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
           }
           else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
-            _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
+            _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY),
+              hotend >= 0 ? PSTR(MSG_THERMAL_RUNAWAY) : PSTR(MSG_THERMAL_RUNAWAY_BED)
+            );
         #endif
       } // every 2 seconds
 
       // Timeout after 20 minutes since the last undershoot/overshoot cycle
       if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
 
       if (cycles > ncycles) {
@@ -1407,21 +1409,23 @@ void Temperature::init() {
         *state = TRStable;
       // While the temperature is stable watch for a bad temperature
       case TRStable:
         if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
           *timer = millis() + period_seconds * 1000UL;
           break;
         }
         else if (PENDING(millis(), *timer)) break;
         *state = TRRunaway;
       case TRRunaway:
-        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
+        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY),
+          heater_id >= 0 ? PSTR(MSG_THERMAL_RUNAWAY) : PSTR(MSG_THERMAL_RUNAWAY_BED)
+        );
     }
   }
 
 #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
 
 void Temperature::disable_all_heaters() {
 
   #if ENABLED(AUTOTEMP)
     planner.autotemp_enabled = false;
   #endif

commit e698998343062cf8d15d79b26d14be0481ab35fe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 8 20:36:05 2018 -0600

    More reliable PROBING_HEATERS_OFF with BED_LIMIT_SWITCHING

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 824d77fb9b..975e8892fb 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -737,20 +737,24 @@ float Temperature::get_pid_output(const int8_t e) {
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
 void Temperature::manage_heater() {
 
+  #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+    static bool last_pause_state;
+  #endif
+
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
     if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
 
   #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
@@ -813,22 +817,29 @@ void Temperature::manage_heater() {
     // Make sure temperature is increasing
     if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
       if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
         _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
       else                                                            // Start again if the target is still far off
         start_watching_bed();
     }
   #endif // WATCH_THE_BED
 
   #if DISABLED(PIDTEMPBED)
-    if (PENDING(ms, next_bed_check_ms)) return;
+    if (PENDING(ms, next_bed_check_ms)
+      #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+        && paused == last_pause_state
+      #endif
+    ) return;
     next_bed_check_ms = ms + BED_CHECK_INTERVAL;
+    #if ENABLED(PROBING_HEATERS_OFF) && ENABLED(BED_LIMIT_SWITCHING)
+      last_pause_state = paused;
+    #endif
   #endif
 
   #if HAS_TEMP_BED
 
     #if HEATER_IDLE_HANDLER
       if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
         bed_idle_timeout_exceeded = true;
     #endif
 
     #if HAS_THERMALLY_PROTECTED_BED

commit b5e92f4f908461ca2c78a86eefe069b85af0a2dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 6 00:22:30 2018 -0600

    [2.0.x] Enable / disable PSU automatically (#9503)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 224fbcfced..824d77fb9b 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -56,24 +56,29 @@
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
 #endif
 
 Temperature thermalManager;
 
 // public:
 
 float Temperature::current_temperature[HOTENDS] = { 0.0 },
       Temperature::current_temperature_bed = 0.0;
+
 int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
         Temperature::target_temperature[HOTENDS] = { 0 },
         Temperature::current_temperature_bed_raw = 0;
 
+#if ENABLED(AUTO_POWER_E_FANS)
+  int16_t Temperature::autofan_speed[HOTENDS] = { 0 };
+#endif
+
 #if HAS_HEATER_BED
   int16_t Temperature::target_temperature_bed = 0;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(PIDTEMP)
   #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
     #if ENABLED(PID_EXTRUSION_SCALING)
       float Temperature::Kc[HOTENDS];
@@ -522,20 +527,23 @@ int Temperature::getHeaterPower(int heater) {
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanPin); f++) {
       #ifdef ARDUINO
         pin_t pin = pgm_read_byte(&fanPin[f]);
       #else
         pin_t pin = fanPin[f];
       #endif
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (pin >= 0 && !TEST(fanDone, bit)) {
         uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
+        #if ENABLED(AUTO_POWER_E_FANS)
+          autofan_speed[f] = newFanSpeed;
+        #endif
         // this idiom allows both digital and PWM fan outputs (see M42 handling).
         digitalWrite(pin, newFanSpeed);
         analogWrite(pin, newFanSpeed);
         SBI(fanDone, bit);
       }
     }
   }
 
 #endif // HAS_AUTO_FAN
 

commit 2bea1bda569ac7aecc87c0f79a7ceaa7a073a0b4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 21:17:33 2018 -0600

    Move more strings to PROGMEM

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index a80626764d..224fbcfced 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -259,25 +259,25 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
     #else
       #define _TOP_HOTEND -1
     #endif
     #if ENABLED(PIDTEMPBED)
       #define _BOT_HOTEND -1
     #else
       #define _BOT_HOTEND 0
     #endif
 
     if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
-      SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
+      SERIAL_ECHOLNPGM(MSG_PID_BAD_EXTRUDER_NUM);
       return;
     }
 
-    SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
+    SERIAL_ECHOLNPGM(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters(); // switch off all heaters.
 
     #if HAS_PID_FOR_BOTH
       if (hotend < 0)
         soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
       else
         soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
     #elif ENABLED(PIDTEMP)
       soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;

commit 750cc02b3a0abfa70c6dec808095909cfa14a8cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 20 14:13:17 2018 -0600

    Use delay() in serial temp report

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index d684c35f82..a80626764d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2147,21 +2147,21 @@ void Temperature::isr() {
     #if HOTENDS > 1
       if (e >= 0) SERIAL_PROTOCOLCHAR_P(port, '0' + e);
     #endif
     SERIAL_PROTOCOLCHAR_P(port, ':');
     SERIAL_PROTOCOL_P(port, c);
     SERIAL_PROTOCOLPAIR_P(port, " /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_PROTOCOLPAIR_P(port, " (", r / OVERSAMPLENR);
       SERIAL_PROTOCOLCHAR_P(port, ')');
     #endif
-    safe_delay(2);
+    delay(2);
   }
 
   void Temperature::print_heaterstates(
     #if NUM_SERIAL > 1
       const int8_t port
     #endif
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)

commit a408209d24ef2bdc8fa68679ba285db7c93cb005
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 15 00:39:31 2018 -0600

    More reliable temperature serial report?

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c859e414fe..d684c35f82 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2147,20 +2147,21 @@ void Temperature::isr() {
     #if HOTENDS > 1
       if (e >= 0) SERIAL_PROTOCOLCHAR_P(port, '0' + e);
     #endif
     SERIAL_PROTOCOLCHAR_P(port, ':');
     SERIAL_PROTOCOL_P(port, c);
     SERIAL_PROTOCOLPAIR_P(port, " /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_PROTOCOLPAIR_P(port, " (", r / OVERSAMPLENR);
       SERIAL_PROTOCOLCHAR_P(port, ')');
     #endif
+    safe_delay(2);
   }
 
   void Temperature::print_heaterstates(
     #if NUM_SERIAL > 1
       const int8_t port
     #endif
   ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 887b0717ef..c859e414fe 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2114,87 +2114,103 @@ void Temperature::isr() {
     cli();
   #endif
   in_temp_isr = false;
   ENABLE_TEMPERATURE_INTERRUPT(); //re-enable Temperature ISR
 }
 
 #if HAS_TEMP_HOTEND || HAS_TEMP_BED
 
   #include "../gcode/gcode.h"
 
-  void print_heater_state(const float &c, const float &t,
+  static void print_heater_state(const float &c, const float &t
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      const float r,
+      , const float r
     #endif
-    const int8_t e=-2
+    #if NUM_SERIAL > 1
+      , const int8_t port=-1
+    #endif
+    , const int8_t e=-2
   ) {
     #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
       UNUSED(e);
     #endif
 
-    SERIAL_PROTOCOLCHAR(' ');
-    SERIAL_PROTOCOLCHAR(
+    SERIAL_PROTOCOLCHAR_P(port, ' ');
+    SERIAL_PROTOCOLCHAR_P(port,
       #if HAS_TEMP_BED && HAS_TEMP_HOTEND
         e == -1 ? 'B' : 'T'
       #elif HAS_TEMP_HOTEND
         'T'
       #else
         'B'
       #endif
     );
     #if HOTENDS > 1
-      if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
+      if (e >= 0) SERIAL_PROTOCOLCHAR_P(port, '0' + e);
     #endif
-    SERIAL_PROTOCOLCHAR(':');
-    SERIAL_PROTOCOL(c);
-    SERIAL_PROTOCOLPAIR(" /" , t);
+    SERIAL_PROTOCOLCHAR_P(port, ':');
+    SERIAL_PROTOCOL_P(port, c);
+    SERIAL_PROTOCOLPAIR_P(port, " /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
-      SERIAL_PROTOCOLCHAR(')');
+      SERIAL_PROTOCOLPAIR_P(port, " (", r / OVERSAMPLENR);
+      SERIAL_PROTOCOLCHAR_P(port, ')');
     #endif
   }
 
-  void Temperature::print_heaterstates() {
+  void Temperature::print_heaterstates(
+    #if NUM_SERIAL > 1
+      const int8_t port
+    #endif
+  ) {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(gcode.target_extruder)
         #endif
+        #if NUM_SERIAL > 1
+          , port
+        #endif
       );
     #endif
     #if HAS_TEMP_BED
       print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawBedTemp()
         #endif
+        #if NUM_SERIAL > 1
+          , port
+        #endif
         , -1 // BED
       );
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(e)
         #endif
+        #if NUM_SERIAL > 1
+          , port
+        #endif
         , e
       );
     #endif
-    SERIAL_PROTOCOLPGM(" @:");
-    SERIAL_PROTOCOL(getHeaterPower(gcode.target_extruder));
+    SERIAL_PROTOCOLPGM_P(port, " @:");
+    SERIAL_PROTOCOL_P(port, getHeaterPower(gcode.target_extruder));
     #if HAS_TEMP_BED
-      SERIAL_PROTOCOLPGM(" B@:");
-      SERIAL_PROTOCOL(getHeaterPower(-1));
+      SERIAL_PROTOCOLPGM_P(port, " B@:");
+      SERIAL_PROTOCOL_P(port, getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
-        SERIAL_PROTOCOLPAIR(" @", e);
-        SERIAL_PROTOCOLCHAR(':');
-        SERIAL_PROTOCOL(getHeaterPower(e));
+        SERIAL_PROTOCOLPAIR_P(port, " @", e);
+        SERIAL_PROTOCOLCHAR_P(port, ':');
+        SERIAL_PROTOCOL_P(port, getHeaterPower(e));
       }
     #endif
   }
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
 
     uint8_t Temperature::auto_report_temp_interval;
     millis_t Temperature::next_temp_report_ms;
 
     void Temperature::auto_report_temperatures() {

commit 0e935069856db7059acd45555a6fec080b82706b
Author: revilor <oliver.rossmueller@web.de>
Date:   Thu Jan 4 10:26:14 2018 +0100

    Fix for issue #9005, #8942 - Bed PID autotuning (#9036)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 21d1a5bd71..887b0717ef 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -235,22 +235,22 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
     #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
     #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
       #define TV(B,H) (hotend < 0 ? (B) : (H))
     #elif HAS_TP_BED
       #define TV(B,H) (B)
     #else
       #define TV(B,H) (H)
     #endif
 
     #if WATCH_THE_BED || WATCH_HOTENDS
-      const int8_t watch_temp_period = TV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD),
-                   watch_temp_increase = TV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
+      const uint16_t watch_temp_period = TV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD);
+      const uint8_t watch_temp_increase = TV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
       const float watch_temp_target = target - float(watch_temp_increase + TV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 

commit 4af3d436b271f25bd7ffae78d860bc016525dd5a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 3 21:30:45 2018 -0600

    M303 pid autotune cleanup, commentary

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 09f492ee18..21d1a5bd71 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -212,61 +212,46 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
 #endif
 
 #if HAS_PID_HEATING
 
   /**
    * PID Autotuning (M303)
    *
    * Alternately heat and cool the nozzle, observing its behavior to
    * determine the best PID values to achieve a stable temperature.
    */
-  void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
-    float input = 0.0;
+  void Temperature::PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
+    float current = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     float Ku, Tu,
           workKp = 0, workKi = 0, workKd = 0,
           max = 0, min = 10000;
 
+    #define HAS_TP_BED (ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED))
+    #if HAS_TP_BED && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
+      #define TV(B,H) (hotend < 0 ? (B) : (H))
+    #elif HAS_TP_BED
+      #define TV(B,H) (B)
+    #else
+      #define TV(B,H) (H)
+    #endif
+
     #if WATCH_THE_BED || WATCH_HOTENDS
-      const float watch_temp_target = temp -
-        #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-          (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))
-        #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
-          (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)
-        #else
-          (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)
-        #endif
-      ;
-      const int8_t watch_temp_period =
-        #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-          hotend < 0 ? WATCH_BED_TEMP_PERIOD : WATCH_TEMP_PERIOD
-        #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
-          WATCH_BED_TEMP_PERIOD
-        #else
-          WATCH_TEMP_PERIOD
-        #endif
-      ;
-      const int8_t watch_temp_increase =
-        #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-          hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE
-        #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
-          WATCH_BED_TEMP_INCREASE
-        #else
-          WATCH_TEMP_INCREASE
-        #endif
-      ;
+      const int8_t watch_temp_period = TV(WATCH_BED_TEMP_PERIOD, WATCH_TEMP_PERIOD),
+                   watch_temp_increase = TV(WATCH_BED_TEMP_INCREASE, WATCH_TEMP_INCREASE);
+      const float watch_temp_target = target - float(watch_temp_increase + TV(TEMP_BED_HYSTERESIS, TEMP_HYSTERESIS) + 1);
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     #if ENABLED(PIDTEMP)
@@ -293,70 +278,70 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
       if (hotend < 0)
         soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
       else
         soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
     #elif ENABLED(PIDTEMP)
       soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
     #else
       soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
     #endif
 
-    wait_for_heatup = true;
+    wait_for_heatup = true; // Can be interrupted with M108
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
       const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
-        input =
+        // Get the current temperature and constrain it
+        current =
           #if HAS_PID_FOR_BOTH
             hotend < 0 ? current_temperature_bed : current_temperature[hotend]
           #elif ENABLED(PIDTEMP)
             current_temperature[hotend]
           #else
             current_temperature_bed
           #endif
         ;
-
-        NOLESS(max, input);
-        NOMORE(min, input);
+        NOLESS(max, current);
+        NOMORE(min, current);
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
             checkExtruderAutoFans();
             next_auto_fan_check_ms = ms + 2500UL;
           }
         #endif
 
-        if (heating && input > temp) {
+        if (heating && current > target) {
           if (ELAPSED(ms, t2 + 5000UL)) {
             heating = false;
             #if HAS_PID_FOR_BOTH
               if (hotend < 0)
                 soft_pwm_amount_bed = (bias - d) >> 1;
               else
                 soft_pwm_amount[hotend] = (bias - d) >> 1;
             #elif ENABLED(PIDTEMP)
               soft_pwm_amount[hotend] = (bias - d) >> 1;
             #elif ENABLED(PIDTEMPBED)
               soft_pwm_amount_bed = (bias - d) >> 1;
             #endif
             t1 = ms;
             t_high = t1 - t2;
-            max = temp;
+            max = target;
           }
         }
 
-        if (!heating && input < temp) {
+        if (!heating && current < target) {
           if (ELAPSED(ms, t1 + 5000UL)) {
             heating = true;
             t2 = ms;
             t_low = t2 - t1;
             if (cycles > 0) {
               long max_pow =
                 #if HAS_PID_FOR_BOTH
                   hotend < 0 ? MAX_BED_POWER : PID_MAX
                 #elif ENABLED(PIDTEMP)
                   PID_MAX
@@ -366,21 +351,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
               ;
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
               SERIAL_PROTOCOLPAIR(MSG_D, d);
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
-                Ku = (4.0 * d) / (M_PI * (max - min) * 0.5); // i.e., CIRCLE_CIRC((max - min) * 0.25)
+                Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
                 Tu = ((float)(t_low + t_high) * 0.001);
                 SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
                 SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
                 workKp = 0.6 * Ku;
                 workKi = 2 * workKp / Tu;
                 workKd = workKp * Tu * 0.125;
                 SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
                 SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
                 SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
                 SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
@@ -406,55 +391,62 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
               if (hotend < 0)
                 soft_pwm_amount_bed = (bias + d) >> 1;
               else
                 soft_pwm_amount[hotend] = (bias + d) >> 1;
             #elif ENABLED(PIDTEMP)
               soft_pwm_amount[hotend] = (bias + d) >> 1;
             #else
               soft_pwm_amount_bed = (bias + d) >> 1;
             #endif
             cycles++;
-            min = temp;
+            min = target;
           }
         }
       }
+
+      // Did the temperature overshoot very far?
       #define MAX_OVERSHOOT_PID_AUTOTUNE 20
-      if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
+      if (current > target + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
         break;
       }
-      // Every 2 seconds...
+
+      // Report heater states every 2 seconds
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_HOTEND || HAS_TEMP_BED
           print_heaterstates();
           SERIAL_EOL();
         #endif
-
         next_temp_ms = ms + 2000UL;
 
+        // Make sure heating is actually working
         #if WATCH_THE_BED || WATCH_HOTENDS
-          if (!heated && input > next_watch_temp) {
-            if (input > watch_temp_target) heated = true;
-            next_watch_temp = input + watch_temp_increase;
-            temp_change_ms = ms + watch_temp_period * 1000UL;
+          if (!heated) {                                          // If not yet reached target...
+            if (current > next_watch_temp) {                      // Over the watch temp?
+              next_watch_temp = current + watch_temp_increase;    // - set the next temp to watch for
+              temp_change_ms = ms + watch_temp_period * 1000UL;   // - move the expiration timer up
+              if (current > watch_temp_target) heated = true;     // - Flag if target temperature reached
+            }
+            else if (ELAPSED(ms, temp_change_ms))                 // Watch timer expired
+              _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
           }
-          else if (!heated && ELAPSED(ms, temp_change_ms))
-            _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
-          else if (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE)
+          else if (current < target - (MAX_OVERSHOOT_PID_AUTOTUNE)) // Heated, then temperature fell too far?
             _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
         #endif
       } // every 2 seconds
+
       // Timeout after 20 minutes since the last undershoot/overshoot cycle
       if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
+
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char* estring = hotend < 0 ? "bed" : "";
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
         #elif ENABLED(PIDTEMP)
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();

commit 5e01ee8adf8348a09711bcf136da730bb05dc3a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 1 18:24:54 2018 -0600

    Temperature updates for parity with 1.1.x

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0e6e0686ec..09f492ee18 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -237,25 +237,25 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
           (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
           (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)
         #else
           (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)
         #endif
       ;
       const int8_t watch_temp_period =
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-          hotend < 0 ? THERMAL_PROTECTION_BED_PERIOD : THERMAL_PROTECTION_PERIOD
+          hotend < 0 ? WATCH_BED_TEMP_PERIOD : WATCH_TEMP_PERIOD
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
-          THERMAL_PROTECTION_BED_PERIOD
+          WATCH_BED_TEMP_PERIOD
         #else
-          THERMAL_PROTECTION_PERIOD
+          WATCH_TEMP_PERIOD
         #endif
       ;
       const int8_t watch_temp_increase =
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
           hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
           WATCH_BED_TEMP_INCREASE
         #else
           WATCH_TEMP_INCREASE
         #endif
@@ -430,21 +430,23 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
         #endif
 
         next_temp_ms = ms + 2000UL;
 
         #if WATCH_THE_BED || WATCH_HOTENDS
           if (!heated && input > next_watch_temp) {
             if (input > watch_temp_target) heated = true;
             next_watch_temp = input + watch_temp_increase;
             temp_change_ms = ms + watch_temp_period * 1000UL;
           }
-          else if ((!heated && ELAPSED(ms, temp_change_ms)) || (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE))
+          else if (!heated && ELAPSED(ms, temp_change_ms))
+            _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+          else if (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE)
             _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
         #endif
       } // every 2 seconds
       // Timeout after 20 minutes since the last undershoot/overshoot cycle
       if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
@@ -827,65 +829,57 @@ void Temperature::manage_heater() {
     #if HEATER_IDLE_HANDLER
       if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
         bed_idle_timeout_exceeded = true;
     #endif
 
     #if HAS_THERMALLY_PROTECTED_BED
       thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
     #endif
 
     #if HEATER_IDLE_HANDLER
-      if (bed_idle_timeout_exceeded)
-      {
+      if (bed_idle_timeout_exceeded) {
         soft_pwm_amount_bed = 0;
-
         #if DISABLED(PIDTEMPBED)
           WRITE_HEATER_BED(LOW);
         #endif
       }
       else
     #endif
     {
       #if ENABLED(PIDTEMPBED)
         soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
-
-      #elif ENABLED(BED_LIMIT_SWITCHING)
+      #else
         // Check if temperature is within the correct band
         if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
-          if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
-            soft_pwm_amount_bed = 0;
-          else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
-            soft_pwm_amount_bed = MAX_BED_POWER >> 1;
-        }
-        else {
-          soft_pwm_amount_bed = 0;
-          WRITE_HEATER_BED(LOW);
-        }
-      #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
-        // Check if temperature is within the correct range
-        if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
-          soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
+          #if ENABLED(BED_LIMIT_SWITCHING)
+            if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
+              soft_pwm_amount_bed = 0;
+            else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
+              soft_pwm_amount_bed = MAX_BED_POWER >> 1;
+          #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
+            soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
+          #endif
         }
         else {
           soft_pwm_amount_bed = 0;
           WRITE_HEATER_BED(LOW);
         }
       #endif
     }
   #endif // HAS_TEMP_BED
 }
 
 #define PGM_RD_W(x)   (short)pgm_read_word(&x)
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
-float Temperature::analog2temp(int raw, uint8_t e) {
+float Temperature::analog2temp(const int raw, const uint8_t e) {
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     if (e > HOTENDS)
   #else
     if (e >= HOTENDS)
   #endif
     {
       SERIAL_ERROR_START();
       SERIAL_ERROR((int)e);
       SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
       kill(PSTR(MSG_KILLED));
@@ -912,53 +906,55 @@ float Temperature::analog2temp(int raw, uint8_t e) {
     }
 
     // Overflow: Set to last value in the table
     if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
 
     return celsius;
   }
   return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
 }
 
-// Derived from RepRap FiveD extruder::getTemperature()
-// For bed temperature measurement.
-float Temperature::analog2tempBed(const int raw) {
-  #if ENABLED(BED_USES_THERMISTOR)
-    float celsius = 0;
-    byte i;
-
-    for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
-      if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
-        celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
-                   (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
-                   (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
-                   (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
-        break;
+#if HAS_TEMP_BED
+  // Derived from RepRap FiveD extruder::getTemperature()
+  // For bed temperature measurement.
+  float Temperature::analog2tempBed(const int raw) {
+    #if ENABLED(BED_USES_THERMISTOR)
+      float celsius = 0;
+      byte i;
+
+      for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
+        if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
+          celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
+                     (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
+                     (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
+                     (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
+          break;
+        }
       }
-    }
 
-    // Overflow: Set to last value in the table
-    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
+      // Overflow: Set to last value in the table
+      if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
 
-    return celsius;
+      return celsius;
 
-  #elif defined(BED_USES_AD595)
+    #elif defined(BED_USES_AD595)
 
-    return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
+      return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
 
-  #else
+    #else
 
-    UNUSED(raw);
-    return 0;
+      UNUSED(raw);
+      return 0;
 
-  #endif
-}
+    #endif
+  }
+#endif // HAS_TEMP_BED
 
 /**
  * Get the raw values into the actual temperatures.
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = read_max6675();
@@ -1229,38 +1225,40 @@ void Temperature::init() {
             TEMP_MIN_ROUTINE(4);
           #endif
           #ifdef HEATER_4_MAXTEMP
             TEMP_MAX_ROUTINE(4);
           #endif
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
   #endif // HOTENDS > 1
 
-  #ifdef BED_MINTEMP
-    while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
-      #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
-        bed_minttemp_raw += OVERSAMPLENR;
-      #else
-        bed_minttemp_raw -= OVERSAMPLENR;
-      #endif
-    }
-  #endif // BED_MINTEMP
-  #ifdef BED_MAXTEMP
-    while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
-      #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
-        bed_maxttemp_raw -= OVERSAMPLENR;
-      #else
-        bed_maxttemp_raw += OVERSAMPLENR;
-      #endif
-    }
-  #endif // BED_MAXTEMP
+  #if HAS_TEMP_BED
+    #ifdef BED_MINTEMP
+      while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
+        #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+          bed_minttemp_raw += OVERSAMPLENR;
+        #else
+          bed_minttemp_raw -= OVERSAMPLENR;
+        #endif
+      }
+    #endif // BED_MINTEMP
+    #ifdef BED_MAXTEMP
+      while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
+        #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+          bed_maxttemp_raw -= OVERSAMPLENR;
+        #else
+          bed_maxttemp_raw += OVERSAMPLENR;
+        #endif
+      }
+    #endif // BED_MAXTEMP
+  #endif // HAS_TEMP_BED
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
 #if ENABLED(FAST_PWM_FAN)
 
   void Temperature::setPwmFrequency(const pin_t pin, int val) {
     #ifdef ARDUINO
@@ -1341,21 +1339,21 @@ void Temperature::init() {
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
     Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
     millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   #endif
 
   #if HAS_THERMALLY_PROTECTED_BED
     Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
     millis_t Temperature::thermal_runaway_bed_timer;
   #endif
 
-  void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
+  void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
         SERIAL_ECHO_START();
         SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
         if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
         SERIAL_ECHOPAIR(" ;  State:", *state);
         SERIAL_ECHOPAIR(" ;  Timer:", *timer);
         SERIAL_ECHOPAIR(" ;  Temperature:", current);
@@ -1364,36 +1362,36 @@ void Temperature::init() {
           SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
         else
           SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
         SERIAL_EOL();
     */
 
     const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
 
     #if HEATER_IDLE_HANDLER
       // If the heater idle timeout expires, restart
-      if (heater_id >= 0 && heater_idle_timeout_exceeded[heater_id]) {
+      if ((heater_id >= 0 && heater_idle_timeout_exceeded[heater_id])
+        #if HAS_TEMP_BED
+          || (heater_id < 0 && bed_idle_timeout_exceeded)
+        #endif
+      ) {
         *state = TRInactive;
         tr_target_temperature[heater_index] = 0;
       }
-      #if HAS_TEMP_BED
-        else if (heater_id < 0 && bed_idle_timeout_exceeded) {
-          *state = TRInactive;
-          tr_target_temperature[heater_index] = 0;
-        }
-      #endif
       else
     #endif
-    // If the target temperature changes, restart
-    if (tr_target_temperature[heater_index] != target) {
-      tr_target_temperature[heater_index] = target;
-      *state = target > 0 ? TRFirstHeating : TRInactive;
+    {
+      // If the target temperature changes, restart
+      if (tr_target_temperature[heater_index] != target) {
+        tr_target_temperature[heater_index] = target;
+        *state = target > 0 ? TRFirstHeating : TRInactive;
+      }
     }
 
     switch (*state) {
       // Inactive state waits for a target temperature to be set
       case TRInactive: break;
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
         if (current < tr_target_temperature[heater_index]) break;
         *state = TRStable;
       // While the temperature is stable watch for a bad temperature
@@ -2165,33 +2163,33 @@ void Temperature::isr() {
 
   void Temperature::print_heaterstates() {
     #if HAS_TEMP_HOTEND
       print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           , rawHotendTemp(gcode.target_extruder)
         #endif
       );
     #endif
     #if HAS_TEMP_BED
-      print_heater_state(degBed(), degTargetBed(),
+      print_heater_state(degBed(), degTargetBed()
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          rawBedTemp(),
+          , rawBedTemp()
         #endif
-        -1 // BED
+        , -1 // BED
       );
     #endif
     #if HOTENDS > 1
-      HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e),
+      HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          rawHotendTemp(e),
+          , rawHotendTemp(e)
         #endif
-        e
+        , e
       );
     #endif
     SERIAL_PROTOCOLPGM(" @:");
     SERIAL_PROTOCOL(getHeaterPower(gcode.target_extruder));
     #if HAS_TEMP_BED
       SERIAL_PROTOCOLPGM(" B@:");
       SERIAL_PROTOCOL(getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {

commit fdc5e72720edd95a7d1971749c497cb88b1413b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 21:26:06 2017 -0600

    A single setting to validate filament width

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 21e5b1fd60..0e6e0686ec 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -995,21 +995,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 
   /**
    * Convert Filament Width (mm) to a simple ratio
    * and reduce to an 8 bit value.
    *
    * A nominal width of 1.75 and measured width of 1.73
    * gives (100 * 1.75 / 1.73) for a ratio of 101 and
    * a return value of 1.
    */
   int8_t Temperature::widthFil_to_size_ratio() {
-    if (WITHIN(filament_width_meas, MEASURED_LOWER_LIMIT, MEASURED_UPPER_LIMIT))
+    if (FABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
       return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
     return 0;
   }
 
 #endif
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #ifndef MAX6675_SCK_PIN
     #define MAX6675_SCK_PIN SCK_PIN
   #endif

commit de5ca96654313a4c9cecaafe265035f6654128bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 18:36:16 2017 -0600

    More parity with 1.1.x, plus whitespace

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 333bc98285..21e5b1fd60 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -796,21 +796,21 @@ void Temperature::manage_heater() {
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     /**
      * Filament Width Sensor dynamically sets the volumetric multiplier
      * based on a delayed measurement of the filament diameter.
      */
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
-      calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index])
+      planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if WATCH_THE_BED
     // Make sure temperature is increasing
     if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
       if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
         _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
       else                                                            // Start again if the target is still far off
         start_watching_bed();

commit 0d531d96551abb6329e3513f5c10ad0c75250338
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Fri Dec 15 11:32:37 2017 -0800

    Missing HAS_HEAT_BED conditional
    
    Fixes issue found in #8779

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5b22b2ba42..333bc98285 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -958,21 +958,23 @@ float Temperature::analog2tempBed(const int raw) {
  * The raw values are created in interrupt context,
  * and this function is called from normal context
  * as it would block the stepper routine.
  */
 void Temperature::updateTemperaturesFromRawValues() {
   #if ENABLED(HEATER_0_USES_MAX6675)
     current_temperature_raw[0] = read_max6675();
   #endif
   HOTEND_LOOP()
     current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
-  current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
+  #if HAS_TEMP_BED
+    current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
+  #endif
   #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     filament_width_meas = analog2widthFil();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     // Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();

commit cf2193c07ffc07597ece619da2db8cc587f68479
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 13 02:32:34 2017 -0600

    Comment, fix filament width sensor

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 4401864c2e..5b22b2ba42 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -733,31 +733,20 @@ float Temperature::get_pid_output(const int8_t e) {
 
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
  *    - Also resets the watchdog timer
  *  - Invoke thermal runaway protection
  *  - Manage extruder auto-fan
  *  - Apply filament width to the extrusion rate (may move)
  *  - Update the heated bed PID output value
  */
-
-/**
- * The following line SOMETIMES results in the dreaded "unable to find a register to spill in class 'POINTER_REGS'"
- * compile error.
- *    thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
- *
- * This is due to a bug in the C++ compiler used by the Arduino IDE from 1.6.10 to at least 1.8.1.
- *
- * The work around is to add the compiler flag "__attribute__((__optimize__("O2")))" to the declaration for manage_heater()
- */
-//void Temperature::manage_heater()  __attribute__((__optimize__("O2")));
 void Temperature::manage_heater() {
 
   if (!temp_meas_ready) return;
 
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
     if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
     if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   #endif
@@ -798,32 +787,30 @@ void Temperature::manage_heater() {
 
   } // HOTEND_LOOP
 
   #if HAS_AUTO_FAN
     if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
       next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
-  // Control the extruder rate based on the width sensor
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    /**
+     * Filament Width Sensor dynamically sets the volumetric multiplier
+     * based on a delayed measurement of the filament diameter.
+     */
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
-
-      // Get the delayed info and add 100 to reconstitute to a percent of
-      // the nominal filament diameter then square it to get an area
-      const float vmroot = measurement_delay[meas_shift_index] * 0.01 + 1.0;
-      planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
-      planner.refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
+      calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index])
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if WATCH_THE_BED
     // Make sure temperature is increasing
     if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
       if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
         _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
       else                                                            // Start again if the target is still far off
         start_watching_bed();
@@ -997,26 +984,32 @@ void Temperature::updateTemperaturesFromRawValues() {
 }
 
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
   // Convert raw Filament Width to millimeters
   float Temperature::analog2widthFil() {
     return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
   }
 
-  // Convert raw Filament Width to a ratio
-  int Temperature::widthFil_to_size_ratio() {
-    float temp = filament_width_meas;
-    if (temp < MEASURED_LOWER_LIMIT) temp = filament_width_nominal;  // Assume a bad sensor reading
-    else NOMORE(temp, MEASURED_UPPER_LIMIT);
-    return filament_width_nominal / temp * 100;
+  /**
+   * Convert Filament Width (mm) to a simple ratio
+   * and reduce to an 8 bit value.
+   *
+   * A nominal width of 1.75 and measured width of 1.73
+   * gives (100 * 1.75 / 1.73) for a ratio of 101 and
+   * a return value of 1.
+   */
+  int8_t Temperature::widthFil_to_size_ratio() {
+    if (WITHIN(filament_width_meas, MEASURED_LOWER_LIMIT, MEASURED_UPPER_LIMIT))
+      return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
+    return 0;
   }
 
 #endif
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #ifndef MAX6675_SCK_PIN
     #define MAX6675_SCK_PIN SCK_PIN
   #endif
   #ifndef MAX6675_DO_PIN
     #define MAX6675_DO_PIN MISO_PIN

commit 4fa65a5c25d8e4771359b0d562b631769183f5f1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 22:13:03 2017 -0600

    TCNT0 => HAL_timer_get_current_count
    
    Fix #8710

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5813200b5c..4401864c2e 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1581,21 +1581,21 @@ void Temperature::set_current_temp_raw() {
       #endif
     #endif
   #endif
   current_temperature_bed_raw = raw_temp_bed_value;
   temp_meas_ready = true;
 }
 
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
- * This ISR uses the compare method so it runs at the base
+ * On AVR this ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
  *  - Step the babysteps value for each axis towards 0
  *  - For PINS_DEBUGGING, monitor and report endstop pins
  *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
  */

commit c1184552acfd69ec118ddae57d8e135357234959
Author: Richard Wackerbarth <rkw@dataplex.net>
Date:   Fri Dec 1 09:08:30 2017 -0600

    Change K1 to required option PID_K1

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c66cb30e89..5813200b5c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -42,24 +42,20 @@
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(PINS_DEBUGGING)
   #include "endstops.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
-#ifdef K1 // Defined in Configuration.h in the PID settings
-  #define K2 (1.0-K1)
-#endif
-
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
   static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
 #else
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
 #endif
 
 Temperature thermalManager;
 
@@ -596,21 +592,21 @@ float Temperature::get_pid_output(const int8_t e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST     true
   #else
     #define _HOTEND_TEST     e == active_extruder
   #endif
   float pid_output;
   #if ENABLED(PIDTEMP)
     #if DISABLED(PID_OPENLOOP)
       pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
-      dTerm[HOTEND_INDEX] = K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + K1 * dTerm[HOTEND_INDEX];
+      dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + PID_K1 * dTerm[HOTEND_INDEX];
       temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
       #if HEATER_IDLE_HANDLER
         if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
           pid_output = 0;
           pid_reset[HOTEND_INDEX] = true;
         }
         else
       #endif
       if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
         pid_output = BANG_MAX;
@@ -693,21 +689,21 @@ float Temperature::get_pid_output(const int8_t e) {
 
 #if ENABLED(PIDTEMPBED)
   float Temperature::get_pid_output_bed() {
     float pid_output;
     #if DISABLED(PID_OPENLOOP)
       pid_error_bed = target_temperature_bed - current_temperature_bed;
       pTerm_bed = bedKp * pid_error_bed;
       temp_iState_bed += pid_error_bed;
       iTerm_bed = bedKi * temp_iState_bed;
 
-      dTerm_bed = K2 * bedKd * (current_temperature_bed - temp_dState_bed) + K1 * dTerm_bed;
+      dTerm_bed = PID_K2 * bedKd * (current_temperature_bed - temp_dState_bed) + PID_K1 * dTerm_bed;
       temp_dState_bed = current_temperature_bed;
 
       pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
       if (pid_output > MAX_BED_POWER) {
         if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
         pid_output = MAX_BED_POWER;
       }
       else if (pid_output < 0) {
         if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
         pid_output = 0;

commit 45c2388a5894c502d66cebce52c19311d71803a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 19:42:44 2017 -0600

    Apply const to thermal_runaway_protection args

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 75a0a16487..c66cb30e89 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1350,21 +1350,21 @@ void Temperature::init() {
   #if ENABLED(THERMAL_PROTECTION_HOTENDS)
     Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
     millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   #endif
 
   #if HAS_THERMALLY_PROTECTED_BED
     Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
     millis_t Temperature::thermal_runaway_bed_timer;
   #endif
 
-  void Temperature::thermal_runaway_protection(Temperature::TRState* state, millis_t* timer, float current, float target, int heater_id, int period_seconds, int hysteresis_degc) {
+  void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
 
     static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
 
     /**
         SERIAL_ECHO_START();
         SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
         if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
         SERIAL_ECHOPAIR(" ;  State:", *state);
         SERIAL_ECHOPAIR(" ;  Timer:", *timer);
         SERIAL_ECHOPAIR(" ;  Temperature:", current);

commit 27c5692b132c680ecf626f817cb81ef8c3374fd9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 25 18:13:36 2017 -0600

    Syntax tweaks

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 309adc35e4..75a0a16487 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1279,25 +1279,28 @@ void Temperature::init() {
           #if !AVR_AT90USB1286_FAMILY
             case TIMER0A:
           #endif
           case TIMER0B:                           //_SET_CS(0, val);
                                                     break;
         #endif
         #ifdef TCCR1A
           case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
                                                     break;
         #endif
-        #ifdef TCCR2
-          case TIMER2: case TIMER2:                 _SET_CS(2, val); break;
-        #endif
-        #ifdef TCCR2A
-          case TIMER2A: case TIMER2B:               _SET_CS(2, val); break;
+        #if defined(TCCR2) || defined(TCCR2A)
+          #ifdef TCCR2
+            case TIMER2:
+          #endif
+          #ifdef TCCR2A
+            case TIMER2A: case TIMER2B:
+          #endif
+                                                    _SET_CS(2, val); break;
         #endif
         #ifdef TCCR3A
           case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
         #endif
         #ifdef TCCR4A
           case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
         #endif
         #ifdef TCCR5A
           case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
         #endif

commit d29cb646e3c5d3445d95cc31314b684b62cd19cf
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Nov 25 10:40:56 2017 -0600

    Fix erroneous reference to temperature in time calculations
    
    Travis is having problems at:  https://github.com/MarlinFirmware/Marlin/pull/8560
    
    So...   doing a direct commit to get things correct.   Bugfix_v1.1.x does not have this bug.  Nothing needs to be done to that branch.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7149c020c2..309adc35e4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -241,21 +241,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
           (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
           (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)
         #else
           (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)
         #endif
       ;
       const int8_t watch_temp_period =
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-          hotend < 0 ? temp - THERMAL_PROTECTION_BED_PERIOD : THERMAL_PROTECTION_PERIOD
+          hotend < 0 ? THERMAL_PROTECTION_BED_PERIOD : THERMAL_PROTECTION_PERIOD
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
           THERMAL_PROTECTION_BED_PERIOD
         #else
           THERMAL_PROTECTION_PERIOD
         #endif
       ;
       const int8_t watch_temp_increase =
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
           hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)

commit e2724c68ab712b0a47b3e51abfe835c7cf94435f
Author: Vitaliy Sapyanov <vynt-1@yandex.ru>
Date:   Tue Nov 14 00:32:43 2017 +0300

    Update pins_RURAMPS4D.h
    
    Add and bugfix pins

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 98319fc775..7149c020c2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1295,21 +1295,21 @@ void Temperature::init() {
         #ifdef TCCR3A
           case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
         #endif
         #ifdef TCCR4A
           case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
         #endif
         #ifdef TCCR5A
           case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
         #endif
       }
-    #endif  
+    #endif
   }
 
 #endif // FAST_PWM_FAN
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */

commit c14000775b1a5e9e8c24e139424bd9f0b4845465
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Wed Nov 15 19:01:52 2017 -0600

    PWM fixes, slow down fan update
    
    include LPC1768 syntax for M42
    
    couple more pin_t changes
    
    consistency
    
    change M42 to R, P format
    
    Revert "change M42 to R, P format"
    
    This reverts commit 01f12f579ec9ccc1bb9126e68d2c86449e9b7edf.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 80e3a4447f..98319fc775 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1264,82 +1264,63 @@ void Temperature::init() {
     }
   #endif // BED_MAXTEMP
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
 #if ENABLED(FAST_PWM_FAN)
 
-  void Temperature::setPwmFrequency(const uint8_t pin, int val) {
-    val &= 0x07;
-    switch (digitalPinToTimer(pin)) {
-      #ifdef TCCR0A
-        #if !AVR_AT90USB1286_FAMILY
-          case TIMER0A:
+  void Temperature::setPwmFrequency(const pin_t pin, int val) {
+    #ifdef ARDUINO
+      val &= 0x07;
+      switch (digitalPinToTimer(pin)) {
+        #ifdef TCCR0A
+          #if !AVR_AT90USB1286_FAMILY
+            case TIMER0A:
+          #endif
+          case TIMER0B:                           //_SET_CS(0, val);
+                                                    break;
         #endif
-        case TIMER0B:
-          //_SET_CS(0, val);
-          break;
-      #endif
-      #ifdef TCCR1A
-        case TIMER1A:
-        case TIMER1B:
-          //_SET_CS(1, val);
-          break;
-      #endif
-      #ifdef TCCR2
-        case TIMER2:
-        case TIMER2:
-          _SET_CS(2, val);
-          break;
-      #endif
-      #ifdef TCCR2A
-        case TIMER2A:
-        case TIMER2B:
-          _SET_CS(2, val);
-          break;
-      #endif
-      #ifdef TCCR3A
-        case TIMER3A:
-        case TIMER3B:
-        case TIMER3C:
-          _SET_CS(3, val);
-          break;
-      #endif
-      #ifdef TCCR4A
-        case TIMER4A:
-        case TIMER4B:
-        case TIMER4C:
-          _SET_CS(4, val);
-          break;
-      #endif
-      #ifdef TCCR5A
-        case TIMER5A:
-        case TIMER5B:
-        case TIMER5C:
-          _SET_CS(5, val);
-          break;
-      #endif
-    }
+        #ifdef TCCR1A
+          case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
+                                                    break;
+        #endif
+        #ifdef TCCR2
+          case TIMER2: case TIMER2:                 _SET_CS(2, val); break;
+        #endif
+        #ifdef TCCR2A
+          case TIMER2A: case TIMER2B:               _SET_CS(2, val); break;
+        #endif
+        #ifdef TCCR3A
+          case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
+        #endif
+        #ifdef TCCR4A
+          case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
+        #endif
+        #ifdef TCCR5A
+          case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
+        #endif
+      }
+    #endif  
   }
 
 #endif // FAST_PWM_FAN
 
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
-  void Temperature::start_watching_heater(uint8_t e) {
+  void Temperature::start_watching_heater(const uint8_t e) {
     #if HOTENDS == 1
       UNUSED(e);
     #endif
     if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
       watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
       watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
     }
     else
       watch_heater_next_ms[HOTEND_INDEX] = 0;
   }

commit 7eea000f4bf770b94614cc333478f1f1a97faa2e
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Thu Nov 16 18:10:54 2017 -0600

    E0 auto fan fixes

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 0f3e4114d4..80e3a4447f 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -508,37 +508,41 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
 
 Temperature::Temperature() { }
 
 int Temperature::getHeaterPower(int heater) {
   return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
-    static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
+    static const pin_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
     static const uint8_t fanBit[] PROGMEM = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
       AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
       AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
       AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
     };
     uint8_t fanState = 0;
 
     HOTEND_LOOP()
       if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, pgm_read_byte(&fanBit[e]));
 
     uint8_t fanDone = 0;
     for (uint8_t f = 0; f < COUNT(fanPin); f++) {
-      int8_t pin = pgm_read_byte(&fanPin[f]);
+      #ifdef ARDUINO
+        pin_t pin = pgm_read_byte(&fanPin[f]);
+      #else
+        pin_t pin = fanPin[f];
+      #endif
       const uint8_t bit = pgm_read_byte(&fanBit[f]);
       if (pin >= 0 && !TEST(fanDone, bit)) {
         uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
         // this idiom allows both digital and PWM fan outputs (see M42 handling).
         digitalWrite(pin, newFanSpeed);
         analogWrite(pin, newFanSpeed);
         SBI(fanDone, bit);
       }
     }
   }

commit b2dda096fe12a0780a9884177770e5bd125182b2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 16 16:19:58 2017 -0600

    Fix FILAMENT_LCD_DISPLAY for disabled state

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index cb781d588a..0f3e4114d4 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -995,27 +995,26 @@ void Temperature::updateTemperaturesFromRawValues() {
   temp_meas_ready = false;
   CRITICAL_SECTION_END;
 }
 
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
   // Convert raw Filament Width to millimeters
   float Temperature::analog2widthFil() {
     return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
-    //return current_raw_filwidth;
   }
 
   // Convert raw Filament Width to a ratio
   int Temperature::widthFil_to_size_ratio() {
     float temp = filament_width_meas;
-    if (temp < MEASURED_LOWER_LIMIT) temp = filament_width_nominal;  //assume sensor cut out
+    if (temp < MEASURED_LOWER_LIMIT) temp = filament_width_nominal;  // Assume a bad sensor reading
     else NOMORE(temp, MEASURED_UPPER_LIMIT);
     return filament_width_nominal / temp * 100;
   }
 
 #endif
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #ifndef MAX6675_SCK_PIN
     #define MAX6675_SCK_PIN SCK_PIN
   #endif

commit 6131533157c6770e72d1e8e3dc5b8d3a6ccaea74
Author: RowanMeara <rrm89@cornell.edu>
Date:   Tue Nov 14 00:36:35 2017 -0800

    Change dithering behavior to intended.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e3ebd4e5e5..cb781d588a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1710,29 +1710,29 @@ void Temperature::isr() {
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
       #if HAS_HEATER_BED
         soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
         WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
-          soft_pwm_count_fan[0] = ((soft_pwm_count_fan[0] & pwm_mask) + soft_pwm_amount_fan[0]) >> 1;
+          soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
           WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
         #endif
         #if HAS_FAN1
-          soft_pwm_count_fan[1] = ((soft_pwm_count_fan[1] & pwm_mask) + soft_pwm_amount_fan[1]) >> 1;
+          soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + (soft_pwm_amount_fan[1] >> 1);
           WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
         #endif
         #if HAS_FAN2
-          soft_pwm_count_fan[2] = ((soft_pwm_count_fan[2] & pwm_mask) + soft_pwm_amount_fan[2]) >> 1;
+          soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + (soft_pwm_amount_fan[2] >> 1);
           WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
         #endif
       #endif
     }
     else {
       if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
       #if HOTENDS > 1
         if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
         #if HOTENDS > 2
           if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);

commit 91baca6abb95a4e1eac1f14ac3f1bbf9d2a8f88e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 13 03:32:39 2017 -0600

    Patches for compiler warnings/errors

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 1ab6b4bf97..e3ebd4e5e5 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1710,29 +1710,29 @@ void Temperature::isr() {
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
 
       #if HAS_HEATER_BED
         soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
         WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
       #endif
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
-          soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + soft_pwm_amount_fan[0] >> 1;
+          soft_pwm_count_fan[0] = ((soft_pwm_count_fan[0] & pwm_mask) + soft_pwm_amount_fan[0]) >> 1;
           WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
         #endif
         #if HAS_FAN1
-          soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + soft_pwm_amount_fan[1] >> 1;
+          soft_pwm_count_fan[1] = ((soft_pwm_count_fan[1] & pwm_mask) + soft_pwm_amount_fan[1]) >> 1;
           WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
         #endif
         #if HAS_FAN2
-          soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + soft_pwm_amount_fan[2] >> 1;
+          soft_pwm_count_fan[2] = ((soft_pwm_count_fan[2] & pwm_mask) + soft_pwm_amount_fan[2]) >> 1;
           WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
         #endif
       #endif
     }
     else {
       if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
       #if HOTENDS > 1
         if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
         #if HOTENDS > 2
           if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);

commit 36426af564cb2c11825b83cdd6c1976b874b6ab7
Merge: c0fe6cc34d cba9c1cf9e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 10 19:44:08 2017 -0600

    Merge pull request #8356 from tcm0116/2.0.x-M600
    
    [2.0.x] Normalize load/unload length in M600

diff --combined Marlin/src/module/temperature.cpp
index f92cd815dd,79137da99c..1ab6b4bf97
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@@ -210,26 -210,20 +210,26 @@@ uint8_t Temperature::soft_pwm_amount[HO
    #endif
  #endif
  
  #if ENABLED(ADC_KEYPAD)
    uint32_t Temperature::current_ADCKey_raw = 0;
    uint8_t Temperature::ADCKey_count = 0;
  #endif
  
  #if HAS_PID_HEATING
  
 +  /**
 +   * PID Autotuning (M303)
 +   *
 +   * Alternately heat and cool the nozzle, observing its behavior to
 +   * determine the best PID values to achieve a stable temperature.
 +   */
    void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
      float input = 0.0;
      int cycles = 0;
      bool heating = true;
  
      millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
      long t_high = 0, t_low = 0;
  
      long bias, d;
      float Ku, Tu,
@@@ -465,21 -459,21 +465,21 @@@
          #else
            SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
            SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
            SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
          #endif
  
          #define _SET_BED_PID() do { \
            bedKp = workKp; \
            bedKi = scalePID_i(workKi); \
            bedKd = scalePID_d(workKd); \
 -          updatePID(); }while(0)
 +        }while(0)
  
          #define _SET_EXTRUDER_PID() do { \
            PID_PARAM(Kp, hotend) = workKp; \
            PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
            PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
            updatePID(); }while(0)
  
          // Use the result? (As with "M303 U1")
          if (set_result) {
            #if HAS_PID_FOR_BOTH
@@@ -501,20 -495,28 +501,20 @@@
    }
  
  #endif // HAS_PID_HEATING
  
  /**
   * Class and Instance Methods
   */
  
  Temperature::Temperature() { }
  
 -void Temperature::updatePID() {
 -  #if ENABLED(PIDTEMP)
 -    #if ENABLED(PID_EXTRUSION_SCALING)
 -      last_e_position = 0;
 -    #endif
 -  #endif
 -}
 -
  int Temperature::getHeaterPower(int heater) {
    return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
  }
  
  #if HAS_AUTO_FAN
  
    void Temperature::checkExtruderAutoFans() {
      static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
      static const uint8_t fanBit[] PROGMEM = {
                      0,
@@@ -809,20 -811,21 +809,21 @@@ void Temperature::manage_heater() 
    #if ENABLED(FILAMENT_WIDTH_SENSOR)
      if (filament_sensor) {
        meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
        if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
        meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
  
        // Get the delayed info and add 100 to reconstitute to a percent of
        // the nominal filament diameter then square it to get an area
        const float vmroot = measurement_delay[meas_shift_index] * 0.01 + 1.0;
        planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
+       planner.refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
      }
    #endif // FILAMENT_WIDTH_SENSOR
  
    #if WATCH_THE_BED
      // Make sure temperature is increasing
      if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
        if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
          _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
        else                                                            // Start again if the target is still far off
          start_watching_bed();

commit 1ed86adf9cbcd9199263ef0466a939bb38c96484
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 00:48:00 2017 -0600

    Cleanup around updatePID

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 34f18858c2..f92cd815dd 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -210,20 +210,26 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
   #endif
 #endif
 
 #if ENABLED(ADC_KEYPAD)
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if HAS_PID_HEATING
 
+  /**
+   * PID Autotuning (M303)
+   *
+   * Alternately heat and cool the nozzle, observing its behavior to
+   * determine the best PID values to achieve a stable temperature.
+   */
   void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
     float input = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     float Ku, Tu,
@@ -459,21 +465,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
         #else
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
         #endif
 
         #define _SET_BED_PID() do { \
           bedKp = workKp; \
           bedKi = scalePID_i(workKi); \
           bedKd = scalePID_d(workKd); \
-          updatePID(); }while(0)
+        }while(0)
 
         #define _SET_EXTRUDER_PID() do { \
           PID_PARAM(Kp, hotend) = workKp; \
           PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
           PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
           updatePID(); }while(0)
 
         // Use the result? (As with "M303 U1")
         if (set_result) {
           #if HAS_PID_FOR_BOTH
@@ -495,28 +501,20 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
-void Temperature::updatePID() {
-  #if ENABLED(PIDTEMP)
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      last_e_position = 0;
-    #endif
-  #endif
-}
-
 int Temperature::getHeaterPower(int heater) {
   return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
 }
 
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
     static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
     static const uint8_t fanBit[] PROGMEM = {
                     0,

commit cba9c1cf9e7831a86acbdc35fe405fb600e0f6e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 02:26:49 2017 -0600

    Add pre-calculated planner.e_factor

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 34f18858c2..79137da99c 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -811,20 +811,21 @@ void Temperature::manage_heater() {
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
 
       // Get the delayed info and add 100 to reconstitute to a percent of
       // the nominal filament diameter then square it to get an area
       const float vmroot = measurement_delay[meas_shift_index] * 0.01 + 1.0;
       planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
+      planner.refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if WATCH_THE_BED
     // Make sure temperature is increasing
     if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
       if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
         _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
       else                                                            // Start again if the target is still far off
         start_watching_bed();

commit 8fea26aa9d15f841c11db4030998dd7daea79b1c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 7 15:51:48 2017 -0600

    Fix PID_autotune watch temp increase value

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8901b6052a..34f18858c2 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -242,27 +242,27 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
       ;
       const int8_t watch_temp_period =
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
           hotend < 0 ? temp - THERMAL_PROTECTION_BED_PERIOD : THERMAL_PROTECTION_PERIOD
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
           THERMAL_PROTECTION_BED_PERIOD
         #else
           THERMAL_PROTECTION_PERIOD
         #endif
       ;
-      const int8_t hysteresis =
+      const int8_t watch_temp_increase =
         #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
-          hotend < 0 ? TEMP_BED_HYSTERESIS : TEMP_HYSTERESIS
+          hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE
         #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
-          TEMP_BED_HYSTERESIS
+          WATCH_BED_TEMP_INCREASE
         #else
-          TEMP_HYSTERESIS
+          WATCH_TEMP_INCREASE
         #endif
       ;
       millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
       float next_watch_temp = 0.0;
       bool heated = false;
     #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
@@ -425,21 +425,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
         #if HAS_TEMP_HOTEND || HAS_TEMP_BED
           print_heaterstates();
           SERIAL_EOL();
         #endif
 
         next_temp_ms = ms + 2000UL;
 
         #if WATCH_THE_BED || WATCH_HOTENDS
           if (!heated && input > next_watch_temp) {
             if (input > watch_temp_target) heated = true;
-            next_watch_temp = input + hysteresis;
+            next_watch_temp = input + watch_temp_increase;
             temp_change_ms = ms + watch_temp_period * 1000UL;
           }
           else if ((!heated && ELAPSED(ms, temp_change_ms)) || (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE))
             _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
         #endif
       } // every 2 seconds
       // Timeout after 20 minutes since the last undershoot/overshoot cycle
       if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;

commit 2f9e42feb91d9dee59026f312001300d766c17d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 3 03:24:19 2017 -0500

    M303 thermal runaway protection

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c04e702f0d..8901b6052a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -210,50 +210,82 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
   #endif
 #endif
 
 #if ENABLED(ADC_KEYPAD)
   uint32_t Temperature::current_ADCKey_raw = 0;
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if HAS_PID_HEATING
 
-  void Temperature::PID_autotune(float temp, int hotend, int ncycles, bool set_result/*=false*/) {
+  void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
     float input = 0.0;
     int cycles = 0;
     bool heating = true;
 
     millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
-    float Ku, Tu;
-    float workKp = 0, workKi = 0, workKd = 0;
-    float max = 0, min = 10000;
+    float Ku, Tu,
+          workKp = 0, workKi = 0, workKd = 0,
+          max = 0, min = 10000;
+
+    #if WATCH_THE_BED || WATCH_HOTENDS
+      const float watch_temp_target = temp -
+        #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
+          (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))
+        #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
+          (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)
+        #else
+          (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)
+        #endif
+      ;
+      const int8_t watch_temp_period =
+        #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
+          hotend < 0 ? temp - THERMAL_PROTECTION_BED_PERIOD : THERMAL_PROTECTION_PERIOD
+        #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
+          THERMAL_PROTECTION_BED_PERIOD
+        #else
+          THERMAL_PROTECTION_PERIOD
+        #endif
+      ;
+      const int8_t hysteresis =
+        #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
+          hotend < 0 ? TEMP_BED_HYSTERESIS : TEMP_HYSTERESIS
+        #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
+          TEMP_BED_HYSTERESIS
+        #else
+          TEMP_HYSTERESIS
+        #endif
+      ;
+      millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
+      float next_watch_temp = 0.0;
+      bool heated = false;
+    #endif
 
     #if HAS_AUTO_FAN
       next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
-    if (hotend >=
-        #if ENABLED(PIDTEMP)
-          HOTENDS
-        #else
-          0
-        #endif
-      || hotend <
-        #if ENABLED(PIDTEMPBED)
-          -1
-        #else
-          0
-        #endif
-    ) {
+    #if ENABLED(PIDTEMP)
+      #define _TOP_HOTEND HOTENDS - 1
+    #else
+      #define _TOP_HOTEND -1
+    #endif
+    #if ENABLED(PIDTEMPBED)
+      #define _BOT_HOTEND -1
+    #else
+      #define _BOT_HOTEND 0
+    #endif
+
+    if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
       SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
       return;
     }
 
     SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
 
     disable_all_heaters(); // switch off all heaters.
 
     #if HAS_PID_FOR_BOTH
       if (hotend < 0)
@@ -325,21 +357,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
                 #if HAS_PID_FOR_BOTH
                   hotend < 0 ? MAX_BED_POWER : PID_MAX
                 #elif ENABLED(PIDTEMP)
                   PID_MAX
                 #else
                   MAX_BED_POWER
                 #endif
               ;
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
-              d = (bias > max_pow / 2) ? max_pow - 1 - bias : bias;
+              d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
 
               SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
               SERIAL_PROTOCOLPAIR(MSG_D, d);
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
                 Ku = (4.0 * d) / (M_PI * (max - min) * 0.5); // i.e., CIRCLE_CIRC((max - min) * 0.25)
                 Tu = ((float)(t_low + t_high) * 0.001);
                 SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
                 SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
@@ -389,20 +421,30 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
         break;
       }
       // Every 2 seconds...
       if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_HOTEND || HAS_TEMP_BED
           print_heaterstates();
           SERIAL_EOL();
         #endif
 
         next_temp_ms = ms + 2000UL;
+
+        #if WATCH_THE_BED || WATCH_HOTENDS
+          if (!heated && input > next_watch_temp) {
+            if (input > watch_temp_target) heated = true;
+            next_watch_temp = input + hysteresis;
+            temp_change_ms = ms + watch_temp_period * 1000UL;
+          }
+          else if ((!heated && ELAPSED(ms, temp_change_ms)) || (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE))
+            _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
+        #endif
       } // every 2 seconds
       // Timeout after 20 minutes since the last undershoot/overshoot cycle
       if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
         break;
       }
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH

commit eae0aea1e04f4cb61cdad703d3764ee8012663ed
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 04:30:50 2017 -0500

    Fix M303 thermal protection

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7be79c4513..c04e702f0d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -215,30 +215,30 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
   uint8_t Temperature::ADCKey_count = 0;
 #endif
 
 #if HAS_PID_HEATING
 
   void Temperature::PID_autotune(float temp, int hotend, int ncycles, bool set_result/*=false*/) {
     float input = 0.0;
     int cycles = 0;
     bool heating = true;
 
-    millis_t temp_ms = millis(), t1 = temp_ms, t2 = temp_ms;
+    millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
     long t_high = 0, t_low = 0;
 
     long bias, d;
     float Ku, Tu;
     float workKp = 0, workKi = 0, workKd = 0;
     float max = 0, min = 10000;
 
     #if HAS_AUTO_FAN
-      next_auto_fan_check_ms = temp_ms + 2500UL;
+      next_auto_fan_check_ms = next_temp_ms + 2500UL;
     #endif
 
     if (hotend >=
         #if ENABLED(PIDTEMP)
           HOTENDS
         #else
           0
         #endif
       || hotend <
         #if ENABLED(PIDTEMPBED)
@@ -264,21 +264,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
       soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
     #else
       soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
     #endif
 
     wait_for_heatup = true;
 
     // PID Tuning loop
     while (wait_for_heatup) {
 
-      millis_t ms = millis();
+      const millis_t ms = millis();
 
       if (temp_meas_ready) { // temp sample ready
         updateTemperaturesFromRawValues();
 
         input =
           #if HAS_PID_FOR_BOTH
             hotend < 0 ? current_temperature_bed : current_temperature[hotend]
           #elif ENABLED(PIDTEMP)
             current_temperature[hotend]
           #else
@@ -379,35 +379,35 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
               soft_pwm_amount_bed = (bias + d) >> 1;
             #endif
             cycles++;
             min = temp;
           }
         }
       }
       #define MAX_OVERSHOOT_PID_AUTOTUNE 20
       if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
-        return;
+        break;
       }
       // Every 2 seconds...
-      if (ELAPSED(ms, temp_ms + 2000UL)) {
+      if (ELAPSED(ms, next_temp_ms)) {
         #if HAS_TEMP_HOTEND || HAS_TEMP_BED
           print_heaterstates();
           SERIAL_EOL();
         #endif
 
-        temp_ms = ms;
+        next_temp_ms = ms + 2000UL;
       } // every 2 seconds
-      // Over 2 minutes?
-      if (((ms - t1) + (ms - t2)) > (10L * 60L * 1000L * 2L)) {
+      // Timeout after 20 minutes since the last undershoot/overshoot cycle
+      if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
-        return;
+        break;
       }
       if (cycles > ncycles) {
         SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
 
         #if HAS_PID_FOR_BOTH
           const char* estring = hotend < 0 ? "bed" : "";
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
           SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
         #elif ENABLED(PIDTEMP)
@@ -442,21 +442,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
           #elif ENABLED(PIDTEMP)
             _SET_EXTRUDER_PID();
           #else
             _SET_BED_PID();
           #endif
         }
         return;
       }
       lcd_update();
     }
-    if (!wait_for_heatup) disable_all_heaters();
+    disable_all_heaters();
   }
 
 #endif // HAS_PID_HEATING
 
 /**
  * Class and Instance Methods
  */
 
 Temperature::Temperature() { }
 
@@ -2026,41 +2026,55 @@ void Temperature::isr() {
             #if HOTENDS > 4
               , TEMPDIR(4)
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
     };
 
     for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
       const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
-      if (rawtemp > maxttemp_raw[e] * tdir && target_temperature[e] > 0) max_temp_error(e);
-      if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && target_temperature[e] > 0) {
+      const bool heater_on = 0 <
+        #if ENABLED(PIDTEMP)
+          soft_pwm_amount[e]
+        #else
+          target_temperature[e]
+        #endif
+      ;
+      if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
+      if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
           if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
         #endif
             min_temp_error(e);
       }
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         else
           consecutive_low_temperature_error[e] = 0;
       #endif
     }
 
     #if HAS_TEMP_BED
       #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
         #define GEBED <=
       #else
         #define GEBED >=
       #endif
-      if (current_temperature_bed_raw GEBED bed_maxttemp_raw && target_temperature_bed > 0) max_temp_error(-1);
-      if (bed_minttemp_raw GEBED current_temperature_bed_raw && target_temperature_bed > 0) min_temp_error(-1);
+      const bool bed_on = 0 <
+        #if ENABLED(PIDTEMPBED)
+          soft_pwm_amount_bed
+        #else
+          target_temperature_bed
+        #endif
+      ;
+      if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
+      if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
     #endif
 
   } // temp_count >= OVERSAMPLENR
 
   // Go to the next state, up to SensorsReady
   adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
   if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
 
   #if ENABLED(BABYSTEPPING)
     LOOP_XYZ(axis) {

commit ca665740627cfd4e5f9fccc562a05cede1a9abf1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 14 01:54:05 2017 -0500

    ADC sensor fix inspired by 'Evgen2' on Twitter

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7eec289903..7be79c4513 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2052,21 +2052,22 @@ void Temperature::isr() {
       #else
         #define GEBED >=
       #endif
       if (current_temperature_bed_raw GEBED bed_maxttemp_raw && target_temperature_bed > 0) max_temp_error(-1);
       if (bed_minttemp_raw GEBED current_temperature_bed_raw && target_temperature_bed > 0) min_temp_error(-1);
     #endif
 
   } // temp_count >= OVERSAMPLENR
 
   // Go to the next state, up to SensorsReady
-  adc_sensor_state = (ADCSensorState)((int(adc_sensor_state) + 1) % int(StartupDelay));
+  adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
+  if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
 
   #if ENABLED(BABYSTEPPING)
     LOOP_XYZ(axis) {
       const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
       if (curTodo) {
         stepper.babystep((AxisEnum)axis, curTodo > 0);
         if (curTodo > 0) babystepsTodo[axis]--;
                     else babystepsTodo[axis]++;
       }
     }

commit 0cb00f52d94773411e405ae10a463a4687b70658
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Sep 30 16:06:43 2017 -0500

    Cleanup warnings

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index e1c8154af3..7eec289903 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1737,39 +1737,39 @@ void Temperature::isr() {
      * SLOW PWM HEATERS
      *
      * For relay-driven heaters
      */
     #ifndef MIN_STATE_TIME
       #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
     #endif
 
     // Macros for Slow PWM timer logic
     #define _SLOW_PWM_ROUTINE(NR, src) \
-      soft_pwm_ ##NR = src; \
-      if (soft_pwm_ ##NR > 0) { \
+      soft_pwm_count_ ##NR = src; \
+      if (soft_pwm_count_ ##NR > 0) { \
         if (state_timer_heater_ ##NR == 0) { \
           if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
           state_heater_ ##NR = 1; \
           WRITE_HEATER_ ##NR(1); \
         } \
       } \
       else { \
         if (state_timer_heater_ ##NR == 0) { \
           if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
           state_heater_ ##NR = 0; \
           WRITE_HEATER_ ##NR(0); \
         } \
       }
     #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
 
     #define PWM_OFF_ROUTINE(NR) \
-      if (soft_pwm_ ##NR < slow_pwm_count) { \
+      if (soft_pwm_count_ ##NR < slow_pwm_count) { \
         if (state_timer_heater_ ##NR == 0) { \
           if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
           state_heater_ ##NR = 0; \
           WRITE_HEATER_ ##NR (0); \
         } \
       }
 
     if (slow_pwm_count == 0) {
 
       SLOW_PWM_ROUTINE(0);

commit 10c1b442caa1653a925b357ebaf92d1e1c0c4066
Author: Phr3d13 <phr3d13@gmail.com>
Date:   Wed Sep 27 05:40:48 2017 -0400

    Fixes for Anet10 and gt2560
    
    Fixes for 2 "... not declared in this scope" compiler errors.

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index c25e0929f3..e1c8154af3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1965,21 +1965,21 @@ void Temperature::isr() {
       case Measure_FILWIDTH:
         if (HAL_READ_ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
           raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
           raw_filwidth_value += ((unsigned long)HAL_READ_ADC << 7); // Add new ADC reading, scaled by 128
         }
       break;
     #endif
 
     #if ENABLED(ADC_KEYPAD)
       case Prepare_ADC_KEY:
-        START_ADC(ADC_KEYPAD_PIN);
+        HAL_START_ADC(ADC_KEYPAD_PIN);
         break;
       case Measure_ADC_KEY:
         if (ADCKey_count < 16) {
           raw_ADCKey_value = ADC;
           if (raw_ADCKey_value > 900) {
             //ADC Key release
             ADCKey_count = 0;
             current_ADCKey_raw = 0;
           }
           else {

commit 37eb6d1732beb0df33ab3cfd9aa157fab4708071
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 26 23:36:58 2017 -0500

    Babystepping code tweak

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5aed0302aa..c25e0929f3 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2057,27 +2057,24 @@ void Temperature::isr() {
     #endif
 
   } // temp_count >= OVERSAMPLENR
 
   // Go to the next state, up to SensorsReady
   adc_sensor_state = (ADCSensorState)((int(adc_sensor_state) + 1) % int(StartupDelay));
 
   #if ENABLED(BABYSTEPPING)
     LOOP_XYZ(axis) {
       const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
-      if (curTodo > 0) {
-        stepper.babystep((AxisEnum)axis, /*fwd*/true);
-        babystepsTodo[axis]--;
-      }
-      else if (curTodo < 0) {
-        stepper.babystep((AxisEnum)axis, /*fwd*/false);
-        babystepsTodo[axis]++;
+      if (curTodo) {
+        stepper.babystep((AxisEnum)axis, curTodo > 0);
+        if (curTodo > 0) babystepsTodo[axis]--;
+                    else babystepsTodo[axis]++;
       }
     }
   #endif // BABYSTEPPING
 
   #if ENABLED(PINS_DEBUGGING)
     endstops.run_monitor();  // report changes in endstop status
   #endif
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
 

commit f58ba3a64e94d5f6fa414f3e1bb4d7c1e2ddb46e
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Sat Sep 23 21:25:28 2017 -0700

    Improve AVR arch detection
    
    Replace ARDUINO_ARCH_AVR with __AVR__ to better detect architecture for non-Arduino dev environments.  Resolves compile failure in PIO for 8-bit Teensduino targets
    
    More info:
    https://forum.pjrc.com/threads/33234-Using-Teensyduino-Selecting-Teensy-3-2-3-1-board-has-incorrect-platform-define
    http://www.atmel.com/webdoc/avrlibcreferencemanual/using_tools_1using_avr_gcc_mach_opt.html

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 97f5824613..5aed0302aa 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1074,21 +1074,21 @@ void Temperature::init() {
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
   // todo: HAL: fix abstraction
-  #ifdef ARDUINO_ARCH_AVR
+  #ifdef __AVR__
     // Use timer0 for temperature measurement
     // Interleave temperature interrupt with millies interrupt
     OCR0B = 128;
     SBI(TIMSK0, OCIE0B);
   #else
     HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
     HAL_timer_enable_interrupt(TEMP_TIMER_NUM);
   #endif
 
   #if HAS_AUTO_FAN_0

commit 2e20c53c9d3f1ef29a51db9030dd10b2be8c65fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:55:09 2017 -0500

    Move endstop debug to Endstops

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 7ff161950d..97f5824613 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -32,21 +32,21 @@
 #include "../core/language.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "stepper.h"
 #endif
 
-#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(PINS_DEBUGGING)
   #include "endstops.h"
 #endif
 
 #include "printcounter.h"
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #ifdef K1 // Defined in Configuration.h in the PID settings
@@ -1554,101 +1554,20 @@ void Temperature::set_current_temp_raw() {
         #if HAS_TEMP_4
           current_temperature_raw[4] = raw_temp_value[4];
         #endif
       #endif
     #endif
   #endif
   current_temperature_bed_raw = raw_temp_bed_value;
   temp_meas_ready = true;
 }
 
-#if ENABLED(PINS_DEBUGGING)
-  /**
-   * monitors endstops & Z probe for changes
-   *
-   * If a change is detected then the LED is toggled and
-   * a message is sent out the serial port
-   *
-   * Yes, we could miss a rapid back & forth change but
-   * that won't matter because this is all manual.
-   *
-   */
-  void endstop_monitor() {
-    static uint16_t old_endstop_bits_local = 0;
-    static uint8_t local_LED_status = 0;
-    uint16_t current_endstop_bits_local = 0;
-    #if HAS_X_MIN
-      if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
-    #endif
-    #if HAS_X_MAX
-      if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
-    #endif
-    #if HAS_Y_MIN
-      if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
-    #endif
-    #if HAS_Y_MAX
-      if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
-    #endif
-    #if HAS_Z_MIN
-      if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
-    #endif
-    #if HAS_Z_MAX
-      if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
-    #endif
-    #if HAS_Z_MIN_PROBE_PIN
-      if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
-    #endif
-    #if HAS_Z2_MIN
-      if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
-    #endif
-    #if HAS_Z2_MAX
-      if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
-    #endif
-
-    uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
-
-    if (endstop_change) {
-      #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
-      #endif
-      #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
-      #endif
-      #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
-      #endif
-      #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
-      #endif
-      #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
-      #endif
-      #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
-      #endif
-      #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
-      #endif
-      #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
-      #endif
-      #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
-      #endif
-      SERIAL_PROTOCOLPGM("\n\n");
-      analogWrite(LED_PIN, local_LED_status);
-      local_LED_status ^= 255;
-      old_endstop_bits_local = current_endstop_bits_local;
-    }
-  }
-#endif // PINS_DEBUGGING
-
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * This ISR uses the compare method so it runs at the base
  * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
  *  - Prepare or Measure one of the raw ADC sensor values
  *  - Check new temperature values for MIN/MAX errors (kill on error)
@@ -2150,28 +2069,21 @@ void Temperature::isr() {
         babystepsTodo[axis]--;
       }
       else if (curTodo < 0) {
         stepper.babystep((AxisEnum)axis, /*fwd*/false);
         babystepsTodo[axis]++;
       }
     }
   #endif // BABYSTEPPING
 
   #if ENABLED(PINS_DEBUGGING)
-    extern bool endstop_monitor_flag;
-    // run the endstop monitor at 15Hz
-    static uint8_t endstop_monitor_count = 16;  // offset this check from the others
-    if (endstop_monitor_flag) {
-      endstop_monitor_count += _BV(1);  //  15 Hz
-      endstop_monitor_count &= 0x7F;
-      if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
-    }
+    endstops.run_monitor();  // report changes in endstop status
   #endif
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
 
     extern volatile uint8_t e_hit;
 
     if (e_hit && ENDSTOPS_ENABLED) {
       endstops.update();  // call endstop update routine
       e_hit--;
     }

commit a10451ceed61e16a62d5395c27ad4ebe8ed06029
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:51:45 2017 -0500

    Move Volumetric methods to Planner

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 03cce00f78..7ff161950d 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -768,21 +768,21 @@ void Temperature::manage_heater() {
   // Control the extruder rate based on the width sensor
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (filament_sensor) {
       meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
       meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
 
       // Get the delayed info and add 100 to reconstitute to a percent of
       // the nominal filament diameter then square it to get an area
       const float vmroot = measurement_delay[meas_shift_index] * 0.01 + 1.0;
-      volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
+      planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
     }
   #endif // FILAMENT_WIDTH_SENSOR
 
   #if WATCH_THE_BED
     // Make sure temperature is increasing
     if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
       if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
         _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
       else                                                            // Start again if the target is still far off
         start_watching_bed();

commit df0432c7c8abee61e1bc8956cbf8adb8e35c846a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 13:05:01 2017 -0500

    Move M155 to cpp, auto-report to Temperature

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 5bf392fdae..03cce00f78 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2252,11 +2252,26 @@ void Temperature::isr() {
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
         SERIAL_PROTOCOLPAIR(" @", e);
         SERIAL_PROTOCOLCHAR(':');
         SERIAL_PROTOCOL(getHeaterPower(e));
       }
     #endif
   }
 
+  #if ENABLED(AUTO_REPORT_TEMPERATURES)
+
+    uint8_t Temperature::auto_report_temp_interval;
+    millis_t Temperature::next_temp_report_ms;
+
+    void Temperature::auto_report_temperatures() {
+      if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
+        next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
+        print_heaterstates();
+        SERIAL_EOL();
+      }
+    }
+
+  #endif // AUTO_REPORT_TEMPERATURES
+
 #endif // HAS_TEMP_HOTEND || HAS_TEMP_BED

commit 9c21191f74de06cfb9b966c0135cb05cd668a7a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 20:47:04 2017 -0500

    Rename SPI class to avoid conflict (good?)

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 57eb529f2a..5bf392fdae 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -974,21 +974,21 @@ void Temperature::updateTemperaturesFromRawValues() {
 
 #endif
 
 #if ENABLED(HEATER_0_USES_MAX6675)
   #ifndef MAX6675_SCK_PIN
     #define MAX6675_SCK_PIN SCK_PIN
   #endif
   #ifndef MAX6675_DO_PIN
     #define MAX6675_DO_PIN MISO_PIN
   #endif
-  SPI<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
+  SPIclass<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
 #endif
 
 /**
  * Initialize the temperature manager
  * The manager is implemented by periodic calls to manage_heater()
  */
 void Temperature::init() {
 
   #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
     // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector

commit 4f1eadf41f1e2d79f7c62c60a1ead6ae34b63be5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 12 15:02:17 2017 -0500

    FILAMENT_WIDTH_SENSOR feature

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 8944e581bf..57eb529f2a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -38,20 +38,24 @@
 #if ENABLED(BABYSTEPPING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "endstops.h"
 #endif
 
 #include "printcounter.h"
 
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  #include "../feature/filwidth.h"
+#endif
+
 #ifdef K1 // Defined in Configuration.h in the PID settings
   #define K2 (1.0-K1)
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
   static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
 #else
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);

commit 71aefc2e2250744b96f351e0b3b57f68c54fe1ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:44:37 2017 -0500

    Move heater output to Temperature class

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 65efc26476..8944e581bf 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -2172,10 +2172,87 @@ void Temperature::isr() {
       e_hit--;
     }
   #endif
 
   #ifndef CPU_32_BIT
     cli();
   #endif
   in_temp_isr = false;
   ENABLE_TEMPERATURE_INTERRUPT(); //re-enable Temperature ISR
 }
+
+#if HAS_TEMP_HOTEND || HAS_TEMP_BED
+
+  #include "../gcode/gcode.h"
+
+  void print_heater_state(const float &c, const float &t,
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      const float r,
+    #endif
+    const int8_t e=-2
+  ) {
+    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
+      UNUSED(e);
+    #endif
+
+    SERIAL_PROTOCOLCHAR(' ');
+    SERIAL_PROTOCOLCHAR(
+      #if HAS_TEMP_BED && HAS_TEMP_HOTEND
+        e == -1 ? 'B' : 'T'
+      #elif HAS_TEMP_HOTEND
+        'T'
+      #else
+        'B'
+      #endif
+    );
+    #if HOTENDS > 1
+      if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
+    #endif
+    SERIAL_PROTOCOLCHAR(':');
+    SERIAL_PROTOCOL(c);
+    SERIAL_PROTOCOLPAIR(" /" , t);
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
+      SERIAL_PROTOCOLCHAR(')');
+    #endif
+  }
+
+  void Temperature::print_heaterstates() {
+    #if HAS_TEMP_HOTEND
+      print_heater_state(degHotend(gcode.target_extruder), degTargetHotend(gcode.target_extruder)
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , rawHotendTemp(gcode.target_extruder)
+        #endif
+      );
+    #endif
+    #if HAS_TEMP_BED
+      print_heater_state(degBed(), degTargetBed(),
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          rawBedTemp(),
+        #endif
+        -1 // BED
+      );
+    #endif
+    #if HOTENDS > 1
+      HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e),
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          rawHotendTemp(e),
+        #endif
+        e
+      );
+    #endif
+    SERIAL_PROTOCOLPGM(" @:");
+    SERIAL_PROTOCOL(getHeaterPower(gcode.target_extruder));
+    #if HAS_TEMP_BED
+      SERIAL_PROTOCOLPGM(" B@:");
+      SERIAL_PROTOCOL(getHeaterPower(-1));
+    #endif
+    #if HOTENDS > 1
+      HOTEND_LOOP() {
+        SERIAL_PROTOCOLPAIR(" @", e);
+        SERIAL_PROTOCOLCHAR(':');
+        SERIAL_PROTOCOL(getHeaterPower(e));
+      }
+    #endif
+  }
+
+#endif // HAS_TEMP_HOTEND || HAS_TEMP_BED

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index 33df993cc3..65efc26476 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -17,39 +17,41 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * temperature.cpp - temperature control
  */
 
-#include "Marlin.h"
 #include "temperature.h"
-#include "thermistortables.h"
-#include "ultralcd.h"
+
+#include "../Marlin.h"
+#include "../lcd/ultralcd.h"
 #include "planner.h"
-#include "language.h"
+#include "../core/language.h"
 
 #if ENABLED(HEATER_0_USES_MAX6675)
-  #include "private_spi.h"
+  #include "../libs/private_spi.h"
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "stepper.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "endstops.h"
 #endif
 
+#include "printcounter.h"
+
 #ifdef K1 // Defined in Configuration.h in the PID settings
   #define K2 (1.0-K1)
 #endif
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
   static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
 #else
   static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
   static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
@@ -326,21 +328,21 @@ uint8_t Temperature::soft_pwm_amount[HOTENDS],
               ;
               bias += (d * (t_high - t_low)) / (t_low + t_high);
               bias = constrain(bias, 20, max_pow - 20);
               d = (bias > max_pow / 2) ? max_pow - 1 - bias : bias;
 
               SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
               SERIAL_PROTOCOLPAIR(MSG_D, d);
               SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
               SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
               if (cycles > 2) {
-                Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
+                Ku = (4.0 * d) / (M_PI * (max - min) * 0.5); // i.e., CIRCLE_CIRC((max - min) * 0.25)
                 Tu = ((float)(t_low + t_high) * 0.001);
                 SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
                 SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
                 workKp = 0.6 * Ku;
                 workKi = 2 * workKp / Tu;
                 workKd = workKp * Tu * 0.125;
                 SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
                 SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
                 SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
                 SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
@@ -1067,21 +1069,21 @@ void Temperature::init() {
   #if HAS_TEMP_4
     HAL_ANALOG_SELECT(TEMP_4_PIN);
   #endif
   #if HAS_TEMP_BED
     HAL_ANALOG_SELECT(TEMP_BED_PIN);
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     HAL_ANALOG_SELECT(FILWIDTH_PIN);
   #endif
 
-// todo: HAL: fix abstraction
+  // todo: HAL: fix abstraction
   #ifdef ARDUINO_ARCH_AVR
     // Use timer0 for temperature measurement
     // Interleave temperature interrupt with millies interrupt
     OCR0B = 128;
     SBI(TIMSK0, OCIE0B);
   #else
     HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
     HAL_timer_enable_interrupt(TEMP_TIMER_NUM);
   #endif
 
@@ -1212,20 +1214,77 @@ void Temperature::init() {
         bed_maxttemp_raw += OVERSAMPLENR;
       #endif
     }
   #endif // BED_MAXTEMP
 
   #if ENABLED(PROBING_HEATERS_OFF)
     paused = false;
   #endif
 }
 
+#if ENABLED(FAST_PWM_FAN)
+
+  void Temperature::setPwmFrequency(const uint8_t pin, int val) {
+    val &= 0x07;
+    switch (digitalPinToTimer(pin)) {
+      #ifdef TCCR0A
+        #if !AVR_AT90USB1286_FAMILY
+          case TIMER0A:
+        #endif
+        case TIMER0B:
+          //_SET_CS(0, val);
+          break;
+      #endif
+      #ifdef TCCR1A
+        case TIMER1A:
+        case TIMER1B:
+          //_SET_CS(1, val);
+          break;
+      #endif
+      #ifdef TCCR2
+        case TIMER2:
+        case TIMER2:
+          _SET_CS(2, val);
+          break;
+      #endif
+      #ifdef TCCR2A
+        case TIMER2A:
+        case TIMER2B:
+          _SET_CS(2, val);
+          break;
+      #endif
+      #ifdef TCCR3A
+        case TIMER3A:
+        case TIMER3B:
+        case TIMER3C:
+          _SET_CS(3, val);
+          break;
+      #endif
+      #ifdef TCCR4A
+        case TIMER4A:
+        case TIMER4B:
+        case TIMER4C:
+          _SET_CS(4, val);
+          break;
+      #endif
+      #ifdef TCCR5A
+        case TIMER5A:
+        case TIMER5B:
+        case TIMER5C:
+          _SET_CS(5, val);
+          break;
+      #endif
+    }
+  }
+
+#endif // FAST_PWM_FAN
+
 #if WATCH_HOTENDS
   /**
    * Start Heating Sanity Check for hotends that are below
    * their target temperature by a configurable margin.
    * This is called when the temperature is set. (M104, M109)
    */
   void Temperature::start_watching_heater(uint8_t e) {
     #if HOTENDS == 1
       UNUSED(e);
     #endif

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
new file mode 100644
index 0000000000..33df993cc3
--- /dev/null
+++ b/Marlin/src/module/temperature.cpp
@@ -0,0 +1,2122 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * temperature.cpp - temperature control
+ */
+
+#include "Marlin.h"
+#include "temperature.h"
+#include "thermistortables.h"
+#include "ultralcd.h"
+#include "planner.h"
+#include "language.h"
+
+#if ENABLED(HEATER_0_USES_MAX6675)
+  #include "private_spi.h"
+#endif
+
+#if ENABLED(BABYSTEPPING)
+  #include "stepper.h"
+#endif
+
+#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  #include "endstops.h"
+#endif
+
+#ifdef K1 // Defined in Configuration.h in the PID settings
+  #define K2 (1.0-K1)
+#endif
+
+#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+  static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
+  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
+#else
+  static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
+  static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
+#endif
+
+Temperature thermalManager;
+
+// public:
+
+float Temperature::current_temperature[HOTENDS] = { 0.0 },
+      Temperature::current_temperature_bed = 0.0;
+int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },
+        Temperature::target_temperature[HOTENDS] = { 0 },
+        Temperature::current_temperature_bed_raw = 0;
+
+#if HAS_HEATER_BED
+  int16_t Temperature::target_temperature_bed = 0;
+#endif
+
+// Initialized by settings.load()
+#if ENABLED(PIDTEMP)
+  #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+    float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      float Temperature::Kc[HOTENDS];
+    #endif
+  #else
+    float Temperature::Kp, Temperature::Ki, Temperature::Kd;
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      float Temperature::Kc;
+    #endif
+  #endif
+#endif
+
+// Initialized by settings.load()
+#if ENABLED(PIDTEMPBED)
+  float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd;
+#endif
+
+#if ENABLED(BABYSTEPPING)
+  volatile int Temperature::babystepsTodo[XYZ] = { 0 };
+#endif
+
+#if WATCH_HOTENDS
+  uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
+  millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
+#endif
+
+#if WATCH_THE_BED
+  uint16_t Temperature::watch_target_bed_temp = 0;
+  millis_t Temperature::watch_bed_next_ms = 0;
+#endif
+
+#if ENABLED(PREVENT_COLD_EXTRUSION)
+  bool Temperature::allow_cold_extrude = false;
+  int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
+#endif
+
+// private:
+
+#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+  uint16_t Temperature::redundant_temperature_raw = 0;
+  float Temperature::redundant_temperature = 0.0;
+#endif
+
+volatile bool Temperature::temp_meas_ready = false;
+
+#if ENABLED(PIDTEMP)
+  float Temperature::temp_iState[HOTENDS] = { 0 },
+        Temperature::temp_dState[HOTENDS] = { 0 },
+        Temperature::pTerm[HOTENDS],
+        Temperature::iTerm[HOTENDS],
+        Temperature::dTerm[HOTENDS];
+
+  #if ENABLED(PID_EXTRUSION_SCALING)
+    float Temperature::cTerm[HOTENDS];
+    long Temperature::last_e_position;
+    long Temperature::lpq[LPQ_MAX_LEN];
+    int Temperature::lpq_ptr = 0;
+  #endif
+
+  float Temperature::pid_error[HOTENDS];
+  bool Temperature::pid_reset[HOTENDS];
+#endif
+
+#if ENABLED(PIDTEMPBED)
+  float Temperature::temp_iState_bed = { 0 },
+        Temperature::temp_dState_bed = { 0 },
+        Temperature::pTerm_bed,
+        Temperature::iTerm_bed,
+        Temperature::dTerm_bed,
+        Temperature::pid_error_bed;
+#else
+  millis_t Temperature::next_bed_check_ms;
+#endif
+
+uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
+         Temperature::raw_temp_bed_value = 0;
+
+// Init min and max temp with extreme values to prevent false errors during startup
+int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
+        Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
+        Temperature::minttemp[HOTENDS] = { 0 },
+        Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
+
+#ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+  uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
+#endif
+
+#ifdef MILLISECONDS_PREHEAT_TIME
+  millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
+#endif
+
+#ifdef BED_MINTEMP
+  int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
+#endif
+
+#ifdef BED_MAXTEMP
+  int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
+#endif
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
+#endif
+
+#if HAS_AUTO_FAN
+  millis_t Temperature::next_auto_fan_check_ms = 0;
+#endif
+
+uint8_t Temperature::soft_pwm_amount[HOTENDS],
+        Temperature::soft_pwm_amount_bed;
+
+#if ENABLED(FAN_SOFT_PWM)
+  uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
+          Temperature::soft_pwm_count_fan[FAN_COUNT];
+#endif
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
+#endif
+
+#if ENABLED(PROBING_HEATERS_OFF)
+  bool Temperature::paused;
+#endif
+
+#if HEATER_IDLE_HANDLER
+  millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
+  bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
+  #if HAS_TEMP_BED
+    millis_t Temperature::bed_idle_timeout_ms = 0;
+    bool Temperature::bed_idle_timeout_exceeded = false;
+  #endif
+#endif
+
+#if ENABLED(ADC_KEYPAD)
+  uint32_t Temperature::current_ADCKey_raw = 0;
+  uint8_t Temperature::ADCKey_count = 0;
+#endif
+
+#if HAS_PID_HEATING
+
+  void Temperature::PID_autotune(float temp, int hotend, int ncycles, bool set_result/*=false*/) {
+    float input = 0.0;
+    int cycles = 0;
+    bool heating = true;
+
+    millis_t temp_ms = millis(), t1 = temp_ms, t2 = temp_ms;
+    long t_high = 0, t_low = 0;
+
+    long bias, d;
+    float Ku, Tu;
+    float workKp = 0, workKi = 0, workKd = 0;
+    float max = 0, min = 10000;
+
+    #if HAS_AUTO_FAN
+      next_auto_fan_check_ms = temp_ms + 2500UL;
+    #endif
+
+    if (hotend >=
+        #if ENABLED(PIDTEMP)
+          HOTENDS
+        #else
+          0
+        #endif
+      || hotend <
+        #if ENABLED(PIDTEMPBED)
+          -1
+        #else
+          0
+        #endif
+    ) {
+      SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
+      return;
+    }
+
+    SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
+
+    disable_all_heaters(); // switch off all heaters.
+
+    #if HAS_PID_FOR_BOTH
+      if (hotend < 0)
+        soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
+      else
+        soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
+    #elif ENABLED(PIDTEMP)
+      soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
+    #else
+      soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
+    #endif
+
+    wait_for_heatup = true;
+
+    // PID Tuning loop
+    while (wait_for_heatup) {
+
+      millis_t ms = millis();
+
+      if (temp_meas_ready) { // temp sample ready
+        updateTemperaturesFromRawValues();
+
+        input =
+          #if HAS_PID_FOR_BOTH
+            hotend < 0 ? current_temperature_bed : current_temperature[hotend]
+          #elif ENABLED(PIDTEMP)
+            current_temperature[hotend]
+          #else
+            current_temperature_bed
+          #endif
+        ;
+
+        NOLESS(max, input);
+        NOMORE(min, input);
+
+        #if HAS_AUTO_FAN
+          if (ELAPSED(ms, next_auto_fan_check_ms)) {
+            checkExtruderAutoFans();
+            next_auto_fan_check_ms = ms + 2500UL;
+          }
+        #endif
+
+        if (heating && input > temp) {
+          if (ELAPSED(ms, t2 + 5000UL)) {
+            heating = false;
+            #if HAS_PID_FOR_BOTH
+              if (hotend < 0)
+                soft_pwm_amount_bed = (bias - d) >> 1;
+              else
+                soft_pwm_amount[hotend] = (bias - d) >> 1;
+            #elif ENABLED(PIDTEMP)
+              soft_pwm_amount[hotend] = (bias - d) >> 1;
+            #elif ENABLED(PIDTEMPBED)
+              soft_pwm_amount_bed = (bias - d) >> 1;
+            #endif
+            t1 = ms;
+            t_high = t1 - t2;
+            max = temp;
+          }
+        }
+
+        if (!heating && input < temp) {
+          if (ELAPSED(ms, t1 + 5000UL)) {
+            heating = true;
+            t2 = ms;
+            t_low = t2 - t1;
+            if (cycles > 0) {
+              long max_pow =
+                #if HAS_PID_FOR_BOTH
+                  hotend < 0 ? MAX_BED_POWER : PID_MAX
+                #elif ENABLED(PIDTEMP)
+                  PID_MAX
+                #else
+                  MAX_BED_POWER
+                #endif
+              ;
+              bias += (d * (t_high - t_low)) / (t_low + t_high);
+              bias = constrain(bias, 20, max_pow - 20);
+              d = (bias > max_pow / 2) ? max_pow - 1 - bias : bias;
+
+              SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
+              SERIAL_PROTOCOLPAIR(MSG_D, d);
+              SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
+              SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
+              if (cycles > 2) {
+                Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
+                Tu = ((float)(t_low + t_high) * 0.001);
+                SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
+                SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
+                workKp = 0.6 * Ku;
+                workKi = 2 * workKp / Tu;
+                workKd = workKp * Tu * 0.125;
+                SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
+                SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
+                SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
+                SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
+                /**
+                workKp = 0.33*Ku;
+                workKi = workKp/Tu;
+                workKd = workKp*Tu/3;
+                SERIAL_PROTOCOLLNPGM(" Some overshoot");
+                SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
+                SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
+                SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
+                workKp = 0.2*Ku;
+                workKi = 2*workKp/Tu;
+                workKd = workKp*Tu/3;
+                SERIAL_PROTOCOLLNPGM(" No overshoot");
+                SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
+                SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
+                SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
+                */
+              }
+            }
+            #if HAS_PID_FOR_BOTH
+              if (hotend < 0)
+                soft_pwm_amount_bed = (bias + d) >> 1;
+              else
+                soft_pwm_amount[hotend] = (bias + d) >> 1;
+            #elif ENABLED(PIDTEMP)
+              soft_pwm_amount[hotend] = (bias + d) >> 1;
+            #else
+              soft_pwm_amount_bed = (bias + d) >> 1;
+            #endif
+            cycles++;
+            min = temp;
+          }
+        }
+      }
+      #define MAX_OVERSHOOT_PID_AUTOTUNE 20
+      if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
+        SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
+        return;
+      }
+      // Every 2 seconds...
+      if (ELAPSED(ms, temp_ms + 2000UL)) {
+        #if HAS_TEMP_HOTEND || HAS_TEMP_BED
+          print_heaterstates();
+          SERIAL_EOL();
+        #endif
+
+        temp_ms = ms;
+      } // every 2 seconds
+      // Over 2 minutes?
+      if (((ms - t1) + (ms - t2)) > (10L * 60L * 1000L * 2L)) {
+        SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
+        return;
+      }
+      if (cycles > ncycles) {
+        SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
+
+        #if HAS_PID_FOR_BOTH
+          const char* estring = hotend < 0 ? "bed" : "";
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
+        #elif ENABLED(PIDTEMP)
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
+        #else
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
+          SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
+        #endif
+
+        #define _SET_BED_PID() do { \
+          bedKp = workKp; \
+          bedKi = scalePID_i(workKi); \
+          bedKd = scalePID_d(workKd); \
+          updatePID(); }while(0)
+
+        #define _SET_EXTRUDER_PID() do { \
+          PID_PARAM(Kp, hotend) = workKp; \
+          PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
+          PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
+          updatePID(); }while(0)
+
+        // Use the result? (As with "M303 U1")
+        if (set_result) {
+          #if HAS_PID_FOR_BOTH
+            if (hotend < 0)
+              _SET_BED_PID();
+            else
+              _SET_EXTRUDER_PID();
+          #elif ENABLED(PIDTEMP)
+            _SET_EXTRUDER_PID();
+          #else
+            _SET_BED_PID();
+          #endif
+        }
+        return;
+      }
+      lcd_update();
+    }
+    if (!wait_for_heatup) disable_all_heaters();
+  }
+
+#endif // HAS_PID_HEATING
+
+/**
+ * Class and Instance Methods
+ */
+
+Temperature::Temperature() { }
+
+void Temperature::updatePID() {
+  #if ENABLED(PIDTEMP)
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      last_e_position = 0;
+    #endif
+  #endif
+}
+
+int Temperature::getHeaterPower(int heater) {
+  return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
+}
+
+#if HAS_AUTO_FAN
+
+  void Temperature::checkExtruderAutoFans() {
+    static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
+    static const uint8_t fanBit[] PROGMEM = {
+                    0,
+      AUTO_1_IS_0 ? 0 :               1,
+      AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
+      AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
+      AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
+    };
+    uint8_t fanState = 0;
+
+    HOTEND_LOOP()
+      if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
+        SBI(fanState, pgm_read_byte(&fanBit[e]));
+
+    uint8_t fanDone = 0;
+    for (uint8_t f = 0; f < COUNT(fanPin); f++) {
+      int8_t pin = pgm_read_byte(&fanPin[f]);
+      const uint8_t bit = pgm_read_byte(&fanBit[f]);
+      if (pin >= 0 && !TEST(fanDone, bit)) {
+        uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
+        // this idiom allows both digital and PWM fan outputs (see M42 handling).
+        digitalWrite(pin, newFanSpeed);
+        analogWrite(pin, newFanSpeed);
+        SBI(fanDone, bit);
+      }
+    }
+  }
+
+#endif // HAS_AUTO_FAN
+
+//
+// Temperature Error Handlers
+//
+void Temperature::_temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg) {
+  static bool killed = false;
+  if (IsRunning()) {
+    SERIAL_ERROR_START();
+    serialprintPGM(serial_msg);
+    SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
+    if (e >= 0) SERIAL_ERRORLN((int)e); else SERIAL_ERRORLNPGM(MSG_HEATER_BED);
+  }
+  #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
+    if (!killed) {
+      Running = false;
+      killed = true;
+      kill(lcd_msg);
+    }
+    else
+      disable_all_heaters(); // paranoia
+  #endif
+}
+
+void Temperature::max_temp_error(const int8_t e) {
+  #if HAS_TEMP_BED
+    _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
+  #else
+    _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
+    #if HOTENDS == 1
+      UNUSED(e);
+    #endif
+  #endif
+}
+void Temperature::min_temp_error(const int8_t e) {
+  #if HAS_TEMP_BED
+    _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
+  #else
+    _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
+    #if HOTENDS == 1
+      UNUSED(e);
+    #endif
+  #endif
+}
+
+float Temperature::get_pid_output(const int8_t e) {
+  #if HOTENDS == 1
+    UNUSED(e);
+    #define _HOTEND_TEST     true
+  #else
+    #define _HOTEND_TEST     e == active_extruder
+  #endif
+  float pid_output;
+  #if ENABLED(PIDTEMP)
+    #if DISABLED(PID_OPENLOOP)
+      pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
+      dTerm[HOTEND_INDEX] = K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + K1 * dTerm[HOTEND_INDEX];
+      temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
+      #if HEATER_IDLE_HANDLER
+        if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
+          pid_output = 0;
+          pid_reset[HOTEND_INDEX] = true;
+        }
+        else
+      #endif
+      if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
+        pid_output = BANG_MAX;
+        pid_reset[HOTEND_INDEX] = true;
+      }
+      else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
+        #if HEATER_IDLE_HANDLER
+          || heater_idle_timeout_exceeded[HOTEND_INDEX]
+        #endif
+        ) {
+        pid_output = 0;
+        pid_reset[HOTEND_INDEX] = true;
+      }
+      else {
+        if (pid_reset[HOTEND_INDEX]) {
+          temp_iState[HOTEND_INDEX] = 0.0;
+          pid_reset[HOTEND_INDEX] = false;
+        }
+        pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
+        temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
+        iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
+
+        pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
+
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          cTerm[HOTEND_INDEX] = 0;
+          if (_HOTEND_TEST) {
+            long e_position = stepper.position(E_AXIS);
+            if (e_position > last_e_position) {
+              lpq[lpq_ptr] = e_position - last_e_position;
+              last_e_position = e_position;
+            }
+            else {
+              lpq[lpq_ptr] = 0;
+            }
+            if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
+            cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
+            pid_output += cTerm[HOTEND_INDEX];
+          }
+        #endif // PID_EXTRUSION_SCALING
+
+        if (pid_output > PID_MAX) {
+          if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
+          pid_output = PID_MAX;
+        }
+        else if (pid_output < 0) {
+          if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
+          pid_output = 0;
+        }
+      }
+    #else
+      pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
+    #endif // PID_OPENLOOP
+
+    #if ENABLED(PID_DEBUG)
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
+      SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
+      SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
+      SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
+      SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
+      SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
+      #endif
+      SERIAL_EOL();
+    #endif // PID_DEBUG
+
+  #else /* PID off */
+    #if HEATER_IDLE_HANDLER
+      if (heater_idle_timeout_exceeded[HOTEND_INDEX])
+        pid_output = 0;
+      else
+    #endif
+    pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
+  #endif
+
+  return pid_output;
+}
+
+#if ENABLED(PIDTEMPBED)
+  float Temperature::get_pid_output_bed() {
+    float pid_output;
+    #if DISABLED(PID_OPENLOOP)
+      pid_error_bed = target_temperature_bed - current_temperature_bed;
+      pTerm_bed = bedKp * pid_error_bed;
+      temp_iState_bed += pid_error_bed;
+      iTerm_bed = bedKi * temp_iState_bed;
+
+      dTerm_bed = K2 * bedKd * (current_temperature_bed - temp_dState_bed) + K1 * dTerm_bed;
+      temp_dState_bed = current_temperature_bed;
+
+      pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
+      if (pid_output > MAX_BED_POWER) {
+        if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
+        pid_output = MAX_BED_POWER;
+      }
+      else if (pid_output < 0) {
+        if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
+        pid_output = 0;
+      }
+    #else
+      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
+    #endif // PID_OPENLOOP
+
+    #if ENABLED(PID_BED_DEBUG)
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM(" PID_BED_DEBUG ");
+      SERIAL_ECHOPGM(": Input ");
+      SERIAL_ECHO(current_temperature_bed);
+      SERIAL_ECHOPGM(" Output ");
+      SERIAL_ECHO(pid_output);
+      SERIAL_ECHOPGM(" pTerm ");
+      SERIAL_ECHO(pTerm_bed);
+      SERIAL_ECHOPGM(" iTerm ");
+      SERIAL_ECHO(iTerm_bed);
+      SERIAL_ECHOPGM(" dTerm ");
+      SERIAL_ECHOLN(dTerm_bed);
+    #endif // PID_BED_DEBUG
+
+    return pid_output;
+  }
+#endif // PIDTEMPBED
+
+/**
+ * Manage heating activities for extruder hot-ends and a heated bed
+ *  - Acquire updated temperature readings
+ *    - Also resets the watchdog timer
+ *  - Invoke thermal runaway protection
+ *  - Manage extruder auto-fan
+ *  - Apply filament width to the extrusion rate (may move)
+ *  - Update the heated bed PID output value
+ */
+
+/**
+ * The following line SOMETIMES results in the dreaded "unable to find a register to spill in class 'POINTER_REGS'"
+ * compile error.
+ *    thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+ *
+ * This is due to a bug in the C++ compiler used by the Arduino IDE from 1.6.10 to at least 1.8.1.
+ *
+ * The work around is to add the compiler flag "__attribute__((__optimize__("O2")))" to the declaration for manage_heater()
+ */
+//void Temperature::manage_heater()  __attribute__((__optimize__("O2")));
+void Temperature::manage_heater() {
+
+  if (!temp_meas_ready) return;
+
+  updateTemperaturesFromRawValues(); // also resets the watchdog
+
+  #if ENABLED(HEATER_0_USES_MAX6675)
+    if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
+    if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
+  #endif
+
+  #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
+    millis_t ms = millis();
+  #endif
+
+  HOTEND_LOOP() {
+
+    #if HEATER_IDLE_HANDLER
+      if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
+        heater_idle_timeout_exceeded[e] = true;
+    #endif
+
+    #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+      // Check for thermal runaway
+      thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
+    #endif
+
+    soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
+
+    #if WATCH_HOTENDS
+      // Make sure temperature is increasing
+      if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
+        if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
+          _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+        else                                                                 // Start again if the target is still far off
+          start_watching_heater(e);
+      }
+    #endif
+
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      // Make sure measured temperatures are close together
+      if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
+        _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
+    #endif
+
+  } // HOTEND_LOOP
+
+  #if HAS_AUTO_FAN
+    if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
+      checkExtruderAutoFans();
+      next_auto_fan_check_ms = ms + 2500UL;
+    }
+  #endif
+
+  // Control the extruder rate based on the width sensor
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    if (filament_sensor) {
+      meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
+      if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
+      meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
+
+      // Get the delayed info and add 100 to reconstitute to a percent of
+      // the nominal filament diameter then square it to get an area
+      const float vmroot = measurement_delay[meas_shift_index] * 0.01 + 1.0;
+      volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
+    }
+  #endif // FILAMENT_WIDTH_SENSOR
+
+  #if WATCH_THE_BED
+    // Make sure temperature is increasing
+    if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
+      if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
+        _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
+      else                                                            // Start again if the target is still far off
+        start_watching_bed();
+    }
+  #endif // WATCH_THE_BED
+
+  #if DISABLED(PIDTEMPBED)
+    if (PENDING(ms, next_bed_check_ms)) return;
+    next_bed_check_ms = ms + BED_CHECK_INTERVAL;
+  #endif
+
+  #if HAS_TEMP_BED
+
+    #if HEATER_IDLE_HANDLER
+      if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
+        bed_idle_timeout_exceeded = true;
+    #endif
+
+    #if HAS_THERMALLY_PROTECTED_BED
+      thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
+    #endif
+
+    #if HEATER_IDLE_HANDLER
+      if (bed_idle_timeout_exceeded)
+      {
+        soft_pwm_amount_bed = 0;
+
+        #if DISABLED(PIDTEMPBED)
+          WRITE_HEATER_BED(LOW);
+        #endif
+      }
+      else
+    #endif
+    {
+      #if ENABLED(PIDTEMPBED)
+        soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
+
+      #elif ENABLED(BED_LIMIT_SWITCHING)
+        // Check if temperature is within the correct band
+        if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
+          if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
+            soft_pwm_amount_bed = 0;
+          else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
+            soft_pwm_amount_bed = MAX_BED_POWER >> 1;
+        }
+        else {
+          soft_pwm_amount_bed = 0;
+          WRITE_HEATER_BED(LOW);
+        }
+      #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
+        // Check if temperature is within the correct range
+        if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
+          soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
+        }
+        else {
+          soft_pwm_amount_bed = 0;
+          WRITE_HEATER_BED(LOW);
+        }
+      #endif
+    }
+  #endif // HAS_TEMP_BED
+}
+
+#define PGM_RD_W(x)   (short)pgm_read_word(&x)
+
+// Derived from RepRap FiveD extruder::getTemperature()
+// For hot end temperature measurement.
+float Temperature::analog2temp(int raw, uint8_t e) {
+  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+    if (e > HOTENDS)
+  #else
+    if (e >= HOTENDS)
+  #endif
+    {
+      SERIAL_ERROR_START();
+      SERIAL_ERROR((int)e);
+      SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
+      kill(PSTR(MSG_KILLED));
+      return 0.0;
+    }
+
+  #if ENABLED(HEATER_0_USES_MAX6675)
+    if (e == 0) return 0.25 * raw;
+  #endif
+
+  if (heater_ttbl_map[e] != NULL) {
+    float celsius = 0;
+    uint8_t i;
+    short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
+
+    for (i = 1; i < heater_ttbllen_map[e]; i++) {
+      if (PGM_RD_W((*tt)[i][0]) > raw) {
+        celsius = PGM_RD_W((*tt)[i - 1][1]) +
+                  (raw - PGM_RD_W((*tt)[i - 1][0])) *
+                  (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
+                  (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
+        break;
+      }
+    }
+
+    // Overflow: Set to last value in the table
+    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
+
+    return celsius;
+  }
+  return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
+}
+
+// Derived from RepRap FiveD extruder::getTemperature()
+// For bed temperature measurement.
+float Temperature::analog2tempBed(const int raw) {
+  #if ENABLED(BED_USES_THERMISTOR)
+    float celsius = 0;
+    byte i;
+
+    for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
+      if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
+        celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
+                   (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
+                   (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
+                   (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
+        break;
+      }
+    }
+
+    // Overflow: Set to last value in the table
+    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
+
+    return celsius;
+
+  #elif defined(BED_USES_AD595)
+
+    return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
+
+  #else
+
+    UNUSED(raw);
+    return 0;
+
+  #endif
+}
+
+/**
+ * Get the raw values into the actual temperatures.
+ * The raw values are created in interrupt context,
+ * and this function is called from normal context
+ * as it would block the stepper routine.
+ */
+void Temperature::updateTemperaturesFromRawValues() {
+  #if ENABLED(HEATER_0_USES_MAX6675)
+    current_temperature_raw[0] = read_max6675();
+  #endif
+  HOTEND_LOOP()
+    current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
+  current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
+  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+    redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
+  #endif
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    filament_width_meas = analog2widthFil();
+  #endif
+
+  #if ENABLED(USE_WATCHDOG)
+    // Reset the watchdog after we know we have a temperature measurement.
+    watchdog_reset();
+  #endif
+
+  CRITICAL_SECTION_START;
+  temp_meas_ready = false;
+  CRITICAL_SECTION_END;
+}
+
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+
+  // Convert raw Filament Width to millimeters
+  float Temperature::analog2widthFil() {
+    return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
+    //return current_raw_filwidth;
+  }
+
+  // Convert raw Filament Width to a ratio
+  int Temperature::widthFil_to_size_ratio() {
+    float temp = filament_width_meas;
+    if (temp < MEASURED_LOWER_LIMIT) temp = filament_width_nominal;  //assume sensor cut out
+    else NOMORE(temp, MEASURED_UPPER_LIMIT);
+    return filament_width_nominal / temp * 100;
+  }
+
+#endif
+
+#if ENABLED(HEATER_0_USES_MAX6675)
+  #ifndef MAX6675_SCK_PIN
+    #define MAX6675_SCK_PIN SCK_PIN
+  #endif
+  #ifndef MAX6675_DO_PIN
+    #define MAX6675_DO_PIN MISO_PIN
+  #endif
+  SPI<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
+#endif
+
+/**
+ * Initialize the temperature manager
+ * The manager is implemented by periodic calls to manage_heater()
+ */
+void Temperature::init() {
+
+  #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
+    // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
+    MCUCR = _BV(JTD);
+    MCUCR = _BV(JTD);
+  #endif
+
+  // Finish init of mult hotend arrays
+  HOTEND_LOOP() maxttemp[e] = maxttemp[0];
+
+  #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
+    last_e_position = 0;
+  #endif
+
+  #if HAS_HEATER_0
+    SET_OUTPUT(HEATER_0_PIN);
+  #endif
+  #if HAS_HEATER_1
+    SET_OUTPUT(HEATER_1_PIN);
+  #endif
+  #if HAS_HEATER_2
+    SET_OUTPUT(HEATER_2_PIN);
+  #endif
+  #if HAS_HEATER_3
+    SET_OUTPUT(HEATER_3_PIN);
+  #endif
+  #if HAS_HEATER_4
+    SET_OUTPUT(HEATER_3_PIN);
+  #endif
+  #if HAS_HEATER_BED
+    SET_OUTPUT(HEATER_BED_PIN);
+  #endif
+
+  #if HAS_FAN0
+    SET_OUTPUT(FAN_PIN);
+    #if ENABLED(FAST_PWM_FAN)
+      setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+    #endif
+  #endif
+
+  #if HAS_FAN1
+    SET_OUTPUT(FAN1_PIN);
+    #if ENABLED(FAST_PWM_FAN)
+      setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+    #endif
+  #endif
+
+  #if HAS_FAN2
+    SET_OUTPUT(FAN2_PIN);
+    #if ENABLED(FAST_PWM_FAN)
+      setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+    #endif
+  #endif
+
+  #if ENABLED(HEATER_0_USES_MAX6675)
+
+    OUT_WRITE(SCK_PIN, LOW);
+    OUT_WRITE(MOSI_PIN, HIGH);
+    SET_INPUT_PULLUP(MISO_PIN);
+
+    max6675_spi.init();
+
+    OUT_WRITE(SS_PIN, HIGH);
+    OUT_WRITE(MAX6675_SS, HIGH);
+
+  #endif // HEATER_0_USES_MAX6675
+
+  HAL_adc_init();
+
+  #if HAS_TEMP_0
+    HAL_ANALOG_SELECT(TEMP_0_PIN);
+  #endif
+  #if HAS_TEMP_1
+    HAL_ANALOG_SELECT(TEMP_1_PIN);
+  #endif
+  #if HAS_TEMP_2
+    HAL_ANALOG_SELECT(TEMP_2_PIN);
+  #endif
+  #if HAS_TEMP_3
+    HAL_ANALOG_SELECT(TEMP_3_PIN);
+  #endif
+  #if HAS_TEMP_4
+    HAL_ANALOG_SELECT(TEMP_4_PIN);
+  #endif
+  #if HAS_TEMP_BED
+    HAL_ANALOG_SELECT(TEMP_BED_PIN);
+  #endif
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    HAL_ANALOG_SELECT(FILWIDTH_PIN);
+  #endif
+
+// todo: HAL: fix abstraction
+  #ifdef ARDUINO_ARCH_AVR
+    // Use timer0 for temperature measurement
+    // Interleave temperature interrupt with millies interrupt
+    OCR0B = 128;
+    SBI(TIMSK0, OCIE0B);
+  #else
+    HAL_timer_start(TEMP_TIMER_NUM, TEMP_TIMER_FREQUENCY);
+    HAL_timer_enable_interrupt(TEMP_TIMER_NUM);
+  #endif
+
+  #if HAS_AUTO_FAN_0
+    #if E0_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E0_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(E0_AUTO_FAN_PIN);
+    #endif
+  #endif
+  #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
+    #if E1_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E1_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(E1_AUTO_FAN_PIN);
+    #endif
+  #endif
+  #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
+    #if E2_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E2_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(E2_AUTO_FAN_PIN);
+    #endif
+  #endif
+  #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
+    #if E3_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E3_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(E3_AUTO_FAN_PIN);
+    #endif
+  #endif
+  #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
+    #if E4_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E4_AUTO_FAN_PIN);
+      #if ENABLED(FAST_PWM_FAN)
+        setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+      #endif
+    #else
+      SET_OUTPUT(E4_AUTO_FAN_PIN);
+    #endif
+  #endif
+
+  // Wait for temperature measurement to settle
+  delay(250);
+
+  #define TEMP_MIN_ROUTINE(NR) \
+    minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
+    while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
+      if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
+        minttemp_raw[NR] += OVERSAMPLENR; \
+      else \
+        minttemp_raw[NR] -= OVERSAMPLENR; \
+    }
+  #define TEMP_MAX_ROUTINE(NR) \
+    maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
+    while (analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
+      if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
+        maxttemp_raw[NR] -= OVERSAMPLENR; \
+      else \
+        maxttemp_raw[NR] += OVERSAMPLENR; \
+    }
+
+  #ifdef HEATER_0_MINTEMP
+    TEMP_MIN_ROUTINE(0);
+  #endif
+  #ifdef HEATER_0_MAXTEMP
+    TEMP_MAX_ROUTINE(0);
+  #endif
+  #if HOTENDS > 1
+    #ifdef HEATER_1_MINTEMP
+      TEMP_MIN_ROUTINE(1);
+    #endif
+    #ifdef HEATER_1_MAXTEMP
+      TEMP_MAX_ROUTINE(1);
+    #endif
+    #if HOTENDS > 2
+      #ifdef HEATER_2_MINTEMP
+        TEMP_MIN_ROUTINE(2);
+      #endif
+      #ifdef HEATER_2_MAXTEMP
+        TEMP_MAX_ROUTINE(2);
+      #endif
+      #if HOTENDS > 3
+        #ifdef HEATER_3_MINTEMP
+          TEMP_MIN_ROUTINE(3);
+        #endif
+        #ifdef HEATER_3_MAXTEMP
+          TEMP_MAX_ROUTINE(3);
+        #endif
+        #if HOTENDS > 4
+          #ifdef HEATER_4_MINTEMP
+            TEMP_MIN_ROUTINE(4);
+          #endif
+          #ifdef HEATER_4_MAXTEMP
+            TEMP_MAX_ROUTINE(4);
+          #endif
+        #endif // HOTENDS > 4
+      #endif // HOTENDS > 3
+    #endif // HOTENDS > 2
+  #endif // HOTENDS > 1
+
+  #ifdef BED_MINTEMP
+    while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
+      #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+        bed_minttemp_raw += OVERSAMPLENR;
+      #else
+        bed_minttemp_raw -= OVERSAMPLENR;
+      #endif
+    }
+  #endif // BED_MINTEMP
+  #ifdef BED_MAXTEMP
+    while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
+      #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+        bed_maxttemp_raw -= OVERSAMPLENR;
+      #else
+        bed_maxttemp_raw += OVERSAMPLENR;
+      #endif
+    }
+  #endif // BED_MAXTEMP
+
+  #if ENABLED(PROBING_HEATERS_OFF)
+    paused = false;
+  #endif
+}
+
+#if WATCH_HOTENDS
+  /**
+   * Start Heating Sanity Check for hotends that are below
+   * their target temperature by a configurable margin.
+   * This is called when the temperature is set. (M104, M109)
+   */
+  void Temperature::start_watching_heater(uint8_t e) {
+    #if HOTENDS == 1
+      UNUSED(e);
+    #endif
+    if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
+      watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
+      watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
+    }
+    else
+      watch_heater_next_ms[HOTEND_INDEX] = 0;
+  }
+#endif
+
+#if WATCH_THE_BED
+  /**
+   * Start Heating Sanity Check for hotends that are below
+   * their target temperature by a configurable margin.
+   * This is called when the temperature is set. (M140, M190)
+   */
+  void Temperature::start_watching_bed() {
+    if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
+      watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
+      watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
+    }
+    else
+      watch_bed_next_ms = 0;
+  }
+#endif
+
+#if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
+
+  #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+    Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
+    millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
+  #endif
+
+  #if HAS_THERMALLY_PROTECTED_BED
+    Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
+    millis_t Temperature::thermal_runaway_bed_timer;
+  #endif
+
+  void Temperature::thermal_runaway_protection(Temperature::TRState* state, millis_t* timer, float current, float target, int heater_id, int period_seconds, int hysteresis_degc) {
+
+    static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
+
+    /**
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
+        if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
+        SERIAL_ECHOPAIR(" ;  State:", *state);
+        SERIAL_ECHOPAIR(" ;  Timer:", *timer);
+        SERIAL_ECHOPAIR(" ;  Temperature:", current);
+        SERIAL_ECHOPAIR(" ;  Target Temp:", target);
+        if (heater_id >= 0)
+          SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
+        else
+          SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
+        SERIAL_EOL();
+    */
+
+    const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
+
+    #if HEATER_IDLE_HANDLER
+      // If the heater idle timeout expires, restart
+      if (heater_id >= 0 && heater_idle_timeout_exceeded[heater_id]) {
+        *state = TRInactive;
+        tr_target_temperature[heater_index] = 0;
+      }
+      #if HAS_TEMP_BED
+        else if (heater_id < 0 && bed_idle_timeout_exceeded) {
+          *state = TRInactive;
+          tr_target_temperature[heater_index] = 0;
+        }
+      #endif
+      else
+    #endif
+    // If the target temperature changes, restart
+    if (tr_target_temperature[heater_index] != target) {
+      tr_target_temperature[heater_index] = target;
+      *state = target > 0 ? TRFirstHeating : TRInactive;
+    }
+
+    switch (*state) {
+      // Inactive state waits for a target temperature to be set
+      case TRInactive: break;
+      // When first heating, wait for the temperature to be reached then go to Stable state
+      case TRFirstHeating:
+        if (current < tr_target_temperature[heater_index]) break;
+        *state = TRStable;
+      // While the temperature is stable watch for a bad temperature
+      case TRStable:
+        if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
+          *timer = millis() + period_seconds * 1000UL;
+          break;
+        }
+        else if (PENDING(millis(), *timer)) break;
+        *state = TRRunaway;
+      case TRRunaway:
+        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
+    }
+  }
+
+#endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
+
+void Temperature::disable_all_heaters() {
+
+  #if ENABLED(AUTOTEMP)
+    planner.autotemp_enabled = false;
+  #endif
+
+  HOTEND_LOOP() setTargetHotend(0, e);
+  setTargetBed(0);
+
+  // Unpause and reset everything
+  #if ENABLED(PROBING_HEATERS_OFF)
+    pause(false);
+  #endif
+
+  // If all heaters go down then for sure our print job has stopped
+  print_job_timer.stop();
+
+  #define DISABLE_HEATER(NR) { \
+    setTargetHotend(0, NR); \
+    soft_pwm_amount[NR] = 0; \
+    WRITE_HEATER_ ##NR (LOW); \
+  }
+
+  #if HAS_TEMP_HOTEND
+    DISABLE_HEATER(0);
+    #if HOTENDS > 1
+      DISABLE_HEATER(1);
+      #if HOTENDS > 2
+        DISABLE_HEATER(2);
+        #if HOTENDS > 3
+          DISABLE_HEATER(3);
+          #if HOTENDS > 4
+            DISABLE_HEATER(4);
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+  #endif
+
+  #if HAS_TEMP_BED
+    target_temperature_bed = 0;
+    soft_pwm_amount_bed = 0;
+    #if HAS_HEATER_BED
+      WRITE_HEATER_BED(LOW);
+    #endif
+  #endif
+}
+
+#if ENABLED(PROBING_HEATERS_OFF)
+
+  void Temperature::pause(const bool p) {
+    if (p != paused) {
+      paused = p;
+      if (p) {
+        HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
+        #if HAS_TEMP_BED
+          start_bed_idle_timer(0); // timeout immediately
+        #endif
+      }
+      else {
+        HOTEND_LOOP() reset_heater_idle_timer(e);
+        #if HAS_TEMP_BED
+          reset_bed_idle_timer();
+        #endif
+      }
+    }
+  }
+
+#endif // PROBING_HEATERS_OFF
+
+#if ENABLED(HEATER_0_USES_MAX6675)
+
+  #define MAX6675_HEAT_INTERVAL 250u
+
+  #if ENABLED(MAX6675_IS_MAX31855)
+    uint32_t max6675_temp = 2000;
+    #define MAX6675_ERROR_MASK 7
+    #define MAX6675_DISCARD_BITS 18
+    #define MAX6675_SPEED_BITS 3  // (_BV(SPR1)) // clock √∑ 64
+  #else
+    uint16_t max6675_temp = 2000;
+    #define MAX6675_ERROR_MASK 4
+    #define MAX6675_DISCARD_BITS 3
+    #define MAX6675_SPEED_BITS 2 // (_BV(SPR0)) // clock √∑ 16
+  #endif
+
+  int Temperature::read_max6675() {
+
+    static millis_t next_max6675_ms = 0;
+
+    millis_t ms = millis();
+
+    if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
+
+    next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
+
+    spiBegin();
+    spiInit(MAX6675_SPEED_BITS);
+
+    WRITE(MAX6675_SS, 0); // enable TT_MAX6675
+
+    // ensure 100ns delay - a bit extra is fine
+    asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
+    asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
+
+    // Read a big-endian temperature value
+    max6675_temp = 0;
+    for (uint8_t i = sizeof(max6675_temp); i--;) {
+      max6675_temp |= spiRec();
+      if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
+    }
+
+    WRITE(MAX6675_SS, 1); // disable TT_MAX6675
+
+    if (max6675_temp & MAX6675_ERROR_MASK) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORPGM("Temp measurement error! ");
+      #if MAX6675_ERROR_MASK == 7
+        SERIAL_ERRORPGM("MAX31855 ");
+        if (max6675_temp & 1)
+          SERIAL_ERRORLNPGM("Open Circuit");
+        else if (max6675_temp & 2)
+          SERIAL_ERRORLNPGM("Short to GND");
+        else if (max6675_temp & 4)
+          SERIAL_ERRORLNPGM("Short to VCC");
+      #else
+        SERIAL_ERRORLNPGM("MAX6675");
+      #endif
+      max6675_temp = MAX6675_TMAX * 4; // thermocouple open
+    }
+    else
+      max6675_temp >>= MAX6675_DISCARD_BITS;
+      #if ENABLED(MAX6675_IS_MAX31855)
+        // Support negative temperature
+        if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
+      #endif
+
+    return (int)max6675_temp;
+  }
+
+#endif // HEATER_0_USES_MAX6675
+
+/**
+ * Get raw temperatures
+ */
+void Temperature::set_current_temp_raw() {
+  #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
+    current_temperature_raw[0] = raw_temp_value[0];
+  #endif
+  #if HAS_TEMP_1
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      redundant_temperature_raw = raw_temp_value[1];
+    #else
+      current_temperature_raw[1] = raw_temp_value[1];
+    #endif
+    #if HAS_TEMP_2
+      current_temperature_raw[2] = raw_temp_value[2];
+      #if HAS_TEMP_3
+        current_temperature_raw[3] = raw_temp_value[3];
+        #if HAS_TEMP_4
+          current_temperature_raw[4] = raw_temp_value[4];
+        #endif
+      #endif
+    #endif
+  #endif
+  current_temperature_bed_raw = raw_temp_bed_value;
+  temp_meas_ready = true;
+}
+
+#if ENABLED(PINS_DEBUGGING)
+  /**
+   * monitors endstops & Z probe for changes
+   *
+   * If a change is detected then the LED is toggled and
+   * a message is sent out the serial port
+   *
+   * Yes, we could miss a rapid back & forth change but
+   * that won't matter because this is all manual.
+   *
+   */
+  void endstop_monitor() {
+    static uint16_t old_endstop_bits_local = 0;
+    static uint8_t local_LED_status = 0;
+    uint16_t current_endstop_bits_local = 0;
+    #if HAS_X_MIN
+      if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
+    #endif
+    #if HAS_X_MAX
+      if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
+    #endif
+    #if HAS_Y_MIN
+      if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
+    #endif
+    #if HAS_Y_MAX
+      if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
+    #endif
+    #if HAS_Z_MIN
+      if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
+    #endif
+    #if HAS_Z_MAX
+      if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
+    #endif
+    #if HAS_Z_MIN_PROBE_PIN
+      if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
+    #endif
+    #if HAS_Z2_MIN
+      if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
+    #endif
+    #if HAS_Z2_MAX
+      if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
+    #endif
+
+    uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
+
+    if (endstop_change) {
+      #if HAS_X_MIN
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
+      #endif
+      #if HAS_X_MAX
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
+      #endif
+      #if HAS_Y_MIN
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
+      #endif
+      #if HAS_Y_MAX
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
+      #endif
+      #if HAS_Z_MIN
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
+      #endif
+      #if HAS_Z_MAX
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
+      #endif
+      #if HAS_Z_MIN_PROBE_PIN
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
+      #endif
+      #if HAS_Z2_MIN
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
+      #endif
+      #if HAS_Z2_MAX
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
+      #endif
+      SERIAL_PROTOCOLPGM("\n\n");
+      analogWrite(LED_PIN, local_LED_status);
+      local_LED_status ^= 255;
+      old_endstop_bits_local = current_endstop_bits_local;
+    }
+  }
+#endif // PINS_DEBUGGING
+
+/**
+ * Timer 0 is shared with millies so don't change the prescaler.
+ *
+ * This ISR uses the compare method so it runs at the base
+ * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
+ * in OCR0B above (128 or halfway between OVFs).
+ *
+ *  - Manage PWM to all the heaters and fan
+ *  - Prepare or Measure one of the raw ADC sensor values
+ *  - Check new temperature values for MIN/MAX errors (kill on error)
+ *  - Step the babysteps value for each axis towards 0
+ *  - For PINS_DEBUGGING, monitor and report endstop pins
+ *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
+ */
+HAL_TEMP_TIMER_ISR {
+  HAL_timer_isr_prologue(TEMP_TIMER_NUM);
+  Temperature::isr();
+}
+
+volatile bool Temperature::in_temp_isr = false;
+
+void Temperature::isr() {
+  // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
+  // at the end of its run, potentially causing re-entry. This flag prevents it.
+  if (in_temp_isr) return;
+  in_temp_isr = true;
+
+  // Allow UART and stepper ISRs
+  DISABLE_TEMPERATURE_INTERRUPT(); //Disable Temperature ISR
+  #ifndef CPU_32_BIT
+    sei();
+  #endif
+
+  static int8_t temp_count = -1;
+  static ADCSensorState adc_sensor_state = StartupDelay;
+  static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
+  // avoid multiple loads of pwm_count
+  uint8_t pwm_count_tmp = pwm_count;
+  #if ENABLED(ADC_KEYPAD)
+    static unsigned int raw_ADCKey_value = 0;
+  #endif
+
+  // Static members for each heater
+  #if ENABLED(SLOW_PWM_HEATERS)
+    static uint8_t slow_pwm_count = 0;
+    #define ISR_STATICS(n) \
+      static uint8_t soft_pwm_count_ ## n, \
+                     state_heater_ ## n = 0, \
+                     state_timer_heater_ ## n = 0
+  #else
+    #define ISR_STATICS(n) static uint8_t soft_pwm_count_ ## n = 0
+  #endif
+
+  // Statics per heater
+  ISR_STATICS(0);
+  #if HOTENDS > 1
+    ISR_STATICS(1);
+    #if HOTENDS > 2
+      ISR_STATICS(2);
+      #if HOTENDS > 3
+        ISR_STATICS(3);
+        #if HOTENDS > 4
+          ISR_STATICS(4);
+        #endif // HOTENDS > 4
+      #endif // HOTENDS > 3
+    #endif // HOTENDS > 2
+  #endif // HOTENDS > 1
+  #if HAS_HEATER_BED
+    ISR_STATICS(BED);
+  #endif
+
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    static unsigned long raw_filwidth_value = 0;
+  #endif
+
+  #if DISABLED(SLOW_PWM_HEATERS)
+    constexpr uint8_t pwm_mask =
+      #if ENABLED(SOFT_PWM_DITHER)
+        _BV(SOFT_PWM_SCALE) - 1
+      #else
+        0
+      #endif
+    ;
+
+    /**
+     * Standard PWM modulation
+     */
+    if (pwm_count_tmp >= 127) {
+      pwm_count_tmp -= 127;
+      soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
+      WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
+      #if HOTENDS > 1
+        soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
+        WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
+        #if HOTENDS > 2
+          soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
+          WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
+          #if HOTENDS > 3
+            soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
+            WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
+            #if HOTENDS > 4
+              soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
+              WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+
+      #if HAS_HEATER_BED
+        soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
+        WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
+      #endif
+
+      #if ENABLED(FAN_SOFT_PWM)
+        #if HAS_FAN0
+          soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + soft_pwm_amount_fan[0] >> 1;
+          WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
+        #endif
+        #if HAS_FAN1
+          soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + soft_pwm_amount_fan[1] >> 1;
+          WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
+        #endif
+        #if HAS_FAN2
+          soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + soft_pwm_amount_fan[2] >> 1;
+          WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
+        #endif
+      #endif
+    }
+    else {
+      if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
+      #if HOTENDS > 1
+        if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
+        #if HOTENDS > 2
+          if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
+          #if HOTENDS > 3
+            if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
+            #if HOTENDS > 4
+              if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+
+      #if HAS_HEATER_BED
+        if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
+      #endif
+
+      #if ENABLED(FAN_SOFT_PWM)
+        #if HAS_FAN0
+          if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
+        #endif
+        #if HAS_FAN1
+          if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
+        #endif
+        #if HAS_FAN2
+          if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
+        #endif
+      #endif
+    }
+
+    // SOFT_PWM_SCALE to frequency:
+    //
+    // 0: 16000000/64/256/128 =   7.6294 Hz
+    // 1:                / 64 =  15.2588 Hz
+    // 2:                / 32 =  30.5176 Hz
+    // 3:                / 16 =  61.0352 Hz
+    // 4:                /  8 = 122.0703 Hz
+    // 5:                /  4 = 244.1406 Hz
+    pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
+
+  #else // SLOW_PWM_HEATERS
+
+    /**
+     * SLOW PWM HEATERS
+     *
+     * For relay-driven heaters
+     */
+    #ifndef MIN_STATE_TIME
+      #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
+    #endif
+
+    // Macros for Slow PWM timer logic
+    #define _SLOW_PWM_ROUTINE(NR, src) \
+      soft_pwm_ ##NR = src; \
+      if (soft_pwm_ ##NR > 0) { \
+        if (state_timer_heater_ ##NR == 0) { \
+          if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
+          state_heater_ ##NR = 1; \
+          WRITE_HEATER_ ##NR(1); \
+        } \
+      } \
+      else { \
+        if (state_timer_heater_ ##NR == 0) { \
+          if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
+          state_heater_ ##NR = 0; \
+          WRITE_HEATER_ ##NR(0); \
+        } \
+      }
+    #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
+
+    #define PWM_OFF_ROUTINE(NR) \
+      if (soft_pwm_ ##NR < slow_pwm_count) { \
+        if (state_timer_heater_ ##NR == 0) { \
+          if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
+          state_heater_ ##NR = 0; \
+          WRITE_HEATER_ ##NR (0); \
+        } \
+      }
+
+    if (slow_pwm_count == 0) {
+
+      SLOW_PWM_ROUTINE(0);
+      #if HOTENDS > 1
+        SLOW_PWM_ROUTINE(1);
+        #if HOTENDS > 2
+          SLOW_PWM_ROUTINE(2);
+          #if HOTENDS > 3
+            SLOW_PWM_ROUTINE(3);
+            #if HOTENDS > 4
+              SLOW_PWM_ROUTINE(4);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+      #if HAS_HEATER_BED
+        _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
+      #endif
+
+    } // slow_pwm_count == 0
+
+    PWM_OFF_ROUTINE(0);
+    #if HOTENDS > 1
+      PWM_OFF_ROUTINE(1);
+      #if HOTENDS > 2
+        PWM_OFF_ROUTINE(2);
+        #if HOTENDS > 3
+          PWM_OFF_ROUTINE(3);
+          #if HOTENDS > 4
+            PWM_OFF_ROUTINE(4);
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+    #if HAS_HEATER_BED
+      PWM_OFF_ROUTINE(BED); // BED
+    #endif
+
+    #if ENABLED(FAN_SOFT_PWM)
+      if (pwm_count_tmp >= 127) {
+        pwm_count_tmp = 0;
+        #if HAS_FAN0
+          soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
+          WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
+        #endif
+        #if HAS_FAN1
+          soft_pwm_count_fan[1] = soft_pwm_amount_fan[1] >> 1;
+          WRITE_FAN1(soft_pwm_count_fan[1] > 0 ? HIGH : LOW);
+        #endif
+        #if HAS_FAN2
+          soft_pwm_count_fan[2] = soft_pwm_amount_fan[2] >> 1;
+          WRITE_FAN2(soft_pwm_count_fan[2] > 0 ? HIGH : LOW);
+        #endif
+      }
+      #if HAS_FAN0
+        if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
+      #endif
+      #if HAS_FAN1
+        if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
+      #endif
+      #if HAS_FAN2
+        if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
+      #endif
+    #endif // FAN_SOFT_PWM
+
+    // SOFT_PWM_SCALE to frequency:
+    //
+    // 0: 16000000/64/256/128 =   7.6294 Hz
+    // 1:                / 64 =  15.2588 Hz
+    // 2:                / 32 =  30.5176 Hz
+    // 3:                / 16 =  61.0352 Hz
+    // 4:                /  8 = 122.0703 Hz
+    // 5:                /  4 = 244.1406 Hz
+    pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
+
+    // increment slow_pwm_count only every 64th pwm_count,
+    // i.e. yielding a PWM frequency of 16/128 Hz (8s).
+    if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
+      slow_pwm_count++;
+      slow_pwm_count &= 0x7F;
+
+      if (state_timer_heater_0 > 0) state_timer_heater_0--;
+      #if HOTENDS > 1
+        if (state_timer_heater_1 > 0) state_timer_heater_1--;
+        #if HOTENDS > 2
+          if (state_timer_heater_2 > 0) state_timer_heater_2--;
+          #if HOTENDS > 3
+            if (state_timer_heater_3 > 0) state_timer_heater_3--;
+            #if HOTENDS > 4
+              if (state_timer_heater_4 > 0) state_timer_heater_4--;
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+      #if HAS_HEATER_BED
+        if (state_timer_heater_BED > 0) state_timer_heater_BED--;
+      #endif
+    } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
+
+  #endif // SLOW_PWM_HEATERS
+
+  //
+  // Update lcd buttons 488 times per second
+  //
+  static bool do_buttons;
+  if ((do_buttons ^= true)) lcd_buttons_update();
+
+  /**
+   * One sensor is sampled on every other call of the ISR.
+   * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
+   *
+   * On each Prepare pass, ADC is started for a sensor pin.
+   * On the next pass, the ADC value is read and accumulated.
+   *
+   * This gives each ADC 0.9765ms to charge up.
+   */
+
+  switch (adc_sensor_state) {
+
+    case SensorsReady: {
+      // All sensors have been read. Stay in this state for a few
+      // ISRs to save on calls to temp update/checking code below.
+      constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
+      static uint8_t delay_count = 0;
+      if (extra_loops > 0) {
+        if (delay_count == 0) delay_count = extra_loops;   // Init this delay
+        if (--delay_count)                                 // While delaying...
+          adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
+        break;
+      }
+      else
+        adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
+    }
+
+    #if HAS_TEMP_0
+      case PrepareTemp_0:
+        HAL_START_ADC(TEMP_0_PIN);
+        break;
+      case MeasureTemp_0:
+        raw_temp_value[0] += HAL_READ_ADC;
+        break;
+    #endif
+
+    #if HAS_TEMP_BED
+      case PrepareTemp_BED:
+        HAL_START_ADC(TEMP_BED_PIN);
+        break;
+      case MeasureTemp_BED:
+        raw_temp_bed_value += HAL_READ_ADC;
+        break;
+    #endif
+
+    #if HAS_TEMP_1
+      case PrepareTemp_1:
+        HAL_START_ADC(TEMP_1_PIN);
+        break;
+      case MeasureTemp_1:
+        raw_temp_value[1] += HAL_READ_ADC;
+        break;
+    #endif
+
+    #if HAS_TEMP_2
+      case PrepareTemp_2:
+        HAL_START_ADC(TEMP_2_PIN);
+        break;
+      case MeasureTemp_2:
+        raw_temp_value[2] += HAL_READ_ADC;
+        break;
+    #endif
+
+    #if HAS_TEMP_3
+      case PrepareTemp_3:
+        HAL_START_ADC(TEMP_3_PIN);
+        break;
+      case MeasureTemp_3:
+        raw_temp_value[3] += HAL_READ_ADC;
+        break;
+    #endif
+
+    #if HAS_TEMP_4
+      case PrepareTemp_4:
+        HAL_START_ADC(TEMP_4_PIN);
+        break;
+      case MeasureTemp_4:
+        raw_temp_value[4] += HAL_READ_ADC;
+        break;
+    #endif
+
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      case Prepare_FILWIDTH:
+        HAL_START_ADC(FILWIDTH_PIN);
+      break;
+      case Measure_FILWIDTH:
+        if (HAL_READ_ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
+          raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
+          raw_filwidth_value += ((unsigned long)HAL_READ_ADC << 7); // Add new ADC reading, scaled by 128
+        }
+      break;
+    #endif
+
+    #if ENABLED(ADC_KEYPAD)
+      case Prepare_ADC_KEY:
+        START_ADC(ADC_KEYPAD_PIN);
+        break;
+      case Measure_ADC_KEY:
+        if (ADCKey_count < 16) {
+          raw_ADCKey_value = ADC;
+          if (raw_ADCKey_value > 900) {
+            //ADC Key release
+            ADCKey_count = 0;
+            current_ADCKey_raw = 0;
+          }
+          else {
+            current_ADCKey_raw += raw_ADCKey_value;
+            ADCKey_count++;
+          }
+        }
+        break;
+    #endif // ADC_KEYPAD
+
+    case StartupDelay: break;
+
+  } // switch(adc_sensor_state)
+
+  if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
+
+    temp_count = 0;
+
+    // Update the raw values if they've been read. Else we could be updating them during reading.
+    if (!temp_meas_ready) set_current_temp_raw();
+
+    // Filament Sensor - can be read any time since IIR filtering is used
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
+    #endif
+
+    ZERO(raw_temp_value);
+    raw_temp_bed_value = 0;
+
+    #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
+
+    int constexpr temp_dir[] = {
+      #if ENABLED(HEATER_0_USES_MAX6675)
+         0
+      #else
+        TEMPDIR(0)
+      #endif
+      #if HOTENDS > 1
+        , TEMPDIR(1)
+        #if HOTENDS > 2
+          , TEMPDIR(2)
+          #if HOTENDS > 3
+            , TEMPDIR(3)
+            #if HOTENDS > 4
+              , TEMPDIR(4)
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+    };
+
+    for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
+      const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
+      if (rawtemp > maxttemp_raw[e] * tdir && target_temperature[e] > 0) max_temp_error(e);
+      if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && target_temperature[e] > 0) {
+        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+        #endif
+            min_temp_error(e);
+      }
+      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+        else
+          consecutive_low_temperature_error[e] = 0;
+      #endif
+    }
+
+    #if HAS_TEMP_BED
+      #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
+        #define GEBED <=
+      #else
+        #define GEBED >=
+      #endif
+      if (current_temperature_bed_raw GEBED bed_maxttemp_raw && target_temperature_bed > 0) max_temp_error(-1);
+      if (bed_minttemp_raw GEBED current_temperature_bed_raw && target_temperature_bed > 0) min_temp_error(-1);
+    #endif
+
+  } // temp_count >= OVERSAMPLENR
+
+  // Go to the next state, up to SensorsReady
+  adc_sensor_state = (ADCSensorState)((int(adc_sensor_state) + 1) % int(StartupDelay));
+
+  #if ENABLED(BABYSTEPPING)
+    LOOP_XYZ(axis) {
+      const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
+      if (curTodo > 0) {
+        stepper.babystep((AxisEnum)axis, /*fwd*/true);
+        babystepsTodo[axis]--;
+      }
+      else if (curTodo < 0) {
+        stepper.babystep((AxisEnum)axis, /*fwd*/false);
+        babystepsTodo[axis]++;
+      }
+    }
+  #endif // BABYSTEPPING
+
+  #if ENABLED(PINS_DEBUGGING)
+    extern bool endstop_monitor_flag;
+    // run the endstop monitor at 15Hz
+    static uint8_t endstop_monitor_count = 16;  // offset this check from the others
+    if (endstop_monitor_flag) {
+      endstop_monitor_count += _BV(1);  //  15 Hz
+      endstop_monitor_count &= 0x7F;
+      if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
+    }
+  #endif
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+
+    extern volatile uint8_t e_hit;
+
+    if (e_hit && ENDSTOPS_ENABLED) {
+      endstops.update();  // call endstop update routine
+      e_hit--;
+    }
+  #endif
+
+  #ifndef CPU_32_BIT
+    cli();
+  #endif
+  in_temp_isr = false;
+  ENABLE_TEMPERATURE_INTERRUPT(); //re-enable Temperature ISR
+}
