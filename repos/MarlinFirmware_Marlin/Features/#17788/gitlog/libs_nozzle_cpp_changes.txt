commit b2758208c7e63567baa0165a3d552b706c85cf85
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Nov 9 17:34:48 2023 -0500

    ‚ú® G27 P3 / P4 (#26401)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 10ebd71efd..3b982718a2 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -266,34 +266,45 @@ Nozzle nozzle;
       constexpr feedRate_t fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
       switch (z_action) {
-        case 1: // Go to Z-park height
+        case 1:   // Go to Z-park height
           do_blocking_move_to_z(park.z, fr_z);
           break;
 
-        case 2: // Raise by Z-park height
+        case 2:   // Raise by Z-park height
           do_blocking_move_to_z(_MIN(current_position.z + park.z, Z_MAX_POS), fr_z);
           break;
 
-        default: // Raise by NOZZLE_PARK_Z_RAISE_MIN, use park.z as a minimum height
+        case 3: { // Raise by NOZZLE_PARK_Z_RAISE_MIN, bypass XY-park position
+          do_blocking_move_to_z(park_mode_0_height(0), fr_z);
+          goto SKIP_XY_MOVE;
+        } break;
+
+        case 4:   // Skip Z raise, go to XY position
+          break;
+
+        default:  // Raise by NOZZLE_PARK_Z_RAISE_MIN, use park.z as a minimum height
           do_blocking_move_to_z(park_mode_0_height(park.z), fr_z);
           break;
       }
     #endif // HAS_Z_AXIS
 
-    #ifndef NOZZLE_PARK_MOVE
-      #define NOZZLE_PARK_MOVE 0
-    #endif
-    constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE;
-    switch (NOZZLE_PARK_MOVE) {
-      case 0: do_blocking_move_to_xy(park, fr_xy); break;
-      case 1: do_blocking_move_to_x(park.x, fr_xy); break;
-      case 2: do_blocking_move_to_y(park.y, fr_xy); break;
-      case 3: do_blocking_move_to_x(park.x, fr_xy);
-              do_blocking_move_to_y(park.y, fr_xy); break;
-      case 4: do_blocking_move_to_y(park.y, fr_xy);
-              do_blocking_move_to_x(park.x, fr_xy); break;
+    {
+      #ifndef NOZZLE_PARK_MOVE
+        #define NOZZLE_PARK_MOVE 0
+      #endif
+      constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE;
+      switch (NOZZLE_PARK_MOVE) {
+        case 0: do_blocking_move_to_xy(park, fr_xy); break;
+        case 1: do_blocking_move_to_x(park.x, fr_xy); break;
+        case 2: do_blocking_move_to_y(park.y, fr_xy); break;
+        case 3: do_blocking_move_to_x(park.x, fr_xy);
+                do_blocking_move_to_y(park.y, fr_xy); break;
+        case 4: do_blocking_move_to_y(park.y, fr_xy);
+                do_blocking_move_to_x(park.x, fr_xy); break;
+      }
     }
 
+    SKIP_XY_MOVE:
     report_current_position();
   }
 

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 58c097e316..10ebd71efd 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -63,7 +63,7 @@ Nozzle nozzle;
       #endif
 
       // Start the stroke pattern
-      LOOP_L_N(i, strokes >> 1) {
+      for (uint8_t i = 0; i < strokes >> 1; ++i) {
         #if ENABLED(NOZZLE_CLEAN_NO_Y)
           do_blocking_move_to_x(end.x);
           do_blocking_move_to_x(start.x);
@@ -105,7 +105,7 @@ Nozzle nozzle;
       const bool horiz = ABS(diff.x) >= ABS(diff.y);    // Do a horizontal wipe?
       const float P = (horiz ? diff.x : diff.y) / zigs; // Period of each zig / zag
       const xyz_pos_t *side;
-      LOOP_L_N(j, strokes) {
+      for (uint8_t j = 0; j < strokes; ++j) {
         for (int8_t i = 0; i < zigs; i++) {
           side = (i & 1) ? &end : &start;
           if (horiz)
@@ -143,8 +143,8 @@ Nozzle nozzle;
       #endif
       TERN(NOZZLE_CLEAN_NO_Z, do_blocking_move_to_xy, do_blocking_move_to)(start);
 
-      LOOP_L_N(s, strokes)
-        LOOP_L_N(i, NOZZLE_CLEAN_CIRCLE_FN)
+      for (uint8_t s = 0; s < strokes; ++s)
+        for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; ++i)
           do_blocking_move_to_xy(
             middle.x + sin((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
             middle.y + cos((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index e675c53cb1..58c097e316 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -22,7 +22,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if EITHER(NOZZLE_CLEAN_FEATURE, NOZZLE_PARK_FEATURE)
+#if ANY(NOZZLE_CLEAN_FEATURE, NOZZLE_PARK_FEATURE)
 
 #include "nozzle.h"
 
@@ -170,7 +170,7 @@ Nozzle nozzle;
       xyz_pos_t middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
     #endif
 
-    const uint8_t arrPos = EITHER(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
+    const uint8_t arrPos = ANY(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
 
     switch (pattern) {
       #if DISABLED(NOZZLE_CLEAN_PATTERN_LINE)

commit 9aa69cbc85c9559e2671127d6d6e4298001a6bd5
Author: plampix <plampix@users.noreply.github.com>
Date:   Tue May 2 07:01:44 2023 +0200

    Fix G12 Nozzle Clean (#25766)
    
    Followup to #25666

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 8f44c69c5c..e675c53cb1 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -46,7 +46,7 @@ Nozzle nozzle;
      * @param end xyz_pos_t defining the ending point
      * @param strokes number of strokes to execute
      */
-    void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes) {
+    void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t strokes) {
       #if ENABLED(NOZZLE_CLEAN_GOBACK)
         const xyz_pos_t oldpos = current_position;
       #endif
@@ -87,7 +87,7 @@ Nozzle nozzle;
      * @param strokes number of strokes to execute
      * @param objects number of triangles to do
      */
-    void Nozzle::zigzag(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes, const uint8_t &objects) {
+    void Nozzle::zigzag(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t strokes, const uint8_t objects) {
       const xy_pos_t diff = end - start;
       if (!diff.x || !diff.y) return;
 
@@ -135,7 +135,7 @@ Nozzle nozzle;
      * @param strokes number of strokes to execute
      * @param radius radius of circle
      */
-    void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const_float_t radius) {
+    void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t strokes, const_float_t radius) {
       if (strokes == 0) return;
 
       #if ENABLED(NOZZLE_CLEAN_GOBACK)
@@ -164,7 +164,7 @@ Nozzle nozzle;
    * @param pattern one of the available patterns
    * @param argument depends on the cleaning pattern
    */
-  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const_float_t radius, const uint8_t &objects, const uint8_t cleans) {
+  void Nozzle::clean(const uint8_t pattern, const uint8_t strokes, const_float_t radius, const uint8_t objects, const uint8_t cleans) {
     xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT;
     #if ENABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
       xyz_pos_t middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
@@ -230,10 +230,9 @@ Nozzle nozzle;
     }
     if (!TEST(cleans, Z_AXIS)) start[arrPos].z = end[arrPos].z = current_position.z;
 
-    switch (pattern) {
-      default:
+    switch (pattern) { // no default clause as pattern is already validated
       #if ENABLED(NOZZLE_CLEAN_PATTERN_LINE)
-        case 0: stroke(start[arrPos], end[arrPos], strokes);
+        case 0: stroke(start[arrPos], end[arrPos], strokes); break;
       #endif
       #if ENABLED(NOZZLE_CLEAN_PATTERN_ZIGZAG)
         case 1: zigzag(start[arrPos], end[arrPos], strokes, objects); break;

commit df4f80622eb262fe39cc898e0237257b2870aa7f
Author: plampix <plampix@users.noreply.github.com>
Date:   Mon Apr 24 01:12:47 2023 +0200

    ‚ú® NOZZLE_CLEAN_PATTERN_* (#25666)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 74f61c33d0..8f44c69c5c 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -37,119 +37,125 @@ Nozzle nozzle;
 
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
 
-  /**
-   * @brief Stroke clean pattern
-   * @details Wipes the nozzle back and forth in a linear movement
-   *
-   * @param start xyz_pos_t defining the starting point
-   * @param end xyz_pos_t defining the ending point
-   * @param strokes number of strokes to execute
-   */
-  void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes) {
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const xyz_pos_t oldpos = current_position;
-    #endif
-
-    // Move to the starting point
-    #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      #if ENABLED(NOZZLE_CLEAN_NO_Y)
-        do_blocking_move_to_x(start.x);
-      #else
-        do_blocking_move_to_xy(start);
+  #if ENABLED(NOZZLE_CLEAN_PATTERN_LINE)
+    /**
+     * @brief Stroke clean pattern
+     * @details Wipes the nozzle back and forth in a linear movement
+     *
+     * @param start xyz_pos_t defining the starting point
+     * @param end xyz_pos_t defining the ending point
+     * @param strokes number of strokes to execute
+     */
+    void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes) {
+      #if ENABLED(NOZZLE_CLEAN_GOBACK)
+        const xyz_pos_t oldpos = current_position;
       #endif
-    #else
-      do_blocking_move_to(start);
-    #endif
 
-    // Start the stroke pattern
-    LOOP_L_N(i, strokes >> 1) {
-      #if ENABLED(NOZZLE_CLEAN_NO_Y)
-        do_blocking_move_to_x(end.x);
-        do_blocking_move_to_x(start.x);
+      // Move to the starting point
+      #if ENABLED(NOZZLE_CLEAN_NO_Z)
+        #if ENABLED(NOZZLE_CLEAN_NO_Y)
+          do_blocking_move_to_x(start.x);
+        #else
+          do_blocking_move_to_xy(start);
+        #endif
       #else
-        do_blocking_move_to_xy(end);
-        do_blocking_move_to_xy(start);
+        do_blocking_move_to(start);
       #endif
-    }
 
-    TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(oldpos));
-  }
-
-  /**
-   * @brief Zig-zag clean pattern
-   * @details Apply a zig-zag cleaning pattern
-   *
-   * @param start xyz_pos_t defining the starting point
-   * @param end xyz_pos_t defining the ending point
-   * @param strokes number of strokes to execute
-   * @param objects number of triangles to do
-   */
-  void Nozzle::zigzag(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes, const uint8_t &objects) {
-    const xy_pos_t diff = end - start;
-    if (!diff.x || !diff.y) return;
-
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const xyz_pos_t back = current_position;
-    #endif
-
-    #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      do_blocking_move_to_xy(start);
-    #else
-      do_blocking_move_to(start);
-    #endif
-
-    const uint8_t zigs = objects << 1;
-    const bool horiz = ABS(diff.x) >= ABS(diff.y);    // Do a horizontal wipe?
-    const float P = (horiz ? diff.x : diff.y) / zigs; // Period of each zig / zag
-    const xyz_pos_t *side;
-    LOOP_L_N(j, strokes) {
-      for (int8_t i = 0; i < zigs; i++) {
-        side = (i & 1) ? &end : &start;
-        if (horiz)
-          do_blocking_move_to_xy(start.x + i * P, side->y);
-        else
-          do_blocking_move_to_xy(side->x, start.y + i * P);
-      }
-      for (int8_t i = zigs; i >= 0; i--) {
-        side = (i & 1) ? &end : &start;
-        if (horiz)
-          do_blocking_move_to_xy(start.x + i * P, side->y);
-        else
-          do_blocking_move_to_xy(side->x, start.y + i * P);
+      // Start the stroke pattern
+      LOOP_L_N(i, strokes >> 1) {
+        #if ENABLED(NOZZLE_CLEAN_NO_Y)
+          do_blocking_move_to_x(end.x);
+          do_blocking_move_to_x(start.x);
+        #else
+          do_blocking_move_to_xy(end);
+          do_blocking_move_to_xy(start);
+        #endif
       }
+
+      TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(oldpos));
     }
+  #endif
+
+  #if ENABLED(NOZZLE_CLEAN_PATTERN_ZIGZAG)
+    /**
+     * @brief Zig-zag clean pattern
+     * @details Apply a zig-zag cleaning pattern
+     *
+     * @param start xyz_pos_t defining the starting point
+     * @param end xyz_pos_t defining the ending point
+     * @param strokes number of strokes to execute
+     * @param objects number of triangles to do
+     */
+    void Nozzle::zigzag(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes, const uint8_t &objects) {
+      const xy_pos_t diff = end - start;
+      if (!diff.x || !diff.y) return;
+
+      #if ENABLED(NOZZLE_CLEAN_GOBACK)
+        const xyz_pos_t back = current_position;
+      #endif
 
-    TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(back));
-  }
+      #if ENABLED(NOZZLE_CLEAN_NO_Z)
+        do_blocking_move_to_xy(start);
+      #else
+        do_blocking_move_to(start);
+      #endif
 
-  /**
-   * @brief Circular clean pattern
-   * @details Apply a circular cleaning pattern
-   *
-   * @param start xyz_pos_t defining the middle of circle
-   * @param strokes number of strokes to execute
-   * @param radius radius of circle
-   */
-  void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const_float_t radius) {
-    if (strokes == 0) return;
+      const uint8_t zigs = objects << 1;
+      const bool horiz = ABS(diff.x) >= ABS(diff.y);    // Do a horizontal wipe?
+      const float P = (horiz ? diff.x : diff.y) / zigs; // Period of each zig / zag
+      const xyz_pos_t *side;
+      LOOP_L_N(j, strokes) {
+        for (int8_t i = 0; i < zigs; i++) {
+          side = (i & 1) ? &end : &start;
+          if (horiz)
+            do_blocking_move_to_xy(start.x + i * P, side->y);
+          else
+            do_blocking_move_to_xy(side->x, start.y + i * P);
+        }
+        for (int8_t i = zigs; i >= 0; i--) {
+          side = (i & 1) ? &end : &start;
+          if (horiz)
+            do_blocking_move_to_xy(start.x + i * P, side->y);
+          else
+            do_blocking_move_to_xy(side->x, start.y + i * P);
+        }
+      }
 
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const xyz_pos_t back = current_position;
-    #endif
-    TERN(NOZZLE_CLEAN_NO_Z, do_blocking_move_to_xy, do_blocking_move_to)(start);
+      TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(back));
+    }
+  #endif
+
+  #if ENABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
+    /**
+     * @brief Circular clean pattern
+     * @details Apply a circular cleaning pattern
+     *
+     * @param start xyz_pos_t defining the middle of circle
+     * @param strokes number of strokes to execute
+     * @param radius radius of circle
+     */
+    void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const_float_t radius) {
+      if (strokes == 0) return;
+
+      #if ENABLED(NOZZLE_CLEAN_GOBACK)
+        const xyz_pos_t back = current_position;
+      #endif
+      TERN(NOZZLE_CLEAN_NO_Z, do_blocking_move_to_xy, do_blocking_move_to)(start);
 
-    LOOP_L_N(s, strokes)
-      LOOP_L_N(i, NOZZLE_CLEAN_CIRCLE_FN)
-        do_blocking_move_to_xy(
-          middle.x + sin((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
-          middle.y + cos((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius
-        );
+      LOOP_L_N(s, strokes)
+        LOOP_L_N(i, NOZZLE_CLEAN_CIRCLE_FN)
+          do_blocking_move_to_xy(
+            middle.x + sin((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
+            middle.y + cos((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius
+          );
 
-    // Let's be safe
-    do_blocking_move_to_xy(start);
+      // Let's be safe
+      do_blocking_move_to_xy(start);
 
-    TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(back));
-  }
+      TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(back));
+    }
+  #endif
 
   /**
    * @brief Clean the nozzle
@@ -159,10 +165,25 @@ Nozzle nozzle;
    * @param argument depends on the cleaning pattern
    */
   void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const_float_t radius, const uint8_t &objects, const uint8_t cleans) {
-    xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT, middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
+    xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT;
+    #if ENABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
+      xyz_pos_t middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
+    #endif
 
     const uint8_t arrPos = EITHER(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
 
+    switch (pattern) {
+      #if DISABLED(NOZZLE_CLEAN_PATTERN_LINE)
+        case 0: SERIAL_ECHOLNPGM("Pattern ", F("LINE"), " not enabled."); return;
+      #endif
+      #if DISABLED(NOZZLE_CLEAN_PATTERN_ZIGZAG)
+        case 1: SERIAL_ECHOLNPGM("Pattern ", F("ZIGZAG"), " not enabled."); return;
+      #endif
+      #if DISABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
+        case 2: SERIAL_ECHOLNPGM("Pattern ", F("CIRCULAR"), " not enabled."); return;
+      #endif
+    }
+
     #if NOZZLE_CLEAN_MIN_TEMP > 20
       if (thermalManager.degTargetHotend(arrPos) < NOZZLE_CLEAN_MIN_TEMP) {
         #if ENABLED(NOZZLE_CLEAN_HEATUP)
@@ -179,45 +200,47 @@ Nozzle nozzle;
     #if HAS_SOFTWARE_ENDSTOPS
 
       #define LIMIT_AXIS(A) do{ \
-        LIMIT( start[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
-        LIMIT(middle[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
-        LIMIT(   end[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
+                                           LIMIT( start[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
+                                           LIMIT(   end[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
+        TERN_(NOZZLE_CLEAN_PATTERN_CIRCLE, LIMIT(middle[arrPos].A, soft_endstop.min.A, soft_endstop.max.A)); \
       }while(0)
 
       if (soft_endstop.enabled()) {
-
-        LIMIT_AXIS(x);
-        LIMIT_AXIS(y);
-        LIMIT_AXIS(z);
-        const bool radiusOutOfRange = (middle[arrPos].x + radius > soft_endstop.max.x)
-                                   || (middle[arrPos].x - radius < soft_endstop.min.x)
-                                   || (middle[arrPos].y + radius > soft_endstop.max.y)
-                                   || (middle[arrPos].y - radius < soft_endstop.min.y);
-        if (radiusOutOfRange && pattern == 2) {
-          SERIAL_ECHOLNPGM("Warning: Radius Out of Range");
-          return;
-        }
-
+        LIMIT_AXIS(x); LIMIT_AXIS(y); LIMIT_AXIS(z);
+        #if ENABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
+          if (pattern == 2 && !(WITHIN(middle[arrPos].x, soft_endstop.min.x + radius, soft_endstop.max.x - radius)
+                             && WITHIN(middle[arrPos].y, soft_endstop.min.y + radius, soft_endstop.max.y - radius))
+          ) {
+            SERIAL_ECHOLNPGM("Warning: Radius Out of Range"); return;
+          }
+        #endif
       }
 
     #endif
 
-    if (pattern == 2) {
-      if (!(cleans & (_BV(X_AXIS) | _BV(Y_AXIS)))) {
-        SERIAL_ECHOLNPGM("Warning: Clean Circle requires XY");
-        return;
+    #if ENABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
+      if (pattern == 2 && !(cleans & (_BV(X_AXIS) | _BV(Y_AXIS)))) {
+        SERIAL_ECHOLNPGM("Warning: Clean Circle requires XY"); return;
       }
-    }
-    else {
+    #endif
+
+    if (TERN1(NOZZLE_CLEAN_PATTERN_CIRCLE, pattern != 2)) {
       if (!TEST(cleans, X_AXIS)) start[arrPos].x = end[arrPos].x = current_position.x;
       if (!TEST(cleans, Y_AXIS)) start[arrPos].y = end[arrPos].y = current_position.y;
     }
     if (!TEST(cleans, Z_AXIS)) start[arrPos].z = end[arrPos].z = current_position.z;
 
     switch (pattern) {
-       case 1: zigzag(start[arrPos], end[arrPos], strokes, objects); break;
-       case 2: circle(start[arrPos], middle[arrPos], strokes, radius);  break;
-      default: stroke(start[arrPos], end[arrPos], strokes);
+      default:
+      #if ENABLED(NOZZLE_CLEAN_PATTERN_LINE)
+        case 0: stroke(start[arrPos], end[arrPos], strokes);
+      #endif
+      #if ENABLED(NOZZLE_CLEAN_PATTERN_ZIGZAG)
+        case 1: zigzag(start[arrPos], end[arrPos], strokes, objects); break;
+      #endif
+      #if ENABLED(NOZZLE_CLEAN_PATTERN_CIRCLE)
+        case 2: circle(start[arrPos], middle[arrPos], strokes, radius); break;
+      #endif
     }
   }
 

commit 3156595078c4d6ecdae5a5976ef0dbba060fa603
Author: jbubik <jbubik@centrum.cz>
Date:   Tue Mar 14 02:19:24 2023 +0100

    üêõ Fix Polargraph without Z (#25514)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 575e74a814..74f61c33d0 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -225,38 +225,43 @@ Nozzle nozzle;
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
-  float Nozzle::park_mode_0_height(const_float_t park_z) {
-    // Apply a minimum raise, if specified. Use park.z as a minimum height instead.
-    return _MAX(park_z,                       // Minimum height over 0 based on input
-      _MIN(Z_MAX_POS,                         // Maximum height is fixed
-        #ifdef NOZZLE_PARK_Z_RAISE_MIN
-          NOZZLE_PARK_Z_RAISE_MIN +           // Minimum raise...
-        #endif
-        current_position.z                    // ...over current position
-      )
-    );
-  }
+  #if HAS_Z_AXIS
+    float Nozzle::park_mode_0_height(const_float_t park_z) {
+      // Apply a minimum raise, if specified. Use park.z as a minimum height instead.
+      return _MAX(park_z,                       // Minimum height over 0 based on input
+        _MIN(Z_MAX_POS,                         // Maximum height is fixed
+          #ifdef NOZZLE_PARK_Z_RAISE_MIN
+            NOZZLE_PARK_Z_RAISE_MIN +           // Minimum raise...
+          #endif
+          current_position.z                    // ...over current position
+        )
+      );
+    }
+  #endif // HAS_Z_AXIS
 
   void Nozzle::park(const uint8_t z_action, const xyz_pos_t &park/*=NOZZLE_PARK_POINT*/) {
-    constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE, fr_z = NOZZLE_PARK_Z_FEEDRATE;
+    #if HAS_Z_AXIS
+      constexpr feedRate_t fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
-    switch (z_action) {
-      case 1: // Go to Z-park height
-        do_blocking_move_to_z(park.z, fr_z);
-        break;
+      switch (z_action) {
+        case 1: // Go to Z-park height
+          do_blocking_move_to_z(park.z, fr_z);
+          break;
 
-      case 2: // Raise by Z-park height
-        do_blocking_move_to_z(_MIN(current_position.z + park.z, Z_MAX_POS), fr_z);
-        break;
+        case 2: // Raise by Z-park height
+          do_blocking_move_to_z(_MIN(current_position.z + park.z, Z_MAX_POS), fr_z);
+          break;
 
-      default: // Raise by NOZZLE_PARK_Z_RAISE_MIN, use park.z as a minimum height
-        do_blocking_move_to_z(park_mode_0_height(park.z), fr_z);
-        break;
-    }
+        default: // Raise by NOZZLE_PARK_Z_RAISE_MIN, use park.z as a minimum height
+          do_blocking_move_to_z(park_mode_0_height(park.z), fr_z);
+          break;
+      }
+    #endif // HAS_Z_AXIS
 
     #ifndef NOZZLE_PARK_MOVE
       #define NOZZLE_PARK_MOVE 0
     #endif
+    constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE;
     switch (NOZZLE_PARK_MOVE) {
       case 0: do_blocking_move_to_xy(park, fr_xy); break;
       case 1: do_blocking_move_to_x(park.x, fr_xy); break;

commit 2dc543c4f58c39e6cdf7a4a001c15100268cdf46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 13 21:22:53 2022 -0500

    üé® ANY => EITHER

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 4ca8fa2cae..575e74a814 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -161,7 +161,7 @@ Nozzle nozzle;
   void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const_float_t radius, const uint8_t &objects, const uint8_t cleans) {
     xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT, middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
 
-    const uint8_t arrPos = ANY(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
+    const uint8_t arrPos = EITHER(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
 
     #if NOZZLE_CLEAN_MIN_TEMP > 20
       if (thermalManager.degTargetHotend(arrPos) < NOZZLE_CLEAN_MIN_TEMP) {

commit 9530df4816ed409e79c7b0403613e663f0d63511
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 21 19:54:03 2022 -0600

    üìù Update Toolchange FS comments

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 5cd2014d7f..4ca8fa2cae 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -263,7 +263,7 @@ Nozzle nozzle;
       case 2: do_blocking_move_to_y(park.y, fr_xy); break;
       case 3: do_blocking_move_to_x(park.x, fr_xy);
               do_blocking_move_to_y(park.y, fr_xy); break;
-      case 4: do_blocking_move_to_y(park.y, fr_xy); 
+      case 4: do_blocking_move_to_y(park.y, fr_xy);
               do_blocking_move_to_x(park.x, fr_xy); break;
     }
 

commit b4d3e1da34f5a4365d35b685d2d7e97d76dedf98
Author: John Robertson <john@cirtech.co.uk>
Date:   Fri Feb 11 21:04:47 2022 +0000

    ‚ú® More Nozzle Park move options (#23158)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index e277216ab4..5cd2014d7f 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -254,11 +254,18 @@ Nozzle nozzle;
         break;
     }
 
-    do_blocking_move_to_xy(
-      TERN(NOZZLE_PARK_Y_ONLY, current_position, park).x,
-      TERN(NOZZLE_PARK_X_ONLY, current_position, park).y,
-      fr_xy
-    );
+    #ifndef NOZZLE_PARK_MOVE
+      #define NOZZLE_PARK_MOVE 0
+    #endif
+    switch (NOZZLE_PARK_MOVE) {
+      case 0: do_blocking_move_to_xy(park, fr_xy); break;
+      case 1: do_blocking_move_to_x(park.x, fr_xy); break;
+      case 2: do_blocking_move_to_y(park.y, fr_xy); break;
+      case 3: do_blocking_move_to_x(park.x, fr_xy);
+              do_blocking_move_to_y(park.y, fr_xy); break;
+      case 4: do_blocking_move_to_y(park.y, fr_xy); 
+              do_blocking_move_to_x(park.x, fr_xy); break;
+    }
 
     report_current_position();
   }

commit dfc906930c9b31ddd4d70e9c0ccf15e369abd188
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 3 20:55:05 2021 -0500

    Pause and PLR refinements
    
    - Move `pause_print` argument `unload_length` after `show_lcd` so it's next to `DXC_ARGS`.
    - Tweak the position and conditions of PLR save in `resume_print`.
    - Add `Nozzle::park_mode_0_height` accessor to get the raised Z height.
    - Remove extraneous `recovery.save` from `dwin.cpp`.
    - Move PLR `info.volumetric...` to `flag`.
    - Remove some G-code spaces in PLR code
    - Document `pause.h` function declarations.

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 6918d2fd80..e277216ab4 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -225,6 +225,18 @@ Nozzle nozzle;
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
+  float Nozzle::park_mode_0_height(const_float_t park_z) {
+    // Apply a minimum raise, if specified. Use park.z as a minimum height instead.
+    return _MAX(park_z,                       // Minimum height over 0 based on input
+      _MIN(Z_MAX_POS,                         // Maximum height is fixed
+        #ifdef NOZZLE_PARK_Z_RAISE_MIN
+          NOZZLE_PARK_Z_RAISE_MIN +           // Minimum raise...
+        #endif
+        current_position.z                    // ...over current position
+      )
+    );
+  }
+
   void Nozzle::park(const uint8_t z_action, const xyz_pos_t &park/*=NOZZLE_PARK_POINT*/) {
     constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE, fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
@@ -237,15 +249,9 @@ Nozzle nozzle;
         do_blocking_move_to_z(_MIN(current_position.z + park.z, Z_MAX_POS), fr_z);
         break;
 
-      default: {
-        // Apply a minimum raise, overriding G27 Z
-        const float min_raised_z =_MIN(Z_MAX_POS, current_position.z
-          #ifdef NOZZLE_PARK_Z_RAISE_MIN
-            + NOZZLE_PARK_Z_RAISE_MIN
-          #endif
-        );
-        do_blocking_move_to_z(_MAX(park.z, min_raised_z), fr_z);
-      } break;
+      default: // Raise by NOZZLE_PARK_Z_RAISE_MIN, use park.z as a minimum height
+        do_blocking_move_to_z(park_mode_0_height(park.z), fr_z);
+        break;
     }
 
     do_blocking_move_to_xy(

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index c56f45c70b..6918d2fd80 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -130,7 +130,7 @@ Nozzle nozzle;
    * @param strokes number of strokes to execute
    * @param radius radius of circle
    */
-  void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const float &radius) {
+  void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const_float_t radius) {
     if (strokes == 0) return;
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
@@ -158,7 +158,7 @@ Nozzle nozzle;
    * @param pattern one of the available patterns
    * @param argument depends on the cleaning pattern
    */
-  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const uint8_t cleans) {
+  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const_float_t radius, const uint8_t &objects, const uint8_t cleans) {
     xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT, middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
 
     const uint8_t arrPos = ANY(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 4277e8d8d0..c56f45c70b 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -46,7 +46,9 @@ Nozzle nozzle;
    * @param strokes number of strokes to execute
    */
   void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes) {
-    TERN_(NOZZLE_CLEAN_GOBACK, const xyz_pos_t oldpos = current_position);
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      const xyz_pos_t oldpos = current_position;
+    #endif
 
     // Move to the starting point
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
@@ -86,7 +88,9 @@ Nozzle nozzle;
     const xy_pos_t diff = end - start;
     if (!diff.x || !diff.y) return;
 
-    TERN_(NOZZLE_CLEAN_GOBACK, const xyz_pos_t back = current_position);
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      const xyz_pos_t back = current_position;
+    #endif
 
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
       do_blocking_move_to_xy(start);
@@ -129,7 +133,9 @@ Nozzle nozzle;
   void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const float &radius) {
     if (strokes == 0) return;
 
-    TERN_(NOZZLE_CLEAN_GOBACK, const xyz_pos_t back = current_position);
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      const xyz_pos_t back = current_position;
+    #endif
     TERN(NOZZLE_CLEAN_NO_Z, do_blocking_move_to_xy, do_blocking_move_to)(start);
 
     LOOP_L_N(s, strokes)

commit 7a168205eb2463022ab1a4306bafa8152ab2d8bc
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:02:38 2020 -0500

    Minimum temp options for Probing and G12 Nozzle Clean (#20383)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 10021005e5..4277e8d8d0 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -31,6 +31,10 @@ Nozzle nozzle;
 #include "../MarlinCore.h"
 #include "../module/motion.h"
 
+#if NOZZLE_CLEAN_MIN_TEMP > 20
+  #include "../module/temperature.h"
+#endif
+
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
 
   /**
@@ -153,6 +157,19 @@ Nozzle nozzle;
 
     const uint8_t arrPos = ANY(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
 
+    #if NOZZLE_CLEAN_MIN_TEMP > 20
+      if (thermalManager.degTargetHotend(arrPos) < NOZZLE_CLEAN_MIN_TEMP) {
+        #if ENABLED(NOZZLE_CLEAN_HEATUP)
+          SERIAL_ECHOLNPGM("Nozzle too Cold - Heating");
+          thermalManager.setTargetHotend(NOZZLE_CLEAN_MIN_TEMP, arrPos);
+          thermalManager.wait_for_hotend(arrPos);
+        #else
+          SERIAL_ECHOLNPGM("Nozzle too cold - Skipping wipe");
+          return;
+        #endif
+      }
+    #endif
+
     #if HAS_SOFTWARE_ENDSTOPS
 
       #define LIMIT_AXIS(A) do{ \

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index f93e552481..10021005e5 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -161,7 +161,7 @@ Nozzle nozzle;
         LIMIT(   end[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
       }while(0)
 
-      if (soft_endstops_enabled) {
+      if (soft_endstop.enabled()) {
 
         LIMIT_AXIS(x);
         LIMIT_AXIS(y);

commit ca105493aa1cf5098e8ecac52197683d2de4bd17
Author: Mathew Winters <mathew@winters.org.nz>
Date:   Sun Aug 23 09:20:37 2020 +1200

    NOZZLE_CLEAN_NO_Y (#18870)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 21e6ffb7cd..f93e552481 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -46,15 +46,24 @@ Nozzle nozzle;
 
     // Move to the starting point
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      do_blocking_move_to_xy(start);
+      #if ENABLED(NOZZLE_CLEAN_NO_Y)
+        do_blocking_move_to_x(start.x);
+      #else
+        do_blocking_move_to_xy(start);
+      #endif
     #else
       do_blocking_move_to(start);
     #endif
 
     // Start the stroke pattern
     LOOP_L_N(i, strokes >> 1) {
-      do_blocking_move_to_xy(end);
-      do_blocking_move_to_xy(start);
+      #if ENABLED(NOZZLE_CLEAN_NO_Y)
+        do_blocking_move_to_x(end.x);
+        do_blocking_move_to_x(start.x);
+      #else
+        do_blocking_move_to_xy(end);
+        do_blocking_move_to_xy(start);
+      #endif
     }
 
     TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(oldpos));

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 6796b4d112..21e6ffb7cd 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 2d758663db570d8fc37255bf75c1bd3a98c333fe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 29 03:25:35 2020 -0500

    G12 E soft endstops parameter (#17788)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index f3434a642d..6796b4d112 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -152,18 +152,20 @@ Nozzle nozzle;
         LIMIT(   end[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
       }while(0)
 
-      LIMIT_AXIS(x);
-      LIMIT_AXIS(y);
-      LIMIT_AXIS(z);
+      if (soft_endstops_enabled) {
+
+        LIMIT_AXIS(x);
+        LIMIT_AXIS(y);
+        LIMIT_AXIS(z);
+        const bool radiusOutOfRange = (middle[arrPos].x + radius > soft_endstop.max.x)
+                                   || (middle[arrPos].x - radius < soft_endstop.min.x)
+                                   || (middle[arrPos].y + radius > soft_endstop.max.y)
+                                   || (middle[arrPos].y - radius < soft_endstop.min.y);
+        if (radiusOutOfRange && pattern == 2) {
+          SERIAL_ECHOLNPGM("Warning: Radius Out of Range");
+          return;
+        }
 
-      const bool radiusOutOfRange = (middle[arrPos].x + radius > soft_endstop.max.x)
-                                 || (middle[arrPos].x - radius < soft_endstop.min.x)
-                                 || (middle[arrPos].y + radius > soft_endstop.max.y)
-                                 || (middle[arrPos].y - radius < soft_endstop.min.y);
-
-      if (radiusOutOfRange && pattern == 2) {
-        SERIAL_ECHOLNPGM("Warning: Radius Out of Range");
-        return;
       }
 
     #endif

commit 65daf3ba4085888661c8f3e78305b670951b0844
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Apr 27 06:22:06 2020 -0400

    Fix G12 for SINGLENOZZLE (#17540)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 926845ced2..f3434a642d 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -142,22 +142,48 @@ Nozzle nozzle;
   void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const uint8_t cleans) {
     xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT, middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
 
+    const uint8_t arrPos = ANY(SINGLENOZZLE, MIXING_EXTRUDER) ? 0 : active_extruder;
+
+    #if HAS_SOFTWARE_ENDSTOPS
+
+      #define LIMIT_AXIS(A) do{ \
+        LIMIT( start[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
+        LIMIT(middle[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
+        LIMIT(   end[arrPos].A, soft_endstop.min.A, soft_endstop.max.A); \
+      }while(0)
+
+      LIMIT_AXIS(x);
+      LIMIT_AXIS(y);
+      LIMIT_AXIS(z);
+
+      const bool radiusOutOfRange = (middle[arrPos].x + radius > soft_endstop.max.x)
+                                 || (middle[arrPos].x - radius < soft_endstop.min.x)
+                                 || (middle[arrPos].y + radius > soft_endstop.max.y)
+                                 || (middle[arrPos].y - radius < soft_endstop.min.y);
+
+      if (radiusOutOfRange && pattern == 2) {
+        SERIAL_ECHOLNPGM("Warning: Radius Out of Range");
+        return;
+      }
+
+    #endif
+
     if (pattern == 2) {
       if (!(cleans & (_BV(X_AXIS) | _BV(Y_AXIS)))) {
-        SERIAL_ECHOLNPGM("Warning : Clean Circle requires XY");
+        SERIAL_ECHOLNPGM("Warning: Clean Circle requires XY");
         return;
       }
     }
     else {
-      if (!TEST(cleans, X_AXIS)) start[active_extruder].x = end[active_extruder].x = current_position.x;
-      if (!TEST(cleans, Y_AXIS)) start[active_extruder].y = end[active_extruder].y = current_position.y;
+      if (!TEST(cleans, X_AXIS)) start[arrPos].x = end[arrPos].x = current_position.x;
+      if (!TEST(cleans, Y_AXIS)) start[arrPos].y = end[arrPos].y = current_position.y;
     }
-    if (!TEST(cleans, Z_AXIS)) start[active_extruder].z = end[active_extruder].z = current_position.z;
+    if (!TEST(cleans, Z_AXIS)) start[arrPos].z = end[arrPos].z = current_position.z;
 
     switch (pattern) {
-       case 1: zigzag(start[active_extruder], end[active_extruder], strokes, objects); break;
-       case 2: circle(start[active_extruder], middle[active_extruder], strokes, radius);  break;
-      default: stroke(start[active_extruder], end[active_extruder], strokes);
+       case 1: zigzag(start[arrPos], end[arrPos], strokes, objects); break;
+       case 2: circle(start[arrPos], middle[arrPos], strokes, radius);  break;
+      default: stroke(start[arrPos], end[arrPos], strokes);
     }
   }
 

commit 58ac9f257cb73a0607e3821591f3dfea75670d27
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Sat Apr 25 17:42:34 2020 +0200

    NOZZLE_PARK_FEATURE - X/Y only axis move (#17697)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index b83ec4280a..926845ced2 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -188,7 +188,11 @@ Nozzle nozzle;
       } break;
     }
 
-    do_blocking_move_to_xy(park, fr_xy);
+    do_blocking_move_to_xy(
+      TERN(NOZZLE_PARK_Y_ONLY, current_position, park).x,
+      TERN(NOZZLE_PARK_X_ONLY, current_position, park).y,
+      fr_xy
+    );
 
     report_current_position();
   }

commit d2a5d51f69ff35961d65577f4855e63d123381fd
Author: Ond≈ôej Nov√Ω <ondrej.novy@firma.seznam.cz>
Date:   Sat Apr 25 05:39:08 2020 +0200

    Add NOZZLE_PARK_Z_RAISE_MIN (#17624)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index c691a7db3b..b83ec4280a 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -177,8 +177,15 @@ Nozzle nozzle;
         do_blocking_move_to_z(_MIN(current_position.z + park.z, Z_MAX_POS), fr_z);
         break;
 
-      default: // Raise to at least the Z-park height
-        do_blocking_move_to_z(_MAX(park.z, current_position.z), fr_z);
+      default: {
+        // Apply a minimum raise, overriding G27 Z
+        const float min_raised_z =_MIN(Z_MAX_POS, current_position.z
+          #ifdef NOZZLE_PARK_Z_RAISE_MIN
+            + NOZZLE_PARK_Z_RAISE_MIN
+          #endif
+        );
+        do_blocking_move_to_z(_MAX(park.z, min_raised_z), fr_z);
+      } break;
     }
 
     do_blocking_move_to_xy(park, fr_xy);

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index ecbfeb331e..c691a7db3b 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -42,9 +42,7 @@ Nozzle nozzle;
    * @param strokes number of strokes to execute
    */
   void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes) {
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const xyz_pos_t oldpos = current_position;
-    #endif
+    TERN_(NOZZLE_CLEAN_GOBACK, const xyz_pos_t oldpos = current_position);
 
     // Move to the starting point
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
@@ -59,9 +57,7 @@ Nozzle nozzle;
       do_blocking_move_to_xy(start);
     }
 
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      do_blocking_move_to(oldpos);
-    #endif
+    TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(oldpos));
   }
 
   /**
@@ -77,9 +73,7 @@ Nozzle nozzle;
     const xy_pos_t diff = end - start;
     if (!diff.x || !diff.y) return;
 
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const xyz_pos_t back = current_position;
-    #endif
+    TERN_(NOZZLE_CLEAN_GOBACK, const xyz_pos_t back = current_position);
 
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
       do_blocking_move_to_xy(start);
@@ -108,9 +102,7 @@ Nozzle nozzle;
       }
     }
 
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      do_blocking_move_to(back);
-    #endif
+    TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(back));
   }
 
   /**
@@ -124,15 +116,8 @@ Nozzle nozzle;
   void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const float &radius) {
     if (strokes == 0) return;
 
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const xyz_pos_t back = current_position;
-    #endif
-
-    #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      do_blocking_move_to_xy(start);
-    #else
-      do_blocking_move_to(start);
-    #endif
+    TERN_(NOZZLE_CLEAN_GOBACK, const xyz_pos_t back = current_position);
+    TERN(NOZZLE_CLEAN_NO_Z, do_blocking_move_to_xy, do_blocking_move_to)(start);
 
     LOOP_L_N(s, strokes)
       LOOP_L_N(i, NOZZLE_CLEAN_CIRCLE_FN)
@@ -144,9 +129,7 @@ Nozzle nozzle;
     // Let's be safe
     do_blocking_move_to_xy(start);
 
-    #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      do_blocking_move_to(back);
-    #endif
+    TERN_(NOZZLE_CLEAN_GOBACK, do_blocking_move_to(back));
   }
 
   /**

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 58ba57e425..ecbfeb331e 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -54,7 +54,7 @@ Nozzle nozzle;
     #endif
 
     // Start the stroke pattern
-    for (uint8_t i = 0; i < (strokes >> 1); i++) {
+    LOOP_L_N(i, strokes >> 1) {
       do_blocking_move_to_xy(end);
       do_blocking_move_to_xy(start);
     }
@@ -91,7 +91,7 @@ Nozzle nozzle;
     const bool horiz = ABS(diff.x) >= ABS(diff.y);    // Do a horizontal wipe?
     const float P = (horiz ? diff.x : diff.y) / zigs; // Period of each zig / zag
     const xyz_pos_t *side;
-    for (uint8_t j = 0; j < strokes; j++) {
+    LOOP_L_N(j, strokes) {
       for (int8_t i = 0; i < zigs; i++) {
         side = (i & 1) ? &end : &start;
         if (horiz)
@@ -134,8 +134,8 @@ Nozzle nozzle;
       do_blocking_move_to(start);
     #endif
 
-    for (uint8_t s = 0; s < strokes; s++)
-      for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; i++)
+    LOOP_L_N(s, strokes)
+      LOOP_L_N(i, NOZZLE_CLEAN_CIRCLE_FN)
         do_blocking_move_to_xy(
           middle.x + sin((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
           middle.y + cos((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index f9b09c2fa9..58ba57e425 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 79810b7fcb4149896180d757e2fbb1ec7a8fc217
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Jan 21 03:51:23 2020 -0500

    G12 defaults per tool. Event G-code for post-toolchange (#16554)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index acacbe3392..f9b09c2fa9 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -157,26 +157,24 @@ Nozzle nozzle;
    * @param argument depends on the cleaning pattern
    */
   void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const uint8_t cleans) {
-    xyz_pos_t start = NOZZLE_CLEAN_START_POINT, end = NOZZLE_CLEAN_END_POINT;
+    xyz_pos_t start[HOTENDS] = NOZZLE_CLEAN_START_POINT, end[HOTENDS] = NOZZLE_CLEAN_END_POINT, middle[HOTENDS] = NOZZLE_CLEAN_CIRCLE_MIDDLE;
 
     if (pattern == 2) {
       if (!(cleans & (_BV(X_AXIS) | _BV(Y_AXIS)))) {
         SERIAL_ECHOLNPGM("Warning : Clean Circle requires XY");
         return;
       }
-      constexpr xyz_pos_t middle NOZZLE_CLEAN_CIRCLE_MIDDLE;
-      end = middle;
     }
     else {
-      if (!TEST(cleans, X_AXIS)) start.x = end.x = current_position.x;
-      if (!TEST(cleans, Y_AXIS)) start.y = end.y = current_position.y;
+      if (!TEST(cleans, X_AXIS)) start[active_extruder].x = end[active_extruder].x = current_position.x;
+      if (!TEST(cleans, Y_AXIS)) start[active_extruder].y = end[active_extruder].y = current_position.y;
     }
-    if (!TEST(cleans, Z_AXIS)) start.z = end.z = current_position.z;
+    if (!TEST(cleans, Z_AXIS)) start[active_extruder].z = end[active_extruder].z = current_position.z;
 
     switch (pattern) {
-       case 1: zigzag(start, end, strokes, objects); break;
-       case 2: circle(start, end, strokes, radius);  break;
-      default: stroke(start, end, strokes);
+       case 1: zigzag(start[active_extruder], end[active_extruder], strokes, objects); break;
+       case 2: circle(start[active_extruder], middle[active_extruder], strokes, radius);  break;
+      default: stroke(start[active_extruder], end[active_extruder], strokes);
     }
   }
 

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index b95a7c8afc..acacbe3392 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -28,7 +28,7 @@
 
 Nozzle nozzle;
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 #include "../module/motion.h"
 
 #if ENABLED(NOZZLE_CLEAN_FEATURE)

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 829d46e1da..b95a7c8afc 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -30,7 +30,6 @@ Nozzle nozzle;
 
 #include "../Marlin.h"
 #include "../module/motion.h"
-#include "point_t.h"
 
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
 
@@ -38,30 +37,30 @@ Nozzle nozzle;
    * @brief Stroke clean pattern
    * @details Wipes the nozzle back and forth in a linear movement
    *
-   * @param start point_t defining the starting point
-   * @param end point_t defining the ending point
+   * @param start xyz_pos_t defining the starting point
+   * @param end xyz_pos_t defining the ending point
    * @param strokes number of strokes to execute
    */
-  void Nozzle::stroke(const point_t &start, const point_t &end, const uint8_t &strokes) {
+  void Nozzle::stroke(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes) {
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
+      const xyz_pos_t oldpos = current_position;
     #endif
 
     // Move to the starting point
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      do_blocking_move_to_xy(start.x, start.y);
+      do_blocking_move_to_xy(start);
     #else
-      do_blocking_move_to(start.x, start.y, start.z);
+      do_blocking_move_to(start);
     #endif
 
     // Start the stroke pattern
     for (uint8_t i = 0; i < (strokes >> 1); i++) {
-      do_blocking_move_to_xy(end.x, end.y);
-      do_blocking_move_to_xy(start.x, start.y);
+      do_blocking_move_to_xy(end);
+      do_blocking_move_to_xy(start);
     }
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      do_blocking_move_to(ix, iy, iz);
+      do_blocking_move_to(oldpos);
     #endif
   }
 
@@ -69,29 +68,29 @@ Nozzle nozzle;
    * @brief Zig-zag clean pattern
    * @details Apply a zig-zag cleaning pattern
    *
-   * @param start point_t defining the starting point
-   * @param end point_t defining the ending point
+   * @param start xyz_pos_t defining the starting point
+   * @param end xyz_pos_t defining the ending point
    * @param strokes number of strokes to execute
    * @param objects number of triangles to do
    */
-  void Nozzle::zigzag(const point_t &start, const point_t &end, const uint8_t &strokes, const uint8_t &objects) {
-    const float diffx = end.x - start.x, diffy = end.y - start.y;
-    if (!diffx || !diffy) return;
+  void Nozzle::zigzag(const xyz_pos_t &start, const xyz_pos_t &end, const uint8_t &strokes, const uint8_t &objects) {
+    const xy_pos_t diff = end - start;
+    if (!diff.x || !diff.y) return;
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
+      const xyz_pos_t back = current_position;
     #endif
 
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      do_blocking_move_to_xy(start.x, start.y);
+      do_blocking_move_to_xy(start);
     #else
-      do_blocking_move_to(start.x, start.y, start.z);
+      do_blocking_move_to(start);
     #endif
 
     const uint8_t zigs = objects << 1;
-    const bool horiz = ABS(diffx) >= ABS(diffy);    // Do a horizontal wipe?
-    const float P = (horiz ? diffx : diffy) / zigs;   // Period of each zig / zag
-    const point_t *side;
+    const bool horiz = ABS(diff.x) >= ABS(diff.y);    // Do a horizontal wipe?
+    const float P = (horiz ? diff.x : diff.y) / zigs; // Period of each zig / zag
+    const xyz_pos_t *side;
     for (uint8_t j = 0; j < strokes; j++) {
       for (int8_t i = 0; i < zigs; i++) {
         side = (i & 1) ? &end : &start;
@@ -110,7 +109,7 @@ Nozzle nozzle;
     }
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      do_blocking_move_to(ix, iy, iz);
+      do_blocking_move_to(back);
     #endif
   }
 
@@ -118,21 +117,21 @@ Nozzle nozzle;
    * @brief Circular clean pattern
    * @details Apply a circular cleaning pattern
    *
-   * @param start point_t defining the middle of circle
+   * @param start xyz_pos_t defining the middle of circle
    * @param strokes number of strokes to execute
    * @param radius radius of circle
    */
-  void Nozzle::circle(const point_t &start, const point_t &middle, const uint8_t &strokes, const float &radius) {
+  void Nozzle::circle(const xyz_pos_t &start, const xyz_pos_t &middle, const uint8_t &strokes, const float &radius) {
     if (strokes == 0) return;
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
+      const xyz_pos_t back = current_position;
     #endif
 
     #if ENABLED(NOZZLE_CLEAN_NO_Z)
-      do_blocking_move_to_xy(start.x, start.y);
+      do_blocking_move_to_xy(start);
     #else
-      do_blocking_move_to(start.x, start.y, start.z);
+      do_blocking_move_to(start);
     #endif
 
     for (uint8_t s = 0; s < strokes; s++)
@@ -143,10 +142,10 @@ Nozzle nozzle;
         );
 
     // Let's be safe
-    do_blocking_move_to_xy(start.x, start.y);
+    do_blocking_move_to_xy(start);
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      do_blocking_move_to(ix, iy, iz);
+      do_blocking_move_to(back);
     #endif
   }
 
@@ -158,21 +157,21 @@ Nozzle nozzle;
    * @param argument depends on the cleaning pattern
    */
   void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const uint8_t cleans) {
-    point_t start = NOZZLE_CLEAN_START_POINT;
-    point_t end = NOZZLE_CLEAN_END_POINT;
+    xyz_pos_t start = NOZZLE_CLEAN_START_POINT, end = NOZZLE_CLEAN_END_POINT;
 
     if (pattern == 2) {
       if (!(cleans & (_BV(X_AXIS) | _BV(Y_AXIS)))) {
         SERIAL_ECHOLNPGM("Warning : Clean Circle requires XY");
         return;
       }
-      end = NOZZLE_CLEAN_CIRCLE_MIDDLE;
+      constexpr xyz_pos_t middle NOZZLE_CLEAN_CIRCLE_MIDDLE;
+      end = middle;
     }
     else {
-      if (!TEST(cleans, X_AXIS)) start.x = end.x = current_position[X_AXIS];
-      if (!TEST(cleans, Y_AXIS)) start.y = end.y = current_position[Y_AXIS];
+      if (!TEST(cleans, X_AXIS)) start.x = end.x = current_position.x;
+      if (!TEST(cleans, Y_AXIS)) start.y = end.y = current_position.y;
     }
-    if (!TEST(cleans, Z_AXIS)) start.z = end.z = current_position[Z_AXIS];
+    if (!TEST(cleans, Z_AXIS)) start.z = end.z = current_position.z;
 
     switch (pattern) {
        case 1: zigzag(start, end, strokes, objects); break;
@@ -185,7 +184,7 @@ Nozzle nozzle;
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
-  void Nozzle::park(const uint8_t z_action, const point_t &park/*=NOZZLE_PARK_POINT*/) {
+  void Nozzle::park(const uint8_t z_action, const xyz_pos_t &park/*=NOZZLE_PARK_POINT*/) {
     constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE, fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
     switch (z_action) {
@@ -194,14 +193,14 @@ Nozzle nozzle;
         break;
 
       case 2: // Raise by Z-park height
-        do_blocking_move_to_z(_MIN(current_position[Z_AXIS] + park.z, Z_MAX_POS), fr_z);
+        do_blocking_move_to_z(_MIN(current_position.z + park.z, Z_MAX_POS), fr_z);
         break;
 
       default: // Raise to at least the Z-park height
-        do_blocking_move_to_z(_MAX(park.z, current_position[Z_AXIS]), fr_z);
+        do_blocking_move_to_z(_MAX(park.z, current_position.z), fr_z);
     }
 
-    do_blocking_move_to_xy(park.x, park.y, fr_xy);
+    do_blocking_move_to_xy(park, fr_xy);
 
     report_current_position();
   }

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 6a59c6d07b..829d46e1da 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -186,7 +186,7 @@ Nozzle nozzle;
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
   void Nozzle::park(const uint8_t z_action, const point_t &park/*=NOZZLE_PARK_POINT*/) {
-    constexpr float fr_xy = NOZZLE_PARK_XY_FEEDRATE, fr_z = NOZZLE_PARK_Z_FEEDRATE;
+    constexpr feedRate_t fr_xy = NOZZLE_PARK_XY_FEEDRATE, fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
     switch (z_action) {
       case 1: // Go to Z-park height

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 3926bfc93c..6a59c6d07b 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -175,16 +175,9 @@ Nozzle nozzle;
     if (!TEST(cleans, Z_AXIS)) start.z = end.z = current_position[Z_AXIS];
 
     switch (pattern) {
-      case 1:
-        zigzag(start, end, strokes, objects);
-        break;
-
-      case 2:
-        circle(start, end, strokes, radius);
-        break;
-
-      default:
-        stroke(start, end, strokes);
+       case 1: zigzag(start, end, strokes, objects); break;
+       case 2: circle(start, end, strokes, radius);  break;
+      default: stroke(start, end, strokes);
     }
   }
 
@@ -193,8 +186,7 @@ Nozzle nozzle;
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
   void Nozzle::park(const uint8_t z_action, const point_t &park/*=NOZZLE_PARK_POINT*/) {
-    const float fr_xy = NOZZLE_PARK_XY_FEEDRATE,
-                fr_z = NOZZLE_PARK_Z_FEEDRATE;
+    constexpr float fr_xy = NOZZLE_PARK_XY_FEEDRATE, fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
     switch (z_action) {
       case 1: // Go to Z-park height

commit b8cc61262f5d4f322f537e7eb2ac75bec9490249
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Jul 17 04:41:04 2019 -0400

    Finish G12, update Nozzle::clean (#14642)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 27c214b876..3926bfc93c 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -26,6 +26,8 @@
 
 #include "nozzle.h"
 
+Nozzle nozzle;
+
 #include "../Marlin.h"
 #include "../module/motion.h"
 #include "point_t.h"
@@ -155,24 +157,34 @@
    * @param pattern one of the available patterns
    * @param argument depends on the cleaning pattern
    */
-  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const bool clean_x, const bool clean_y, const bool clean_z) {
+  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const uint8_t cleans) {
     point_t start = NOZZLE_CLEAN_START_POINT;
     point_t end = NOZZLE_CLEAN_END_POINT;
-    if (!clean_x) start.x = end.x = current_position[X_AXIS];
-    if (!clean_y) start.y = end.y = current_position[Y_AXIS];
-    if (!clean_z) start.z = end.z = current_position[Z_AXIS];
+
+    if (pattern == 2) {
+      if (!(cleans & (_BV(X_AXIS) | _BV(Y_AXIS)))) {
+        SERIAL_ECHOLNPGM("Warning : Clean Circle requires XY");
+        return;
+      }
+      end = NOZZLE_CLEAN_CIRCLE_MIDDLE;
+    }
+    else {
+      if (!TEST(cleans, X_AXIS)) start.x = end.x = current_position[X_AXIS];
+      if (!TEST(cleans, Y_AXIS)) start.y = end.y = current_position[Y_AXIS];
+    }
+    if (!TEST(cleans, Z_AXIS)) start.z = end.z = current_position[Z_AXIS];
 
     switch (pattern) {
       case 1:
-        zigzag(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_END_POINT, strokes, objects);
+        zigzag(start, end, strokes, objects);
         break;
 
       case 2:
-        circle(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_CIRCLE_MIDDLE, strokes, radius);
+        circle(start, end, strokes, radius);
         break;
 
       default:
-        stroke(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_END_POINT, strokes);
+        stroke(start, end, strokes);
     }
   }
 

commit d2f20803baa05874e374c5eefd8f124acd3d97fe
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jul 14 07:58:53 2019 -0400

    Allow nozzle clean with limited Axis (#14619)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 336f189e23..27c214b876 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -46,7 +46,11 @@
     #endif
 
     // Move to the starting point
-    do_blocking_move_to(start.x, start.y, start.z);
+    #if ENABLED(NOZZLE_CLEAN_NO_Z)
+      do_blocking_move_to_xy(start.x, start.y);
+    #else
+      do_blocking_move_to(start.x, start.y, start.z);
+    #endif
 
     // Start the stroke pattern
     for (uint8_t i = 0; i < (strokes >> 1); i++) {
@@ -76,7 +80,11 @@
       const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
     #endif
 
-    do_blocking_move_to(start.x, start.y, start.z);
+    #if ENABLED(NOZZLE_CLEAN_NO_Z)
+      do_blocking_move_to_xy(start.x, start.y);
+    #else
+      do_blocking_move_to(start.x, start.y, start.z);
+    #endif
 
     const uint8_t zigs = objects << 1;
     const bool horiz = ABS(diffx) >= ABS(diffy);    // Do a horizontal wipe?
@@ -119,7 +127,11 @@
       const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
     #endif
 
-    do_blocking_move_to(start.x, start.y, start.z);
+    #if ENABLED(NOZZLE_CLEAN_NO_Z)
+      do_blocking_move_to_xy(start.x, start.y);
+    #else
+      do_blocking_move_to(start.x, start.y, start.z);
+    #endif
 
     for (uint8_t s = 0; s < strokes; s++)
       for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; i++)
@@ -143,7 +155,13 @@
    * @param pattern one of the available patterns
    * @param argument depends on the cleaning pattern
    */
-  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects/*=0*/) {
+  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects, const bool clean_x, const bool clean_y, const bool clean_z) {
+    point_t start = NOZZLE_CLEAN_START_POINT;
+    point_t end = NOZZLE_CLEAN_END_POINT;
+    if (!clean_x) start.x = end.x = current_position[X_AXIS];
+    if (!clean_y) start.y = end.y = current_position[Y_AXIS];
+    if (!clean_z) start.z = end.z = current_position[Z_AXIS];
+
     switch (pattern) {
       case 1:
         zigzag(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_END_POINT, strokes, objects);
@@ -162,9 +180,9 @@
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
-  void Nozzle::park(const uint8_t z_action, const point_t &park /*= NOZZLE_PARK_POINT*/) {
-    const float fr_xy = NOZZLE_PARK_XY_FEEDRATE;
-    const float fr_z = NOZZLE_PARK_Z_FEEDRATE;
+  void Nozzle::park(const uint8_t z_action, const point_t &park/*=NOZZLE_PARK_POINT*/) {
+    const float fr_xy = NOZZLE_PARK_XY_FEEDRATE,
+                fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
     switch (z_action) {
       case 1: // Go to Z-park height

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 9ea6c90c46..336f189e23 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -172,11 +172,11 @@
         break;
 
       case 2: // Raise by Z-park height
-        do_blocking_move_to_z(MIN(current_position[Z_AXIS] + park.z, Z_MAX_POS), fr_z);
+        do_blocking_move_to_z(_MIN(current_position[Z_AXIS] + park.z, Z_MAX_POS), fr_z);
         break;
 
       default: // Raise to at least the Z-park height
-        do_blocking_move_to_z(MAX(park.z, current_position[Z_AXIS]), fr_z);
+        do_blocking_move_to_z(_MAX(park.z, current_position[Z_AXIS]), fr_z);
     }
 
     do_blocking_move_to_xy(park.x, park.y, fr_xy);

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 7038b2f2c3..9ea6c90c46 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 69f2535fd4..7038b2f2c3 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -22,7 +22,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE)
+#if EITHER(NOZZLE_CLEAN_FEATURE, NOZZLE_PARK_FEATURE)
 
 #include "nozzle.h"
 

commit e3ce346f2436d4450b5b1582d0eef18deae047ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 19:06:52 2019 -0500

    Report position to host in Nozzle::park

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index e455a8efad..69f2535fd4 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -180,6 +180,8 @@
     }
 
     do_blocking_move_to_xy(park.x, park.y, fr_xy);
+
+    report_current_position();
   }
 
 #endif // NOZZLE_PARK_FEATURE

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index fd845685d8..e455a8efad 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 9d62cf3912..fd845685d8 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -79,7 +79,7 @@
     do_blocking_move_to(start.x, start.y, start.z);
 
     const uint8_t zigs = objects << 1;
-    const bool horiz = FABS(diffx) >= FABS(diffy);    // Do a horizontal wipe?
+    const bool horiz = ABS(diffx) >= ABS(diffy);    // Do a horizontal wipe?
     const float P = (horiz ? diffx : diffy) / zigs;   // Period of each zig / zag
     const point_t *side;
     for (uint8_t j = 0; j < strokes; j++) {
@@ -172,11 +172,11 @@
         break;
 
       case 2: // Raise by Z-park height
-        do_blocking_move_to_z(min(current_position[Z_AXIS] + park.z, Z_MAX_POS), fr_z);
+        do_blocking_move_to_z(MIN(current_position[Z_AXIS] + park.z, Z_MAX_POS), fr_z);
         break;
 
       default: // Raise to at least the Z-park height
-        do_blocking_move_to_z(max(park.z, current_position[Z_AXIS]), fr_z);
+        do_blocking_move_to_z(MAX(park.z, current_position[Z_AXIS]), fr_z);
     }
 
     do_blocking_move_to_xy(park.x, park.y, fr_xy);

commit 190cd0a111d3b6cc6c0baa8c041a840e4892cdd1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 3 22:39:12 2018 -0600

    Nozzle park args

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 93ed937d66..9d62cf3912 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -162,7 +162,7 @@
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
-  void Nozzle::park(const uint8_t &z_action, const point_t &park /*= NOZZLE_PARK_POINT*/) {
+  void Nozzle::park(const uint8_t z_action, const point_t &park /*= NOZZLE_PARK_POINT*/) {
     const float fr_xy = NOZZLE_PARK_XY_FEEDRATE;
     const float fr_z = NOZZLE_PARK_Z_FEEDRATE;
 

commit f0a8a1a85344207870bc7528fa9dd445d5263adf
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Mon Dec 25 01:38:06 2017 -0600

    [2.0.x] Use NOZZLE_PARK_FEATURE for ADVANCED_PAUSE_FEATURE (#8866)
    
    * Use NOZZLE_PARK_FEATURE for ADVANCED_PAUSE_FEATURE

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 6f80e5ad68..93ed937d66 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -162,23 +162,24 @@
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
 
-  void Nozzle::park(const uint8_t &z_action) {
-    const point_t park = NOZZLE_PARK_POINT;
+  void Nozzle::park(const uint8_t &z_action, const point_t &park /*= NOZZLE_PARK_POINT*/) {
+    const float fr_xy = NOZZLE_PARK_XY_FEEDRATE;
+    const float fr_z = NOZZLE_PARK_Z_FEEDRATE;
 
     switch (z_action) {
       case 1: // Go to Z-park height
-        do_blocking_move_to_z(park.z);
+        do_blocking_move_to_z(park.z, fr_z);
         break;
 
       case 2: // Raise by Z-park height
-        do_blocking_move_to_z(min(current_position[Z_AXIS] + park.z, Z_MAX_POS));
+        do_blocking_move_to_z(min(current_position[Z_AXIS] + park.z, Z_MAX_POS), fr_z);
         break;
 
       default: // Raise to at least the Z-park height
-        do_blocking_move_to_z(max(park.z, current_position[Z_AXIS]));
+        do_blocking_move_to_z(max(park.z, current_position[Z_AXIS]), fr_z);
     }
 
-    do_blocking_move_to_xy(park.x, park.y);
+    do_blocking_move_to_xy(park.x, park.y, fr_xy);
   }
 
 #endif // NOZZLE_PARK_FEATURE

commit cffd052fee8102f8796e3f9722e8d2afd210c9a0
Author: Jonathan Barchi <barchij@gmail.com>
Date:   Fri Dec 8 16:50:05 2017 -0800

    [2.0.x] Fix for #8604 (#8717)
    
    * Nozzle.cpp: replace incorrect M_2_PI (2/pi) with 2.0 * M_PI
    
    * Use RADIANS(360) instead of 2 * M_PI

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index eb9c6f3157..6f80e5ad68 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -124,8 +124,8 @@
     for (uint8_t s = 0; s < strokes; s++)
       for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; i++)
         do_blocking_move_to_xy(
-          middle.x + sin((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
-          middle.y + cos((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius
+          middle.x + sin((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
+          middle.y + cos((RADIANS(360) / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius
         );
 
     // Let's be safe

commit be73d5cc080bcd97075c8bb2178224f6b98fe1ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 3 20:44:56 2017 -0500

    Cleanup Nozzle class, fix XY vs Z move order

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index d5039c4ea2..eb9c6f3157 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -20,246 +20,167 @@
  *
  */
 
+#include "../inc/MarlinConfig.h"
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE)
+
 #include "nozzle.h"
 
 #include "../Marlin.h"
 #include "../module/motion.h"
 #include "point_t.h"
 
-#if ENABLED(DELTA)
-  #include "../module/delta.h"
-#endif
-
-/**
-  * @brief Stroke clean pattern
-  * @details Wipes the nozzle back and forth in a linear movement
-  *
-  * @param start point_t defining the starting point
-  * @param end point_t defining the ending point
-  * @param strokes number of strokes to execute
-  */
-void Nozzle::stroke(
-  _UNUSED point_t const &start,
-  _UNUSED point_t const &end,
-  _UNUSED uint8_t const &strokes
-) {
-  #if ENABLED(NOZZLE_CLEAN_FEATURE)
-
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+
+  /**
+   * @brief Stroke clean pattern
+   * @details Wipes the nozzle back and forth in a linear movement
+   *
+   * @param start point_t defining the starting point
+   * @param end point_t defining the ending point
+   * @param strokes number of strokes to execute
+   */
+  void Nozzle::stroke(const point_t &start, const point_t &end, const uint8_t &strokes) {
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      // Store the current coords
-      point_t const initial = {
-        current_position[X_AXIS],
-        current_position[Y_AXIS],
-        current_position[Z_AXIS],
-        current_position[E_AXIS]
-      };
-    #endif // NOZZLE_CLEAN_GOBACK
+      const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
+    #endif
 
     // Move to the starting point
-    do_blocking_move_to_xy(start.x, start.y);
-    do_blocking_move_to_z(start.z);
+    do_blocking_move_to(start.x, start.y, start.z);
 
     // Start the stroke pattern
-    for (uint8_t i = 0; i < (strokes >>1); i++) {
+    for (uint8_t i = 0; i < (strokes >> 1); i++) {
       do_blocking_move_to_xy(end.x, end.y);
       do_blocking_move_to_xy(start.x, start.y);
     }
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      // Move the nozzle to the initial point
-      do_blocking_move_to(initial.x, initial.y, initial.z);
-    #endif // NOZZLE_CLEAN_GOBACK
-
-  #endif // NOZZLE_CLEAN_FEATURE
-}
-
-/**
-  * @brief Zig-zag clean pattern
-  * @details Apply a zig-zag cleanning pattern
-  *
-  * @param start point_t defining the starting point
-  * @param end point_t defining the ending point
-  * @param strokes number of strokes to execute
-  * @param objects number of objects to create
-  */
-void Nozzle::zigzag(
-  _UNUSED point_t const &start,
-  _UNUSED point_t const &end,
-  _UNUSED uint8_t const &strokes,
-  _UNUSED uint8_t const &objects
-) {
-  #if ENABLED(NOZZLE_CLEAN_FEATURE)
-    const float A = nozzle_clean_horizontal ? nozzle_clean_height : nozzle_clean_length, // [twice the] Amplitude
-                P = (nozzle_clean_horizontal ? nozzle_clean_length : nozzle_clean_height) / (objects << 1); // Period
-
-    // Don't allow impossible triangles
-    if (A <= 0.0f || P <= 0.0f ) return;
+      do_blocking_move_to(ix, iy, iz);
+    #endif
+  }
+
+  /**
+   * @brief Zig-zag clean pattern
+   * @details Apply a zig-zag cleaning pattern
+   *
+   * @param start point_t defining the starting point
+   * @param end point_t defining the ending point
+   * @param strokes number of strokes to execute
+   * @param objects number of triangles to do
+   */
+  void Nozzle::zigzag(const point_t &start, const point_t &end, const uint8_t &strokes, const uint8_t &objects) {
+    const float diffx = end.x - start.x, diffy = end.y - start.y;
+    if (!diffx || !diffy) return;
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      // Store the current coords
-      point_t const initial = {
-        current_position[X_AXIS],
-        current_position[Y_AXIS],
-        current_position[Z_AXIS],
-        current_position[E_AXIS]
-      };
-    #endif // NOZZLE_CLEAN_GOBACK
+      const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
+    #endif
 
-    for (uint8_t j = 0; j < strokes; j++) {
-      for (uint8_t i = 0; i < (objects << 1); i++) {
-        float const x = start.x + ( nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
-        float const y = start.y + (!nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
+    do_blocking_move_to(start.x, start.y, start.z);
 
-        do_blocking_move_to_xy(x, y);
-        if (i == 0) do_blocking_move_to_z(start.z);
+    const uint8_t zigs = objects << 1;
+    const bool horiz = FABS(diffx) >= FABS(diffy);    // Do a horizontal wipe?
+    const float P = (horiz ? diffx : diffy) / zigs;   // Period of each zig / zag
+    const point_t *side;
+    for (uint8_t j = 0; j < strokes; j++) {
+      for (int8_t i = 0; i < zigs; i++) {
+        side = (i & 1) ? &end : &start;
+        if (horiz)
+          do_blocking_move_to_xy(start.x + i * P, side->y);
+        else
+          do_blocking_move_to_xy(side->x, start.y + i * P);
       }
-
-      for (int i = (objects << 1); i > -1; i--) {
-        float const x = start.x + ( nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
-        float const y = start.y + (!nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
-
-        do_blocking_move_to_xy(x, y);
+      for (int8_t i = zigs; i >= 0; i--) {
+        side = (i & 1) ? &end : &start;
+        if (horiz)
+          do_blocking_move_to_xy(start.x + i * P, side->y);
+        else
+          do_blocking_move_to_xy(side->x, start.y + i * P);
       }
     }
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      // Move the nozzle to the initial point
-      do_blocking_move_to_z(initial.z);
-      do_blocking_move_to_xy(initial.x, initial.y);
-    #endif // NOZZLE_CLEAN_GOBACK
-
-  #endif // NOZZLE_CLEAN_FEATURE
-}
-
-
-/**
-  * @brief Circular clean pattern
-  * @details Apply a circular cleaning pattern
-  *
-  * @param start point_t defining the middle of circle
-  * @param strokes number of strokes to execute
-  * @param radius radius of circle
-  */
-void Nozzle::circle(
-  _UNUSED point_t const &start,
-  _UNUSED point_t const &middle,
-  _UNUSED uint8_t const &strokes,
-  _UNUSED float const &radius
-) {
-  #if ENABLED(NOZZLE_CLEAN_FEATURE)
+      do_blocking_move_to(ix, iy, iz);
+    #endif
+  }
+
+  /**
+   * @brief Circular clean pattern
+   * @details Apply a circular cleaning pattern
+   *
+   * @param start point_t defining the middle of circle
+   * @param strokes number of strokes to execute
+   * @param radius radius of circle
+   */
+  void Nozzle::circle(const point_t &start, const point_t &middle, const uint8_t &strokes, const float &radius) {
     if (strokes == 0) return;
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      // Store the current coords
-      point_t const initial = {
-        current_position[X_AXIS],
-        current_position[Y_AXIS],
-        current_position[Z_AXIS],
-        current_position[E_AXIS]
-      };
-    #endif // NOZZLE_CLEAN_GOBACK
-
-    if (start.z <= current_position[Z_AXIS]) {
-      // Order of movement is pretty darn important here
-      do_blocking_move_to_xy(start.x, start.y);
-      do_blocking_move_to_z(start.z);
-    }
-    else {
-      do_blocking_move_to_z(start.z);
-      do_blocking_move_to_xy(start.x, start.y);
-    }
+      const float ix = current_position[X_AXIS], iy = current_position[Y_AXIS], iz = current_position[Z_AXIS];
+    #endif
 
-    float x, y;
-    for (uint8_t s = 0; s < strokes; s++) {
-      for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; i++) {
-        x = middle.x + sin((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius;
-        y = middle.y + cos((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius;
+    do_blocking_move_to(start.x, start.y, start.z);
 
-        do_blocking_move_to_xy(x, y);
-      }
-    }
+    for (uint8_t s = 0; s < strokes; s++)
+      for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; i++)
+        do_blocking_move_to_xy(
+          middle.x + sin((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius,
+          middle.y + cos((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius
+        );
 
     // Let's be safe
     do_blocking_move_to_xy(start.x, start.y);
 
     #if ENABLED(NOZZLE_CLEAN_GOBACK)
-      // Move the nozzle to the initial point
-      if (start.z <= initial.z) {
-        // As above order is important
-        do_blocking_move_to_z(initial.z);
-        do_blocking_move_to_xy(initial.x, initial.y);
-      }
-      else {
-        do_blocking_move_to_xy(initial.x, initial.y);
-        do_blocking_move_to_z(initial.z);
-      }
-    #endif // NOZZLE_CLEAN_GOBACK
-
-  #endif // NOZZLE_CLEAN_FEATURE
-}
-
-/**
-  * @brief Clean the nozzle
-  * @details Starts the selected clean procedure pattern
-  *
-  * @param pattern one of the available patterns
-  * @param argument depends on the cleaning pattern
-  */
-void Nozzle::clean(
-  _UNUSED uint8_t const &pattern,
-  _UNUSED uint8_t const &strokes,
-  _UNUSED float const &radius,
-  _UNUSED uint8_t const &objects
-) {
-  #if ENABLED(NOZZLE_CLEAN_FEATURE)
-    #if ENABLED(DELTA)
-      if (current_position[Z_AXIS] > delta_clip_start_height)
-        do_blocking_move_to_z(delta_clip_start_height);
+      do_blocking_move_to(ix, iy, iz);
     #endif
+  }
+
+  /**
+   * @brief Clean the nozzle
+   * @details Starts the selected clean procedure pattern
+   *
+   * @param pattern one of the available patterns
+   * @param argument depends on the cleaning pattern
+   */
+  void Nozzle::clean(const uint8_t &pattern, const uint8_t &strokes, const float &radius, const uint8_t &objects/*=0*/) {
     switch (pattern) {
       case 1:
-        Nozzle::zigzag(
-          NOZZLE_CLEAN_START_POINT,
-          NOZZLE_CLEAN_END_POINT, strokes, objects);
+        zigzag(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_END_POINT, strokes, objects);
         break;
 
       case 2:
-        Nozzle::circle(
-          NOZZLE_CLEAN_START_POINT,
-          NOZZLE_CLEAN_CIRCLE_MIDDLE, strokes, radius);
+        circle(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_CIRCLE_MIDDLE, strokes, radius);
         break;
 
       default:
-        Nozzle::stroke(
-          NOZZLE_CLEAN_START_POINT,
-          NOZZLE_CLEAN_END_POINT, strokes);
+        stroke(NOZZLE_CLEAN_START_POINT, NOZZLE_CLEAN_END_POINT, strokes);
     }
-  #endif // NOZZLE_CLEAN_FEATURE
-}
-
-void Nozzle::park(
-  _UNUSED uint8_t const &z_action
-) {
-  #if ENABLED(NOZZLE_PARK_FEATURE)
-    float const z = current_position[Z_AXIS];
-    point_t const park = NOZZLE_PARK_POINT;
-
-    switch(z_action) {
-      case 1: // force Z-park height
+  }
+
+#endif // NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_PARK_FEATURE)
+
+  void Nozzle::park(const uint8_t &z_action) {
+    const point_t park = NOZZLE_PARK_POINT;
+
+    switch (z_action) {
+      case 1: // Go to Z-park height
         do_blocking_move_to_z(park.z);
         break;
 
       case 2: // Raise by Z-park height
-        do_blocking_move_to_z(
-          (z + park.z > Z_MAX_POS) ? Z_MAX_POS : z + park.z);
+        do_blocking_move_to_z(min(current_position[Z_AXIS] + park.z, Z_MAX_POS));
         break;
 
-      default: // Raise to Z-park height if lower
-        if (current_position[Z_AXIS] < park.z)
-          do_blocking_move_to_z(park.z);
+      default: // Raise to at least the Z-park height
+        do_blocking_move_to_z(max(park.z, current_position[Z_AXIS]));
     }
 
     do_blocking_move_to_xy(park.x, park.y);
+  }
+
+#endif // NOZZLE_PARK_FEATURE
 
-  #endif // NOZZLE_PARK_FEATURE
-}
+#endif // NOZZLE_CLEAN_FEATURE || NOZZLE_PARK_FEATURE

commit 0cb00f52d94773411e405ae10a463a4687b70658
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Sep 30 16:06:43 2017 -0500

    Cleanup warnings

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index 7b7006ee2c..d5039c4ea2 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -26,6 +26,10 @@
 #include "../module/motion.h"
 #include "point_t.h"
 
+#if ENABLED(DELTA)
+  #include "../module/delta.h"
+#endif
+
 /**
   * @brief Stroke clean pattern
   * @details Wipes the nozzle back and forth in a linear movement

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index c8c4732f9e..7b7006ee2c 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -23,6 +23,7 @@
 #include "nozzle.h"
 
 #include "../Marlin.h"
+#include "../module/motion.h"
 #include "point_t.h"
 
 /**

commit d7ee81202fab12f6d344f8ff7a8796bd49d32593
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Libs updates

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
index eec8bfa39a..c8c4732f9e 100644
--- a/Marlin/src/libs/nozzle.cpp
+++ b/Marlin/src/libs/nozzle.cpp
@@ -1,6 +1,28 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
 #include "nozzle.h"
 
-#include "Marlin.h"
+#include "../Marlin.h"
 #include "point_t.h"
 
 /**

commit efa578d6b03deff85bd2dc99c67d3a6871d8ee27
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'libs' files

diff --git a/Marlin/src/libs/nozzle.cpp b/Marlin/src/libs/nozzle.cpp
new file mode 100644
index 0000000000..eec8bfa39a
--- /dev/null
+++ b/Marlin/src/libs/nozzle.cpp
@@ -0,0 +1,238 @@
+#include "nozzle.h"
+
+#include "Marlin.h"
+#include "point_t.h"
+
+/**
+  * @brief Stroke clean pattern
+  * @details Wipes the nozzle back and forth in a linear movement
+  *
+  * @param start point_t defining the starting point
+  * @param end point_t defining the ending point
+  * @param strokes number of strokes to execute
+  */
+void Nozzle::stroke(
+  _UNUSED point_t const &start,
+  _UNUSED point_t const &end,
+  _UNUSED uint8_t const &strokes
+) {
+  #if ENABLED(NOZZLE_CLEAN_FEATURE)
+
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      // Store the current coords
+      point_t const initial = {
+        current_position[X_AXIS],
+        current_position[Y_AXIS],
+        current_position[Z_AXIS],
+        current_position[E_AXIS]
+      };
+    #endif // NOZZLE_CLEAN_GOBACK
+
+    // Move to the starting point
+    do_blocking_move_to_xy(start.x, start.y);
+    do_blocking_move_to_z(start.z);
+
+    // Start the stroke pattern
+    for (uint8_t i = 0; i < (strokes >>1); i++) {
+      do_blocking_move_to_xy(end.x, end.y);
+      do_blocking_move_to_xy(start.x, start.y);
+    }
+
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      // Move the nozzle to the initial point
+      do_blocking_move_to(initial.x, initial.y, initial.z);
+    #endif // NOZZLE_CLEAN_GOBACK
+
+  #endif // NOZZLE_CLEAN_FEATURE
+}
+
+/**
+  * @brief Zig-zag clean pattern
+  * @details Apply a zig-zag cleanning pattern
+  *
+  * @param start point_t defining the starting point
+  * @param end point_t defining the ending point
+  * @param strokes number of strokes to execute
+  * @param objects number of objects to create
+  */
+void Nozzle::zigzag(
+  _UNUSED point_t const &start,
+  _UNUSED point_t const &end,
+  _UNUSED uint8_t const &strokes,
+  _UNUSED uint8_t const &objects
+) {
+  #if ENABLED(NOZZLE_CLEAN_FEATURE)
+    const float A = nozzle_clean_horizontal ? nozzle_clean_height : nozzle_clean_length, // [twice the] Amplitude
+                P = (nozzle_clean_horizontal ? nozzle_clean_length : nozzle_clean_height) / (objects << 1); // Period
+
+    // Don't allow impossible triangles
+    if (A <= 0.0f || P <= 0.0f ) return;
+
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      // Store the current coords
+      point_t const initial = {
+        current_position[X_AXIS],
+        current_position[Y_AXIS],
+        current_position[Z_AXIS],
+        current_position[E_AXIS]
+      };
+    #endif // NOZZLE_CLEAN_GOBACK
+
+    for (uint8_t j = 0; j < strokes; j++) {
+      for (uint8_t i = 0; i < (objects << 1); i++) {
+        float const x = start.x + ( nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
+        float const y = start.y + (!nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
+
+        do_blocking_move_to_xy(x, y);
+        if (i == 0) do_blocking_move_to_z(start.z);
+      }
+
+      for (int i = (objects << 1); i > -1; i--) {
+        float const x = start.x + ( nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
+        float const y = start.y + (!nozzle_clean_horizontal ? i * P : (A/P) * (P - FABS(FMOD((i*P), (2*P)) - P)) );
+
+        do_blocking_move_to_xy(x, y);
+      }
+    }
+
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      // Move the nozzle to the initial point
+      do_blocking_move_to_z(initial.z);
+      do_blocking_move_to_xy(initial.x, initial.y);
+    #endif // NOZZLE_CLEAN_GOBACK
+
+  #endif // NOZZLE_CLEAN_FEATURE
+}
+
+
+/**
+  * @brief Circular clean pattern
+  * @details Apply a circular cleaning pattern
+  *
+  * @param start point_t defining the middle of circle
+  * @param strokes number of strokes to execute
+  * @param radius radius of circle
+  */
+void Nozzle::circle(
+  _UNUSED point_t const &start,
+  _UNUSED point_t const &middle,
+  _UNUSED uint8_t const &strokes,
+  _UNUSED float const &radius
+) {
+  #if ENABLED(NOZZLE_CLEAN_FEATURE)
+    if (strokes == 0) return;
+
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      // Store the current coords
+      point_t const initial = {
+        current_position[X_AXIS],
+        current_position[Y_AXIS],
+        current_position[Z_AXIS],
+        current_position[E_AXIS]
+      };
+    #endif // NOZZLE_CLEAN_GOBACK
+
+    if (start.z <= current_position[Z_AXIS]) {
+      // Order of movement is pretty darn important here
+      do_blocking_move_to_xy(start.x, start.y);
+      do_blocking_move_to_z(start.z);
+    }
+    else {
+      do_blocking_move_to_z(start.z);
+      do_blocking_move_to_xy(start.x, start.y);
+    }
+
+    float x, y;
+    for (uint8_t s = 0; s < strokes; s++) {
+      for (uint8_t i = 0; i < NOZZLE_CLEAN_CIRCLE_FN; i++) {
+        x = middle.x + sin((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius;
+        y = middle.y + cos((M_2_PI / NOZZLE_CLEAN_CIRCLE_FN) * i) * radius;
+
+        do_blocking_move_to_xy(x, y);
+      }
+    }
+
+    // Let's be safe
+    do_blocking_move_to_xy(start.x, start.y);
+
+    #if ENABLED(NOZZLE_CLEAN_GOBACK)
+      // Move the nozzle to the initial point
+      if (start.z <= initial.z) {
+        // As above order is important
+        do_blocking_move_to_z(initial.z);
+        do_blocking_move_to_xy(initial.x, initial.y);
+      }
+      else {
+        do_blocking_move_to_xy(initial.x, initial.y);
+        do_blocking_move_to_z(initial.z);
+      }
+    #endif // NOZZLE_CLEAN_GOBACK
+
+  #endif // NOZZLE_CLEAN_FEATURE
+}
+
+/**
+  * @brief Clean the nozzle
+  * @details Starts the selected clean procedure pattern
+  *
+  * @param pattern one of the available patterns
+  * @param argument depends on the cleaning pattern
+  */
+void Nozzle::clean(
+  _UNUSED uint8_t const &pattern,
+  _UNUSED uint8_t const &strokes,
+  _UNUSED float const &radius,
+  _UNUSED uint8_t const &objects
+) {
+  #if ENABLED(NOZZLE_CLEAN_FEATURE)
+    #if ENABLED(DELTA)
+      if (current_position[Z_AXIS] > delta_clip_start_height)
+        do_blocking_move_to_z(delta_clip_start_height);
+    #endif
+    switch (pattern) {
+      case 1:
+        Nozzle::zigzag(
+          NOZZLE_CLEAN_START_POINT,
+          NOZZLE_CLEAN_END_POINT, strokes, objects);
+        break;
+
+      case 2:
+        Nozzle::circle(
+          NOZZLE_CLEAN_START_POINT,
+          NOZZLE_CLEAN_CIRCLE_MIDDLE, strokes, radius);
+        break;
+
+      default:
+        Nozzle::stroke(
+          NOZZLE_CLEAN_START_POINT,
+          NOZZLE_CLEAN_END_POINT, strokes);
+    }
+  #endif // NOZZLE_CLEAN_FEATURE
+}
+
+void Nozzle::park(
+  _UNUSED uint8_t const &z_action
+) {
+  #if ENABLED(NOZZLE_PARK_FEATURE)
+    float const z = current_position[Z_AXIS];
+    point_t const park = NOZZLE_PARK_POINT;
+
+    switch(z_action) {
+      case 1: // force Z-park height
+        do_blocking_move_to_z(park.z);
+        break;
+
+      case 2: // Raise by Z-park height
+        do_blocking_move_to_z(
+          (z + park.z > Z_MAX_POS) ? Z_MAX_POS : z + park.z);
+        break;
+
+      default: // Raise to Z-park height if lower
+        if (current_position[Z_AXIS] < park.z)
+          do_blocking_move_to_z(park.z);
+    }
+
+    do_blocking_move_to_xy(park.x, park.y);
+
+  #endif // NOZZLE_PARK_FEATURE
+}
