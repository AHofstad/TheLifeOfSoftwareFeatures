commit bd6eb832500478c9e3be55f1126d0139aa013bb0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 1 09:19:13 2023 -0600

    ü©π Fix some minor issues

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index f4d5a269af..9fb9813ee5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -131,21 +131,21 @@
       const float v = current_position.z;
       MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
-      MString<9> msg;
+      MString<10> msg;
       msg.setf(F(" %i / %u"), int(manual_probe_index + 1), total_probe_points);
       MenuItem_static::draw(LCD_HEIGHT / 2, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT), SS_CENTER, msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //

commit cb044d989c397fcbf6f106502df69a7e5c41d34b
Author: Vladimir Sitnikov <sitnikov.vladimir@gmail.com>
Date:   Sun Nov 5 09:46:57 2023 +0300

    ‚ú® Probe XY Offset value limits (#26267)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 981c51a6b0..f4d5a269af 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -271,32 +271,32 @@ void menu_bed_leveling() {
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     // Shadow for editing the fade height
     editable.decimal = planner.z_fade_height;
     EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
-    #if WITHIN(Z_PROBE_OFFSET_RANGE_MIN, -9, 9)
+    #if WITHIN(PROBE_OFFSET_ZMIN, -9, 9)
       #define LCD_Z_OFFSET_TYPE float43    // Values from -9.000 to +9.000
     #else
       #define LCD_Z_OFFSET_TYPE float42_52 // Values from -99.99 to 99.99
     #endif
-    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_MESH_Z_OFFSET, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_MESH_Z_OFFSET, &bedlevel.z_offset, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX);
   #endif
 
   #if ENABLED(PROBE_OFFSET_WIZARD)
     SUBMENU(MSG_PROBE_WIZARD, goto_probe_offset_wizard);
   #endif
 
   #if ENABLED(LCD_BED_TRAMMING)
     SUBMENU(MSG_BED_TRAMMING, _lcd_bed_tramming);
   #endif
 

commit b956001d8175b3f01ef0be2ef6b07825a8509317
Author: lukasradek <lukasradek@users.noreply.github.com>
Date:   Mon Aug 7 05:08:35 2023 +0200

    üö∏ Update LCD Manual Leveling display (#26088)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index beb9342fb9..981c51a6b0 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -132,22 +132,22 @@
       MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       MString<9> msg;
-      msg.setf(F("%i / %u"), int(manual_probe_index + 1), total_probe_points);
-      MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT), &msg);
+      msg.setf(F(" %i / %u"), int(manual_probe_index + 1), total_probe_points);
+      MenuItem_static::draw(LCD_HEIGHT / 2, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT), SS_CENTER, msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index efc05aabde..beb9342fb9 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -131,23 +131,23 @@
       const float v = current_position.z;
       MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
-      char msg[10];
-      sprintf_P(msg, PSTR("%i / %u"), int(manual_probe_index + 1), total_probe_points);
-      MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT), msg);
+      MString<9> msg;
+      msg.setf(F("%i / %u"), int(manual_probe_index + 1), total_probe_points);
+      MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT), &msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index dcf77cb3eb..efc05aabde 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -36,21 +36,21 @@
   #include "../../module/probe.h"
 #endif
 
 #if HAS_GRAPHICAL_TFT
   #include "../tft/tft.h"
   #if ENABLED(TOUCH_SCREEN)
     #include "../tft/touch.h"
   #endif
 #endif
 
-#if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
+#if ANY(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
   // LCD probed points are from defaults
   constexpr grid_count_t total_probe_points = TERN(AUTO_BED_LEVELING_3POINT, 3, GRID_MAX_POINTS);
@@ -162,21 +162,21 @@
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
     if (ui.should_draw()) {
       MenuItem_static::draw(1, GET_TEXT_F(MSG_LEVEL_BED_WAITING));
       // Color UI needs a control to detect a touch
-      #if BOTH(TOUCH_SCREEN, HAS_GRAPHICAL_TFT)
+      #if ALL(TOUCH_SCREEN, HAS_GRAPHICAL_TFT)
         touch.add_control(CLICK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
       #endif
     }
     if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
 
   //
@@ -242,21 +242,21 @@ void menu_bed_leveling() {
 
   START_MENU();
   BACK_ITEM(MSG_MOTION);
 
   // Auto Home if not using manual probing
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
     if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, FPSTR(G28_STR));
   #endif
 
   // Level Bed
-  #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
+  #if ANY(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     SUBMENU(MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     GCODES_ITEM(MSG_LEVEL_BED, is_homed ? F("G29") : F("G29N"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     if (is_valid) SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
   #endif

commit 060ddf5e950b104b00f5d20adf858a9ad00ab72e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:52:52 2023 -0500

    üö∏ Support Bed Leveling Mesh > 16x16
    
    Co-Authored-By: raTmole <ratmole@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 3d6af0012d..dcf77cb3eb 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -46,21 +46,21 @@
 #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
   // LCD probed points are from defaults
-  constexpr uint8_t total_probe_points = TERN(AUTO_BED_LEVELING_3POINT, 3, GRID_MAX_POINTS);
+  constexpr grid_count_t total_probe_points = TERN(AUTO_BED_LEVELING_3POINT, 3, GRID_MAX_POINTS);
 
   //
   // Bed leveling is done. Wait for G29 to complete.
   // A flag is used so that this can release control
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
   // - Raise Z to the "Z after probing" height
   // - Don't return until done.
   //

commit 9b883704bc6a9269ec7bfbc1377050d579abcace
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:31:18 2023 -0500

    üö∏ Reorder some Menu Items

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index a7fb54f68d..3d6af0012d 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -285,20 +285,24 @@ void menu_bed_leveling() {
     #endif
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_MESH_Z_OFFSET, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
+  #if ENABLED(PROBE_OFFSET_WIZARD)
+    SUBMENU(MSG_PROBE_WIZARD, goto_probe_offset_wizard);
+  #endif
+
   #if ENABLED(LCD_BED_TRAMMING)
     SUBMENU(MSG_BED_TRAMMING, _lcd_bed_tramming);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }

commit 10983d0cfe3e353ba465cfcadf8aeb51327f1197
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 15 00:29:37 2023 -0500

    üé® Misc. tramming menu cleanup (#25519)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index d25d35011e..a7fb54f68d 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -286,21 +286,21 @@ void menu_bed_leveling() {
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_MESH_Z_OFFSET, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LCD_BED_TRAMMING)
-    SUBMENU(MSG_BED_TRAMMING, _lcd_level_bed_corners);
+    SUBMENU(MSG_BED_TRAMMING, _lcd_bed_tramming);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }
 
 #endif // LCD_BED_LEVELING

commit 96bc084f3d791bc93265f217181986863e8e5fc7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 18 02:15:16 2023 -0600

    üé® Misc. LCD cleanup (#25400)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 9505a82dd7..d25d35011e 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -276,21 +276,21 @@ void menu_bed_leveling() {
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     #if WITHIN(Z_PROBE_OFFSET_RANGE_MIN, -9, 9)
       #define LCD_Z_OFFSET_TYPE float43    // Values from -9.000 to +9.000
     #else
       #define LCD_Z_OFFSET_TYPE float42_52 // Values from -99.99 to 99.99
     #endif
-    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_BED_Z, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_MESH_Z_OFFSET, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LCD_BED_TRAMMING)
     SUBMENU(MSG_BED_TRAMMING, _lcd_level_bed_corners);

commit 01e58de31a804731d21c491952afd2347fda3753
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 10 22:38:08 2023 -0600

    ü©π ProUI - Remove ManualZOffset

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 294666e356..9505a82dd7 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -61,24 +61,26 @@
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
   // - Raise Z to the "Z after probing" height
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_move) {
-      #if Z_AFTER_PROBING > 0 && DISABLED(MESH_BED_LEVELING)
-        // Display "Done" screen and wait for moves to complete
-        line_to_z(Z_AFTER_PROBING);
-        ui.synchronize(GET_TEXT_F(MSG_LEVEL_BED_DONE));
+      #if DISABLED(MESH_BED_LEVELING) && defined(Z_AFTER_PROBING)
+        if (Z_AFTER_PROBING) {
+          // Display "Done" screen and wait for moves to complete
+          line_to_z(Z_AFTER_PROBING);
+          ui.synchronize(GET_TEXT_F(MSG_LEVEL_BED_DONE));
+        }
       #endif
       ui.goto_previous_screen_no_defer();
       ui.completion_feedback();
     }
     if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT_F(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 

commit 2b3ba02f09832379cffa4fc1baaa055228b82fe8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 18:16:43 2022 -0500

    üîß LEVEL_BED_CORNERS => LCD_BED_TRAMMING

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 142da1696a..294666e356 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -283,21 +283,21 @@ void menu_bed_leveling() {
     #endif
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_BED_Z, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
-  #if ENABLED(LEVEL_BED_CORNERS)
+  #if ENABLED(LCD_BED_TRAMMING)
     SUBMENU(MSG_BED_TRAMMING, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }
 

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 866f709b8e..142da1696a 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -64,26 +64,26 @@
   // - Raise Z to the "Z after probing" height
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_move) {
       #if Z_AFTER_PROBING > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(Z_AFTER_PROBING);
-        ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
+        ui.synchronize(GET_TEXT_F(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
       ui.completion_feedback();
     }
-    if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT(MSG_LEVEL_BED_DONE));
+    if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT_F(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //
   void _lcd_level_bed_get_z() {
 
@@ -120,32 +120,32 @@
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
       const float v = current_position.z;
-      MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+      MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
       sprintf_P(msg, PSTR("%i / %u"), int(manual_probe_index + 1), total_probe_points);
-      MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
+      MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
@@ -158,21 +158,21 @@
       queue.inject(F("G29V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
     if (ui.should_draw()) {
-      MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));
+      MenuItem_static::draw(1, GET_TEXT_F(MSG_LEVEL_BED_WAITING));
       // Color UI needs a control to detect a touch
       #if BOTH(TOUCH_SCREEN, HAS_GRAPHICAL_TFT)
         touch.add_control(CLICK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
       #endif
     }
     if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
@@ -236,30 +236,30 @@
  */
 void menu_bed_leveling() {
   const bool is_homed = all_axes_trusted(),
              is_valid = leveling_is_valid();
 
   START_MENU();
   BACK_ITEM(MSG_MOTION);
 
   // Auto Home if not using manual probing
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
-    if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, G28_STR);
+    if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, FPSTR(G28_STR));
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     SUBMENU(MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
-    GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G29N"));
+    GCODES_ITEM(MSG_LEVEL_BED, is_homed ? F("G29") : F("G29N"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     if (is_valid) SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && is_valid) {
     bool show_state = planner.leveling_active;
     EDIT_ITEM(bool, MSG_BED_LEVELING, &show_state, _lcd_toggle_bed_leveling);

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index f6add52f57..866f709b8e 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -207,21 +207,21 @@
     set_current_from_steppers_for_axis(ALL_AXES_ENUM);
     sync_plan_position();
   }
 
   void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     BACK_ITEM(MSG_BED_LEVELING);
     EDIT_ITEM(uint8, MSG_MESH_X, &xind, 0, (GRID_MAX_POINTS_X) - 1);
     EDIT_ITEM(uint8, MSG_MESH_Y, &yind, 0, (GRID_MAX_POINTS_Y) - 1);
-    EDIT_ITEM_FAST(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
+    EDIT_ITEM_FAST(float43, MSG_MESH_EDIT_Z, &bedlevel.z_values[xind][yind], -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
     END_MENU();
   }
 
 #endif // MESH_EDIT_MENU
 
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion
  *    Auto Home           (if homing needed)
@@ -274,21 +274,21 @@ void menu_bed_leveling() {
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     #if WITHIN(Z_PROBE_OFFSET_RANGE_MIN, -9, 9)
       #define LCD_Z_OFFSET_TYPE float43    // Values from -9.000 to +9.000
     #else
       #define LCD_Z_OFFSET_TYPE float42_52 // Values from -99.99 to 99.99
     #endif
-    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_BED_Z, &mbl.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_BED_Z, &bedlevel.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_BED_TRAMMING, _lcd_level_bed_corners);

commit 1e749e4f48f528179213e736c99371843a90b4fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 20:13:59 2022 -0500

    üßë‚Äçüíª Misc. LCD cleanup

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index a47e2517ae..f6add52f57 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -223,21 +223,21 @@
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion
  *    Auto Home           (if homing needed)
  *    Leveling On/Off     (if data exists, and homed)
  *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
  *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
  *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
  *    Level Bed >
- *    Level Corners >     (if homed)
+ *    Bed Tramming >      (if homed)
  *    Load Settings       (Req: EEPROM_SETTINGS)
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
   const bool is_homed = all_axes_trusted(),
              is_valid = leveling_is_valid();
 
   START_MENU();
   BACK_ITEM(MSG_MOTION);
 

commit a16a059312b0ddb822da2769b5ba5372f9857c48
Author: Giuseppe499 <giuseppe499@live.it>
Date:   Tue Dec 7 02:53:51 2021 +0100

    ‚ú® X Twist Compensation & Calibration (#23238)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index eb286f96b9..a47e2517ae 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -45,22 +45,20 @@
 
 #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
-  static uint8_t manual_probe_index;
-
   // LCD probed points are from defaults
   constexpr uint8_t total_probe_points = TERN(AUTO_BED_LEVELING_3POINT, 3, GRID_MAX_POINTS);
 
   //
   // Bed leveling is done. Wait for G29 to complete.
   // A flag is used so that this can release control
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
   // - Raise Z to the "Z after probing" height

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    üé® Apply F() to G-code suite and queue

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index f01c7899fb..eb286f96b9 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -96,23 +96,23 @@
       //
 
       // If done...
       if (++manual_probe_index >= total_probe_points) {
         //
         // The last G29 records the point and enables bed leveling
         //
         ui.wait_for_move = true;
         ui.goto_screen(_lcd_level_bed_done);
         #if ENABLED(MESH_BED_LEVELING)
-          queue.inject_P(PSTR("G29S2"));
+          queue.inject(F("G29S2"));
         #elif ENABLED(PROBE_MANUALLY)
-          queue.inject_P(PSTR("G29V1"));
+          queue.inject(F("G29V1"));
         #endif
       }
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
@@ -148,23 +148,23 @@
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
 
     // G29 Records Z, moves, and signals when it pauses
     ui.wait_for_move = true;
     #if ENABLED(MESH_BED_LEVELING)
-      queue.inject_P(manual_probe_index ? PSTR("G29S2") : PSTR("G29S1"));
+      queue.inject(manual_probe_index ? F("G29S2") : F("G29S1"));
     #elif ENABLED(PROBE_MANUALLY)
-      queue.inject_P(PSTR("G29V1"));
+      queue.inject(F("G29V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
     if (ui.should_draw()) {
       MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));

commit 885c63c35fdf41bdb91b67266be09cae93910787
Author: borland1 <barryorlando@hotmail.com>
Date:   Wed Jul 28 15:45:32 2021 -0700

    üêõ Fix LCD Menu MBL Z-Offset Adjustment (#22450)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index c03b933014..f01c7899fb 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -271,21 +271,26 @@ void menu_bed_leveling() {
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     // Shadow for editing the fade height
     editable.decimal = planner.z_fade_height;
     EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
-    EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+    #if WITHIN(Z_PROBE_OFFSET_RANGE_MIN, -9, 9)
+      #define LCD_Z_OFFSET_TYPE float43    // Values from -9.000 to +9.000
+    #else
+      #define LCD_Z_OFFSET_TYPE float42_52 // Values from -99.99 to 99.99
+    #endif
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_BED_Z, &mbl.z_offset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_BED_TRAMMING, _lcd_level_bed_corners);

commit b1bc2e80036131cde58b4fbc02b76ac08b5a7924
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 25 02:12:48 2021 -0500

    üåê Level Corners => Bed Tramming

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 62cf8cf1c1..c03b933014 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -281,21 +281,21 @@ void menu_bed_leveling() {
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
-    SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+    SUBMENU(MSG_BED_TRAMMING, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }
 
 #endif // LCD_BED_LEVELING

commit f4951ed56b3fe7b2f85c039677dc9a499d537e8f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:25:54 2021 -0500

    üé® Rename all/no axis enums

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 70de53dab5..62cf8cf1c1 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -199,21 +199,21 @@
     set_all_unhomed();
     ui.goto_screen(_lcd_level_bed_homing);
     queue.inject_P(G28_STR);
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
-    set_current_from_steppers_for_axis(ALL_AXES_MASK);
+    set_current_from_steppers_for_axis(ALL_AXES_ENUM);
     sync_plan_position();
   }
 
   void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     BACK_ITEM(MSG_BED_LEVELING);
     EDIT_ITEM(uint8, MSG_MESH_X, &xind, 0, (GRID_MAX_POINTS_X) - 1);
     EDIT_ITEM(uint8, MSG_MESH_Y, &yind, 0, (GRID_MAX_POINTS_Y) - 1);
     EDIT_ITEM_FAST(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 8e9707de5b..70de53dab5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -199,21 +199,21 @@
     set_all_unhomed();
     ui.goto_screen(_lcd_level_bed_homing);
     queue.inject_P(G28_STR);
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
-    set_current_from_steppers_for_axis(ALL_AXES);
+    set_current_from_steppers_for_axis(ALL_AXES_MASK);
     sync_plan_position();
   }
 
   void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     BACK_ITEM(MSG_BED_LEVELING);
     EDIT_ITEM(uint8, MSG_MESH_X, &xind, 0, (GRID_MAX_POINTS_X) - 1);
     EDIT_ITEM(uint8, MSG_MESH_Y, &yind, 0, (GRID_MAX_POINTS_Y) - 1);
     EDIT_ITEM_FAST(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);

commit a1ee5124d3673077e7812c00f883fca7179b30bd
Author: pinchies <pinchies@gmail.com>
Date:   Sun Apr 25 18:48:20 2021 +1000

    Fix usage, commentary of MANUAL_PROBE_START_Z, Z_AFTER_PROBING (#21692)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 5fc9fbccbd..8e9707de5b 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -56,30 +56,30 @@
 
   // LCD probed points are from defaults
   constexpr uint8_t total_probe_points = TERN(AUTO_BED_LEVELING_3POINT, 3, GRID_MAX_POINTS);
 
   //
   // Bed leveling is done. Wait for G29 to complete.
   // A flag is used so that this can release control
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
-  // - Raise Z to the "manual probe height"
+  // - Raise Z to the "Z after probing" height
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_move) {
-      #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
+      #if Z_AFTER_PROBING > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
-        line_to_z(MANUAL_PROBE_HEIGHT);
+        line_to_z(Z_AFTER_PROBING);
         ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
       ui.completion_feedback();
     }
     if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 6a9f89f118..5fc9fbccbd 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -207,22 +207,22 @@
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }
 
   void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     BACK_ITEM(MSG_BED_LEVELING);
-    EDIT_ITEM(uint8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
-    EDIT_ITEM(uint8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
+    EDIT_ITEM(uint8, MSG_MESH_X, &xind, 0, (GRID_MAX_POINTS_X) - 1);
+    EDIT_ITEM(uint8, MSG_MESH_Y, &yind, 0, (GRID_MAX_POINTS_Y) - 1);
     EDIT_ITEM_FAST(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
     END_MENU();
   }
 
 #endif // MESH_EDIT_MENU
 
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion

commit bb597dcf66ac0baa3f3528bb34c3b4aad78ad520
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 17 12:08:40 2021 -0600

    Internal G29N for G28+G29 (#20800)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 04c2152e61..6a9f89f118 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -247,21 +247,21 @@ void menu_bed_leveling() {
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
     if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, G28_STR);
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     SUBMENU(MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
-    GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
+    GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G29N"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     if (is_valid) SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && is_valid) {
     bool show_state = planner.leveling_active;
     EDIT_ITEM(bool, MSG_BED_LEVELING, &show_state, _lcd_toggle_bed_leveling);

commit fb41413b7614a256302f4bfcdb7ad7bcad50f7a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 16 20:43:24 2021 -0600

    Optimize some G-code strings

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 64dca3b04f..04c2152e61 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -96,23 +96,23 @@
       //
 
       // If done...
       if (++manual_probe_index >= total_probe_points) {
         //
         // The last G29 records the point and enables bed leveling
         //
         ui.wait_for_move = true;
         ui.goto_screen(_lcd_level_bed_done);
         #if ENABLED(MESH_BED_LEVELING)
-          queue.inject_P(PSTR("G29 S2"));
+          queue.inject_P(PSTR("G29S2"));
         #elif ENABLED(PROBE_MANUALLY)
-          queue.inject_P(PSTR("G29 V1"));
+          queue.inject_P(PSTR("G29V1"));
         #endif
       }
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
@@ -148,23 +148,23 @@
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
 
     // G29 Records Z, moves, and signals when it pauses
     ui.wait_for_move = true;
     #if ENABLED(MESH_BED_LEVELING)
-      queue.inject_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
+      queue.inject_P(manual_probe_index ? PSTR("G29S2") : PSTR("G29S1"));
     #elif ENABLED(PROBE_MANUALLY)
-      queue.inject_P(PSTR("G29 V1"));
+      queue.inject_P(PSTR("G29V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
     if (ui.should_draw()) {
       MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index d089b2125a..64dca3b04f 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -230,21 +230,21 @@
  *    Leveling On/Off     (if data exists, and homed)
  *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
  *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
  *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
  *    Level Bed >
  *    Level Corners >     (if homed)
  *    Load Settings       (Req: EEPROM_SETTINGS)
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
-  const bool is_homed = all_axes_known(),
+  const bool is_homed = all_axes_trusted(),
              is_valid = leveling_is_valid();
 
   START_MENU();
   BACK_ITEM(MSG_MOTION);
 
   // Auto Home if not using manual probing
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
     if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, G28_STR);
   #endif
 

commit 75924edcf8e129e90119b86ec8a61176bff12c95
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 17 23:07:34 2020 -0300

    COLOR_UI without TOUCH_SCREEN üëçüèª (#20178)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 905d7a07cd..d089b2125a 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -162,21 +162,23 @@
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
     if (ui.should_draw()) {
       MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));
       // Color UI needs a control to detect a touch
-      TERN_(HAS_GRAPHICAL_TFT, touch.add_control(CLICK, 0, 0, TFT_WIDTH, TFT_HEIGHT));
+      #if BOTH(TOUCH_SCREEN, HAS_GRAPHICAL_TFT)
+        touch.add_control(CLICK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
+      #endif
     }
     if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
 
   //
   // Step 3: Display "Homing XYZ" - Wait for homing to finish
   //

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index e19b04ccb5..905d7a07cd 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -30,22 +30,24 @@
 
 #include "menu_item.h"
 #include "../../module/planner.h"
 #include "../../feature/bedlevel/bedlevel.h"
 
 #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/probe.h"
 #endif
 
 #if HAS_GRAPHICAL_TFT
-  #include "../tft/touch.h"
   #include "../tft/tft.h"
+  #if ENABLED(TOUCH_SCREEN)
+    #include "../tft/touch.h"
+  #endif
 #endif
 
 #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //

commit c650b752f19040d3ee199b7c3c173d2dbe574da1
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Wed Oct 7 20:01:01 2020 +0200

    More accessible PROBE_OFFSET_WIZARD (#19647)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 8bc4f92131..e19b04ccb5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -276,24 +276,20 @@ void menu_bed_leveling() {
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
-  #if ENABLED(PROBE_OFFSET_WIZARD)
-    SUBMENU(MSG_PROBE_WIZARD, goto_probe_offset_wizard);
-  #endif
-
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }

commit 343441d7465fb637f0c2627060b7003a0d0fc25c
Author: Mathew Winters <mathew@winters.org.nz>
Date:   Mon Oct 5 18:31:20 2020 +1300

    Z Probe Offset Wizard (#18866)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index e19b04ccb5..8bc4f92131 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -276,20 +276,24 @@ void menu_bed_leveling() {
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
+  #if ENABLED(PROBE_OFFSET_WIZARD)
+    SUBMENU(MSG_PROBE_WIZARD, goto_probe_offset_wizard);
+  #endif
+
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }

commit a7f5d38da7d6e57d5cfac9358eb13e57fac61db1
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Sep 25 21:58:45 2020 -0300

    Fix MBL "Click to continue" on Color UI touchscreen (#19514)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 6841561c1b..e19b04ccb5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -29,20 +29,25 @@
 #if ENABLED(LCD_BED_LEVELING)
 
 #include "menu_item.h"
 #include "../../module/planner.h"
 #include "../../feature/bedlevel/bedlevel.h"
 
 #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/probe.h"
 #endif
 
+#if HAS_GRAPHICAL_TFT
+  #include "../tft/touch.h"
+  #include "../tft/tft.h"
+#endif
+
 #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
   static uint8_t manual_probe_index;
@@ -152,21 +157,25 @@
     #elif ENABLED(PROBE_MANUALLY)
       queue.inject_P(PSTR("G29 V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
-    if (ui.should_draw()) MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));
+    if (ui.should_draw()) {
+      MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));
+      // Color UI needs a control to detect a touch
+      TERN_(HAS_GRAPHICAL_TFT, touch.add_control(CLICK, 0, 0, TFT_WIDTH, TFT_HEIGHT));
+    }
     if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
 
   //
   // Step 3: Display "Homing XYZ" - Wait for homing to finish
   //
   void _lcd_level_bed_homing() {

commit 4f67642122059a9270f9e3690978248355f88e72
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 21 05:21:34 2020 -0500

    Header for individual menus

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 3796f44ff6..6841561c1b 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -21,21 +21,21 @@
  */
 
 //
 // Bed Leveling Menus
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(LCD_BED_LEVELING)
 
-#include "menu.h"
+#include "menu_item.h"
 #include "../../module/planner.h"
 #include "../../feature/bedlevel/bedlevel.h"
 
 #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/probe.h"
 #endif
 
 #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index fc13ab8031..3796f44ff6 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 //
 // Bed Leveling Menus
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(LCD_BED_LEVELING)

commit 52aa459a2dc08a8f803ad9ffb7aa173dc449637f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 10 00:12:56 2020 -0500

    Improved EEPROM boot error (#17916)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 5192c596da..fc13ab8031 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -272,17 +272,17 @@ void menu_bed_leveling() {
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
-    ACTION_ITEM(MSG_LOAD_EEPROM, lcd_load_settings);
-    ACTION_ITEM(MSG_STORE_EEPROM, lcd_store_settings);
+    ACTION_ITEM(MSG_LOAD_EEPROM, ui.load_settings);
+    ACTION_ITEM(MSG_STORE_EEPROM, ui.store_settings);
   #endif
   END_MENU();
 }
 
 #endif // LCD_BED_LEVELING

commit e8b0796fc70d06f59cb217dbe11a2ad695243ad1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 29 14:52:42 2020 -0500

    Revert menu_item_if ahead of refactor

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 2592f26649..5192c596da 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -249,25 +249,23 @@ void menu_bed_leveling() {
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && is_valid) {
     bool show_state = planner.leveling_active;
     EDIT_ITEM(bool, MSG_BED_LEVELING, &show_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    MENU_ITEM_IF (1) {
-      // Shadow for editing the fade height
-      editable.decimal = planner.z_fade_height;
-      EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
-    }
+    // Shadow for editing the fade height
+    editable.decimal = planner.z_fade_height;
+    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit 4f003fc7a715830da7324da2c90f8411df3b1efc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 27 23:52:11 2020 -0500

    Streamline menu item logic (#17664)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index fa7d099d15..2592f26649 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -217,55 +217,57 @@
  *    Leveling On/Off     (if data exists, and homed)
  *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
  *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
  *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
  *    Level Bed >
  *    Level Corners >     (if homed)
  *    Load Settings       (Req: EEPROM_SETTINGS)
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
+  const bool is_homed = all_axes_known(),
+             is_valid = leveling_is_valid();
+
   START_MENU();
   BACK_ITEM(MSG_MOTION);
 
-  const bool is_homed = all_axes_known();
-
   // Auto Home if not using manual probing
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
     if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, G28_STR);
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     SUBMENU(MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
-    if (leveling_is_valid())
-      SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
+    if (is_valid) SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
-  if (is_homed && leveling_is_valid()) {
+  if (is_homed && is_valid) {
     bool show_state = planner.leveling_active;
     EDIT_ITEM(bool, MSG_BED_LEVELING, &show_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    // Shadow for editing the fade height
-    editable.decimal = planner.z_fade_height;
-    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
+    MENU_ITEM_IF (1) {
+      // Shadow for editing the fade height
+      editable.decimal = planner.z_fade_height;
+      EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
+    }
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit 69f211cf78c1b25469fbd1f6e4c28e0aa6dd6b0a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 15:14:32 2020 -0500

    Add empty ui.completion_feedback

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 54a9cb5c23..fa7d099d15 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -41,48 +41,42 @@
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
   static uint8_t manual_probe_index;
 
   // LCD probed points are from defaults
-  constexpr uint8_t total_probe_points = (
-    #if ENABLED(AUTO_BED_LEVELING_3POINT)
-      3
-    #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
-      GRID_MAX_POINTS
-    #endif
-  );
+  constexpr uint8_t total_probe_points = TERN(AUTO_BED_LEVELING_3POINT, 3, GRID_MAX_POINTS);
 
   //
   // Bed leveling is done. Wait for G29 to complete.
   // A flag is used so that this can release control
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
   // - Raise Z to the "manual probe height"
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_move) {
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
         ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
-      TERN_(HAS_BUZZER, ui.completion_feedback());
+      ui.completion_feedback();
     }
     if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 5834b73ba4..54a9cb5c23 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -68,23 +68,21 @@
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_move) {
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
         ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
-      #if HAS_BUZZER
-        ui.completion_feedback();
-      #endif
+      TERN_(HAS_BUZZER, ui.completion_feedback());
     }
     if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index d16d4670a8..5834b73ba4 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 6cc40cab6c..d16d4670a8 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -272,21 +272,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe_offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe.offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, lcd_load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit 95d5a0c480d655bf96a6989ad3df0f240ae343b2
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Jan 25 22:02:06 2020 -0800

    Fix DELTA_CALIBRATION_MENU recursive call (#16656)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 753aa3d5e1..6cc40cab6c 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -49,35 +49,33 @@
 
   // LCD probed points are from defaults
   constexpr uint8_t total_probe_points = (
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       3
     #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
       GRID_MAX_POINTS
     #endif
   );
 
-  bool MarlinUI::wait_for_bl_move; // = false
-
   //
   // Bed leveling is done. Wait for G29 to complete.
   // A flag is used so that this can release control
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
   // - Raise Z to the "manual probe height"
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
-    if (!ui.wait_for_bl_move) {
+    if (!ui.wait_for_move) {
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
         ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
       #if HAS_BUZZER
         ui.completion_feedback();
       #endif
     }
@@ -96,21 +94,21 @@
 
       //
       // Save the current Z position and move
       //
 
       // If done...
       if (++manual_probe_index >= total_probe_points) {
         //
         // The last G29 records the point and enables bed leveling
         //
-        ui.wait_for_bl_move = true;
+        ui.wait_for_move = true;
         ui.goto_screen(_lcd_level_bed_done);
         #if ENABLED(MESH_BED_LEVELING)
           queue.inject_P(PSTR("G29 S2"));
         #elif ENABLED(PROBE_MANUALLY)
           queue.inject_P(PSTR("G29 V1"));
         #endif
       }
       else
         _lcd_level_goto_next_point();
 
@@ -139,31 +137,31 @@
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
       sprintf_P(msg, PSTR("%i / %u"), int(manual_probe_index + 1), total_probe_points);
       MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
-    if (!ui.wait_for_bl_move) ui.goto_screen(_lcd_level_bed_get_z);
+    if (!ui.wait_for_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
 
     // G29 Records Z, moves, and signals when it pauses
-    ui.wait_for_bl_move = true;
+    ui.wait_for_move = true;
     #if ENABLED(MESH_BED_LEVELING)
       queue.inject_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
     #elif ENABLED(PROBE_MANUALLY)
       queue.inject_P(PSTR("G29 V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position

commit d129ac1b37b96a48f7c4cb87ca3f71e7b5e783bc
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jan 2 21:40:40 2020 -0500

    Z-offset edit precision based on value limits (#16425)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index f4fbf59a42..753aa3d5e1 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -274,21 +274,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    EDIT_ITEM(float52, MSG_ZPROBE_ZOFFSET, &probe_offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(LCD_Z_OFFSET_TYPE, MSG_ZPROBE_ZOFFSET, &probe_offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     ACTION_ITEM(MSG_LOAD_EEPROM, lcd_load_settings);
     ACTION_ITEM(MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit 27cb4db80eae73eb842f1a944260517bb8783eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 14 20:30:30 2019 -0600

    Reduced string storage using tokens (#15593)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 892bb0d1d5..f4fbf59a42 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -125,32 +125,32 @@
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
       const float v = current_position.z;
-      MenuEditItemBase::edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+      MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
       sprintf_P(msg, PSTR("%i / %u"), int(manual_probe_index + 1), total_probe_points);
-      MenuEditItemBase::edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
+      MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_bl_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);

commit ea3217cd4613d723567d9bc8ab375e68d75b294b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 2 07:28:20 2019 -0500

    Move 'draw' methods into Menu Item classes (#15760)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index f53c10f331..892bb0d1d5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -74,21 +74,21 @@
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
         ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
       #if HAS_BUZZER
         ui.completion_feedback();
       #endif
     }
-    if (ui.should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, GET_TEXT(MSG_LEVEL_BED_DONE));
+    if (ui.should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, GET_TEXT(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //
   void _lcd_level_bed_get_z() {
 
@@ -125,32 +125,32 @@
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
       const float v = current_position.z;
-      draw_edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+      MenuEditItemBase::edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
       sprintf_P(msg, PSTR("%i / %u"), int(manual_probe_index + 1), total_probe_points);
-      draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
+      MenuEditItemBase::edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_bl_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
@@ -162,21 +162,21 @@
     #elif ENABLED(PROBE_MANUALLY)
       queue.inject_P(PSTR("G29 V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
-    if (ui.should_draw()) draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_WAITING));
+    if (ui.should_draw()) MenuItem_static::draw(1, GET_TEXT(MSG_LEVEL_BED_WAITING));
     if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
 
   //
   // Step 3: Display "Homing XYZ" - Wait for homing to finish
   //
   void _lcd_level_bed_homing() {

commit ca6d00b862049773135a9ef8d04d042f0af7f9d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 1 23:51:25 2019 -0500

    Save some string flash

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index bd5a96663e..f53c10f331 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -188,21 +188,21 @@
     extern bool g29_in_progress;
   #endif
 
   //
   // Step 2: Continue Bed Leveling...
   //
   void _lcd_level_bed_continue() {
     ui.defer_status_screen();
     set_all_unhomed();
     ui.goto_screen(_lcd_level_bed_homing);
-    queue.inject_P(PSTR("G28"));
+    queue.inject_P(G28_STR);
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }
@@ -234,21 +234,21 @@
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
   START_MENU();
   BACK_ITEM(MSG_MOTION);
 
   const bool is_homed = all_axes_known();
 
   // Auto Home if not using manual probing
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
-    if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, PSTR("G28"));
+    if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, G28_STR);
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     SUBMENU(MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif

commit 23d21dd81c0c634046108e40f50fa09e3503a5dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 2 00:05:05 2019 -0500

    Tweak lambdas

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 603338a433..bd5a96663e 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -261,21 +261,21 @@ void menu_bed_leveling() {
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && leveling_is_valid()) {
     bool show_state = planner.leveling_active;
     EDIT_ITEM(bool, MSG_BED_LEVELING, &show_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     // Shadow for editing the fade height
     editable.decimal = planner.z_fade_height;
-    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, [](){ set_z_fade_height(editable.decimal); });
+    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, []{ set_z_fade_height(editable.decimal); });
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit f00b48f9a8da77d0d603b74c843359b82ee306e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 21 18:34:29 2019 -0500

    Expand encoder value range

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 1318e2307e..603338a433 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -114,42 +114,42 @@
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
     //
     if (ui.encoderPosition) {
-      const float z = current_position.z + float(int16_t(ui.encoderPosition)) * (MESH_EDIT_Z_STEP);
+      const float z = current_position.z + float(int32_t(ui.encoderPosition)) * (MESH_EDIT_Z_STEP);
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
       const float v = current_position.z;
       draw_edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
-      sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
+      sprintf_P(msg, PSTR("%i / %u"), int(manual_probe_index + 1), total_probe_points);
       draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_bl_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index ba03477735..1318e2307e 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -67,28 +67,28 @@
   // - Raise Z to the "manual probe height"
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_bl_move) {
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
-        ui.synchronize(PSTR(MSG_LEVEL_BED_DONE));
+        ui.synchronize(GET_TEXT(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
       #if HAS_BUZZER
         ui.completion_feedback();
       #endif
     }
-    if (ui.should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
+    if (ui.should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, GET_TEXT(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //
   void _lcd_level_bed_get_z() {
 
@@ -125,32 +125,32 @@
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
       const float v = current_position.z;
-      draw_edit_screen(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+      draw_edit_screen(GET_TEXT(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
       sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
-      draw_edit_screen(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+      draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
     ui.refresh(LCDVIEW_CALL_NO_REDRAW);
     if (!ui.wait_for_bl_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
@@ -162,21 +162,21 @@
     #elif ENABLED(PROBE_MANUALLY)
       queue.inject_P(PSTR("G29 V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
-    if (ui.should_draw()) draw_edit_screen(PSTR(MSG_LEVEL_BED_WAITING));
+    if (ui.should_draw()) draw_edit_screen(GET_TEXT(MSG_LEVEL_BED_WAITING));
     if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
 
   //
   // Step 3: Display "Homing XYZ" - Wait for homing to finish
   //
   void _lcd_level_bed_homing() {

commit cc822c1a0513362e28f1b3aff76d4c4c06446f01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 19:44:33 2019 -0500

    Use lambdas in menus, where possible (#15452)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 320a25c5e1..ba03477735 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -253,27 +253,29 @@ void menu_bed_leveling() {
     GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     if (leveling_is_valid())
       SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && leveling_is_valid()) {
-    bool new_level_state = planner.leveling_active;
-    EDIT_ITEM(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+    bool show_state = planner.leveling_active;
+    EDIT_ITEM(bool, MSG_BED_LEVELING, &show_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
+    // Shadow for editing the fade height
+    editable.decimal = planner.z_fade_height;
+    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &editable.decimal, 0, 100, [](){ set_z_fade_height(editable.decimal); });
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit 273cbe931e868554bf6782881443ccbf5fdd4208
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 3 05:38:30 2019 -0500

    Aliases for common menu item types

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 3155a3418c..320a25c5e1 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -203,24 +203,24 @@
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }
 
   void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
-    MENU_BACK(MSG_BED_LEVELING);
-    MENU_ITEM_EDIT(uint8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
-    MENU_ITEM_EDIT(uint8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
+    BACK_ITEM(MSG_BED_LEVELING);
+    EDIT_ITEM(uint8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
+    EDIT_ITEM(uint8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
+    EDIT_ITEM_FAST(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
     END_MENU();
   }
 
 #endif // MESH_EDIT_MENU
 
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion
  *    Auto Home           (if homing needed)
@@ -228,69 +228,69 @@
  *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
  *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
  *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
  *    Level Bed >
  *    Level Corners >     (if homed)
  *    Load Settings       (Req: EEPROM_SETTINGS)
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
   START_MENU();
-  MENU_BACK(MSG_MOTION);
+  BACK_ITEM(MSG_MOTION);
 
   const bool is_homed = all_axes_known();
 
   // Auto Home if not using manual probing
   #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
-    if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+    if (!is_homed) GCODES_ITEM(MSG_AUTO_HOME, PSTR("G28"));
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
-    MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
+    SUBMENU(MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
-    MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
+    GCODES_ITEM(MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     if (leveling_is_valid())
-      MENU_ITEM(submenu, MSG_EDIT_MESH, menu_edit_mesh);
+      SUBMENU(MSG_EDIT_MESH, menu_edit_mesh);
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && leveling_is_valid()) {
     bool new_level_state = planner.leveling_active;
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+    EDIT_ITEM(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
+    EDIT_ITEM_FAST(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
   #endif
 
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
-    MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+    EDIT_ITEM(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-    MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+    SUBMENU(MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &probe_offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    EDIT_ITEM(float52, MSG_ZPROBE_ZOFFSET, &probe_offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
-    MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+    SUBMENU(MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
-    MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-    MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+    ACTION_ITEM(MSG_LOAD_EEPROM, lcd_load_settings);
+    ACTION_ITEM(MSG_STORE_EEPROM, lcd_store_settings);
   #endif
   END_MENU();
 }
 
 #endif // LCD_BED_LEVELING

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index bb4eaa8456..3155a3418c 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -114,31 +114,31 @@
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
     //
     if (ui.encoderPosition) {
-      const float z = current_position[Z_AXIS] + float(int16_t(ui.encoderPosition)) * (MESH_EDIT_Z_STEP);
+      const float z = current_position.z + float(int16_t(ui.encoderPosition)) * (MESH_EDIT_Z_STEP);
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
-      const float v = current_position[Z_AXIS];
+      const float v = current_position.z;
       draw_edit_screen(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
     if (ui.should_draw()) {
       char msg[10];
@@ -272,21 +272,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &probe_offset[Z_AXIS], Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &probe_offset.z, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 33073fc81a..bb4eaa8456 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -272,21 +272,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_offset[Z_AXIS], Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &probe_offset[Z_AXIS], Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 3f1f746af1..33073fc81a 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -272,21 +272,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_offset[Z_AXIS], Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit c4bb458763c810f29025fc6b2c5829022ed509c7
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Jul 29 02:14:50 2019 +0200

    BUZZ cleanup (#14760)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 70a04e2de0..3f1f746af1 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -70,21 +70,23 @@
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
     if (!ui.wait_for_bl_move) {
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
         ui.synchronize(PSTR(MSG_LEVEL_BED_DONE));
       #endif
       ui.goto_previous_screen_no_defer();
-      ui.completion_feedback();
+      #if HAS_BUZZER
+        ui.completion_feedback();
+      #endif
     }
     if (ui.should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //

commit c9aa68ef7aa358bb633b6d87232a94bfa6b7d7c8
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Jul 18 07:41:15 2019 +0700

    Encoder direction: Wrangle, Revert select screen change (#14628)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index c463faa910..70a04e2de0 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -82,21 +82,20 @@
     if (ui.should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
     ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //
   void _lcd_level_bed_get_z() {
-    ui.encoder_direction_normal();
 
     if (ui.use_click()) {
 
       //
       // Save the current Z position and move
       //
 
       // If done...
       if (++manual_probe_index >= total_probe_points) {
         //

commit fe0224104498a42a3921b97ef3902581fba6c309
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:20:15 2019 -0500

    NONE on combined options

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index cd98f21a65..c463faa910 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -232,21 +232,21 @@
  *    Load Settings       (Req: EEPROM_SETTINGS)
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
   START_MENU();
   MENU_BACK(MSG_MOTION);
 
   const bool is_homed = all_axes_known();
 
   // Auto Home if not using manual probing
-  #if DISABLED(PROBE_MANUALLY, MESH_BED_LEVELING)
+  #if NONE(PROBE_MANUALLY, MESH_BED_LEVELING)
     if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 0d534d86ee..cd98f21a65 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index e8107aa58a..0d534d86ee 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -98,23 +98,23 @@
       //
 
       // If done...
       if (++manual_probe_index >= total_probe_points) {
         //
         // The last G29 records the point and enables bed leveling
         //
         ui.wait_for_bl_move = true;
         ui.goto_screen(_lcd_level_bed_done);
         #if ENABLED(MESH_BED_LEVELING)
-          enqueue_and_echo_commands_P(PSTR("G29 S2"));
+          queue.inject_P(PSTR("G29 S2"));
         #elif ENABLED(PROBE_MANUALLY)
-          enqueue_and_echo_commands_P(PSTR("G29 V1"));
+          queue.inject_P(PSTR("G29 V1"));
         #endif
       }
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
@@ -150,23 +150,23 @@
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
     ui.goto_screen(_lcd_level_bed_moving);
 
     // G29 Records Z, moves, and signals when it pauses
     ui.wait_for_bl_move = true;
     #if ENABLED(MESH_BED_LEVELING)
-      enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
+      queue.inject_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
     #elif ENABLED(PROBE_MANUALLY)
-      enqueue_and_echo_commands_P(PSTR("G29 V1"));
+      queue.inject_P(PSTR("G29 V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
     if (ui.should_draw()) draw_edit_screen(PSTR(MSG_LEVEL_BED_WAITING));
     if (ui.use_click()) {
@@ -187,21 +187,21 @@
     extern bool g29_in_progress;
   #endif
 
   //
   // Step 2: Continue Bed Leveling...
   //
   void _lcd_level_bed_continue() {
     ui.defer_status_screen();
     set_all_unhomed();
     ui.goto_screen(_lcd_level_bed_homing);
-    enqueue_and_echo_commands_P(PSTR("G28"));
+    queue.inject_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }

commit 991ee7552b01330afadac37a4d8009e6aaa07892
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 11 19:44:35 2019 -0400

    Restore menu edit to 32bit value (#13976)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 4a4445fb74..e8107aa58a 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -271,21 +271,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52sign, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit 3f758d9e007cedeaabf6c7c501f4817266bc5ff9
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu May 9 19:28:47 2019 -0400

    Fix some edit items for 16-bit encoder (#13948)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index e8107aa58a..4a4445fb74 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -271,21 +271,21 @@ void menu_bed_leveling() {
   //
   // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    MENU_ITEM_EDIT(float52sign, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif

commit 321a5e65805f51e6817ff51db448dc5d8f28c900
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 21:10:41 2019 -0500

    Fix SD card reselect when scrolled (#13624)
    
    - Change encoder position to 16-bit integer.
    - Fix `SD_REPRINT_LAST_SELECTED_FILE` when the screen is scrolled.

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 3e2508647e..e8107aa58a 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -113,21 +113,21 @@
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
     //
     if (ui.encoderPosition) {
-      const float z = current_position[Z_AXIS] + float((int32_t)ui.encoderPosition) * (MESH_EDIT_Z_STEP);
+      const float z = current_position[Z_AXIS] + float(int16_t(ui.encoderPosition)) * (MESH_EDIT_Z_STEP);
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (ui.should_draw()) {
       const float v = current_position[Z_AXIS];

commit d8329d858d7d2c2b2a9107f99df39a93816c0841
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 23 16:30:43 2019 -0500

    Default argument to defer_status_screen

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 5a9f0cf1e7..3e2508647e 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -184,21 +184,21 @@
   }
 
   #if ENABLED(PROBE_MANUALLY)
     extern bool g29_in_progress;
   #endif
 
   //
   // Step 2: Continue Bed Leveling...
   //
   void _lcd_level_bed_continue() {
-    ui.defer_status_screen(true);
+    ui.defer_status_screen();
     set_all_unhomed();
     ui.goto_screen(_lcd_level_bed_homing);
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {

commit b376c7e374bbbc2cb69b6009c619f923f42f84b3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:50:06 2019 -0500

    Group DISABLED items

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 177cae19a9..5a9f0cf1e7 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -232,21 +232,21 @@
  *    Load Settings       (Req: EEPROM_SETTINGS)
  *    Save Settings       (Req: EEPROM_SETTINGS)
  */
 void menu_bed_leveling() {
   START_MENU();
   MENU_BACK(MSG_MOTION);
 
   const bool is_homed = all_axes_known();
 
   // Auto Home if not using manual probing
-  #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
+  #if DISABLED(PROBE_MANUALLY, MESH_BED_LEVELING)
     if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
   #endif
 
   // Level Bed
   #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index d3d04d45a5..177cae19a9 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -29,21 +29,21 @@
 #if ENABLED(LCD_BED_LEVELING)
 
 #include "menu.h"
 #include "../../module/planner.h"
 #include "../../feature/bedlevel/bedlevel.h"
 
 #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/probe.h"
 #endif
 
-#if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
+#if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
   static uint8_t manual_probe_index;
 
@@ -237,21 +237,21 @@ void menu_bed_leveling() {
   MENU_BACK(MSG_MOTION);
 
   const bool is_homed = all_axes_known();
 
   // Auto Home if not using manual probing
   #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
     if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
   #endif
 
   // Level Bed
-  #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
+  #if EITHER(PROBE_MANUALLY, MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     if (leveling_is_valid())
       MENU_ITEM(submenu, MSG_EDIT_MESH, menu_edit_mesh);

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 4af8866dd9..d3d04d45a5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit acf266fe781d6d4bdad7beeb387b70c24cf2e213
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jan 20 01:47:29 2019 +0100

    Fix a compile warning, etc. (#12955)

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 40c51b5726..4af8866dd9 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -203,22 +203,22 @@
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }
 
   void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     MENU_BACK(MSG_BED_LEVELING);
-    MENU_ITEM_EDIT(int8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
-    MENU_ITEM_EDIT(int8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
+    MENU_ITEM_EDIT(uint8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
+    MENU_ITEM_EDIT(uint8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
     MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
     END_MENU();
   }
 
 #endif // MESH_EDIT_MENU
 
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index ae43ca12b4..40c51b5726 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 //
 // Bed Leveling Menus
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_LCD_MENU && ENABLED(LCD_BED_LEVELING)
+#if ENABLED(LCD_BED_LEVELING)
 
 #include "menu.h"
 #include "../../module/planner.h"
 #include "../../feature/bedlevel/bedlevel.h"
 
 #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/probe.h"
 #endif
 
 #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
@@ -49,158 +49,158 @@
 
   // LCD probed points are from defaults
   constexpr uint8_t total_probe_points = (
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       3
     #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
       GRID_MAX_POINTS
     #endif
   );
 
-  bool lcd_wait_for_move;
+  bool MarlinUI::wait_for_bl_move; // = false
 
   //
   // Bed leveling is done. Wait for G29 to complete.
   // A flag is used so that this can release control
   // and allow the command queue to be processed.
   //
   // When G29 finishes the last move:
   // - Raise Z to the "manual probe height"
   // - Don't return until done.
   //
   // ** This blocks the command queue! **
   //
   void _lcd_level_bed_done() {
-    if (!lcd_wait_for_move) {
+    if (!ui.wait_for_bl_move) {
       #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
         // Display "Done" screen and wait for moves to complete
         line_to_z(MANUAL_PROBE_HEIGHT);
-        lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
+        ui.synchronize(PSTR(MSG_LEVEL_BED_DONE));
       #endif
-      lcd_goto_previous_menu_no_defer();
-      lcd_completion_feedback();
+      ui.goto_previous_screen_no_defer();
+      ui.completion_feedback();
     }
-    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
-    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+    if (ui.should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
+    ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
   }
 
   void _lcd_level_goto_next_point();
 
   //
   // Step 7: Get the Z coordinate, click goes to the next point or exits
   //
   void _lcd_level_bed_get_z() {
-    ENCODER_DIRECTION_NORMAL();
+    ui.encoder_direction_normal();
 
-    if (use_click()) {
+    if (ui.use_click()) {
 
       //
       // Save the current Z position and move
       //
 
       // If done...
       if (++manual_probe_index >= total_probe_points) {
         //
         // The last G29 records the point and enables bed leveling
         //
-        lcd_wait_for_move = true;
-        lcd_goto_screen(_lcd_level_bed_done);
+        ui.wait_for_bl_move = true;
+        ui.goto_screen(_lcd_level_bed_done);
         #if ENABLED(MESH_BED_LEVELING)
           enqueue_and_echo_commands_P(PSTR("G29 S2"));
         #elif ENABLED(PROBE_MANUALLY)
           enqueue_and_echo_commands_P(PSTR("G29 V1"));
         #endif
       }
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
     //
-    if (encoderPosition) {
-      const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MESH_EDIT_Z_STEP);
+    if (ui.encoderPosition) {
+      const float z = current_position[Z_AXIS] + float((int32_t)ui.encoderPosition) * (MESH_EDIT_Z_STEP);
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      encoderPosition = 0;
+      ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
+      ui.encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
-    if (lcdDrawUpdate) {
+    if (ui.should_draw()) {
       const float v = current_position[Z_AXIS];
-      lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+      draw_edit_screen(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
     }
   }
 
   //
   // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
   //
   void _lcd_level_bed_moving() {
-    if (lcdDrawUpdate) {
+    if (ui.should_draw()) {
       char msg[10];
       sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
-      lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+      draw_edit_screen(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
     }
-    lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-    if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
+    ui.refresh(LCDVIEW_CALL_NO_REDRAW);
+    if (!ui.wait_for_bl_move) ui.goto_screen(_lcd_level_bed_get_z);
   }
 
   //
   // Step 5: Initiate a move to the next point
   //
   void _lcd_level_goto_next_point() {
-    lcd_goto_screen(_lcd_level_bed_moving);
+    ui.goto_screen(_lcd_level_bed_moving);
 
     // G29 Records Z, moves, and signals when it pauses
-    lcd_wait_for_move = true;
+    ui.wait_for_bl_move = true;
     #if ENABLED(MESH_BED_LEVELING)
       enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
     #elif ENABLED(PROBE_MANUALLY)
       enqueue_and_echo_commands_P(PSTR("G29 V1"));
     #endif
   }
 
   //
   // Step 4: Display "Click to Begin", wait for click
   //         Move to the first probe position
   //
   void _lcd_level_bed_homing_done() {
-    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
-    if (use_click()) {
+    if (ui.should_draw()) draw_edit_screen(PSTR(MSG_LEVEL_BED_WAITING));
+    if (ui.use_click()) {
       manual_probe_index = 0;
       _lcd_level_goto_next_point();
     }
   }
 
   //
   // Step 3: Display "Homing XYZ" - Wait for homing to finish
   //
   void _lcd_level_bed_homing() {
     _lcd_draw_homing();
-    if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
+    if (all_axes_homed()) ui.goto_screen(_lcd_level_bed_homing_done);
   }
 
   #if ENABLED(PROBE_MANUALLY)
     extern bool g29_in_progress;
   #endif
 
   //
   // Step 2: Continue Bed Leveling...
   //
   void _lcd_level_bed_continue() {
-    set_defer_return_to_status(true);
+    ui.defer_status_screen(true);
     set_all_unhomed();
-    lcd_goto_screen(_lcd_level_bed_homing);
+    ui.goto_screen(_lcd_level_bed_homing);
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
@@ -285,11 +285,11 @@ void menu_bed_leveling() {
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif
   END_MENU();
 }
 
-#endif // HAS_LCD_MENU && LCD_BED_LEVELING
+#endif // LCD_BED_LEVELING

commit e574f015680f88137b2ccb0fa159ebd5749c26fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 6 19:25:57 2018 -0600

    More advanced pause tweaks (#12356)
    
    * Followup to LCD_TIMEOUT_TO_STATUS=0
    * Make continuous purge screen fit 20x4
    * Unify purge message modes
    * Preserve last-set pause header mode

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 9d51151fe9..ae43ca12b4 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -184,21 +184,21 @@
   }
 
   #if ENABLED(PROBE_MANUALLY)
     extern bool g29_in_progress;
   #endif
 
   //
   // Step 2: Continue Bed Leveling...
   //
   void _lcd_level_bed_continue() {
-    defer_return_to_status = true;
+    set_defer_return_to_status(true);
     set_all_unhomed();
     lcd_goto_screen(_lcd_level_bed_homing);
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {

commit 93d5b945dd56a6632395522f6c049e942e4b0166
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 5 05:12:56 2018 -0600

    Hide mesh editing until a valid mesh exists

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 69bb2e8fa6..9d51151fe9 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -199,21 +199,21 @@
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(MESH_EDIT_MENU)
 
   inline void refresh_planner() {
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }
 
-  void menu_mbl_edit_mesh() {
+  void menu_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     MENU_BACK(MSG_BED_LEVELING);
     MENU_ITEM_EDIT(int8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
     MENU_ITEM_EDIT(int8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
     MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
     END_MENU();
   }
 
 #endif // MESH_EDIT_MENU
@@ -246,21 +246,22 @@ void menu_bed_leveling() {
   // Level Bed
   #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
-    MENU_ITEM(submenu, MSG_EDIT_MESH, menu_mbl_edit_mesh);
+    if (leveling_is_valid())
+      MENU_ITEM(submenu, MSG_EDIT_MESH, menu_edit_mesh);
   #endif
 
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && leveling_is_valid()) {
     bool new_level_state = planner.leveling_active;
     MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)

commit fed84f2961f76c5fe3f8d767dcf3fa6ef68049f5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 5 00:46:05 2018 -0600

    Use multiplier edit item for mesh point editing

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index b95aa5148c..69bb2e8fa6 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -205,21 +205,21 @@
     set_current_from_steppers_for_axis(ALL_AXES);
     sync_plan_position();
   }
 
   void menu_mbl_edit_mesh() {
     static uint8_t xind, yind; // =0
     START_MENU();
     MENU_BACK(MSG_BED_LEVELING);
     MENU_ITEM_EDIT(int8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
     MENU_ITEM_EDIT(int8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
-    MENU_ITEM_EDIT_CALLBACK(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
     END_MENU();
   }
 
 #endif // MESH_EDIT_MENU
 
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion
  *    Auto Home           (if homing needed)

commit 82ff7c65425ec468e241291ddde0eeb133c703f4
Author: KangDroid <hyunwoo286@gmail.com>
Date:   Wed Jun 6 11:57:25 2018 +0900

    Add a mesh edit menu for MBL / ABL-Bilinear

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 98b1063ea5..b95aa5148c 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -113,21 +113,21 @@
       else
         _lcd_level_goto_next_point();
 
       return;
     }
 
     //
     // Encoder knob or keypad buttons adjust the Z position
     //
     if (encoderPosition) {
-      const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
+      const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MESH_EDIT_Z_STEP);
       line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       encoderPosition = 0;
     }
 
     //
     // Draw on first display, then only on Z change
     //
     if (lcdDrawUpdate) {
       const float v = current_position[Z_AXIS];
@@ -192,20 +192,39 @@
   //
   void _lcd_level_bed_continue() {
     defer_return_to_status = true;
     set_all_unhomed();
     lcd_goto_screen(_lcd_level_bed_homing);
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
+#if ENABLED(MESH_EDIT_MENU)
+
+  inline void refresh_planner() {
+    set_current_from_steppers_for_axis(ALL_AXES);
+    sync_plan_position();
+  }
+
+  void menu_mbl_edit_mesh() {
+    static uint8_t xind, yind; // =0
+    START_MENU();
+    MENU_BACK(MSG_BED_LEVELING);
+    MENU_ITEM_EDIT(int8, MSG_MESH_X, &xind, 0, GRID_MAX_POINTS_X - 1);
+    MENU_ITEM_EDIT(int8, MSG_MESH_Y, &yind, 0, GRID_MAX_POINTS_Y - 1);
+    MENU_ITEM_EDIT_CALLBACK(float43, MSG_MESH_EDIT_Z, &Z_VALUES(xind, yind), -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5, refresh_planner);
+    END_MENU();
+  }
+
+#endif // MESH_EDIT_MENU
+
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion
  *    Auto Home           (if homing needed)
  *    Leveling On/Off     (if data exists, and homed)
  *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
  *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
  *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
  *    Level Bed >
@@ -226,33 +245,37 @@ void menu_bed_leveling() {
 
   // Level Bed
   #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
     // Manual leveling uses a guided procedure
     MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
   #else
     // Automatic leveling can just run the G-code
     MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
   #endif
 
+  #if ENABLED(MESH_EDIT_MENU)
+    MENU_ITEM(submenu, MSG_EDIT_MESH, menu_mbl_edit_mesh);
+  #endif
+
   // Homed and leveling is valid? Then leveling can be toggled.
   if (is_homed && leveling_is_valid()) {
     bool new_level_state = planner.leveling_active;
     MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
   }
 
   // Z Fade Height
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
   #endif
 
   //
-  // MBL Z Offset
+  // Mesh Bed Leveling Z-Offset
   //
   #if ENABLED(MESH_BED_LEVELING)
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif

commit 9f77df25900c22181de1170c4c81f10b4c1b885e
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Thu Nov 1 22:13:33 2018 +0100

    Followup to menu refactor. TMC warnings, sanity. (#12288)
    
    - Followup fixes for menu refactor
    - Fix TMC sanity checks, unused var warnings

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 9e1496a558..98b1063ea5 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -25,20 +25,24 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_LCD_MENU && ENABLED(LCD_BED_LEVELING)
 
 #include "menu.h"
 #include "../../module/planner.h"
 #include "../../feature/bedlevel/bedlevel.h"
 
+#if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
+  #include "../../module/probe.h"
+#endif
+
 #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
 
   #include "../../module/motion.h"
   #include "../../gcode/queue.h"
 
   //
   // Motion > Level Bed handlers
   //
 
   static uint8_t manual_probe_index;

commit 2cff0d1f39061e2309510da0dbc8b21975f965c6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 17:08:21 2018 -0500

    Move menu_level_bed_corners to its own file

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 2e7f7c4f3a..9e1496a558 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -188,91 +188,20 @@
   //
   void _lcd_level_bed_continue() {
     defer_return_to_status = true;
     set_all_unhomed();
     lcd_goto_screen(_lcd_level_bed_homing);
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
-#if ENABLED(LEVEL_BED_CORNERS)
-
-  /**
-   * Level corners, starting in the front-left corner.
-   */
-  static int8_t bed_corner;
-  void _lcd_goto_next_corner() {
-    line_to_z(4.0);
-    switch (bed_corner) {
-      case 0:
-        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
-        current_position[Y_AXIS] = Y_MIN_BED + LEVEL_CORNERS_INSET;
-        break;
-      case 1:
-        current_position[X_AXIS] = X_MAX_BED - LEVEL_CORNERS_INSET;
-        break;
-      case 2:
-        current_position[Y_AXIS] = Y_MAX_BED - LEVEL_CORNERS_INSET;
-        break;
-      case 3:
-        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
-        break;
-      #if ENABLED(LEVEL_CENTER_TOO)
-        case 4:
-          current_position[X_AXIS] = X_CENTER;
-          current_position[Y_AXIS] = Y_CENTER;
-          break;
-      #endif
-    }
-    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
-    line_to_z(0.0);
-    if (++bed_corner > 3
-      #if ENABLED(LEVEL_CENTER_TOO)
-        + 1
-      #endif
-    ) bed_corner = 0;
-  }
-
-  void _lcd_corner_submenu() {
-    START_MENU();
-    MENU_ITEM(function,
-      #if ENABLED(LEVEL_CENTER_TOO)
-        MSG_LEVEL_BED_NEXT_POINT
-      #else
-        MSG_NEXT_CORNER
-      #endif
-      , _lcd_goto_next_corner);
-    MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
-    END_MENU();
-  }
-
-  void _lcd_level_bed_corners_homing() {
-    _lcd_draw_homing();
-    if (all_axes_homed()) {
-      bed_corner = 0;
-      lcd_goto_screen(_lcd_corner_submenu);
-      _lcd_goto_next_corner();
-    }
-  }
-
-  void _lcd_level_bed_corners() {
-    defer_return_to_status = true;
-    if (!all_axes_known()) {
-      axis_homed = 0;
-      enqueue_and_echo_commands_P(PSTR("G28"));
-    }
-    lcd_goto_screen(_lcd_level_bed_corners_homing);
-  }
-
-#endif // LEVEL_BED_CORNERS
-
 /**
  * Step 1: Bed Level entry-point
  *
  * << Motion
  *    Auto Home           (if homing needed)
  *    Leveling On/Off     (if data exists, and homed)
  *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
  *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
  *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
  *    Level Bed >
@@ -318,21 +247,20 @@ void menu_bed_leveling() {
     MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
   #endif
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
   #elif HAS_BED_PROBE
     MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
-    // Move to the next corner for leveling
     MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
   #endif
   END_MENU();
 }
 

commit 44f2a82a567333312c3d85f72176f437bafc9625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 17:07:52 2018 -0500

    Move axis_homed, axis_known_position to motion.*

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
index 5c172b6cf6..2e7f7c4f3a 100644
--- a/Marlin/src/lcd/menu/menu_bed_leveling.cpp
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -181,21 +181,21 @@
 
   #if ENABLED(PROBE_MANUALLY)
     extern bool g29_in_progress;
   #endif
 
   //
   // Step 2: Continue Bed Leveling...
   //
   void _lcd_level_bed_continue() {
     defer_return_to_status = true;
-    axis_homed = 0;
+    set_all_unhomed();
     lcd_goto_screen(_lcd_level_bed_homing);
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
 #endif // PROBE_MANUALLY || MESH_BED_LEVELING
 
 #if ENABLED(LEVEL_BED_CORNERS)
 
   /**
    * Level corners, starting in the front-left corner.

commit 587a64d80c5e9c87614f2fdb8a8b3973283e1226
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 19:48:37 2018 -0500

    Move Bed Leveling Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu_bed_leveling.cpp b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
new file mode 100644
index 0000000000..5c172b6cf6
--- /dev/null
+++ b/Marlin/src/lcd/menu/menu_bed_leveling.cpp
@@ -0,0 +1,339 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+//
+// Bed Leveling Menus
+//
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_LCD_MENU && ENABLED(LCD_BED_LEVELING)
+
+#include "menu.h"
+#include "../../module/planner.h"
+#include "../../feature/bedlevel/bedlevel.h"
+
+#if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
+
+  #include "../../module/motion.h"
+  #include "../../gcode/queue.h"
+
+  //
+  // Motion > Level Bed handlers
+  //
+
+  static uint8_t manual_probe_index;
+
+  // LCD probed points are from defaults
+  constexpr uint8_t total_probe_points = (
+    #if ENABLED(AUTO_BED_LEVELING_3POINT)
+      3
+    #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
+      GRID_MAX_POINTS
+    #endif
+  );
+
+  bool lcd_wait_for_move;
+
+  //
+  // Bed leveling is done. Wait for G29 to complete.
+  // A flag is used so that this can release control
+  // and allow the command queue to be processed.
+  //
+  // When G29 finishes the last move:
+  // - Raise Z to the "manual probe height"
+  // - Don't return until done.
+  //
+  // ** This blocks the command queue! **
+  //
+  void _lcd_level_bed_done() {
+    if (!lcd_wait_for_move) {
+      #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
+        // Display "Done" screen and wait for moves to complete
+        line_to_z(MANUAL_PROBE_HEIGHT);
+        lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
+      #endif
+      lcd_goto_previous_menu_no_defer();
+      lcd_completion_feedback();
+    }
+    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
+    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+  }
+
+  void _lcd_level_goto_next_point();
+
+  //
+  // Step 7: Get the Z coordinate, click goes to the next point or exits
+  //
+  void _lcd_level_bed_get_z() {
+    ENCODER_DIRECTION_NORMAL();
+
+    if (use_click()) {
+
+      //
+      // Save the current Z position and move
+      //
+
+      // If done...
+      if (++manual_probe_index >= total_probe_points) {
+        //
+        // The last G29 records the point and enables bed leveling
+        //
+        lcd_wait_for_move = true;
+        lcd_goto_screen(_lcd_level_bed_done);
+        #if ENABLED(MESH_BED_LEVELING)
+          enqueue_and_echo_commands_P(PSTR("G29 S2"));
+        #elif ENABLED(PROBE_MANUALLY)
+          enqueue_and_echo_commands_P(PSTR("G29 V1"));
+        #endif
+      }
+      else
+        _lcd_level_goto_next_point();
+
+      return;
+    }
+
+    //
+    // Encoder knob or keypad buttons adjust the Z position
+    //
+    if (encoderPosition) {
+      const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
+      line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      encoderPosition = 0;
+    }
+
+    //
+    // Draw on first display, then only on Z change
+    //
+    if (lcdDrawUpdate) {
+      const float v = current_position[Z_AXIS];
+      lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+    }
+  }
+
+  //
+  // Step 6: Display "Next point: 1 / 9" while waiting for move to finish
+  //
+  void _lcd_level_bed_moving() {
+    if (lcdDrawUpdate) {
+      char msg[10];
+      sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
+      lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+    }
+    lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+    if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
+  }
+
+  //
+  // Step 5: Initiate a move to the next point
+  //
+  void _lcd_level_goto_next_point() {
+    lcd_goto_screen(_lcd_level_bed_moving);
+
+    // G29 Records Z, moves, and signals when it pauses
+    lcd_wait_for_move = true;
+    #if ENABLED(MESH_BED_LEVELING)
+      enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
+    #elif ENABLED(PROBE_MANUALLY)
+      enqueue_and_echo_commands_P(PSTR("G29 V1"));
+    #endif
+  }
+
+  //
+  // Step 4: Display "Click to Begin", wait for click
+  //         Move to the first probe position
+  //
+  void _lcd_level_bed_homing_done() {
+    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
+    if (use_click()) {
+      manual_probe_index = 0;
+      _lcd_level_goto_next_point();
+    }
+  }
+
+  //
+  // Step 3: Display "Homing XYZ" - Wait for homing to finish
+  //
+  void _lcd_level_bed_homing() {
+    _lcd_draw_homing();
+    if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
+  }
+
+  #if ENABLED(PROBE_MANUALLY)
+    extern bool g29_in_progress;
+  #endif
+
+  //
+  // Step 2: Continue Bed Leveling...
+  //
+  void _lcd_level_bed_continue() {
+    defer_return_to_status = true;
+    axis_homed = 0;
+    lcd_goto_screen(_lcd_level_bed_homing);
+    enqueue_and_echo_commands_P(PSTR("G28"));
+  }
+
+#endif // PROBE_MANUALLY || MESH_BED_LEVELING
+
+#if ENABLED(LEVEL_BED_CORNERS)
+
+  /**
+   * Level corners, starting in the front-left corner.
+   */
+  static int8_t bed_corner;
+  void _lcd_goto_next_corner() {
+    line_to_z(4.0);
+    switch (bed_corner) {
+      case 0:
+        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
+        current_position[Y_AXIS] = Y_MIN_BED + LEVEL_CORNERS_INSET;
+        break;
+      case 1:
+        current_position[X_AXIS] = X_MAX_BED - LEVEL_CORNERS_INSET;
+        break;
+      case 2:
+        current_position[Y_AXIS] = Y_MAX_BED - LEVEL_CORNERS_INSET;
+        break;
+      case 3:
+        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
+        break;
+      #if ENABLED(LEVEL_CENTER_TOO)
+        case 4:
+          current_position[X_AXIS] = X_CENTER;
+          current_position[Y_AXIS] = Y_CENTER;
+          break;
+      #endif
+    }
+    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
+    line_to_z(0.0);
+    if (++bed_corner > 3
+      #if ENABLED(LEVEL_CENTER_TOO)
+        + 1
+      #endif
+    ) bed_corner = 0;
+  }
+
+  void _lcd_corner_submenu() {
+    START_MENU();
+    MENU_ITEM(function,
+      #if ENABLED(LEVEL_CENTER_TOO)
+        MSG_LEVEL_BED_NEXT_POINT
+      #else
+        MSG_NEXT_CORNER
+      #endif
+      , _lcd_goto_next_corner);
+    MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
+    END_MENU();
+  }
+
+  void _lcd_level_bed_corners_homing() {
+    _lcd_draw_homing();
+    if (all_axes_homed()) {
+      bed_corner = 0;
+      lcd_goto_screen(_lcd_corner_submenu);
+      _lcd_goto_next_corner();
+    }
+  }
+
+  void _lcd_level_bed_corners() {
+    defer_return_to_status = true;
+    if (!all_axes_known()) {
+      axis_homed = 0;
+      enqueue_and_echo_commands_P(PSTR("G28"));
+    }
+    lcd_goto_screen(_lcd_level_bed_corners_homing);
+  }
+
+#endif // LEVEL_BED_CORNERS
+
+/**
+ * Step 1: Bed Level entry-point
+ *
+ * << Motion
+ *    Auto Home           (if homing needed)
+ *    Leveling On/Off     (if data exists, and homed)
+ *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
+ *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
+ *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
+ *    Level Bed >
+ *    Level Corners >     (if homed)
+ *    Load Settings       (Req: EEPROM_SETTINGS)
+ *    Save Settings       (Req: EEPROM_SETTINGS)
+ */
+void menu_bed_leveling() {
+  START_MENU();
+  MENU_BACK(MSG_MOTION);
+
+  const bool is_homed = all_axes_known();
+
+  // Auto Home if not using manual probing
+  #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
+    if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+  #endif
+
+  // Level Bed
+  #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
+    // Manual leveling uses a guided procedure
+    MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
+  #else
+    // Automatic leveling can just run the G-code
+    MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
+  #endif
+
+  // Homed and leveling is valid? Then leveling can be toggled.
+  if (is_homed && leveling_is_valid()) {
+    bool new_level_state = planner.leveling_active;
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+  }
+
+  // Z Fade Height
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
+  #endif
+
+  //
+  // MBL Z Offset
+  //
+  #if ENABLED(MESH_BED_LEVELING)
+    MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+  #endif
+
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+    MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+  #elif HAS_BED_PROBE
+    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+  #endif
+
+  #if ENABLED(LEVEL_BED_CORNERS)
+    // Move to the next corner for leveling
+    MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+  #endif
+
+  #if ENABLED(EEPROM_SETTINGS)
+    MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+    MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+  #endif
+  END_MENU();
+}
+
+#endif // HAS_LCD_MENU && LCD_BED_LEVELING
