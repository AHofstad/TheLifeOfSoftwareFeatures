commit 5334a8f0ed9af2ad3c09ab492d6cd44119981bc5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 15 13:59:19 2024 -0500

    🚸 Fix UI behavior for G29 with retry (#27146)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index d97fc48906..6ff09b3a7a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -63,28 +63,35 @@
     #define PR_INNER_VAR  abl.meshCount.y
     #define PR_INNER_SIZE abl.grid_points.y
   #else
     #define PR_OUTER_VAR  abl.meshCount.y
     #define PR_OUTER_SIZE abl.grid_points.y
     #define PR_INNER_VAR  abl.meshCount.x
     #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
+/**
+ * @brief Do some things before returning from G29.
+ * @param retry : true if the G29 can and should be retried. false if the failure is too serious.
+ * @param   did : true if the leveling procedure completed successfully.
+ */
 static void pre_g29_return(const bool retry, const bool did) {
   if (!retry) {
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false));
   }
-  if (did) {
-    TERN_(DWIN_CREALITY_LCD, dwinLevelingDone());
-    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
-  }
+  #if DISABLED(G29_RETRY_AND_RECOVER)
+    if (!retry || did) {
+      TERN_(DWIN_CREALITY_LCD, dwinLevelingDone());
+      TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
+    }
+  #endif
 }
 
 #define G29_RETURN(retry, did) do{ \
   pre_g29_return(TERN0(G29_RETRY_AND_RECOVER, retry), did); \
   return TERN_(G29_RETRY_AND_RECOVER, retry); \
 }while(0)
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:

commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    🩹 Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 449c25fefd..d97fc48906 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -676,21 +676,21 @@ G29_TYPE GcodeSuite::G29() {
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
           if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT_F(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
           #if ENABLED(BD_SENSOR_PROBE_NO_STOP)
             if (PR_INNER_VAR == inStart) {
               char tmp_1[32];
 
               // move to the start point of new line
               abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
               // Go to the end of the row/column ... and back up by one
               // TODO: Why not just use... PR_INNER_VAR = inStop - inInc
               for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc);
@@ -775,21 +775,21 @@ G29_TYPE GcodeSuite::G29() {
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing point ", i + 1, "/3.");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_POINT), int(i + 1)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT_F(MSG_PROBING_POINT), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = xy_pos_t(points[i]);
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
         if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
       }

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    🚸 Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 3126bee47f..449c25fefd 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -44,22 +44,20 @@
 #endif
 #if ENABLED(BD_SENSOR_PROBE_NO_STOP)
   #include "../../../feature/bedlevel/bdl/bdl.h"
 #endif
 
 #include "../../../lcd/marlinui.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_LCD_PROUI)
-  #include "../../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
     #define PR_OUTER_SIZE abl.grid_points.x
     #define PR_INNER_VAR  abl.meshCount.y
@@ -70,21 +68,21 @@
     #define PR_INNER_VAR  abl.meshCount.x
     #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
 static void pre_g29_return(const bool retry, const bool did) {
   if (!retry) {
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false));
   }
   if (did) {
-    TERN_(HAS_DWIN_E3V2_BASIC, dwinLevelingDone());
+    TERN_(DWIN_CREALITY_LCD, dwinLevelingDone());
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
   }
 }
 
 #define G29_RETURN(retry, did) do{ \
   pre_g29_return(TERN0(G29_RETRY_AND_RECOVER, retry), did); \
   return TERN_(G29_RETRY_AND_RECOVER, retry); \
 }while(0)
 
 // For manual probing values persist over multiple G29
@@ -418,36 +416,30 @@ G29_TYPE GcodeSuite::G29() {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
-    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      TERN_(DWIN_LCD_PROUI, dwinLevelingStart());
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP,
-          #if ALL(DWIN_LCD_PROUI, HAS_HEATED_BED)
-            hmiData.bedLevT
-          #else
-            LEVELING_BED_TEMP
-          #endif
+          TERN(EXTENSIBLE_UI, ExtUI::getLevelingBedTemp(), LEVELING_BED_TEMP)
         );
       #endif
     }
 
     // Position bed horizontally and Z probe vertically.
     #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
         safe_position.x = SAFE_BED_LEVELING_START_X;
       #endif

commit 669814d0d408a622f020a55971ba04030e4fa4bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 23:40:54 2024 -0600

    ✨ MARLIN_SMALL_BUILD option (#26775)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 1ca3826c81..3126bee47f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -337,46 +337,46 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
     // Jettison bed leveling data
     if (!seen_w && parser.seen_test('J')) {
       reset_bed_level();
       G29_RETURN(false, false);
     }
 
     abl.verbose_level = parser.intval('V');
     if (!WITHIN(abl.verbose_level, 0, 4)) {
-      SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
+      SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(V)erbose level implausible (0-4)."));
       G29_RETURN(false, false);
     }
 
     abl.dryrun = parser.boolval('D') || TERN0(PROBE_MANUALLY, no_action);
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       incremental_LSF_reset(&lsf_results);
 
       abl.topography_map = abl.verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl.grid_points.set(
         parser.byteval('X', GRID_MAX_POINTS_X),
         parser.byteval('Y', GRID_MAX_POINTS_Y)
       );
       if (parser.seenval('P')) abl.grid_points.x = abl.grid_points.y = parser.value_int();
 
       if (!WITHIN(abl.grid_points.x, 2, GRID_MAX_POINTS_X)) {
-        SERIAL_ECHOLNPGM("?Probe points (X) implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("Probe points (X) implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ")."));
         G29_RETURN(false, false);
       }
       if (!WITHIN(abl.grid_points.y, 2, GRID_MAX_POINTS_Y)) {
-        SERIAL_ECHOLNPGM("?Probe points (Y) implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("Probe points (Y) implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ")."));
         G29_RETURN(false, false);
       }
 
       abl.abl_points = abl.grid_points.x * abl.grid_points.y;
       abl.mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       abl.Z_offset = parser.linearval('Z');
 
@@ -397,21 +397,21 @@ G29_TYPE GcodeSuite::G29() {
       else {
         abl.probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
         abl.probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
       }
 
       if (!probe.good_bounds(abl.probe_position_lf, abl.probe_position_rb)) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("G29 L", abl.probe_position_lf.x, " R", abl.probe_position_rb.x,
                              " F", abl.probe_position_lf.y, " B", abl.probe_position_rb.y);
         }
-        SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG(" (L,R,F,B) out of bounds."));
         G29_RETURN(false, false);
       }
 
       // Probe at the points of a lattice grid
       abl.gridSpacing.set((abl.probe_position_rb.x - abl.probe_position_lf.x) / (abl.grid_points.x - 1),
                           (abl.probe_position_rb.y - abl.probe_position_lf.y) / (abl.grid_points.y - 1));
 
     #endif // ABL_USES_GRID
 
     if (abl.verbose_level > 0) {

commit f4eafed188189d2a77c53a2a68bd931ee838b584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 7 21:59:25 2024 -0600

    🔧 Z_PROBE_END_SCRIPT => EVENT_GCODE_AFTER_G29

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 700562df81..1ca3826c81 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -980,24 +980,24 @@ G29_TYPE GcodeSuite::G29() {
 
     #endif
 
   } // !isnan(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
-  #ifdef Z_PROBE_END_SCRIPT
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+  #ifdef EVENT_GCODE_AFTER_G29
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", EVENT_GCODE_AFTER_G29);
     planner.synchronize();
-    process_subcommands_now(F(Z_PROBE_END_SCRIPT));
+    process_subcommands_now(F(EVENT_GCODE_AFTER_G29));
   #endif
 
   probe.use_probing_tool(false);
 
   report_current_position();
 
   G29_RETURN(isnan(abl.measured_z), true);
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 52693f72afca243ace00a7a57365301f5f8c42c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 4 13:01:45 2024 -0600

    🎨 Clean up some checks & includes

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index acd920c729..700562df81 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -48,24 +48,20 @@
 
 #include "../../../lcd/marlinui.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../../lcd/e3v2/proui/dwin.h"
 #endif
 
-#if HAS_MULTI_HOTEND
-  #include "../../../module/tool_change.h"
-#endif
-
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
     #define PR_OUTER_SIZE abl.grid_points.x
     #define PR_INNER_VAR  abl.meshCount.y
     #define PR_INNER_SIZE abl.grid_points.y
   #else

commit 67d7562609986fae14d80036ad1e7a7f3aaa49d0
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Wed Dec 20 02:56:47 2023 +0100

    🐛⚡️ FT_MOTION improvements (#26074)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index d6d648c125..acd920c729 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -218,20 +218,21 @@ public:
  *  Y  Y for mesh point, overrides J
  *  Z  Z for mesh point. Otherwise, raw current Z.
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  */
 G29_TYPE GcodeSuite::G29() {
+
   DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
 
   // Leveling state is persistent when done manually with multiple G29 commands
   TERN_(PROBE_MANUALLY, static) G29_State abl;
 
   // Keep powered steppers from timing out
   reset_stepper_timeout();
 
   // Q = Query leveling and G29 state
   const bool seenQ = ANY(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');

commit ffef8f1b297e83aa37eeb5ffcc5369e5c9c42a09
Author: Mark <niujl123@sina.com>
Date:   Mon Aug 7 12:33:20 2023 +0800

    🚸 BD Sensor Z axis stop height (#26015)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5ecb6af66c..d6d648c125 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -741,20 +741,21 @@ G29_TYPE GcodeSuite::G29() {
             constexpr AxisEnum axis = TERN(PROBE_Y_FIRST, Y_AXIS, X_AXIS);
             const float cmp = abl.probePos[axis] - probe.offset_xy[axis];
             float pos;
             for (;;) {
               pos = planner.get_axis_position_mm(axis);
               if (inInc > 0 ? (pos >= cmp) : (pos <= cmp)) break;
               idle_no_sleep();
             }
             //if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM_P(axis == Y_AXIS ? PSTR("Y=") : PSTR("X=", pos);
 
+            safe_delay(4);
             abl.measured_z = current_position.z - bdl.read();
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("x_cur ", planner.get_axis_position_mm(X_AXIS), " z ", abl.measured_z);
 
           #else // !BD_SENSOR_PROBE_NO_STOP
 
             abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           #endif
 
           if (isnan(abl.measured_z)) {

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    🎨 Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5632c6e467..5ecb6af66c 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -422,32 +422,32 @@ G29_TYPE GcodeSuite::G29() {
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      TERN_(DWIN_LCD_PROUI, DWIN_LevelingStart());
+      TERN_(DWIN_LCD_PROUI, dwinLevelingStart());
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP,
           #if ALL(DWIN_LCD_PROUI, HAS_HEATED_BED)
-            HMI_data.BedLevT
+            hmiData.bedLevT
           #else
             LEVELING_BED_TEMP
           #endif
         );
       #endif
     }
 
     // Position bed horizontally and Z probe vertically.
     #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;

commit 441416728cd7f0e9b6ebf94f895d1d27fe59d25a
Author: Mark <niujl123@sina.com>
Date:   Sun Jun 18 17:18:08 2023 +0800

    🚸 Bed distance sensor improvements (#25847)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 4b2d21bc81..5632c6e467 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -35,20 +35,23 @@
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
+#if ENABLED(BD_SENSOR_PROBE_NO_STOP)
+  #include "../../../feature/bedlevel/bdl/bdl.h"
+#endif
 
 #include "../../../lcd/marlinui.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../../lcd/e3v2/proui/dwin.h"
 #endif
 
@@ -686,21 +689,80 @@ G29_TYPE GcodeSuite::G29() {
           abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
           if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
-          abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
+          #if ENABLED(BD_SENSOR_PROBE_NO_STOP)
+            if (PR_INNER_VAR == inStart) {
+              char tmp_1[32];
+
+              // move to the start point of new line
+              abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
+              // Go to the end of the row/column ... and back up by one
+              // TODO: Why not just use... PR_INNER_VAR = inStop - inInc
+              for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc);
+              PR_INNER_VAR -= inInc;
+
+              // Get the coordinate of the resulting grid point
+              abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
+
+              // Coordinate that puts the probe at the grid point
+              abl.probePos -= probe.offset_xy;
+
+              // Put a G1 move into the buffer
+              // TODO: Instead of G1, we can just add the move directly to the planner...
+              //  {
+              //  destination = current_position; destination = abl.probePos;
+              //  REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
+              //  prepare_line_to_destination();
+              //  }
+              sprintf_P(tmp_1, PSTR("G1X%d.%d Y%d.%d F%d"),
+                int(abl.probePos.x), int(abl.probePos.x * 10) % 10,
+                int(abl.probePos.y), int(abl.probePos.y * 10) % 10,
+                XY_PROBE_FEEDRATE
+              );
+              gcode.process_subcommands_now(tmp_1);
+
+              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("destX: ", abl.probePos.x, " Y:", abl.probePos.y);
+
+              // Reset the inner counter back to the start
+              PR_INNER_VAR = inStart;
+
+              // Get the coordinate of the start of the row/column
+              abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
+            }
+
+            // Wait around until the real axis position reaches the comparison point
+            // TODO: Use NEAR() because float is imprecise
+            constexpr AxisEnum axis = TERN(PROBE_Y_FIRST, Y_AXIS, X_AXIS);
+            const float cmp = abl.probePos[axis] - probe.offset_xy[axis];
+            float pos;
+            for (;;) {
+              pos = planner.get_axis_position_mm(axis);
+              if (inInc > 0 ? (pos >= cmp) : (pos <= cmp)) break;
+              idle_no_sleep();
+            }
+            //if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM_P(axis == Y_AXIS ? PSTR("Y=") : PSTR("X=", pos);
+
+            abl.measured_z = current_position.z - bdl.read();
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("x_cur ", planner.get_axis_position_mm(X_AXIS), " z ", abl.measured_z);
+
+          #else // !BD_SENSOR_PROBE_NO_STOP
+
+            abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
+
+          #endif
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             abl.mean += abl.measured_z;
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;

commit 41a5fbb16ad985220f1cee1b823950c3bb771186
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:12:01 2023 -0500

    🎨 More lowercase
    
    Followup to #25939

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 3b669fbba2..4b2d21bc81 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -71,21 +71,21 @@
     #define PR_INNER_VAR  abl.meshCount.x
     #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
 static void pre_g29_return(const bool retry, const bool did) {
   if (!retry) {
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false));
   }
   if (did) {
-    TERN_(HAS_DWIN_E3V2_BASIC, DWIN_LevelingDone());
+    TERN_(HAS_DWIN_E3V2_BASIC, dwinLevelingDone());
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
   }
 }
 
 #define G29_RETURN(retry, did) do{ \
   pre_g29_return(TERN0(G29_RETRY_AND_RECOVER, retry), did); \
   return TERN_(G29_RETRY_AND_RECOVER, retry); \
 }while(0)
 
 // For manual probing values persist over multiple G29

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ♻️ Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ca02fc9765..3b669fbba2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -810,52 +810,52 @@ G29_TYPE GcodeSuite::G29() {
       struct { float a, b, d; } plane_equation_coefficients;
 
       finish_incremental_LSF(&lsf_results);
       plane_equation_coefficients.a = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
       plane_equation_coefficients.b = -lsf_results.B;  // but that is not yet tested.
       plane_equation_coefficients.d = -lsf_results.D;
 
       abl.mean /= abl.abl_points;
 
       if (abl.verbose_level) {
-        SERIAL_ECHOPAIR_F("Eqn coefficients: a: ", plane_equation_coefficients.a, 8);
-        SERIAL_ECHOPAIR_F(" b: ", plane_equation_coefficients.b, 8);
-        SERIAL_ECHOPAIR_F(" d: ", plane_equation_coefficients.d, 8);
+        SERIAL_ECHOPGM("Eqn coefficients: a: ", p_float_t(plane_equation_coefficients.a, 8),
+                                        " b: ", p_float_t(plane_equation_coefficients.b, 8),
+                                        " d: ", p_float_t(plane_equation_coefficients.d, 8));
         if (abl.verbose_level > 2)
-          SERIAL_ECHOPAIR_F("\nMean of sampled points: ", abl.mean, 8);
+          SERIAL_ECHOPGM("\nMean of sampled points: ", p_float_t(abl.mean, 8));
         SERIAL_EOL();
       }
 
       // Create the matrix but don't correct the position yet
       if (!abl.dryrun)
         planner.bed_level_matrix = matrix_3x3::create_look_at(
           vector_3(-plane_equation_coefficients.a, -plane_equation_coefficients.b, 1)    // We can eliminate the '-' here and up above
         );
 
       // Show the Topography map if enabled
       if (abl.topography_map) {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](FSTR_P const title, const bool get_min) {
-          SERIAL_ECHOF(title);
+          SERIAL_ECHO(title);
           for (int8_t yy = abl.grid_points.y - 1; yy >= 0; yy--) {
             for (uint8_t xx = 0; xx < abl.grid_points.x; ++xx) {
               const int ind = abl.indexIntoAB[xx][yy];
               xyz_float_t tmp = { abl.eqnAMatrix[ind + 0 * abl.abl_points],
                                   abl.eqnAMatrix[ind + 1 * abl.abl_points], 0 };
               planner.bed_level_matrix.apply_rotation_xyz(tmp.x, tmp.y, tmp.z);
               if (get_min) NOMORE(min_diff, abl.eqnBVector[ind] - tmp.z);
               const float subval = get_min ? abl.mean : tmp.z + min_diff,
                             diff = abl.eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
-              SERIAL_ECHO_F(diff, 5);
+              SERIAL_ECHO(p_float_t(diff, 5));
             } // xx
             SERIAL_EOL();
           } // yy
           SERIAL_EOL();
         };
 
         print_topo_map(F("\nBed Height Topography:\n"
                            "   +--- BACK --+\n"
                            "   |           |\n"
                            " L |    (+)    | R\n"

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    🧑‍💻 Remove LOOP macros (#25917)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5c86f4b991..ca02fc9765 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -721,21 +721,21 @@ G29_TYPE GcodeSuite::G29() {
           abl.reenable = false; // Don't re-enable after modifying the mesh
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
-      LOOP_L_N(i, 3) {
+      for (uint8_t i = 0; i < 3; ++i) {
         if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing point ", i + 1, "/3.");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_POINT), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = xy_pos_t(points[i]);
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
         if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
@@ -832,21 +832,21 @@ G29_TYPE GcodeSuite::G29() {
         );
 
       // Show the Topography map if enabled
       if (abl.topography_map) {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](FSTR_P const title, const bool get_min) {
           SERIAL_ECHOF(title);
           for (int8_t yy = abl.grid_points.y - 1; yy >= 0; yy--) {
-            LOOP_L_N(xx, abl.grid_points.x) {
+            for (uint8_t xx = 0; xx < abl.grid_points.x; ++xx) {
               const int ind = abl.indexIntoAB[xx][yy];
               xyz_float_t tmp = { abl.eqnAMatrix[ind + 0 * abl.abl_points],
                                   abl.eqnAMatrix[ind + 1 * abl.abl_points], 0 };
               planner.bed_level_matrix.apply_rotation_xyz(tmp.x, tmp.y, tmp.z);
               if (get_min) NOMORE(min_diff, abl.eqnBVector[ind] - tmp.z);
               const float subval = get_min ? abl.mean : tmp.z + min_diff,
                             diff = abl.eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
               SERIAL_ECHO_F(diff, 5);
             } // xx

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    🧑‍💻 Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 1fe4a31bee..5c86f4b991 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -90,21 +90,21 @@ static void pre_g29_return(const bool retry, const bool did) {
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
             reenable;
 
-  #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
+  #if ANY(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     int abl_probe_index;
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     grid_count_t abl_points;
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
     static constexpr grid_count_t abl_points = 3;
   #elif ABL_USES_GRID
     static constexpr grid_count_t abl_points = GRID_MAX_POINTS;
   #endif
@@ -132,21 +132,21 @@ public:
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       float eqnAMatrix[GRID_MAX_POINTS * 3],  // "A" matrix of the linear system of equations
             eqnBVector[GRID_MAX_POINTS],      // "B" vector of Z points
             mean;
     #endif
   #endif
 };
 
-#if ABL_USES_GRID && EITHER(AUTO_BED_LEVELING_3POINT, AUTO_BED_LEVELING_BILINEAR)
+#if ABL_USES_GRID && ANY(AUTO_BED_LEVELING_3POINT, AUTO_BED_LEVELING_BILINEAR)
   constexpr xy_uint8_t G29_State::grid_points;
   constexpr grid_count_t G29_State::abl_points;
 #endif
 
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
@@ -224,21 +224,21 @@ public:
 G29_TYPE GcodeSuite::G29() {
   DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
 
   // Leveling state is persistent when done manually with multiple G29 commands
   TERN_(PROBE_MANUALLY, static) G29_State abl;
 
   // Keep powered steppers from timing out
   reset_stepper_timeout();
 
   // Q = Query leveling and G29 state
-  const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');
+  const bool seenQ = ANY(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (seenQ || DEBUGGING(LEVELING)) log_machine_info();
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false, false);
   #endif
 
   // A = Abort manual probing
   // C<bool> = Generate fake probe points (DEBUG_LEVELING_FEATURE)
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen_test('A')),
@@ -272,21 +272,21 @@ G29_TYPE GcodeSuite::G29() {
   // Set and report "probing" state to host
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE, false));
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     probe.use_probing_tool();
 
-    #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
+    #if ANY(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl.abl_probe_index = -1;
     #endif
 
     abl.reenable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen_test('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
@@ -429,21 +429,21 @@ G29_TYPE GcodeSuite::G29() {
       TERN_(DWIN_LCD_PROUI, DWIN_LevelingStart());
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP,
-          #if BOTH(DWIN_LCD_PROUI, HAS_HEATED_BED)
+          #if ALL(DWIN_LCD_PROUI, HAS_HEATED_BED)
             HMI_data.BedLevT
           #else
             LEVELING_BED_TEMP
           #endif
         );
       #endif
     }
 
     // Position bed horizontally and Z probe vertically.
     #if HAS_SAFE_BED_LEVELING
@@ -477,21 +477,21 @@ G29_TYPE GcodeSuite::G29() {
       #endif
 
       do_blocking_move_to(safe_position);
     #endif // HAS_SAFE_BED_LEVELING
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
-    #if ENABLED(BLTOUCH) || BOTH(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
+    #if ENABLED(BLTOUCH) || ALL(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false, true);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (!abl.dryrun && (abl.gridSpacing != bedlevel.grid_spacing || abl.probe_position_lf != bedlevel.grid_start)) {
@@ -535,21 +535,21 @@ G29_TYPE GcodeSuite::G29() {
     if (no_action) G29_RETURN(false, true);
 
     if (abl.abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
-      #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
+      #if ANY(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl.abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
       abl.measured_z = current_position.z;
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
         abl.mean += abl.measured_z;

commit 060ddf5e950b104b00f5d20adf858a9ad00ab72e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:52:52 2023 -0500

    🚸 Support Bed Leveling Mesh > 16x16
    
    Co-Authored-By: raTmole <ratmole@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index dd325284af..1fe4a31bee 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -95,25 +95,25 @@ public:
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
             reenable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     int abl_probe_index;
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-    int abl_points;
+    grid_count_t abl_points;
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-    static constexpr int abl_points = 3;
+    static constexpr grid_count_t abl_points = 3;
   #elif ABL_USES_GRID
-    static constexpr int abl_points = GRID_MAX_POINTS;
+    static constexpr grid_count_t abl_points = GRID_MAX_POINTS;
   #endif
 
   #if ABL_USES_GRID
 
     xy_int8_t meshCount;
 
     xy_pos_t probe_position_lf,
              probe_position_rb;
 
     xy_float_t gridSpacing; // = { 0.0f, 0.0f }
@@ -125,30 +125,30 @@ public:
       static constexpr xy_uint8_t grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       float Z_offset;
       bed_mesh_t z_values;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-      float eqnAMatrix[(GRID_MAX_POINTS) * 3], // "A" matrix of the linear system of equations
-            eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
+      float eqnAMatrix[GRID_MAX_POINTS * 3],  // "A" matrix of the linear system of equations
+            eqnBVector[GRID_MAX_POINTS],      // "B" vector of Z points
             mean;
     #endif
   #endif
 };
 
 #if ABL_USES_GRID && EITHER(AUTO_BED_LEVELING_3POINT, AUTO_BED_LEVELING_BILINEAR)
   constexpr xy_uint8_t G29_State::grid_points;
-  constexpr int G29_State::abl_points;
+  constexpr grid_count_t G29_State::abl_points;
 #endif
 
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
  *  O  Auto-level only if needed
  *
@@ -670,21 +670,21 @@ G29_TYPE GcodeSuite::G29() {
         }
         else {                          // Zag towards origin
           inStart = PR_INNER_SIZE - 1;  // Right or back
           inStop = -1;                  // Left or front
           inInc = -1;                   // Zag left
         }
 
         zig ^= true; // zag
 
         // An index to print current state
-        uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_SIZE) + 1;
+        grid_count_t pt_index = (PR_OUTER_VAR) * (PR_INNER_SIZE) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area

commit c8c5ab22ce242b93632a7e2b9f855bbaf38b557f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 17 19:29:53 2023 -0500

    🧑‍💻 Gather Z clearances (#25701)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e334412054..dd325284af 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -487,34 +487,27 @@ G29_TYPE GcodeSuite::G29() {
     #if ENABLED(BLTOUCH) || BOTH(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false, true);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      if (!abl.dryrun
-        && (abl.gridSpacing != bedlevel.grid_spacing || abl.probe_position_lf != bedlevel.grid_start)
-      ) {
-        // Reset grid to 0.0 or "not probed". (Also disables ABL)
-        reset_bed_level();
-
-        // Can't re-enable (on error) until the new grid is written
-        abl.reenable = false;
+      if (!abl.dryrun && (abl.gridSpacing != bedlevel.grid_spacing || abl.probe_position_lf != bedlevel.grid_start)) {
+        reset_bed_level();      // Reset grid to 0.0 or "not probed". (Also disables ABL)
+        abl.reenable = false;   // Can't re-enable (on error) until the new grid is written
       }
-
       // Pre-populate local Z values from the stored mesh
       TERN_(IS_KINEMATIC, COPY(abl.z_values, bedlevel.z_values));
-
-    #endif // AUTO_BED_LEVELING_BILINEAR
+    #endif
 
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl.abl_probe_index;
       g29_in_progress = true;

commit 06cfd9c54af1537adf458a719b840cd501395278
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Wed Mar 22 02:15:51 2023 +0200

    ✨ PROBING_TOOL (#24411)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e1fd0124c4..e334412054 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -90,24 +90,20 @@ static void pre_g29_return(const bool retry, const bool did) {
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
             reenable;
 
-  #if HAS_MULTI_HOTEND
-    uint8_t tool_index;
-  #endif
-
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     int abl_probe_index;
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     int abl_points;
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
     static constexpr int abl_points = 3;
   #elif ABL_USES_GRID
     static constexpr int abl_points = GRID_MAX_POINTS;
@@ -274,24 +270,21 @@ G29_TYPE GcodeSuite::G29() {
   #endif
 
   // Set and report "probing" state to host
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE, false));
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
-    #if HAS_MULTI_HOTEND
-      abl.tool_index = active_extruder;
-      if (active_extruder != 0) tool_change(0, true);
-    #endif
+    probe.use_probing_tool();
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl.abl_probe_index = -1;
     #endif
 
     abl.reenable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen_test('W');
@@ -940,18 +933,18 @@ G29_TYPE GcodeSuite::G29() {
   if (!faux) restore_feedrate_and_scaling();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
-  TERN_(HAS_MULTI_HOTEND, if (abl.tool_index != 0) tool_change(abl.tool_index));
+  probe.use_probing_tool(false);
 
   report_current_position();
 
   G29_RETURN(isnan(abl.measured_z), true);
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 66d94ece33c5f7499b1901ee7510b1017cc0fb6f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 14 16:48:17 2023 -0500

    🎨 Misc. formatting

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 114fa55520..e1fd0124c4 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -402,29 +402,29 @@ G29_TYPE GcodeSuite::G29() {
         abl.probe_position_rb.set(_MIN(abl.probe_position_lf.x + size, x_max), _MIN(abl.probe_position_lf.y + size, y_max));
       }
       else {
         abl.probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
         abl.probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
       }
 
       if (!probe.good_bounds(abl.probe_position_lf, abl.probe_position_rb)) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("G29 L", abl.probe_position_lf.x, " R", abl.probe_position_rb.x,
-                              " F", abl.probe_position_lf.y, " B", abl.probe_position_rb.y);
+                             " F", abl.probe_position_lf.y, " B", abl.probe_position_rb.y);
         }
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false, false);
       }
 
       // Probe at the points of a lattice grid
       abl.gridSpacing.set((abl.probe_position_rb.x - abl.probe_position_lf.x) / (abl.grid_points.x - 1),
-                            (abl.probe_position_rb.y - abl.probe_position_lf.y) / (abl.grid_points.y - 1));
+                          (abl.probe_position_rb.y - abl.probe_position_lf.y) / (abl.grid_points.y - 1));
 
     #endif // ABL_USES_GRID
 
     if (abl.verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();

commit db5ff20b72c8769865f1f7a23d3ce5074b0c997e
Author: Kurt Haenen <Misterke@users.noreply.github.com>
Date:   Thu Mar 9 07:20:30 2023 +0100

    ✨ Extra Z Servo Probe options (#21427)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 4769bd79c0..114fa55520 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -484,21 +484,21 @@ G29_TYPE GcodeSuite::G29() {
       #endif
 
       do_blocking_move_to(safe_position);
     #endif // HAS_SAFE_BED_LEVELING
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
-    #if ENABLED(BLTOUCH)
+    #if ENABLED(BLTOUCH) || BOTH(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false, true);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (!abl.dryrun

commit 7e79fc5b8e04e0614d8ae09f908a73728f3e596e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:26:59 2023 -0600

    🩹 Safe Bed Leveling updates

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0fef5ad683..4769bd79c0 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -446,23 +446,21 @@ G29_TYPE GcodeSuite::G29() {
           #if BOTH(DWIN_LCD_PROUI, HAS_HEATED_BED)
             HMI_data.BedLevT
           #else
             LEVELING_BED_TEMP
           #endif
         );
       #endif
     }
 
     // Position bed horizontally and Z probe vertically.
-    #if    defined(SAFE_BED_LEVELING_START_X) || defined(SAFE_BED_LEVELING_START_Y) || defined(SAFE_BED_LEVELING_START_Z) \
-        || defined(SAFE_BED_LEVELING_START_I) || defined(SAFE_BED_LEVELING_START_J) || defined(SAFE_BED_LEVELING_START_K) \
-        || defined(SAFE_BED_LEVELING_START_U) || defined(SAFE_BED_LEVELING_START_V) || defined(SAFE_BED_LEVELING_START_W)
+    #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
         safe_position.x = SAFE_BED_LEVELING_START_X;
       #endif
       #ifdef SAFE_BED_LEVELING_START_Y
         safe_position.y = SAFE_BED_LEVELING_START_Y;
       #endif
       #ifdef SAFE_BED_LEVELING_START_Z
         safe_position.z = SAFE_BED_LEVELING_START_Z;
       #endif
@@ -479,21 +477,21 @@ G29_TYPE GcodeSuite::G29() {
         safe_position.u = SAFE_BED_LEVELING_START_U;
       #endif
       #ifdef SAFE_BED_LEVELING_START_V
         safe_position.v = SAFE_BED_LEVELING_START_V;
       #endif
       #ifdef SAFE_BED_LEVELING_START_W
         safe_position.w = SAFE_BED_LEVELING_START_W;
       #endif
 
       do_blocking_move_to(safe_position);
-    #endif
+    #endif // HAS_SAFE_BED_LEVELING
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if ENABLED(BLTOUCH)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    🧑‍💻  Update planner/stepper includes

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a2c53b5ab2..0fef5ad683 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -25,21 +25,20 @@
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
-#include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif

commit f73fad1b2fa6e70b3d632969ecf2773bee826643
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 6 19:34:45 2022 -0500

    🔥 Remove JyersUI (#24459)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e8c9c4a185..a2c53b5ab2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -44,22 +44,20 @@
   #include "../../../libs/vector_3.h"
 #endif
 
 #include "../../../lcd/marlinui.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../../lcd/e3v2/proui/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-  #include "../../../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ABL_USES_GRID

commit 509dfe92d0c2227ddece025fb97875582ca47aed
Author: Meilleur Gars <98503100+LCh-77@users.noreply.github.com>
Date:   Wed Jul 6 13:46:11 2022 -0700

    🚸 JyersUI updates (#24451)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a2c53b5ab2..e8c9c4a185 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -44,20 +44,22 @@
   #include "../../../libs/vector_3.h"
 #endif
 
 #include "../../../lcd/marlinui.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../../lcd/e3v2/proui/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #include "../../../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ABL_USES_GRID

commit 62057d3204c727fdf5c2c5e9f112e0c597e60924
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Thu May 19 22:15:15 2022 +0100

    🐛 Fix Leveling apply/unapply (#24188)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 8fac5e753e..a2c53b5ab2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -67,28 +67,32 @@
     #define PR_INNER_VAR  abl.meshCount.y
     #define PR_INNER_SIZE abl.grid_points.y
   #else
     #define PR_OUTER_VAR  abl.meshCount.y
     #define PR_OUTER_SIZE abl.grid_points.y
     #define PR_INNER_VAR  abl.meshCount.x
     #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
+static void pre_g29_return(const bool retry, const bool did) {
+  if (!retry) {
+    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false));
+  }
+  if (did) {
+    TERN_(HAS_DWIN_E3V2_BASIC, DWIN_LevelingDone());
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
+  }
+}
+
 #define G29_RETURN(retry, did) do{ \
-  if (TERN(G29_RETRY_AND_RECOVER, !retry, true)) { \
-    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false)); \
-  } \
-  if (did) { \
-    TERN_(HAS_DWIN_E3V2_BASIC, DWIN_LevelingDone()); \
-    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone()); \
-  } \
+  pre_g29_return(TERN0(G29_RETRY_AND_RECOVER, retry), did); \
   return TERN_(G29_RETRY_AND_RECOVER, retry); \
 }while(0)
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
@@ -319,22 +323,24 @@ G29_TYPE GcodeSuite::G29() {
           LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
 
         #pragma GCC diagnostic pop
 
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           bedlevel.z_values[i][j] = rz;
           bedlevel.refresh_bed_level();
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
-          set_bed_leveling_enabled(abl.reenable);
-          if (abl.reenable) report_current_position();
+          if (abl.reenable) {
+            set_bed_leveling_enabled(true);
+            report_current_position();
+          }
         }
         G29_RETURN(false, false);
       } // parser.seen_test('W')
 
     #else
 
       constexpr bool seen_w = false;
 
     #endif
 
@@ -722,21 +728,21 @@ G29_TYPE GcodeSuite::G29() {
             incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             const float z = abl.measured_z + abl.Z_offset;
             abl.z_values[abl.meshCount.x][abl.meshCount.y] = z;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, z));
 
           #endif
 
-          abl.reenable = false;
+          abl.reenable = false; // Don't re-enable after modifying the mesh
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
@@ -907,47 +913,42 @@ G29_TYPE GcodeSuite::G29() {
         ) {
           const float simple_z = current_position.z - abl.measured_z;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
           converted.z = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         current_position = converted;
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
-      }
 
-    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        abl.reenable = true;
+      }
 
-      if (!abl.dryrun) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("G29 uncorrected Z:", current_position.z);
+      // Auto Bed Leveling is complete! Enable if possible.
+      if (abl.reenable) {
+        planner.leveling_active = true;
+        sync_plan_position();
+      }
 
-        // Unapply the offset because it is going to be immediately applied
-        // and cause compensation movement in Z
-        current_position.z -= bedlevel.get_z_correction(current_position)
-          TERN_(ENABLE_LEVELING_FADE_HEIGHT, * planner.fade_scaling_factor_for_z(current_position.z));
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" corrected Z:", current_position.z);
-      }
+      // Auto Bed Leveling is complete! Enable if possible.
+      if (!abl.dryrun || abl.reenable) set_bed_leveling_enabled(true);
 
-    #endif // ABL_PLANAR
+    #endif
 
-    // Auto Bed Leveling is complete! Enable if possible.
-    planner.leveling_active = !abl.dryrun || abl.reenable;
   } // !isnan(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
-  // Sync the planner from the current_position
-  if (planner.leveling_active) sync_plan_position();
-
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
   TERN_(HAS_MULTI_HOTEND, if (abl.tool_index != 0) tool_change(abl.tool_index));
 

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ♻️ Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0d2abbfb35..8fac5e753e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -306,32 +306,32 @@ G29_TYPE GcodeSuite::G29() {
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         #pragma GCC diagnostic push
         #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
-          i = (rx - bbl.get_grid_start().x) / bbl.get_grid_spacing().x + 0.5f;
-          j = (ry - bbl.get_grid_start().y) / bbl.get_grid_spacing().y + 0.5f;
+          i = (rx - bedlevel.grid_start.x) / bedlevel.grid_spacing.x + 0.5f;
+          j = (ry - bedlevel.grid_start.y) / bedlevel.grid_spacing.y + 0.5f;
           LIMIT(i, 0, (GRID_MAX_POINTS_X) - 1);
           LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
 
         #pragma GCC diagnostic pop
 
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
-          Z_VALUES_ARR[i][j] = rz;
-          bbl.refresh_bed_level();
+          bedlevel.z_values[i][j] = rz;
+          bedlevel.refresh_bed_level();
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl.reenable);
           if (abl.reenable) report_current_position();
         }
         G29_RETURN(false, false);
       } // parser.seen_test('W')
 
     #else
 
       constexpr bool seen_w = false;
@@ -492,31 +492,31 @@ G29_TYPE GcodeSuite::G29() {
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false, true);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (!abl.dryrun
-        && (abl.gridSpacing != bbl.get_grid_spacing() || abl.probe_position_lf != bbl.get_grid_start())
+        && (abl.gridSpacing != bedlevel.grid_spacing || abl.probe_position_lf != bedlevel.grid_start)
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
 
       // Pre-populate local Z values from the stored mesh
-      TERN_(IS_KINEMATIC, COPY(abl.z_values, Z_VALUES_ARR));
+      TERN_(IS_KINEMATIC, COPY(abl.z_values, bedlevel.z_values));
 
     #endif // AUTO_BED_LEVELING_BILINEAR
 
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
@@ -789,28 +789,28 @@ G29_TYPE GcodeSuite::G29() {
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
   #endif
 
   // Calculate leveling, print reports, correct the position
   if (!isnan(abl.measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (abl.dryrun)
-        bbl.print_leveling_grid(&abl.z_values);
+        bedlevel.print_leveling_grid(&abl.z_values);
       else {
-        bbl.set_grid(abl.gridSpacing, abl.probe_position_lf);
-        COPY(Z_VALUES_ARR, abl.z_values);
-        TERN_(IS_KINEMATIC, bbl.extrapolate_unprobed_bed_level());
-        bbl.refresh_bed_level();
+        bedlevel.set_grid(abl.gridSpacing, abl.probe_position_lf);
+        COPY(bedlevel.z_values, abl.z_values);
+        TERN_(IS_KINEMATIC, bedlevel.extrapolate_unprobed_bed_level());
+        bedlevel.refresh_bed_level();
 
-        bbl.print_leveling_grid();
+        bedlevel.print_leveling_grid();
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       // For LINEAR leveling calculate matrix, print reports, correct the position
 
       /**
        * solve the plane equation ax + by + d = z
        * A is the matrix with rows [x y 1] for all the probed points
        * B is the vector of the Z positions
@@ -916,22 +916,22 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!abl.dryrun) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
-        const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
-        current_position.z -= fade_scaling_factor * bbl.get_z_correction(current_position);
+        current_position.z -= bedlevel.get_z_correction(current_position)
+          TERN_(ENABLE_LEVELING_FADE_HEIGHT, * planner.fade_scaling_factor_for_z(current_position.z));
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = !abl.dryrun || abl.reenable;
   } // !isnan(abl.measured_z)
 

commit e039d51d183314a1cfb1b2b088e5edfe4af054ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 20:23:32 2022 -0500

    🩹 Fix ProUI leveling start message

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f9bdbf5e9f..0d2abbfb35 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -421,21 +421,21 @@ G29_TYPE GcodeSuite::G29() {
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LevelingStart());
+      TERN_(DWIN_LCD_PROUI, DWIN_LevelingStart());
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP,
           #if BOTH(DWIN_LCD_PROUI, HAS_HEATED_BED)

commit 60b6df4542d78e8263f75a989c77c2f386a894fc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 29 18:54:57 2022 +0100

    🐛 Fix kinetic ABL mesh after refactor (#24107)
    
    Followup to #23868

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 3743f1ffc6..f9bdbf5e9f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -500,20 +500,24 @@ G29_TYPE GcodeSuite::G29() {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (!abl.dryrun
         && (abl.gridSpacing != bbl.get_grid_spacing() || abl.probe_position_lf != bbl.get_grid_start())
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
+
+      // Pre-populate local Z values from the stored mesh
+      TERN_(IS_KINEMATIC, COPY(abl.z_values, Z_VALUES_ARR));
+
     #endif // AUTO_BED_LEVELING_BILINEAR
 
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl.abl_probe_index;

commit 4a73fa18d8d6b7b8909fad8a84dfe90cf8fefab1
Author: Mateusz Kleina <mateuszkleina@gmail.com>
Date:   Fri Apr 22 12:12:39 2022 +0200

    🐛 Fix ProUI / JyersUI leveling preheat (#24064)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 03384fb602..3743f1ffc6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -430,21 +430,27 @@ G29_TYPE GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LevelingStart());
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
-        if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
+        if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP,
+          #if BOTH(DWIN_LCD_PROUI, HAS_HEATED_BED)
+            HMI_data.BedLevT
+          #else
+            LEVELING_BED_TEMP
+          #endif
+        );
       #endif
     }
 
     // Position bed horizontally and Z probe vertically.
     #if    defined(SAFE_BED_LEVELING_START_X) || defined(SAFE_BED_LEVELING_START_Y) || defined(SAFE_BED_LEVELING_START_Z) \
         || defined(SAFE_BED_LEVELING_START_I) || defined(SAFE_BED_LEVELING_START_J) || defined(SAFE_BED_LEVELING_START_K) \
         || defined(SAFE_BED_LEVELING_START_U) || defined(SAFE_BED_LEVELING_START_V) || defined(SAFE_BED_LEVELING_START_W)
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
         safe_position.x = SAFE_BED_LEVELING_START_X;

commit fe745fdef051e5c0cce4368d5a3f2a95140f57a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 22 01:12:43 2022 -0500

    🚸 More ExtUI events for ABL / UBL

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 1a1229f490..03384fb602 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -67,24 +67,28 @@
     #define PR_INNER_VAR  abl.meshCount.y
     #define PR_INNER_SIZE abl.grid_points.y
   #else
     #define PR_OUTER_VAR  abl.meshCount.y
     #define PR_OUTER_SIZE abl.grid_points.y
     #define PR_INNER_VAR  abl.meshCount.x
     #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
-#define G29_RETURN(retry) do{ \
+#define G29_RETURN(retry, did) do{ \
   if (TERN(G29_RETRY_AND_RECOVER, !retry, true)) { \
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false)); \
   } \
+  if (did) { \
+    TERN_(HAS_DWIN_E3V2_BASIC, DWIN_LevelingDone()); \
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone()); \
+  } \
   return TERN_(G29_RETRY_AND_RECOVER, retry); \
 }while(0)
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
@@ -226,41 +230,41 @@ G29_TYPE GcodeSuite::G29() {
 
   // Keep powered steppers from timing out
   reset_stepper_timeout();
 
   // Q = Query leveling and G29 state
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (seenQ || DEBUGGING(LEVELING)) log_machine_info();
-    if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
+    if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false, false);
   #endif
 
   // A = Abort manual probing
   // C<bool> = Generate fake probe points (DEBUG_LEVELING_FEATURE)
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen_test('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   // O = Don't level if leveling is already active
   if (!no_action && planner.leveling_active && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
-    G29_RETURN(false);
+    G29_RETURN(false, false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
   if (parser.seen_test('N'))
     process_subcommands_now(TERN(CAN_SET_LEVELING_AFTER_G28, F("G28L0"), FPSTR(G28_STR)));
 
   // Don't allow auto-leveling without homing first
-  if (homing_needed_error()) G29_RETURN(false);
+  if (homing_needed_error()) G29_RETURN(false, false);
 
   // 3-point leveling gets points from the probe class
   #if ENABLED(AUTO_BED_LEVELING_3POINT)
     vector_3 points[3];
     probe.get_three_points(points);
   #endif
 
   // Storage for ABL Linear results
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
@@ -284,27 +288,27 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
     abl.reenable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen_test('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_MSG("No bilinear grid");
-          G29_RETURN(false);
+          G29_RETURN(false, false);
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position.z;
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
-          G29_RETURN(false);
+          G29_RETURN(false, false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         #pragma GCC diagnostic push
         #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 
         if (!isnan(rx) && !isnan(ry)) {
@@ -318,64 +322,64 @@ G29_TYPE GcodeSuite::G29() {
         #pragma GCC diagnostic pop
 
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           Z_VALUES_ARR[i][j] = rz;
           bbl.refresh_bed_level();
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl.reenable);
           if (abl.reenable) report_current_position();
         }
-        G29_RETURN(false);
+        G29_RETURN(false, false);
       } // parser.seen_test('W')
 
     #else
 
       constexpr bool seen_w = false;
 
     #endif
 
     // Jettison bed leveling data
     if (!seen_w && parser.seen_test('J')) {
       reset_bed_level();
-      G29_RETURN(false);
+      G29_RETURN(false, false);
     }
 
     abl.verbose_level = parser.intval('V');
     if (!WITHIN(abl.verbose_level, 0, 4)) {
       SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
-      G29_RETURN(false);
+      G29_RETURN(false, false);
     }
 
     abl.dryrun = parser.boolval('D') || TERN0(PROBE_MANUALLY, no_action);
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       incremental_LSF_reset(&lsf_results);
 
       abl.topography_map = abl.verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl.grid_points.set(
         parser.byteval('X', GRID_MAX_POINTS_X),
         parser.byteval('Y', GRID_MAX_POINTS_Y)
       );
       if (parser.seenval('P')) abl.grid_points.x = abl.grid_points.y = parser.value_int();
 
       if (!WITHIN(abl.grid_points.x, 2, GRID_MAX_POINTS_X)) {
         SERIAL_ECHOLNPGM("?Probe points (X) implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
-        G29_RETURN(false);
+        G29_RETURN(false, false);
       }
       if (!WITHIN(abl.grid_points.y, 2, GRID_MAX_POINTS_Y)) {
         SERIAL_ECHOLNPGM("?Probe points (Y) implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
-        G29_RETURN(false);
+        G29_RETURN(false, false);
       }
 
       abl.abl_points = abl.grid_points.x * abl.grid_points.y;
       abl.mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       abl.Z_offset = parser.linearval('Z');
 
     #endif
@@ -396,46 +400,46 @@ G29_TYPE GcodeSuite::G29() {
         abl.probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
         abl.probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
       }
 
       if (!probe.good_bounds(abl.probe_position_lf, abl.probe_position_rb)) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("G29 L", abl.probe_position_lf.x, " R", abl.probe_position_rb.x,
                               " F", abl.probe_position_lf.y, " B", abl.probe_position_rb.y);
         }
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
-        G29_RETURN(false);
+        G29_RETURN(false, false);
       }
 
       // Probe at the points of a lattice grid
       abl.gridSpacing.set((abl.probe_position_rb.x - abl.probe_position_lf.x) / (abl.grid_points.x - 1),
                             (abl.probe_position_rb.y - abl.probe_position_lf.y) / (abl.grid_points.y - 1));
 
     #endif // ABL_USES_GRID
 
     if (abl.verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
-
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LevelingStart());
     #endif
 
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
+
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
     // Position bed horizontally and Z probe vertically.
     #if    defined(SAFE_BED_LEVELING_START_X) || defined(SAFE_BED_LEVELING_START_Y) || defined(SAFE_BED_LEVELING_START_Z) \
@@ -476,21 +480,21 @@ G29_TYPE GcodeSuite::G29() {
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if ENABLED(BLTOUCH)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
-        G29_RETURN(false);
+        G29_RETURN(false, true);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (!abl.dryrun
         && (abl.gridSpacing != bbl.get_grid_spacing() || abl.probe_position_lf != bbl.get_grid_start())
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
@@ -522,21 +526,21 @@ G29_TYPE GcodeSuite::G29() {
     // Query G29 status
     if (abl.verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress)
         SERIAL_ECHOLNPGM("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points), " of ", abl.abl_points);
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     // For 'A' or 'Q' exit with success state
-    if (no_action) G29_RETURN(false);
+    if (no_action) G29_RETURN(false, true);
 
     if (abl.abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
       #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
@@ -597,59 +601,56 @@ G29_TYPE GcodeSuite::G29() {
         if (position_is_reachable(abl.probePos)) break;
         ++abl.abl_probe_index;
       }
 
       // Is there a next point to move to?
       if (abl.abl_probe_index < abl.abl_points) {
         _manual_goto_xy(abl.probePos); // Can be used here too!
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
         SET_SOFT_ENDSTOP_LOOSE(true);
-        G29_RETURN(false);
+        G29_RETURN(false, true);
       }
       else {
         // Leveling done! Fall through to G29 finishing code below
         SERIAL_ECHOLNPGM("Grid probing done.");
         // Re-enable software endstops, if needed
         SET_SOFT_ENDSTOP_LOOSE(false);
-        TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl.abl_probe_index < abl.abl_points) {
         abl.probePos = xy_pos_t(points[abl.abl_probe_index]);
         _manual_goto_xy(abl.probePos);
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
         SET_SOFT_ENDSTOP_LOOSE(true);
-        G29_RETURN(false);
+        G29_RETURN(false, true);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         SET_SOFT_ENDSTOP_LOOSE(false);
 
         if (!abl.dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) planeNormal *= -1;
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
           // Can't re-enable (on error) until the new grid is written
           abl.reenable = false;
         }
 
-        TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
-
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
   #else // !PROBE_MANUALLY
   {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     abl.measured_z = 0;
 
@@ -931,21 +932,18 @@ G29_TYPE GcodeSuite::G29() {
   if (planner.leveling_active) sync_plan_position();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
-  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_LevelingDone());
-
   TERN_(HAS_MULTI_HOTEND, if (abl.tool_index != 0) tool_change(abl.tool_index));
 
   report_current_position();
 
-  G29_RETURN(isnan(abl.measured_z));
-
+  G29_RETURN(isnan(abl.measured_z), true);
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 696ae3cc14b659f3ff9151c465d06b6ee3cf26c8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 18 16:41:16 2022 -0500

    ✏️ Remove extra G29 line
    
    Followup to 85a62bbf

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ac8eff0e95..1a1229f490 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -650,22 +650,20 @@ G29_TYPE GcodeSuite::G29() {
   #else // !PROBE_MANUALLY
   {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     abl.measured_z = 0;
 
     #if ABL_USES_GRID
 
       bool zig = PR_OUTER_SIZE & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
-      abl.measured_z = 0;
-
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_SIZE && !isnan(abl.measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) {                      // Zig away from origin
           inStart = 0;                  // Left or front
           inStop = PR_INNER_SIZE;       // Right or back
           inInc = 1;                    // Zig right

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ✨ Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 61848c45bd..ac8eff0e95 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -430,20 +430,56 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
+    // Position bed horizontally and Z probe vertically.
+    #if    defined(SAFE_BED_LEVELING_START_X) || defined(SAFE_BED_LEVELING_START_Y) || defined(SAFE_BED_LEVELING_START_Z) \
+        || defined(SAFE_BED_LEVELING_START_I) || defined(SAFE_BED_LEVELING_START_J) || defined(SAFE_BED_LEVELING_START_K) \
+        || defined(SAFE_BED_LEVELING_START_U) || defined(SAFE_BED_LEVELING_START_V) || defined(SAFE_BED_LEVELING_START_W)
+      xyze_pos_t safe_position = current_position;
+      #ifdef SAFE_BED_LEVELING_START_X
+        safe_position.x = SAFE_BED_LEVELING_START_X;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_Y
+        safe_position.y = SAFE_BED_LEVELING_START_Y;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_Z
+        safe_position.z = SAFE_BED_LEVELING_START_Z;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_I
+        safe_position.i = SAFE_BED_LEVELING_START_I;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_J
+        safe_position.j = SAFE_BED_LEVELING_START_J;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_K
+        safe_position.k = SAFE_BED_LEVELING_START_K;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_U
+        safe_position.u = SAFE_BED_LEVELING_START_U;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_V
+        safe_position.v = SAFE_BED_LEVELING_START_V;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_W
+        safe_position.w = SAFE_BED_LEVELING_START_W;
+      #endif
+
+      do_blocking_move_to(safe_position);
+    #endif
+
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if ENABLED(BLTOUCH)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);

commit ae53033cea506209310fb014b304f3a07c59e9d7
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 03:13:16 2022 +0100

    ♻️ Refactor and fix ABL Bilinear (#23868)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 1868c636ee..61848c45bd 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -117,20 +117,21 @@ public:
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       bool                topography_map;
       xy_uint8_t          grid_points;
     #else // Bilinear
       static constexpr xy_uint8_t grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       float Z_offset;
+      bed_mesh_t z_values;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       float eqnAMatrix[(GRID_MAX_POINTS) * 3], // "A" matrix of the linear system of equations
             eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
             mean;
     #endif
   #endif
 };
@@ -301,32 +302,32 @@ G29_TYPE GcodeSuite::G29() {
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         #pragma GCC diagnostic push
         #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
-          i = (rx - bilinear_start.x + 0.5 * abl.gridSpacing.x) / abl.gridSpacing.x;
-          j = (ry - bilinear_start.y + 0.5 * abl.gridSpacing.y) / abl.gridSpacing.y;
+          i = (rx - bbl.get_grid_start().x) / bbl.get_grid_spacing().x + 0.5f;
+          j = (ry - bbl.get_grid_start().y) / bbl.get_grid_spacing().y + 0.5f;
           LIMIT(i, 0, (GRID_MAX_POINTS_X) - 1);
           LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
 
         #pragma GCC diagnostic pop
 
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
-          z_values[i][j] = rz;
-          TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
+          Z_VALUES_ARR[i][j] = rz;
+          bbl.refresh_bed_level();
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl.reenable);
           if (abl.reenable) report_current_position();
         }
         G29_RETURN(false);
       } // parser.seen_test('W')
 
     #else
 
       constexpr bool seen_w = false;
@@ -444,30 +445,26 @@ G29_TYPE GcodeSuite::G29() {
     #if ENABLED(BLTOUCH)
       do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
     #elif HAS_BED_PROBE
       if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      if (TERN1(PROBE_MANUALLY, !no_action)
-        && (abl.gridSpacing != bilinear_grid_spacing || abl.probe_position_lf != bilinear_start)
+      if (!abl.dryrun
+        && (abl.gridSpacing != bbl.get_grid_spacing() || abl.probe_position_lf != bbl.get_grid_start())
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
-        // Initialize a grid with the given dimensions
-        bilinear_grid_spacing = abl.gridSpacing;
-        bilinear_start = abl.probe_position_lf;
-
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
     #endif // AUTO_BED_LEVELING_BILINEAR
 
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
     // For manual probing, get the next index to probe now.
@@ -524,21 +521,21 @@ G29_TYPE GcodeSuite::G29() {
 
         incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
         points[index].z = abl.measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         const float newz = abl.measured_z + abl.Z_offset;
-        z_values[abl.meshCount.x][abl.meshCount.y] = newz;
+        abl.z_values[abl.meshCount.x][abl.meshCount.y] = newz;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, newz));
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM_P(PSTR("Save X"), abl.meshCount.x, SP_Y_STR, abl.meshCount.y, SP_Z_STR, abl.measured_z + abl.Z_offset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
@@ -675,21 +672,21 @@ G29_TYPE GcodeSuite::G29() {
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
             abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
             abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
             abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 
             incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             const float z = abl.measured_z + abl.Z_offset;
-            z_values[abl.meshCount.x][abl.meshCount.y] = z;
+            abl.z_values[abl.meshCount.x][abl.meshCount.y] = z;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, z));
 
           #endif
 
           abl.reenable = false;
           idle_no_sleep();
 
         } // inner
       } // outer
 
@@ -746,26 +743,30 @@ G29_TYPE GcodeSuite::G29() {
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
   #endif
 
   // Calculate leveling, print reports, correct the position
   if (!isnan(abl.measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      if (!abl.dryrun) extrapolate_unprobed_bed_level();
-      print_bilinear_leveling_grid();
-
-      refresh_bed_level();
+      if (abl.dryrun)
+        bbl.print_leveling_grid(&abl.z_values);
+      else {
+        bbl.set_grid(abl.gridSpacing, abl.probe_position_lf);
+        COPY(Z_VALUES_ARR, abl.z_values);
+        TERN_(IS_KINEMATIC, bbl.extrapolate_unprobed_bed_level());
+        bbl.refresh_bed_level();
 
-      TERN_(ABL_BILINEAR_SUBDIVISION, print_bilinear_leveling_grid_virt());
+        bbl.print_leveling_grid();
+      }
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       // For LINEAR leveling calculate matrix, print reports, correct the position
 
       /**
        * solve the plane equation ax + by + d = z
        * A is the matrix with rows [x y 1] for all the probed points
        * B is the vector of the Z positions
        * the normal vector to the plane is formed by the coefficients of the
@@ -871,21 +872,21 @@ G29_TYPE GcodeSuite::G29() {
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!abl.dryrun) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
         const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
-        current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
+        current_position.z -= fade_scaling_factor * bbl.get_z_correction(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = !abl.dryrun || abl.reenable;
   } // !isnan(abl.measured_z)
 

commit 623c6b720b0d9b14934fb8ccb895d421ab043cc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:58:28 2022 -0600

    🧑‍💻 Add ExtUI::onLevelingDone, match DWIN to ExtUI

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 33f45e1c9f..1868c636ee 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -412,26 +412,27 @@ G29_TYPE GcodeSuite::G29() {
     #endif // ABL_USES_GRID
 
     if (abl.verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
+
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      TERN_(EXTENSIBLE_UI, ExtUI::onMeshLevelingStart());
-      TERN_(DWIN_LCD_PROUI, DWIN_MeshLevelingStart());
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LevelingStart());
     #endif
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
@@ -570,20 +571,21 @@ G29_TYPE GcodeSuite::G29() {
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
         SET_SOFT_ENDSTOP_LOOSE(true);
         G29_RETURN(false);
       }
       else {
         // Leveling done! Fall through to G29 finishing code below
         SERIAL_ECHOLNPGM("Grid probing done.");
         // Re-enable software endstops, if needed
         SET_SOFT_ENDSTOP_LOOSE(false);
+        TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl.abl_probe_index < abl.abl_points) {
         abl.probePos = xy_pos_t(points[abl.abl_probe_index]);
         _manual_goto_xy(abl.probePos);
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
@@ -599,20 +601,22 @@ G29_TYPE GcodeSuite::G29() {
 
         if (!abl.dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) planeNormal *= -1;
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
           // Can't re-enable (on error) until the new grid is written
           abl.reenable = false;
         }
 
+        TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
+
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
   #else // !PROBE_MANUALLY
   {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     abl.measured_z = 0;
 
@@ -892,21 +896,21 @@ G29_TYPE GcodeSuite::G29() {
   if (planner.leveling_active) sync_plan_position();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
-  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedLeveling());
+  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_LevelingDone());
 
   TERN_(HAS_MULTI_HOTEND, if (abl.tool_index != 0) tool_change(abl.tool_index));
 
   report_current_position();
 
   G29_RETURN(isnan(abl.measured_z));
 
 }
 
 #endif // HAS_ABL_NOT_UBL

commit bd3ecc3ea07aaca3ad60441f64654b407f028714
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Mar 12 03:51:25 2022 +1300

    fix g29 (#23887)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 68d8ecc26b..33f45e1c9f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -711,21 +711,21 @@ G29_TYPE GcodeSuite::G29() {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
-    ui.reset_status();
+    TERN_(HAS_STATUS_MESSAGE, ui.reset_status());
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
       set_bed_leveling_enabled(abl.reenable);
       abl.measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //

commit f516c9e5528c67b1fd3119fd9910e0f14ae267f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 11 02:56:24 2022 -0600

    🐛 Fix UI include
    
    Followup to ~2

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a65d844771..68d8ecc26b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,47 +29,44 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
-#if HAS_STATUS_MESSAGE
-  #include "../../../lcd/marlinui.h"
-#endif
-
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
 
-#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
-#include "../../../core/debug_out.h"
-
+#include "../../../lcd/marlinui.h"
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../../core/debug_out.h"
+
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
     #define PR_OUTER_SIZE abl.grid_points.x
     #define PR_INNER_VAR  abl.meshCount.y
     #define PR_INNER_SIZE abl.grid_points.y
   #else
     #define PR_OUTER_VAR  abl.meshCount.y
     #define PR_OUTER_SIZE abl.grid_points.y
     #define PR_INNER_VAR  abl.meshCount.x

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    🔧 DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 20f2369b03..a65d844771 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -48,21 +48,21 @@
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#elif ENABLED(DWIN_LCD_PROUI)
   #include "../../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
@@ -420,21 +420,21 @@ G29_TYPE GcodeSuite::G29() {
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshLevelingStart());
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_MeshLevelingStart());
+      TERN_(DWIN_LCD_PROUI, DWIN_MeshLevelingStart());
     #endif
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
@@ -714,21 +714,21 @@ G29_TYPE GcodeSuite::G29() {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
-    TERN_(HAS_STATUS_MESSAGE, ui.reset_status());
+    ui.reset_status();
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
       set_bed_leveling_enabled(abl.reenable);
       abl.measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //

commit 2e39bc30fd748b0ade7aafdab4827f942536cdcd
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Wed Mar 2 22:13:46 2022 +0000

    🚸 Universal X_AXIS_TWIST_COMPENSATION (#23828)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a6ef6d2729..20f2369b03 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -674,21 +674,21 @@ G29_TYPE GcodeSuite::G29() {
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
             abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
             abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
             abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 
             incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             const float z = abl.measured_z + abl.Z_offset;
-            z_values[abl.meshCount.x][abl.meshCount.y] = z PLUS_TERN0(X_AXIS_TWIST_COMPENSATION, xatc.compensation(abl.probePos));
+            z_values[abl.meshCount.x][abl.meshCount.y] = z;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, z));
 
           #endif
 
           abl.reenable = false;
           idle_no_sleep();
 
         } // inner
       } // outer
 

commit b07a34eb6bd8928aebef631554626aaa8c88c567
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 2 16:04:17 2022 -0600

    🐛 Fix M_State_grbl when G29 calls G28

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 24c0268b9f..a6ef6d2729 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -70,21 +70,26 @@
     #define PR_INNER_VAR  abl.meshCount.y
     #define PR_INNER_SIZE abl.grid_points.y
   #else
     #define PR_OUTER_VAR  abl.meshCount.y
     #define PR_OUTER_SIZE abl.grid_points.y
     #define PR_INNER_VAR  abl.meshCount.x
     #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
-#define G29_RETURN(b) return TERN_(G29_RETRY_AND_RECOVER, b)
+#define G29_RETURN(retry) do{ \
+  if (TERN(G29_RETRY_AND_RECOVER, !retry, true)) { \
+    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE, false)); \
+  } \
+  return TERN_(G29_RETRY_AND_RECOVER, retry); \
+}while(0)
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
             reenable;
 
@@ -211,59 +216,68 @@ public:
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  */
 G29_TYPE GcodeSuite::G29() {
   DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
 
+  // Leveling state is persistent when done manually with multiple G29 commands
   TERN_(PROBE_MANUALLY, static) G29_State abl;
 
-  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
-
+  // Keep powered steppers from timing out
   reset_stepper_timeout();
 
+  // Q = Query leveling and G29 state
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (seenQ || DEBUGGING(LEVELING)) log_machine_info();
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
+  // A = Abort manual probing
+  // C<bool> = Generate fake probe points (DEBUG_LEVELING_FEATURE)
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen_test('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
-  if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
+  // O = Don't level if leveling is already active
+  if (!no_action && planner.leveling_active && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
   if (parser.seen_test('N'))
     process_subcommands_now(TERN(CAN_SET_LEVELING_AFTER_G28, F("G28L0"), FPSTR(G28_STR)));
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
+  // 3-point leveling gets points from the probe class
   #if ENABLED(AUTO_BED_LEVELING_3POINT)
     vector_3 points[3];
     probe.get_three_points(points);
   #endif
 
+  // Storage for ABL Linear results
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
   #endif
 
+  // Set and report "probing" state to host
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE, false));
+
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     #if HAS_MULTI_HOTEND
       abl.tool_index = active_extruder;
       if (active_extruder != 0) tool_change(0, true);
     #endif
 
@@ -422,24 +436,24 @@ G29_TYPE GcodeSuite::G29() {
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
-    #if HAS_BED_PROBE
-      if (ENABLED(BLTOUCH))
-        do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
-      else if (probe.deploy()) {
+    #if ENABLED(BLTOUCH)
+      do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
+    #elif HAS_BED_PROBE
+      if (probe.deploy()) { // (returns true on deploy failure)
         set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (TERN1(PROBE_MANUALLY, !no_action)
         && (abl.gridSpacing != bilinear_grid_spacing || abl.probe_position_lf != bilinear_start)
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
@@ -476,20 +490,21 @@ G29_TYPE GcodeSuite::G29() {
 
     // Query G29 status
     if (abl.verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress)
         SERIAL_ECHOLNPGM("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points), " of ", abl.abl_points);
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
+    // For 'A' or 'Q' exit with success state
     if (no_action) G29_RETURN(false);
 
     if (abl.abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
@@ -886,17 +901,15 @@ G29_TYPE GcodeSuite::G29() {
     planner.synchronize();
     process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedLeveling());
 
   TERN_(HAS_MULTI_HOTEND, if (abl.tool_index != 0) tool_change(abl.tool_index));
 
   report_current_position();
 
-  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
-
   G29_RETURN(isnan(abl.measured_z));
 
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 8f8427ec8f69705e09ca226d9f16da6b82634439
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Feb 22 01:15:52 2022 +0000

    ⚡️ Apply PTC on all probing (#23764)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9ec43fe49d..24c0268b9f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,25 +29,20 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
-#if HAS_PTC
-  #include "../../../feature/probe_temp_comp.h"
-  #include "../../../module/temperature.h"
-#endif
-
 #if HAS_STATUS_MESSAGE
   #include "../../../lcd/marlinui.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
@@ -651,24 +646,20 @@ G29_TYPE GcodeSuite::G29() {
           if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
-          TERN_(PTC_BED,    ptc.compensate_measurement(TSI_BED,   thermalManager.degBed(),     abl.measured_z));
-          TERN_(PTC_PROBE,  ptc.compensate_measurement(TSI_PROBE, thermalManager.degProbe(),   abl.measured_z));
-          TERN_(PTC_HOTEND, ptc.compensate_measurement(TSI_EXT,   thermalManager.degHotend(0), abl.measured_z));
-
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             abl.mean += abl.measured_z;
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
             abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
             abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
             abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 
             incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 

commit 0a24f858f3009b358c3c0841654521146949261a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu Feb 10 05:46:53 2022 +1300

    🚸 Restore active tool after ABL G29 (#23692)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index fddca22c32..9ec43fe49d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -86,20 +86,24 @@
 
 // For manual probing values persist over multiple G29
 class G29_State {
 public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
             reenable;
 
+  #if HAS_MULTI_HOTEND
+    uint8_t tool_index;
+  #endif
+
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     int abl_probe_index;
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     int abl_points;
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
     static constexpr int abl_points = 3;
   #elif ABL_USES_GRID
     static constexpr int abl_points = GRID_MAX_POINTS;
@@ -256,21 +260,24 @@ G29_TYPE GcodeSuite::G29() {
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
-    TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
+    #if HAS_MULTI_HOTEND
+      abl.tool_index = active_extruder;
+      if (active_extruder != 0) tool_change(0, true);
+    #endif
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl.abl_probe_index = -1;
     #endif
 
     abl.reenable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen_test('W');
@@ -884,19 +891,21 @@ G29_TYPE GcodeSuite::G29() {
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedLeveling());
 
+  TERN_(HAS_MULTI_HOTEND, if (abl.tool_index != 0) tool_change(abl.tool_index));
+
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   G29_RETURN(isnan(abl.measured_z));
 
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    🚸 Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index eea5d4a7f2..fddca22c32 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -54,21 +54,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
-  #include "../../../lcd/e3v2/enhanced/dwin.h"
+  #include "../../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
     #define PR_OUTER_SIZE abl.grid_points.x

commit 1bd921d6a69412686fa4b31c4c1e5710de9840cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 6 05:07:47 2022 -0600

    🎨 Misc. cleanup, comments

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 6765ec86a6..eea5d4a7f2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -283,27 +283,33 @@ G29_TYPE GcodeSuite::G29() {
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position.z;
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
+        #pragma GCC diagnostic push
+        #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
+
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start.x + 0.5 * abl.gridSpacing.x) / abl.gridSpacing.x;
           j = (ry - bilinear_start.y + 0.5 * abl.gridSpacing.y) / abl.gridSpacing.y;
           LIMIT(i, 0, (GRID_MAX_POINTS_X) - 1);
           LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
+
+        #pragma GCC diagnostic pop
+
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl.reenable);
           if (abl.reenable) report_current_position();
         }
         G29_RETURN(false);
       } // parser.seen_test('W')

commit a16a059312b0ddb822da2769b5ba5372f9857c48
Author: Giuseppe499 <giuseppe499@live.it>
Date:   Tue Dec 7 02:53:51 2021 +0100

    ✨ X Twist Compensation & Calibration (#23238)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 14da38c8fe..6765ec86a6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -655,21 +655,21 @@ G29_TYPE GcodeSuite::G29() {
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
             abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
             abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
             abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 
             incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             const float z = abl.measured_z + abl.Z_offset;
-            z_values[abl.meshCount.x][abl.meshCount.y] = z;
+            z_values[abl.meshCount.x][abl.meshCount.y] = z PLUS_TERN0(X_AXIS_TWIST_COMPENSATION, xatc.compensation(abl.probePos));
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, z));
 
           #endif
 
           abl.reenable = false;
           idle_no_sleep();
 
         } // inner
       } // outer
 

commit 296a6137cd06ce06f062767ab1b59f99ee95a094
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 1 23:03:50 2021 +0000

    🚸 More flexible Probe Temperature Compensation (#23033)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5d94797f16..14da38c8fe 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,21 +29,21 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
-#if ENABLED(PROBE_TEMP_COMPENSATION)
+#if HAS_PTC
   #include "../../../feature/probe_temp_comp.h"
   #include "../../../module/temperature.h"
 #endif
 
 #if HAS_STATUS_MESSAGE
   #include "../../../lcd/marlinui.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
@@ -638,25 +638,23 @@ G29_TYPE GcodeSuite::G29() {
           if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
-          #if ENABLED(PROBE_TEMP_COMPENSATION)
-            temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
-            temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), abl.measured_z);
-            TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(0), abl.measured_z));
-          #endif
+          TERN_(PTC_BED,    ptc.compensate_measurement(TSI_BED,   thermalManager.degBed(),     abl.measured_z));
+          TERN_(PTC_PROBE,  ptc.compensate_measurement(TSI_PROBE, thermalManager.degProbe(),   abl.measured_z));
+          TERN_(PTC_HOTEND, ptc.compensate_measurement(TSI_EXT,   thermalManager.degHotend(0), abl.measured_z));
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             abl.mean += abl.measured_z;
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
             abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
             abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
             abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 
             incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);

commit 444f27dfa0bba82b73b428b7adcc50d44b99775a
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Oct 25 06:33:40 2021 +0100

    🐛 Add USE_TEMP_EXT_COMPENSATION options (#23007)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f7afd93c81..5d94797f16 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -641,21 +641,21 @@ G29_TYPE GcodeSuite::G29() {
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
             temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), abl.measured_z);
-            TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), abl.measured_z));
+            TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(0), abl.measured_z));
           #endif
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             abl.mean += abl.measured_z;
             abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
             abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
             abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
             abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    🎨 Apply F() to various reports

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 07aefe8aed..f7afd93c81 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -776,63 +776,63 @@ G29_TYPE GcodeSuite::G29() {
       if (!abl.dryrun)
         planner.bed_level_matrix = matrix_3x3::create_look_at(
           vector_3(-plane_equation_coefficients.a, -plane_equation_coefficients.b, 1)    // We can eliminate the '-' here and up above
         );
 
       // Show the Topography map if enabled
       if (abl.topography_map) {
 
         float min_diff = 999;
 
-        auto print_topo_map = [&](PGM_P const title, const bool get_min) {
-          SERIAL_ECHOPGM_P(title);
+        auto print_topo_map = [&](FSTR_P const title, const bool get_min) {
+          SERIAL_ECHOF(title);
           for (int8_t yy = abl.grid_points.y - 1; yy >= 0; yy--) {
             LOOP_L_N(xx, abl.grid_points.x) {
               const int ind = abl.indexIntoAB[xx][yy];
               xyz_float_t tmp = { abl.eqnAMatrix[ind + 0 * abl.abl_points],
                                   abl.eqnAMatrix[ind + 1 * abl.abl_points], 0 };
               planner.bed_level_matrix.apply_rotation_xyz(tmp.x, tmp.y, tmp.z);
               if (get_min) NOMORE(min_diff, abl.eqnBVector[ind] - tmp.z);
               const float subval = get_min ? abl.mean : tmp.z + min_diff,
                             diff = abl.eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
               SERIAL_ECHO_F(diff, 5);
             } // xx
             SERIAL_EOL();
           } // yy
           SERIAL_EOL();
         };
 
-        print_topo_map(PSTR("\nBed Height Topography:\n"
-                               "   +--- BACK --+\n"
-                               "   |           |\n"
-                               " L |    (+)    | R\n"
-                               " E |           | I\n"
-                               " F | (-) N (+) | G\n"
-                               " T |           | H\n"
-                               "   |    (-)    | T\n"
-                               "   |           |\n"
-                               "   O-- FRONT --+\n"
-                               " (0,0)\n"), true);
+        print_topo_map(F("\nBed Height Topography:\n"
+                           "   +--- BACK --+\n"
+                           "   |           |\n"
+                           " L |    (+)    | R\n"
+                           " E |           | I\n"
+                           " F | (-) N (+) | G\n"
+                           " T |           | H\n"
+                           "   |    (-)    | T\n"
+                           "   |           |\n"
+                           "   O-- FRONT --+\n"
+                           " (0,0)\n"), true);
         if (abl.verbose_level > 3)
-          print_topo_map(PSTR("\nCorrected Bed Height vs. Bed Topology:\n"), false);
+          print_topo_map(F("\nCorrected Bed Height vs. Bed Topology:\n"), false);
 
       } // abl.topography_map
 
     #endif // AUTO_BED_LEVELING_LINEAR
 
     #if ABL_PLANAR
 
       // For LINEAR and 3POINT leveling correct the current position
 
       if (abl.verbose_level > 0)
-        planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
+        planner.bed_level_matrix.debug(F("\n\nBed Level Correction Matrix:"));
 
       if (!abl.dryrun) {
         //
         // Correct the current XYZ position based on the tilted plane.
         //
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         xyze_pos_t converted = current_position;
         planner.force_unapply_leveling(converted); // use conversion machinery

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    🎨 Apply F() to status message

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 03b0450c6b..07aefe8aed 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -629,21 +629,21 @@ G29_TYPE GcodeSuite::G29() {
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
           if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
@@ -674,21 +674,21 @@ G29_TYPE GcodeSuite::G29() {
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing point ", i + 1, "/3.");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_POINT), int(i + 1)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_POINT), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = xy_pos_t(points[i]);
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
         if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
       }

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    🎨 Apply F() to G-code subcommands

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0eb13dba96..03b0450c6b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -237,21 +237,21 @@ G29_TYPE GcodeSuite::G29() {
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
   if (parser.seen_test('N'))
-    process_subcommands_now_P(TERN(CAN_SET_LEVELING_AFTER_G28, PSTR("G28L0"), G28_STR));
+    process_subcommands_now(TERN(CAN_SET_LEVELING_AFTER_G28, F("G28L0"), FPSTR(G28_STR)));
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
   #if ENABLED(AUTO_BED_LEVELING_3POINT)
     vector_3 points[3];
     probe.get_three_points(points);
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -875,21 +875,21 @@ G29_TYPE GcodeSuite::G29() {
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
-    process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
+    process_subcommands_now(F(Z_PROBE_END_SCRIPT));
   #endif
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedLeveling());
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   G29_RETURN(isnan(abl.measured_z));
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f756aa89df..0eb13dba96 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -372,21 +372,21 @@ G29_TYPE GcodeSuite::G29() {
         abl.probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
         abl.probe_position_rb.set(_MIN(abl.probe_position_lf.x + size, x_max), _MIN(abl.probe_position_lf.y + size, y_max));
       }
       else {
         abl.probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
         abl.probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
       }
 
       if (!probe.good_bounds(abl.probe_position_lf, abl.probe_position_rb)) {
         if (DEBUGGING(LEVELING)) {
-          DEBUG_ECHOLNPAIR("G29 L", abl.probe_position_lf.x, " R", abl.probe_position_rb.x,
+          DEBUG_ECHOLNPGM("G29 L", abl.probe_position_lf.x, " R", abl.probe_position_rb.x,
                               " F", abl.probe_position_lf.y, " B", abl.probe_position_rb.y);
         }
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false);
       }
 
       // Probe at the points of a lattice grid
       abl.gridSpacing.set((abl.probe_position_rb.x - abl.probe_position_lf.x) / (abl.grid_points.x - 1),
                             (abl.probe_position_rb.y - abl.probe_position_lf.y) / (abl.grid_points.y - 1));
 
@@ -463,21 +463,21 @@ G29_TYPE GcodeSuite::G29() {
       SET_SOFT_ENDSTOP_LOOSE(false);
       set_bed_leveling_enabled(abl.reenable);
       g29_in_progress = false;
       TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
     }
 
     // Query G29 status
     if (abl.verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress)
-        SERIAL_ECHOLNPAIR("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points), " of ", abl.abl_points);
+        SERIAL_ECHOLNPGM("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points), " of ", abl.abl_points);
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl.abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point
@@ -506,21 +506,21 @@ G29_TYPE GcodeSuite::G29() {
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
         points[index].z = abl.measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         const float newz = abl.measured_z + abl.Z_offset;
         z_values[abl.meshCount.x][abl.meshCount.y] = newz;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, newz));
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_P(PSTR("Save X"), abl.meshCount.x, SP_Y_STR, abl.meshCount.y, SP_Z_STR, abl.measured_z + abl.Z_offset);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM_P(PSTR("Save X"), abl.meshCount.x, SP_Y_STR, abl.meshCount.y, SP_Z_STR, abl.measured_z + abl.Z_offset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
     #if ABL_USES_GRID
 
@@ -628,21 +628,21 @@ G29_TYPE GcodeSuite::G29() {
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
-          if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
+          if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
@@ -673,21 +673,21 @@ G29_TYPE GcodeSuite::G29() {
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
-        if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
+        if (abl.verbose_level) SERIAL_ECHOLNPGM("Probing point ", i + 1, "/3.");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_POINT), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = xy_pos_t(points[i]);
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
         if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
@@ -835,59 +835,59 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         xyze_pos_t converted = current_position;
         planner.force_unapply_leveling(converted); // use conversion machinery
 
         // Use the last measured distance to the bed, if possible
         if ( NEAR(current_position.x, abl.probePos.x - probe.offset_xy.x)
           && NEAR(current_position.y, abl.probePos.y - probe.offset_xy.y)
         ) {
           const float simple_z = current_position.z - abl.measured_z;
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
           converted.z = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         current_position = converted;
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!abl.dryrun) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position.z);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
         const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
         current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = !abl.dryrun || abl.reenable;
   } // !isnan(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedLeveling());
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 

commit 0f61d9e4dd4d4e4f27e5c688ab2c5dbd0f03af84
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Sep 7 02:15:24 2021 -0500

    ✨ Ender-3 V2 CrealityUI Enhanced (#21942)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ca36f6d46e..f756aa89df 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -51,24 +51,24 @@
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
-#endif
-
-#if ENABLED(DWIN_CREALITY_LCD)
+#elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/e3v2/creality/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "../../../lcd/e3v2/enhanced/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
     #define PR_OUTER_SIZE abl.grid_points.x
@@ -396,24 +396,23 @@ G29_TYPE GcodeSuite::G29() {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
-    #endif
-
-    #if BOTH(AUTO_BED_LEVELING_BILINEAR, EXTENSIBLE_UI)
-      ExtUI::onMeshLevelingStart();
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshLevelingStart());
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_MeshLevelingStart());
     #endif
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
@@ -879,23 +878,21 @@ G29_TYPE GcodeSuite::G29() {
   if (planner.leveling_active) sync_plan_position();
 
   TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
-  #if ENABLED(DWIN_CREALITY_LCD)
-    DWIN_CompletedLeveling();
-  #endif
+  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedLeveling());
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   G29_RETURN(isnan(abl.measured_z));
 
 }
 
 #endif // HAS_ABL_NOT_UBL

commit d95d452b29b80e66d534b36c78262454664ce5a1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 29 23:02:53 2021 -0500

    🌐 MSG_PROBING_MESH => MSG_PROBING_POINT

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c3c8d3c92b..ca36f6d46e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -630,21 +630,21 @@ G29_TYPE GcodeSuite::G29() {
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
           if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl.abl_points)));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
           if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
@@ -675,21 +675,21 @@ G29_TYPE GcodeSuite::G29() {
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_POINT), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = xy_pos_t(points[i]);
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
         if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
       }

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    🎨 Misc code and spacing cleanup

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 29009c6e2d..c3c8d3c92b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -871,23 +871,21 @@ G29_TYPE GcodeSuite::G29() {
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = !abl.dryrun || abl.reenable;
   } // !isnan(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
-  #if HAS_BED_PROBE
-    probe.move_z_after_probing();
-  #endif
+  TERN_(HAS_BED_PROBE, probe.move_z_after_probing());
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif

commit 6464601411346c1da7bf15016b07c0fa9558a28c
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Aug 17 20:27:21 2021 -0700

    ⏪️ Revert ABL G29 feedrate (#22574)
    
    Reverts 9130f58

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 18e3862128..29009c6e2d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -356,22 +356,20 @@ G29_TYPE GcodeSuite::G29() {
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       abl.Z_offset = parser.linearval('Z');
 
     #endif
 
     #if ABL_USES_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_FEEDRATE));
-      if (!xy_probe_feedrate_mm_s) xy_probe_feedrate_mm_s = PLANNER_XY_FEEDRATE();
-      NOLESS(xy_probe_feedrate_mm_s, planner.settings.min_feedrate_mm_s);
 
       const float x_min = probe.min_x(), x_max = probe.max_x(),
                   y_min = probe.min_y(), y_max = probe.max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
         abl.probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
         abl.probe_position_rb.set(_MIN(abl.probe_position_lf.x + size, x_max), _MIN(abl.probe_position_lf.y + size, y_max));
       }
       else {

commit 9130f58f3f553584278ec716c617005b9e03cb49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Aug 4 16:37:02 2021 -0500

    🐛 Prevent ABL G29 setting a funky feedrate
    
    See #22472

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 29009c6e2d..18e3862128 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -356,20 +356,22 @@ G29_TYPE GcodeSuite::G29() {
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       abl.Z_offset = parser.linearval('Z');
 
     #endif
 
     #if ABL_USES_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_FEEDRATE));
+      if (!xy_probe_feedrate_mm_s) xy_probe_feedrate_mm_s = PLANNER_XY_FEEDRATE();
+      NOLESS(xy_probe_feedrate_mm_s, planner.settings.min_feedrate_mm_s);
 
       const float x_min = probe.min_x(), x_max = probe.max_x(),
                   y_min = probe.min_y(), y_max = probe.max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
         abl.probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
         abl.probe_position_rb.set(_MIN(abl.probe_position_lf.x + size, x_max), _MIN(abl.probe_position_lf.y + size, y_max));
       }
       else {

commit 9bb5b10c0c9cf5a61d2bfb9dfdb6cfe210b6002b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 31 05:32:13 2021 -0500

    🚚 Relocate and adjust DWIN E3V2 (#22471)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a88e089479..29009c6e2d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -54,21 +54,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../../../lcd/dwin/e3v2/dwin.h"
+  #include "../../../lcd/e3v2/creality/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR  abl.meshCount.x
     #define PR_OUTER_SIZE abl.grid_points.x

commit b6f720ca1ae1fb3a9998db168cbb4e87e14df9e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 30 22:43:58 2021 -0500

    ✅ Custom logging for MBL

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0c0fb07760..a88e089479 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -210,35 +210,33 @@ public:
  *  Y  Y for mesh point, overrides J
  *  Z  Z for mesh point. Otherwise, raw current Z.
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  */
 G29_TYPE GcodeSuite::G29() {
+  DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
+
   TERN_(PROBE_MANUALLY, static) G29_State abl;
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   reset_stepper_timeout();
 
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    const uint8_t old_debug_flags = marlin_debug_flags;
-    if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
-    DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
-    if (DEBUGGING(LEVELING)) log_machine_info();
-    marlin_debug_flags = old_debug_flags;
+    if (seenQ || DEBUGGING(LEVELING)) log_machine_info();
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen_test('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
@@ -465,24 +463,22 @@ G29_TYPE GcodeSuite::G29() {
       SERIAL_ECHOLNPGM("Manual G29 aborted");
       SET_SOFT_ENDSTOP_LOOSE(false);
       set_bed_leveling_enabled(abl.reenable);
       g29_in_progress = false;
       TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
     }
 
     // Query G29 status
     if (abl.verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
-      if (g29_in_progress) {
-        SERIAL_ECHOPAIR("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points));
-        SERIAL_ECHOLNPAIR(" of ", abl.abl_points);
-      }
+      if (g29_in_progress)
+        SERIAL_ECHOLNPAIR("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points), " of ", abl.abl_points);
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl.abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point

commit 46dc8e916f2b235dfcc73d258e66acf530cb51ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 29 19:34:49 2021 -0500

    🐛 Fix 3-point leveling position
    
    See #22457. Fixes a G29 regression from #19112.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 729bca93a6..0c0fb07760 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -561,21 +561,21 @@ G29_TYPE GcodeSuite::G29() {
         // Leveling done! Fall through to G29 finishing code below
         SERIAL_ECHOLNPGM("Grid probing done.");
         // Re-enable software endstops, if needed
         SET_SOFT_ENDSTOP_LOOSE(false);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl.abl_probe_index < abl.abl_points) {
-        abl.probePos = points[abl.abl_probe_index];
+        abl.probePos = xy_pos_t(points[abl.abl_probe_index]);
         _manual_goto_xy(abl.probePos);
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
         SET_SOFT_ENDSTOP_LOOSE(true);
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 

commit 0e1e1591879077cdda868a28b095c427098fda07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 10 02:05:04 2021 -0500

    🎨 Adjust some conditionals

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5760667bed..729bca93a6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -239,21 +239,21 @@ G29_TYPE GcodeSuite::G29() {
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
   if (parser.seen_test('N'))
-    process_subcommands_now_P(TERN(G28_L0_ENSURES_LEVELING_OFF, PSTR("G28L0"), G28_STR));
+    process_subcommands_now_P(TERN(CAN_SET_LEVELING_AFTER_G28, PSTR("G28L0"), G28_STR));
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
   #if ENABLED(AUTO_BED_LEVELING_3POINT)
     vector_3 points[3];
     probe.get_three_points(points);
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    🏗️ Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a8c3f45cdc..5760667bed 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -682,21 +682,21 @@ G29_TYPE GcodeSuite::G29() {
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
-        abl.probePos = points[i];
+        abl.probePos = xy_pos_t(points[i]);
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
         if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
       }
 
       if (!abl.dryrun && !isnan(abl.measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
@@ -788,21 +788,21 @@ G29_TYPE GcodeSuite::G29() {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](PGM_P const title, const bool get_min) {
           SERIAL_ECHOPGM_P(title);
           for (int8_t yy = abl.grid_points.y - 1; yy >= 0; yy--) {
             LOOP_L_N(xx, abl.grid_points.x) {
               const int ind = abl.indexIntoAB[xx][yy];
               xyz_float_t tmp = { abl.eqnAMatrix[ind + 0 * abl.abl_points],
                                   abl.eqnAMatrix[ind + 1 * abl.abl_points], 0 };
-              planner.bed_level_matrix.apply_rotation_xyz(tmp);
+              planner.bed_level_matrix.apply_rotation_xyz(tmp.x, tmp.y, tmp.z);
               if (get_min) NOMORE(min_diff, abl.eqnBVector[ind] - tmp.z);
               const float subval = get_min ? abl.mean : tmp.z + min_diff,
                             diff = abl.eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
               SERIAL_ECHO_F(diff, 5);
             } // xx
             SERIAL_EOL();
           } // yy
           SERIAL_EOL();
         };

commit 49548c343deb1e7f38f6027af20c02a79dbe5031
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 9 03:50:51 2021 -0500

    Optimize G-code flag parameters (#21849)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 3bd96ef495..a8c3f45cdc 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -216,43 +216,43 @@ public:
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  */
 G29_TYPE GcodeSuite::G29() {
   TERN_(PROBE_MANUALLY, static) G29_State abl;
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   reset_stepper_timeout();
 
-  const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
+  const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen_test('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
     if (DEBUGGING(LEVELING)) log_machine_info();
     marlin_debug_flags = old_debug_flags;
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
-  const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
+  const bool seenA = TERN0(PROBE_MANUALLY, parser.seen_test('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
-  if (parser.seen('N'))
+  if (parser.seen_test('N'))
     process_subcommands_now_P(TERN(G28_L0_ENSURES_LEVELING_OFF, PSTR("G28L0"), G28_STR));
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
   #if ENABLED(AUTO_BED_LEVELING_3POINT)
     vector_3 points[3];
     probe.get_three_points(points);
   #endif
 
@@ -268,21 +268,21 @@ G29_TYPE GcodeSuite::G29() {
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl.abl_probe_index = -1;
     #endif
 
     abl.reenable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      const bool seen_w = parser.seen('W');
+      const bool seen_w = parser.seen_test('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_MSG("No bilinear grid");
           G29_RETURN(false);
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position.z;
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
@@ -301,30 +301,30 @@ G29_TYPE GcodeSuite::G29() {
         }
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl.reenable);
           if (abl.reenable) report_current_position();
         }
         G29_RETURN(false);
-      } // parser.seen('W')
+      } // parser.seen_test('W')
 
     #else
 
       constexpr bool seen_w = false;
 
     #endif
 
     // Jettison bed leveling data
-    if (!seen_w && parser.seen('J')) {
+    if (!seen_w && parser.seen_test('J')) {
       reset_bed_level();
       G29_RETURN(false);
     }
 
     abl.verbose_level = parser.intval('V');
     if (!WITHIN(abl.verbose_level, 0, 4)) {
       SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
       G29_RETURN(false);
     }
 

commit ffbf7a9141ca886dfc799251ad5405dc0542c2af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 1 20:06:49 2021 -0500

    Fix undefined abl_points

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 735fad015e..3bd96ef495 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -90,44 +90,44 @@ public:
   int       verbose_level;
   xy_pos_t  probePos;
   float     measured_z;
   bool      dryrun,
             reenable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     int abl_probe_index;
   #endif
 
+  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+    int abl_points;
+  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+    static constexpr int abl_points = 3;
+  #elif ABL_USES_GRID
+    static constexpr int abl_points = GRID_MAX_POINTS;
+  #endif
+
   #if ABL_USES_GRID
 
     xy_int8_t meshCount;
 
     xy_pos_t probe_position_lf,
              probe_position_rb;
 
     xy_float_t gridSpacing; // = { 0.0f, 0.0f }
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       bool                topography_map;
       xy_uint8_t          grid_points;
     #else // Bilinear
       static constexpr xy_uint8_t grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
-    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      int abl_points;
-    #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-      static constexpr int abl_points = 3;
-    #else
-      static constexpr int abl_points = GRID_MAX_POINTS;
-    #endif
-
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       float Z_offset;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       float eqnAMatrix[(GRID_MAX_POINTS) * 3], // "A" matrix of the linear system of equations
             eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
             mean;
     #endif

commit b8cf818dac851f6d57de49f6f45cdfe2da884a00
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Sat Apr 17 10:54:43 2021 +0200

    Fix Realtime Reporting with G-code Motion Modes (#21630)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 8cc0a66216..735fad015e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -894,13 +894,14 @@ G29_TYPE GcodeSuite::G29() {
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   G29_RETURN(isnan(abl.measured_z));
+
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a10b2b89b1..8cc0a66216 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -281,25 +281,25 @@ G29_TYPE GcodeSuite::G29() {
           SERIAL_ERROR_MSG("No bilinear grid");
           G29_RETURN(false);
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position.z;
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
-        const float rx = RAW_X_POSITION(parser.linearval('X', MFNAN)),
-                    ry = RAW_Y_POSITION(parser.linearval('Y', MFNAN));
+        const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
+                    ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
-        if (!ISNAN(rx) && !ISNAN(ry)) {
+        if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start.x + 0.5 * abl.gridSpacing.x) / abl.gridSpacing.x;
           j = (ry - bilinear_start.y + 0.5 * abl.gridSpacing.y) / abl.gridSpacing.y;
           LIMIT(i, 0, (GRID_MAX_POINTS_X) - 1);
           LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
@@ -602,21 +602,21 @@ G29_TYPE GcodeSuite::G29() {
     abl.measured_z = 0;
 
     #if ABL_USES_GRID
 
       bool zig = PR_OUTER_SIZE & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       abl.measured_z = 0;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
-      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_SIZE && !ISNAN(abl.measured_z); PR_OUTER_VAR++) {
+      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_SIZE && !isnan(abl.measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) {                      // Zig away from origin
           inStart = 0;                  // Left or front
           inStop = PR_INNER_SIZE;       // Right or back
           inInc = 1;                    // Zig right
         }
         else {                          // Zag towards origin
           inStart = PR_INNER_SIZE - 1;  // Right or back
@@ -638,21 +638,21 @@ G29_TYPE GcodeSuite::G29() {
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
           if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
-          if (ISNAN(abl.measured_z)) {
+          if (isnan(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
             temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), abl.measured_z);
             TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), abl.measured_z));
           #endif
 
@@ -684,44 +684,44 @@ G29_TYPE GcodeSuite::G29() {
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = points[i];
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
-        if (ISNAN(abl.measured_z)) {
+        if (isnan(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
       }
 
-      if (!abl.dryrun && !ISNAN(abl.measured_z)) {
+      if (!abl.dryrun && !isnan(abl.measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     TERN_(HAS_STATUS_MESSAGE, ui.reset_status());
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
       set_bed_leveling_enabled(abl.reenable);
-      abl.measured_z = MFNAN;
+      abl.measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
   // definitely be enabled after this point.
   //
@@ -730,21 +730,21 @@ G29_TYPE GcodeSuite::G29() {
   //
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
   #endif
 
   // Calculate leveling, print reports, correct the position
-  if (!ISNAN(abl.measured_z)) {
+  if (!isnan(abl.measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!abl.dryrun) extrapolate_unprobed_bed_level();
       print_bilinear_leveling_grid();
 
       refresh_bed_level();
 
       TERN_(ABL_BILINEAR_SUBDIVISION, print_bilinear_leveling_grid_virt());
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -867,21 +867,21 @@ G29_TYPE GcodeSuite::G29() {
         const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
         current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = !abl.dryrun || abl.reenable;
-  } // !ISNAN(abl.measured_z)
+  } // !isnan(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
   #if HAS_BED_PROBE
     probe.move_z_after_probing();
   #endif
@@ -893,14 +893,14 @@ G29_TYPE GcodeSuite::G29() {
   #endif
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
-  G29_RETURN(ISNAN(abl.measured_z));
+  G29_RETURN(isnan(abl.measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 423857dbb0..a10b2b89b1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -210,23 +210,24 @@ public:
  *  Y  Y for mesh point, overrides J
  *  Z  Z for mesh point. Otherwise, raw current Z.
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  */
 G29_TYPE GcodeSuite::G29() {
-
   TERN_(PROBE_MANUALLY, static) G29_State abl;
 
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
+
   reset_stepper_timeout();
 
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
     if (DEBUGGING(LEVELING)) log_machine_info();
@@ -890,14 +891,16 @@ G29_TYPE GcodeSuite::G29() {
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif
 
   report_current_position();
 
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
+
   G29_RETURN(ISNAN(abl.measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 654a381383..423857dbb0 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -280,25 +280,25 @@ G29_TYPE GcodeSuite::G29() {
           SERIAL_ERROR_MSG("No bilinear grid");
           G29_RETURN(false);
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position.z;
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
-        const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
-                    ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
+        const float rx = RAW_X_POSITION(parser.linearval('X', MFNAN)),
+                    ry = RAW_Y_POSITION(parser.linearval('Y', MFNAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
-        if (!isnan(rx) && !isnan(ry)) {
+        if (!ISNAN(rx) && !ISNAN(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start.x + 0.5 * abl.gridSpacing.x) / abl.gridSpacing.x;
           j = (ry - bilinear_start.y + 0.5 * abl.gridSpacing.y) / abl.gridSpacing.y;
           LIMIT(i, 0, (GRID_MAX_POINTS_X) - 1);
           LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
         if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
@@ -601,21 +601,21 @@ G29_TYPE GcodeSuite::G29() {
     abl.measured_z = 0;
 
     #if ABL_USES_GRID
 
       bool zig = PR_OUTER_SIZE & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       abl.measured_z = 0;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
-      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_SIZE && !isnan(abl.measured_z); PR_OUTER_VAR++) {
+      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_SIZE && !ISNAN(abl.measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) {                      // Zig away from origin
           inStart = 0;                  // Left or front
           inStop = PR_INNER_SIZE;       // Right or back
           inInc = 1;                    // Zig right
         }
         else {                          // Zag towards origin
           inStart = PR_INNER_SIZE - 1;  // Right or back
@@ -637,21 +637,21 @@ G29_TYPE GcodeSuite::G29() {
           TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
           if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl.abl_points)));
 
           abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
-          if (isnan(abl.measured_z)) {
+          if (ISNAN(abl.measured_z)) {
             set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
             temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), abl.measured_z);
             TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), abl.measured_z));
           #endif
 
@@ -683,44 +683,44 @@ G29_TYPE GcodeSuite::G29() {
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
         abl.probePos = points[i];
         abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
-        if (isnan(abl.measured_z)) {
+        if (ISNAN(abl.measured_z)) {
           set_bed_leveling_enabled(abl.reenable);
           break;
         }
         points[i].z = abl.measured_z;
       }
 
-      if (!abl.dryrun && !isnan(abl.measured_z)) {
+      if (!abl.dryrun && !ISNAN(abl.measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl.reenable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     TERN_(HAS_STATUS_MESSAGE, ui.reset_status());
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
       set_bed_leveling_enabled(abl.reenable);
-      abl.measured_z = NAN;
+      abl.measured_z = MFNAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
   // definitely be enabled after this point.
   //
@@ -729,21 +729,21 @@ G29_TYPE GcodeSuite::G29() {
   //
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
   #endif
 
   // Calculate leveling, print reports, correct the position
-  if (!isnan(abl.measured_z)) {
+  if (!ISNAN(abl.measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!abl.dryrun) extrapolate_unprobed_bed_level();
       print_bilinear_leveling_grid();
 
       refresh_bed_level();
 
       TERN_(ABL_BILINEAR_SUBDIVISION, print_bilinear_leveling_grid_virt());
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -866,21 +866,21 @@ G29_TYPE GcodeSuite::G29() {
         const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
         current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = !abl.dryrun || abl.reenable;
-  } // !isnan(abl.measured_z)
+  } // !ISNAN(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
   #if HAS_BED_PROBE
     probe.move_z_after_probing();
   #endif
@@ -890,14 +890,14 @@ G29_TYPE GcodeSuite::G29() {
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif
 
   report_current_position();
 
-  G29_RETURN(isnan(abl.measured_z));
+  G29_RETURN(ISNAN(abl.measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 42d3a75da1..654a381383 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -288,24 +288,24 @@ G29_TYPE GcodeSuite::G29() {
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start.x + 0.5 * abl.gridSpacing.x) / abl.gridSpacing.x;
           j = (ry - bilinear_start.y + 0.5 * abl.gridSpacing.y) / abl.gridSpacing.y;
-          LIMIT(i, 0, GRID_MAX_POINTS_X - 1);
-          LIMIT(j, 0, GRID_MAX_POINTS_Y - 1);
+          LIMIT(i, 0, (GRID_MAX_POINTS_X) - 1);
+          LIMIT(j, 0, (GRID_MAX_POINTS_Y) - 1);
         }
-        if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
+        if (WITHIN(i, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(j, 0, (GRID_MAX_POINTS_Y) - 1)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl.reenable);
           if (abl.reenable) report_current_position();
         }
         G29_RETURN(false);
       } // parser.seen('W')
 

commit be775ed72db983ea150669ad6e0e094285b2fec2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 30 23:16:29 2021 -0500

    Move apply_rotation_xyz into matrix_3x3

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f3cfe02e40..42d3a75da1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -787,21 +787,21 @@ G29_TYPE GcodeSuite::G29() {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](PGM_P const title, const bool get_min) {
           SERIAL_ECHOPGM_P(title);
           for (int8_t yy = abl.grid_points.y - 1; yy >= 0; yy--) {
             LOOP_L_N(xx, abl.grid_points.x) {
               const int ind = abl.indexIntoAB[xx][yy];
               xyz_float_t tmp = { abl.eqnAMatrix[ind + 0 * abl.abl_points],
                                   abl.eqnAMatrix[ind + 1 * abl.abl_points], 0 };
-              apply_rotation_xyz(planner.bed_level_matrix, tmp);
+              planner.bed_level_matrix.apply_rotation_xyz(tmp);
               if (get_min) NOMORE(min_diff, abl.eqnBVector[ind] - tmp.z);
               const float subval = get_min ? abl.mean : tmp.z + min_diff,
                             diff = abl.eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
               SERIAL_ECHO_F(diff, 5);
             } // xx
             SERIAL_EOL();
           } // yy
           SERIAL_EOL();
         };

commit 8d083eb2488c6e4bd19bec8090b1673d60d2da2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 30 21:54:34 2021 -0500

    Put ABL state into a class

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a746b86108..f3cfe02e40 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -61,36 +61,91 @@
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../../../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
-#if ABL_GRID
+#if ABL_USES_GRID
   #if ENABLED(PROBE_Y_FIRST)
-    #define PR_OUTER_VAR meshCount.x
-    #define PR_OUTER_END abl_grid_points.x
-    #define PR_INNER_VAR meshCount.y
-    #define PR_INNER_END abl_grid_points.y
+    #define PR_OUTER_VAR  abl.meshCount.x
+    #define PR_OUTER_SIZE abl.grid_points.x
+    #define PR_INNER_VAR  abl.meshCount.y
+    #define PR_INNER_SIZE abl.grid_points.y
   #else
-    #define PR_OUTER_VAR meshCount.y
-    #define PR_OUTER_END abl_grid_points.y
-    #define PR_INNER_VAR meshCount.x
-    #define PR_INNER_END abl_grid_points.x
+    #define PR_OUTER_VAR  abl.meshCount.y
+    #define PR_OUTER_SIZE abl.grid_points.y
+    #define PR_INNER_VAR  abl.meshCount.x
+    #define PR_INNER_SIZE abl.grid_points.x
   #endif
 #endif
 
 #define G29_RETURN(b) return TERN_(G29_RETRY_AND_RECOVER, b)
 
+// For manual probing values persist over multiple G29
+class G29_State {
+public:
+  int       verbose_level;
+  xy_pos_t  probePos;
+  float     measured_z;
+  bool      dryrun,
+            reenable;
+
+  #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
+    int abl_probe_index;
+  #endif
+
+  #if ABL_USES_GRID
+
+    xy_int8_t meshCount;
+
+    xy_pos_t probe_position_lf,
+             probe_position_rb;
+
+    xy_float_t gridSpacing; // = { 0.0f, 0.0f }
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+      bool                topography_map;
+      xy_uint8_t          grid_points;
+    #else // Bilinear
+      static constexpr xy_uint8_t grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
+    #endif
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+      int abl_points;
+    #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+      static constexpr int abl_points = 3;
+    #else
+      static constexpr int abl_points = GRID_MAX_POINTS;
+    #endif
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+      float Z_offset;
+    #endif
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+      int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+      float eqnAMatrix[(GRID_MAX_POINTS) * 3], // "A" matrix of the linear system of equations
+            eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
+            mean;
+    #endif
+  #endif
+};
+
+#if ABL_USES_GRID && EITHER(AUTO_BED_LEVELING_3POINT, AUTO_BED_LEVELING_BILINEAR)
+  constexpr xy_uint8_t G29_State::grid_points;
+  constexpr int G29_State::abl_points;
+#endif
+
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
  *  O  Auto-level only if needed
  *
  *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
  *     or alter the bed level data. Useful to check the topology
@@ -156,20 +211,22 @@
  *  Z  Z for mesh point. Otherwise, raw current Z.
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  */
 G29_TYPE GcodeSuite::G29() {
 
+  TERN_(PROBE_MANUALLY, static) G29_State abl;
+
   reset_stepper_timeout();
 
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
     if (DEBUGGING(LEVELING)) log_machine_info();
@@ -186,94 +243,41 @@ G29_TYPE GcodeSuite::G29() {
     G29_RETURN(false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
   if (parser.seen('N'))
     process_subcommands_now_P(TERN(G28_L0_ENSURES_LEVELING_OFF, PSTR("G28L0"), G28_STR));
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
-  // Define local vars 'static' for manual probing, 'auto' otherwise
-  #define ABL_VAR TERN_(PROBE_MANUALLY, static)
-
-  ABL_VAR int verbose_level;
-  ABL_VAR xy_pos_t probePos;
-  ABL_VAR float measured_z;
-  ABL_VAR bool dryrun, abl_should_enable;
-
-  #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
-    ABL_VAR int abl_probe_index;
-  #endif
-
-  #if ABL_GRID
-
-    #if ENABLED(PROBE_MANUALLY)
-      ABL_VAR xy_int8_t meshCount;
-    #endif
-
-    ABL_VAR xy_pos_t probe_position_lf, probe_position_rb;
-    ABL_VAR xy_float_t gridSpacing = { 0, 0 };
-
-    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      ABL_VAR bool do_topography_map;
-      ABL_VAR xy_uint8_t abl_grid_points;
-    #else // Bilinear
-      constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
-    #endif
-
-    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      ABL_VAR int abl_points;
-    #else
-      int constexpr abl_points = GRID_MAX_POINTS;
-    #endif
-
-    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-      ABL_VAR float zoffset;
-
-    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
-
-      ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-
-      ABL_VAR float eqnAMatrix[(GRID_MAX_POINTS) * 3], // "A" matrix of the linear system of equations
-                    eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
-                    mean;
-    #endif
-
-  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-
-    #if ENABLED(PROBE_MANUALLY)
-      int constexpr abl_points = 3; // used to show total points
-    #endif
-
+  #if ENABLED(AUTO_BED_LEVELING_3POINT)
     vector_3 points[3];
     probe.get_three_points(points);
-
-  #endif // AUTO_BED_LEVELING_3POINT
+  #endif
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
-      abl_probe_index = -1;
+      abl.abl_probe_index = -1;
     #endif
 
-    abl_should_enable = planner.leveling_active;
+    abl.reenable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_MSG("No bilinear grid");
           G29_RETURN(false);
         }
 
@@ -282,443 +286,441 @@ G29_TYPE GcodeSuite::G29() {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
-          i = (rx - bilinear_start.x + 0.5 * gridSpacing.x) / gridSpacing.x;
-          j = (ry - bilinear_start.y + 0.5 * gridSpacing.y) / gridSpacing.y;
+          i = (rx - bilinear_start.x + 0.5 * abl.gridSpacing.x) / abl.gridSpacing.x;
+          j = (ry - bilinear_start.y + 0.5 * abl.gridSpacing.y) / abl.gridSpacing.y;
           LIMIT(i, 0, GRID_MAX_POINTS_X - 1);
           LIMIT(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
-          set_bed_leveling_enabled(abl_should_enable);
-          if (abl_should_enable) report_current_position();
+          set_bed_leveling_enabled(abl.reenable);
+          if (abl.reenable) report_current_position();
         }
         G29_RETURN(false);
       } // parser.seen('W')
 
     #else
 
       constexpr bool seen_w = false;
 
     #endif
 
     // Jettison bed leveling data
     if (!seen_w && parser.seen('J')) {
       reset_bed_level();
       G29_RETURN(false);
     }
 
-    verbose_level = parser.intval('V');
-    if (!WITHIN(verbose_level, 0, 4)) {
+    abl.verbose_level = parser.intval('V');
+    if (!WITHIN(abl.verbose_level, 0, 4)) {
       SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
       G29_RETURN(false);
     }
 
-    dryrun = parser.boolval('D') || TERN0(PROBE_MANUALLY, no_action);
+    abl.dryrun = parser.boolval('D') || TERN0(PROBE_MANUALLY, no_action);
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       incremental_LSF_reset(&lsf_results);
 
-      do_topography_map = verbose_level > 2 || parser.boolval('T');
+      abl.topography_map = abl.verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
-      abl_grid_points.set(
+      abl.grid_points.set(
         parser.byteval('X', GRID_MAX_POINTS_X),
         parser.byteval('Y', GRID_MAX_POINTS_Y)
       );
-      if (parser.seenval('P')) abl_grid_points.x = abl_grid_points.y = parser.value_int();
+      if (parser.seenval('P')) abl.grid_points.x = abl.grid_points.y = parser.value_int();
 
-      if (!WITHIN(abl_grid_points.x, 2, GRID_MAX_POINTS_X)) {
+      if (!WITHIN(abl.grid_points.x, 2, GRID_MAX_POINTS_X)) {
         SERIAL_ECHOLNPGM("?Probe points (X) implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
         G29_RETURN(false);
       }
-      if (!WITHIN(abl_grid_points.y, 2, GRID_MAX_POINTS_Y)) {
+      if (!WITHIN(abl.grid_points.y, 2, GRID_MAX_POINTS_Y)) {
         SERIAL_ECHOLNPGM("?Probe points (Y) implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
         G29_RETURN(false);
       }
 
-      abl_points = abl_grid_points.x * abl_grid_points.y;
-      mean = 0;
+      abl.abl_points = abl.grid_points.x * abl.grid_points.y;
+      abl.mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      zoffset = parser.linearval('Z');
+      abl.Z_offset = parser.linearval('Z');
 
     #endif
 
-    #if ABL_GRID
+    #if ABL_USES_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_FEEDRATE));
 
       const float x_min = probe.min_x(), x_max = probe.max_x(),
                   y_min = probe.min_y(), y_max = probe.max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
-        probe_position_rb.set(_MIN(probe_position_lf.x + size, x_max), _MIN(probe_position_lf.y + size, y_max));
+        abl.probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
+        abl.probe_position_rb.set(_MIN(abl.probe_position_lf.x + size, x_max), _MIN(abl.probe_position_lf.y + size, y_max));
       }
       else {
-        probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
-        probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
+        abl.probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
+        abl.probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
       }
 
-      if (!probe.good_bounds(probe_position_lf, probe_position_rb)) {
+      if (!probe.good_bounds(abl.probe_position_lf, abl.probe_position_rb)) {
         if (DEBUGGING(LEVELING)) {
-          DEBUG_ECHOLNPAIR("G29 L", probe_position_lf.x, " R", probe_position_rb.x,
-                              " F", probe_position_lf.y, " B", probe_position_rb.y);
+          DEBUG_ECHOLNPAIR("G29 L", abl.probe_position_lf.x, " R", abl.probe_position_rb.x,
+                              " F", abl.probe_position_lf.y, " B", abl.probe_position_rb.y);
         }
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false);
       }
 
       // Probe at the points of a lattice grid
-      gridSpacing.set((probe_position_rb.x - probe_position_lf.x) / (abl_grid_points.x - 1),
-                      (probe_position_rb.y - probe_position_lf.y) / (abl_grid_points.y - 1));
+      abl.gridSpacing.set((abl.probe_position_rb.x - abl.probe_position_lf.x) / (abl.grid_points.x - 1),
+                            (abl.probe_position_rb.y - abl.probe_position_lf.y) / (abl.grid_points.y - 1));
 
-    #endif // ABL_GRID
+    #endif // ABL_USES_GRID
 
-    if (verbose_level > 0) {
+    if (abl.verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
-      if (dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
+      if (abl.dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #endif
 
     #if BOTH(AUTO_BED_LEVELING_BILINEAR, EXTENSIBLE_UI)
       ExtUI::onMeshLevelingStart();
     #endif
 
     if (!faux) {
       remember_feedrate_scaling_off();
 
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
-        if (!dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
+        if (!abl.dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
     }
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
       if (ENABLED(BLTOUCH))
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       else if (probe.deploy()) {
-        set_bed_leveling_enabled(abl_should_enable);
+        set_bed_leveling_enabled(abl.reenable);
         G29_RETURN(false);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       if (TERN1(PROBE_MANUALLY, !no_action)
-        && (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start)
+        && (abl.gridSpacing != bilinear_grid_spacing || abl.probe_position_lf != bilinear_start)
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
-        bilinear_grid_spacing = gridSpacing;
-        bilinear_start = probe_position_lf;
+        bilinear_grid_spacing = abl.gridSpacing;
+        bilinear_start = abl.probe_position_lf;
 
         // Can't re-enable (on error) until the new grid is written
-        abl_should_enable = false;
+        abl.reenable = false;
       }
     #endif // AUTO_BED_LEVELING_BILINEAR
 
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
-      ++abl_probe_index;
+      ++abl.abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_ECHOLNPGM("Manual G29 aborted");
       SET_SOFT_ENDSTOP_LOOSE(false);
-      set_bed_leveling_enabled(abl_should_enable);
+      set_bed_leveling_enabled(abl.reenable);
       g29_in_progress = false;
       TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
     }
 
     // Query G29 status
-    if (verbose_level || seenQ) {
+    if (abl.verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress) {
-        SERIAL_ECHOPAIR("point ", _MIN(abl_probe_index + 1, abl_points));
-        SERIAL_ECHOLNPAIR(" of ", abl_points);
+        SERIAL_ECHOPAIR("point ", _MIN(abl.abl_probe_index + 1, abl.abl_points));
+        SERIAL_ECHOLNPAIR(" of ", abl.abl_points);
       }
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
-    if (abl_probe_index == 0) {
+    if (abl.abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
       #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
-        const uint16_t index = abl_probe_index - 1;
+        const uint16_t index = abl.abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
-      measured_z = current_position.z;
+      abl.measured_z = current_position.z;
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
-        mean += measured_z;
-        eqnBVector[index] = measured_z;
-        eqnAMatrix[index + 0 * abl_points] = probePos.x;
-        eqnAMatrix[index + 1 * abl_points] = probePos.y;
-        eqnAMatrix[index + 2 * abl_points] = 1;
+        abl.mean += abl.measured_z;
+        abl.eqnBVector[index] = abl.measured_z;
+        abl.eqnAMatrix[index + 0 * abl.abl_points] = abl.probePos.x;
+        abl.eqnAMatrix[index + 1 * abl.abl_points] = abl.probePos.y;
+        abl.eqnAMatrix[index + 2 * abl.abl_points] = 1;
 
-        incremental_LSF(&lsf_results, probePos, measured_z);
+        incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-        points[index].z = measured_z;
+        points[index].z = abl.measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-        const float newz = measured_z + zoffset;
-        z_values[meshCount.x][meshCount.y] = newz;
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, newz));
+        const float newz = abl.measured_z + abl.Z_offset;
+        z_values[abl.meshCount.x][abl.meshCount.y] = newz;
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, newz));
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_P(PSTR("Save X"), meshCount.x, SP_Y_STR, meshCount.y, SP_Z_STR, measured_z + zoffset);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_P(PSTR("Save X"), abl.meshCount.x, SP_Y_STR, abl.meshCount.y, SP_Z_STR, abl.measured_z + abl.Z_offset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
-    #if ABL_GRID
+    #if ABL_USES_GRID
 
       // Skip any unreachable points
-      while (abl_probe_index < abl_points) {
+      while (abl.abl_probe_index < abl.abl_points) {
 
-        // Set meshCount.x, meshCount.y based on abl_probe_index, with zig-zag
-        PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
-        PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
+        // Set abl.meshCount.x, abl.meshCount.y based on abl.abl_probe_index, with zig-zag
+        PR_OUTER_VAR = abl.abl_probe_index / PR_INNER_SIZE;
+        PR_INNER_VAR = abl.abl_probe_index - (PR_OUTER_VAR * PR_INNER_SIZE);
 
         // Probe in reverse order for every other row/column
-        const bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
-        if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
+        const bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_SIZE) & 1);
+        if (zig) PR_INNER_VAR = (PR_INNER_SIZE - 1) - PR_INNER_VAR;
 
-        probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
+        abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
-        TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = abl_probe_index);
+        TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = abl.abl_probe_index);
 
         // Keep looping till a reachable point is found
-        if (position_is_reachable(probePos)) break;
-        ++abl_probe_index;
+        if (position_is_reachable(abl.probePos)) break;
+        ++abl.abl_probe_index;
       }
 
       // Is there a next point to move to?
-      if (abl_probe_index < abl_points) {
-        _manual_goto_xy(probePos); // Can be used here too!
+      if (abl.abl_probe_index < abl.abl_points) {
+        _manual_goto_xy(abl.probePos); // Can be used here too!
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
         SET_SOFT_ENDSTOP_LOOSE(true);
         G29_RETURN(false);
       }
       else {
         // Leveling done! Fall through to G29 finishing code below
         SERIAL_ECHOLNPGM("Grid probing done.");
         // Re-enable software endstops, if needed
         SET_SOFT_ENDSTOP_LOOSE(false);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
-      if (abl_probe_index < abl_points) {
-        probePos = points[abl_probe_index];
-        _manual_goto_xy(probePos);
+      if (abl.abl_probe_index < abl.abl_points) {
+        abl.probePos = points[abl.abl_probe_index];
+        _manual_goto_xy(abl.probePos);
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
         SET_SOFT_ENDSTOP_LOOSE(true);
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         SET_SOFT_ENDSTOP_LOOSE(false);
 
-        if (!dryrun) {
+        if (!abl.dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) planeNormal *= -1;
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
           // Can't re-enable (on error) until the new grid is written
-          abl_should_enable = false;
+          abl.reenable = false;
         }
 
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
   #else // !PROBE_MANUALLY
   {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
-    measured_z = 0;
-
-    #if ABL_GRID
+    abl.measured_z = 0;
 
-      bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
+    #if ABL_USES_GRID
 
-      measured_z = 0;
+      bool zig = PR_OUTER_SIZE & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
-      xy_int8_t meshCount;
+      abl.measured_z = 0;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
-      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
+      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_SIZE && !isnan(abl.measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
-        if (zig) {                    // Zig away from origin
-          inStart = 0;                // Left or front
-          inStop = PR_INNER_END;      // Right or back
-          inInc = 1;                  // Zig right
+        if (zig) {                      // Zig away from origin
+          inStart = 0;                  // Left or front
+          inStop = PR_INNER_SIZE;       // Right or back
+          inInc = 1;                    // Zig right
         }
-        else {                        // Zag towards origin
-          inStart = PR_INNER_END - 1; // Right or back
-          inStop = -1;                // Left or front
-          inInc = -1;                 // Zag left
+        else {                          // Zag towards origin
+          inStart = PR_INNER_SIZE - 1;  // Right or back
+          inStop = -1;                  // Left or front
+          inInc = -1;                   // Zag left
         }
 
         zig ^= true; // zag
 
         // An index to print current state
-        uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
+        uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_SIZE) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
-          probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
+          abl.probePos = abl.probe_position_lf + abl.gridSpacing * abl.meshCount.asFloat();
 
-          TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
+          TERN_(AUTO_BED_LEVELING_LINEAR, abl.indexIntoAB[abl.meshCount.x][abl.meshCount.y] = ++abl.abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
-          if (TERN0(IS_KINEMATIC, !probe.can_reach(probePos))) continue;
+          if (TERN0(IS_KINEMATIC, !probe.can_reach(abl.probePos))) continue;
 
-          if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl_points, ".");
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl_points)));
+          if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl.abl_points, ".");
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl.abl_points)));
 
-          measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
+          abl.measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
 
-          if (isnan(measured_z)) {
-            set_bed_leveling_enabled(abl_should_enable);
+          if (isnan(abl.measured_z)) {
+            set_bed_leveling_enabled(abl.reenable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
-            temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), measured_z);
-            temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), measured_z);
-            TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), measured_z));
+            temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), abl.measured_z);
+            temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), abl.measured_z);
+            TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), abl.measured_z));
           #endif
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
-            mean += measured_z;
-            eqnBVector[abl_probe_index] = measured_z;
-            eqnAMatrix[abl_probe_index + 0 * abl_points] = probePos.x;
-            eqnAMatrix[abl_probe_index + 1 * abl_points] = probePos.y;
-            eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
+            abl.mean += abl.measured_z;
+            abl.eqnBVector[abl.abl_probe_index] = abl.measured_z;
+            abl.eqnAMatrix[abl.abl_probe_index + 0 * abl.abl_points] = abl.probePos.x;
+            abl.eqnAMatrix[abl.abl_probe_index + 1 * abl.abl_points] = abl.probePos.y;
+            abl.eqnAMatrix[abl.abl_probe_index + 2 * abl.abl_points] = 1;
 
-            incremental_LSF(&lsf_results, probePos, measured_z);
+            incremental_LSF(&lsf_results, abl.probePos, abl.measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-            const float z = measured_z + zoffset;
-            z_values[meshCount.x][meshCount.y] = z;
-            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, z));
+            const float z = abl.measured_z + abl.Z_offset;
+            z_values[abl.meshCount.x][abl.meshCount.y] = z;
+            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(abl.meshCount, z));
 
           #endif
 
-          abl_should_enable = false;
+          abl.reenable = false;
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
-        if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
+        if (abl.verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
-        probePos = points[i];
-        measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
-        if (isnan(measured_z)) {
-          set_bed_leveling_enabled(abl_should_enable);
+        abl.probePos = points[i];
+        abl.measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(abl.probePos, raise_after, abl.verbose_level);
+        if (isnan(abl.measured_z)) {
+          set_bed_leveling_enabled(abl.reenable);
           break;
         }
-        points[i].z = measured_z;
+        points[i].z = abl.measured_z;
       }
 
-      if (!dryrun && !isnan(measured_z)) {
+      if (!abl.dryrun && !isnan(abl.measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
-        abl_should_enable = false;
+        abl.reenable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     TERN_(HAS_STATUS_MESSAGE, ui.reset_status());
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
-      set_bed_leveling_enabled(abl_should_enable);
-      measured_z = NAN;
+      set_bed_leveling_enabled(abl.reenable);
+      abl.measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
   // definitely be enabled after this point.
   //
@@ -727,24 +729,24 @@ G29_TYPE GcodeSuite::G29() {
   //
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
   #endif
 
   // Calculate leveling, print reports, correct the position
-  if (!isnan(measured_z)) {
+  if (!isnan(abl.measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      if (!dryrun) extrapolate_unprobed_bed_level();
+      if (!abl.dryrun) extrapolate_unprobed_bed_level();
       print_bilinear_leveling_grid();
 
       refresh_bed_level();
 
       TERN_(ABL_BILINEAR_SUBDIVISION, print_bilinear_leveling_grid_virt());
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       // For LINEAR leveling calculate matrix, print reports, correct the position
 
@@ -756,129 +758,129 @@ G29_TYPE GcodeSuite::G29() {
        * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
        * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
        */
       struct { float a, b, d; } plane_equation_coefficients;
 
       finish_incremental_LSF(&lsf_results);
       plane_equation_coefficients.a = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
       plane_equation_coefficients.b = -lsf_results.B;  // but that is not yet tested.
       plane_equation_coefficients.d = -lsf_results.D;
 
-      mean /= abl_points;
+      abl.mean /= abl.abl_points;
 
-      if (verbose_level) {
+      if (abl.verbose_level) {
         SERIAL_ECHOPAIR_F("Eqn coefficients: a: ", plane_equation_coefficients.a, 8);
         SERIAL_ECHOPAIR_F(" b: ", plane_equation_coefficients.b, 8);
         SERIAL_ECHOPAIR_F(" d: ", plane_equation_coefficients.d, 8);
-        if (verbose_level > 2)
-          SERIAL_ECHOPAIR_F("\nMean of sampled points: ", mean, 8);
+        if (abl.verbose_level > 2)
+          SERIAL_ECHOPAIR_F("\nMean of sampled points: ", abl.mean, 8);
         SERIAL_EOL();
       }
 
       // Create the matrix but don't correct the position yet
-      if (!dryrun)
+      if (!abl.dryrun)
         planner.bed_level_matrix = matrix_3x3::create_look_at(
           vector_3(-plane_equation_coefficients.a, -plane_equation_coefficients.b, 1)    // We can eliminate the '-' here and up above
         );
 
       // Show the Topography map if enabled
-      if (do_topography_map) {
+      if (abl.topography_map) {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](PGM_P const title, const bool get_min) {
           SERIAL_ECHOPGM_P(title);
-          for (int8_t yy = abl_grid_points.y - 1; yy >= 0; yy--) {
-            LOOP_L_N(xx, abl_grid_points.x) {
-              const int ind = indexIntoAB[xx][yy];
-              xyz_float_t tmp = { eqnAMatrix[ind + 0 * abl_points],
-                                  eqnAMatrix[ind + 1 * abl_points], 0 };
+          for (int8_t yy = abl.grid_points.y - 1; yy >= 0; yy--) {
+            LOOP_L_N(xx, abl.grid_points.x) {
+              const int ind = abl.indexIntoAB[xx][yy];
+              xyz_float_t tmp = { abl.eqnAMatrix[ind + 0 * abl.abl_points],
+                                  abl.eqnAMatrix[ind + 1 * abl.abl_points], 0 };
               apply_rotation_xyz(planner.bed_level_matrix, tmp);
-              if (get_min) NOMORE(min_diff, eqnBVector[ind] - tmp.z);
-              const float subval = get_min ? mean : tmp.z + min_diff,
-                            diff = eqnBVector[ind] - subval;
+              if (get_min) NOMORE(min_diff, abl.eqnBVector[ind] - tmp.z);
+              const float subval = get_min ? abl.mean : tmp.z + min_diff,
+                            diff = abl.eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
               SERIAL_ECHO_F(diff, 5);
             } // xx
             SERIAL_EOL();
           } // yy
           SERIAL_EOL();
         };
 
         print_topo_map(PSTR("\nBed Height Topography:\n"
                                "   +--- BACK --+\n"
                                "   |           |\n"
                                " L |    (+)    | R\n"
                                " E |           | I\n"
                                " F | (-) N (+) | G\n"
                                " T |           | H\n"
                                "   |    (-)    | T\n"
                                "   |           |\n"
                                "   O-- FRONT --+\n"
                                " (0,0)\n"), true);
-        if (verbose_level > 3)
+        if (abl.verbose_level > 3)
           print_topo_map(PSTR("\nCorrected Bed Height vs. Bed Topology:\n"), false);
 
-      } //do_topography_map
+      } // abl.topography_map
 
     #endif // AUTO_BED_LEVELING_LINEAR
 
     #if ABL_PLANAR
 
       // For LINEAR and 3POINT leveling correct the current position
 
-      if (verbose_level > 0)
+      if (abl.verbose_level > 0)
         planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
 
-      if (!dryrun) {
+      if (!abl.dryrun) {
         //
         // Correct the current XYZ position based on the tilted plane.
         //
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         xyze_pos_t converted = current_position;
         planner.force_unapply_leveling(converted); // use conversion machinery
 
         // Use the last measured distance to the bed, if possible
-        if ( NEAR(current_position.x, probePos.x - probe.offset_xy.x)
-          && NEAR(current_position.y, probePos.y - probe.offset_xy.y)
+        if ( NEAR(current_position.x, abl.probePos.x - probe.offset_xy.x)
+          && NEAR(current_position.y, abl.probePos.y - probe.offset_xy.y)
         ) {
-          const float simple_z = current_position.z - measured_z;
+          const float simple_z = current_position.z - abl.measured_z;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
           converted.z = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         current_position = converted;
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      if (!dryrun) {
+      if (!abl.dryrun) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
         const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
         current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
-    planner.leveling_active = dryrun ? abl_should_enable : true;
-  } // !isnan(measured_z)
+    planner.leveling_active = !abl.dryrun || abl.reenable;
+  } // !isnan(abl.measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
   #if HAS_BED_PROBE
     probe.move_z_after_probing();
   #endif
@@ -888,14 +890,14 @@ G29_TYPE GcodeSuite::G29() {
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif
 
   report_current_position();
 
-  G29_RETURN(isnan(measured_z));
+  G29_RETURN(isnan(abl.measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e642c1ccf2..a746b86108 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -34,21 +34,21 @@
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../../../feature/probe_temp_comp.h"
   #include "../../../module/temperature.h"
 #endif
 
-#if HAS_DISPLAY
+#if HAS_STATUS_MESSAGE
   #include "../../../lcd/marlinui.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
@@ -631,21 +631,21 @@ G29_TYPE GcodeSuite::G29() {
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(probePos))) continue;
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl_points, ".");
-          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl_points)));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl_points)));
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), measured_z);
@@ -676,21 +676,21 @@ G29_TYPE GcodeSuite::G29() {
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
-        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
@@ -699,21 +699,21 @@ G29_TYPE GcodeSuite::G29() {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
-    TERN_(HAS_DISPLAY, ui.reset_status());
+    TERN_(HAS_STATUS_MESSAGE, ui.reset_status());
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
       set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 233e7f7415..e642c1ccf2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -779,21 +779,21 @@ G29_TYPE GcodeSuite::G29() {
         planner.bed_level_matrix = matrix_3x3::create_look_at(
           vector_3(-plane_equation_coefficients.a, -plane_equation_coefficients.b, 1)    // We can eliminate the '-' here and up above
         );
 
       // Show the Topography map if enabled
       if (do_topography_map) {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](PGM_P const title, const bool get_min) {
-          serialprintPGM(title);
+          SERIAL_ECHOPGM_P(title);
           for (int8_t yy = abl_grid_points.y - 1; yy >= 0; yy--) {
             LOOP_L_N(xx, abl_grid_points.x) {
               const int ind = indexIntoAB[xx][yy];
               xyz_float_t tmp = { eqnAMatrix[ind + 0 * abl_points],
                                   eqnAMatrix[ind + 1 * abl_points], 0 };
               apply_rotation_xyz(planner.bed_level_matrix, tmp);
               if (get_min) NOMORE(min_diff, eqnBVector[ind] - tmp.z);
               const float subval = get_min ? mean : tmp.z + min_diff,
                             diff = eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment

commit ee7701c15bc91f7a05f973e03624fb14815f5027
Author: jbuck2005 <59450931+jbuck2005@users.noreply.github.com>
Date:   Sat Feb 27 16:54:43 2021 -0500

    SPEED => FEEDRATE (#21217)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index b1e9fcedaa..233e7f7415 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -352,21 +352,21 @@ G29_TYPE GcodeSuite::G29() {
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
-      xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
+      xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_FEEDRATE));
 
       const float x_min = probe.min_x(), x_max = probe.max_x(),
                   y_min = probe.min_y(), y_max = probe.max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
         probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
         probe_position_rb.set(_MIN(probe_position_lf.x + size, x_max), _MIN(probe_position_lf.y + size, y_max));
       }
       else {

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 2e80f090a4..b1e9fcedaa 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -630,21 +630,21 @@ G29_TYPE GcodeSuite::G29() {
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(probePos))) continue;
 
-          if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", abl_points, ".");
+          if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", pt_index, "/", abl_points, ".");
           TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl_points)));
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
@@ -675,21 +675,21 @@ G29_TYPE GcodeSuite::G29() {
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
-        if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i + 1), "/3.");
+        if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", i + 1, "/3.");
         TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 28ffd59edc..2e80f090a4 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -181,21 +181,21 @@ G29_TYPE GcodeSuite::G29() {
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Send 'N' to force homing before G29 (internal only)
   if (parser.seen('N'))
-    gcode.process_subcommands_now_P(TERN(G28_L0_ENSURES_LEVELING_OFF, PSTR("G28L0"), G28_STR));
+    process_subcommands_now_P(TERN(G28_L0_ENSURES_LEVELING_OFF, PSTR("G28L0"), G28_STR));
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #define ABL_VAR TERN_(PROBE_MANUALLY, static)
 
   ABL_VAR int verbose_level;
   ABL_VAR xy_pos_t probePos;
   ABL_VAR float measured_z;

commit bb597dcf66ac0baa3f3528bb34c3b4aad78ad520
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 17 12:08:40 2021 -0600

    Internal G29N for G28+G29 (#20800)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 8e87bb4f7d..28ffd59edc 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -174,28 +174,32 @@ G29_TYPE GcodeSuite::G29() {
     DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
     if (DEBUGGING(LEVELING)) log_machine_info();
     marlin_debug_flags = old_debug_flags;
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
-  // Don't allow auto-leveling without homing first
-  if (homing_needed_error()) G29_RETURN(false);
-
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
+  // Send 'N' to force homing before G29 (internal only)
+  if (parser.seen('N'))
+    gcode.process_subcommands_now_P(TERN(G28_L0_ENSURES_LEVELING_OFF, PSTR("G28L0"), G28_STR));
+
+  // Don't allow auto-leveling without homing first
+  if (homing_needed_error()) G29_RETURN(false);
+
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #define ABL_VAR TERN_(PROBE_MANUALLY, static)
 
   ABL_VAR int verbose_level;
   ABL_VAR xy_pos_t probePos;
   ABL_VAR float measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
@@ -242,21 +246,20 @@ G29_TYPE GcodeSuite::G29() {
       int constexpr abl_points = 3; // used to show total points
     #endif
 
     vector_3 points[3];
     probe.get_three_points(points);
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
-    incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
@@ -317,20 +320,22 @@ G29_TYPE GcodeSuite::G29() {
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
       SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
       G29_RETURN(false);
     }
 
     dryrun = parser.boolval('D') || TERN0(PROBE_MANUALLY, no_action);
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
+      incremental_LSF_reset(&lsf_results);
+
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl_grid_points.set(
         parser.byteval('X', GRID_MAX_POINTS_X),
         parser.byteval('Y', GRID_MAX_POINTS_Y)
       );
       if (parser.seenval('P')) abl_grid_points.x = abl_grid_points.y = parser.value_int();
 

commit 7a168205eb2463022ab1a4306bafa8152ab2d8bc
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:02:38 2020 -0500

    Minimum temp options for Probing and G12 Nozzle Clean (#20383)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 157353c063..8e87bb4f7d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,26 +29,23 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
-#if EITHER(PROBE_TEMP_COMPENSATION, PREHEAT_BEFORE_LEVELING)
-  #include "../../../module/temperature.h"
-#endif
-
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../../../feature/probe_temp_comp.h"
+  #include "../../../module/temperature.h"
 #endif
 
 #if HAS_DISPLAY
   #include "../../../lcd/marlinui.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
@@ -397,39 +394,27 @@ G29_TYPE GcodeSuite::G29() {
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #endif
 
     #if BOTH(AUTO_BED_LEVELING_BILINEAR, EXTENSIBLE_UI)
       ExtUI::onMeshLevelingStart();
     #endif
 
-    if (!faux) remember_feedrate_scaling_off();
+    if (!faux) {
+      remember_feedrate_scaling_off();
 
-    #if ENABLED(PREHEAT_BEFORE_LEVELING)
-      #ifndef LEVELING_NOZZLE_TEMP
-        #define LEVELING_NOZZLE_TEMP 0
+      #if ENABLED(PREHEAT_BEFORE_LEVELING)
+        if (!dryrun) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
       #endif
-      #ifndef LEVELING_BED_TEMP
-        #define LEVELING_BED_TEMP 0
-      #endif
-      if (!dryrun && !faux) {
-        constexpr uint16_t hotendPreheat = LEVELING_NOZZLE_TEMP, bedPreheat = LEVELING_BED_TEMP;
-        if (DEBUGGING(LEVELING))
-          DEBUG_ECHOLNPAIR("Preheating hotend (", hotendPreheat, ") and bed (", bedPreheat, ")");
-        if (hotendPreheat) thermalManager.setTargetHotend(hotendPreheat, 0);
-        if (bedPreheat)    thermalManager.setTargetBed(bedPreheat);
-        if (hotendPreheat) thermalManager.wait_for_hotend(0);
-        if (bedPreheat)    thermalManager.wait_for_bed_heating();
-      }
-    #endif
+    }
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
       if (ENABLED(BLTOUCH))
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       else if (probe.deploy()) {

commit e349a44c6013a4a9d8d218e02dd334f70f3a79ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 5 19:56:16 2020 -0600

    Preheat before leveling

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 05260955bf..157353c063 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,23 +29,26 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
+#if EITHER(PROBE_TEMP_COMPENSATION, PREHEAT_BEFORE_LEVELING)
+  #include "../../../module/temperature.h"
+#endif
+
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../../../feature/probe_temp_comp.h"
-  #include "../../../module/temperature.h"
 #endif
 
 #if HAS_DISPLAY
   #include "../../../lcd/marlinui.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
@@ -396,20 +399,38 @@ G29_TYPE GcodeSuite::G29() {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #endif
 
     #if BOTH(AUTO_BED_LEVELING_BILINEAR, EXTENSIBLE_UI)
       ExtUI::onMeshLevelingStart();
     #endif
 
     if (!faux) remember_feedrate_scaling_off();
 
+    #if ENABLED(PREHEAT_BEFORE_LEVELING)
+      #ifndef LEVELING_NOZZLE_TEMP
+        #define LEVELING_NOZZLE_TEMP 0
+      #endif
+      #ifndef LEVELING_BED_TEMP
+        #define LEVELING_BED_TEMP 0
+      #endif
+      if (!dryrun && !faux) {
+        constexpr uint16_t hotendPreheat = LEVELING_NOZZLE_TEMP, bedPreheat = LEVELING_BED_TEMP;
+        if (DEBUGGING(LEVELING))
+          DEBUG_ECHOLNPAIR("Preheating hotend (", hotendPreheat, ") and bed (", bedPreheat, ")");
+        if (hotendPreheat) thermalManager.setTargetHotend(hotendPreheat, 0);
+        if (bedPreheat)    thermalManager.setTargetBed(bedPreheat);
+        if (hotendPreheat) thermalManager.wait_for_hotend(0);
+        if (bedPreheat)    thermalManager.wait_for_bed_heating();
+      }
+    #endif
+
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
       if (ENABLED(BLTOUCH))
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       else if (probe.deploy()) {
         set_bed_leveling_enabled(abl_should_enable);

commit 3404cb1fc4eced0f608cdea4e752e20daf9f9112
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Dec 9 12:07:26 2020 -0500

    Move ExtUI ABL mesh edit, limit to bilinear (#20381)
    
    * Move ExtUI call
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>
    Co-authored-by: Victor Mateus Oliveira <rhapsodyv@gmail.com>
    Co-authored-by: Sebastiaan Dammann <sebastiaandammann@outlook.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 15555d5f8d..05260955bf 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -170,22 +170,20 @@ G29_TYPE GcodeSuite::G29() {
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
     if (DEBUGGING(LEVELING)) log_machine_info();
     marlin_debug_flags = old_debug_flags;
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
-  TERN_(EXTENSIBLE_UI, ExtUI::onMeshLevelingStart());
-
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
@@ -392,20 +390,24 @@ G29_TYPE GcodeSuite::G29() {
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
       points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
     #endif
 
+    #if BOTH(AUTO_BED_LEVELING_BILINEAR, EXTENSIBLE_UI)
+      ExtUI::onMeshLevelingStart();
+    #endif
+
     if (!faux) remember_feedrate_scaling_off();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
       if (ENABLED(BLTOUCH))
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);

commit a8dffdebd4afff1f161af492086e95e70bf76928
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 5 19:57:50 2020 -0600

    Move G29 3-point startup earlier

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 653c632f1a..15555d5f8d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -387,63 +387,57 @@ G29_TYPE GcodeSuite::G29() {
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
+    #if ENABLED(AUTO_BED_LEVELING_3POINT)
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
+      points[0].z = points[1].z = points[2].z = 0;  // Probe at 3 arbitrary points
+    #endif
+
     if (!faux) remember_feedrate_scaling_off();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
       if (ENABLED(BLTOUCH))
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       else if (probe.deploy()) {
         set_bed_leveling_enabled(abl_should_enable);
         G29_RETURN(false);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
       if (TERN1(PROBE_MANUALLY, !no_action)
         && (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start)
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
         bilinear_grid_spacing = gridSpacing;
         bilinear_start = probe_position_lf;
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
-
     #endif // AUTO_BED_LEVELING_BILINEAR
 
-    #if ENABLED(AUTO_BED_LEVELING_3POINT)
-
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
-
-      // Probe at 3 arbitrary points
-      points[0].z = points[1].z = points[2].z = 0;
-
-    #endif // AUTO_BED_LEVELING_3POINT
-
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl_probe_index;
       g29_in_progress = true;
     }

commit 889695b6ba54ec56ca7ed7fd50d597c29a854687
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 5 16:45:22 2020 -0600

    ExtUI homing / leveling additions

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9999d92e22..653c632f1a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -170,20 +170,22 @@ G29_TYPE GcodeSuite::G29() {
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
     if (DEBUGGING(LEVELING)) log_machine_info();
     marlin_debug_flags = old_debug_flags;
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
+  TERN_(EXTENSIBLE_UI, ExtUI::onMeshLevelingStart());
+
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   // Don't allow auto-leveling without homing first
   if (homing_needed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);

commit b28b2ca26674219d6654cd287bb9da30c91b2231
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 24 17:53:26 2020 -0600

    Cosmetic G29 ABL tweak

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f387dd9bd8..9999d92e22 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -649,22 +649,23 @@ G29_TYPE GcodeSuite::G29() {
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl_points] = probePos.x;
             eqnAMatrix[abl_probe_index + 1 * abl_points] = probePos.y;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
             incremental_LSF(&lsf_results, probePos, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-            z_values[meshCount.x][meshCount.y] = measured_z + zoffset;
-            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, z_values[meshCount.x][meshCount.y]));
+            const float z = measured_z + zoffset;
+            z_values[meshCount.x][meshCount.y] = z;
+            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, z));
 
           #endif
 
           abl_should_enable = false;
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)

commit 6375829448eebe01b2835689aac69b73b63ebfd8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 18 16:53:12 2020 -0400

    Apply home offsets to probing, Z Safe Homing (#19423)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index fcdab742cf..f387dd9bd8 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -354,46 +354,38 @@ G29_TYPE GcodeSuite::G29() {
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       const float x_min = probe.min_x(), x_max = probe.max_x(),
                   y_min = probe.min_y(), y_max = probe.max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        probe_position_lf.set(
-          _MAX(X_CENTER - size / 2, x_min),
-          _MAX(Y_CENTER - size / 2, y_min)
-        );
-        probe_position_rb.set(
-          _MIN(probe_position_lf.x + size, x_max),
-          _MIN(probe_position_lf.y + size, y_max)
-        );
+        probe_position_lf.set(_MAX((X_CENTER) - size / 2, x_min), _MAX((Y_CENTER) - size / 2, y_min));
+        probe_position_rb.set(_MIN(probe_position_lf.x + size, x_max), _MIN(probe_position_lf.y + size, y_max));
       }
       else {
-        probe_position_lf.set(
-          parser.seenval('L') ? RAW_X_POSITION(parser.value_linear_units()) : x_min,
-          parser.seenval('F') ? RAW_Y_POSITION(parser.value_linear_units()) : y_min
-        );
-        probe_position_rb.set(
-          parser.seenval('R') ? RAW_X_POSITION(parser.value_linear_units()) : x_max,
-          parser.seenval('B') ? RAW_Y_POSITION(parser.value_linear_units()) : y_max
-        );
+        probe_position_lf.set(parser.linearval('L', x_min), parser.linearval('F', y_min));
+        probe_position_rb.set(parser.linearval('R', x_max), parser.linearval('B', y_max));
       }
 
       if (!probe.good_bounds(probe_position_lf, probe_position_rb)) {
+        if (DEBUGGING(LEVELING)) {
+          DEBUG_ECHOLNPAIR("G29 L", probe_position_lf.x, " R", probe_position_rb.x,
+                              " F", probe_position_lf.y, " B", probe_position_rb.y);
+        }
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false);
       }
 
-      // probe at the points of a lattice grid
+      // Probe at the points of a lattice grid
       gridSpacing.set((probe_position_rb.x - probe_position_lf.x) / (abl_grid_points.x - 1),
                       (probe_position_rb.y - probe_position_lf.y) / (abl_grid_points.y - 1));
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f7de6c8cee..fcdab742cf 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -35,21 +35,21 @@
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../../../feature/probe_temp_comp.h"
   #include "../../../module/temperature.h"
 #endif
 
 #if HAS_DISPLAY
-  #include "../../../lcd/ultralcd.h"
+  #include "../../../lcd/marlinui.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
 

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e9b6e0e3a6..f7de6c8cee 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -194,24 +194,20 @@ G29_TYPE GcodeSuite::G29() {
 
   ABL_VAR int verbose_level;
   ABL_VAR xy_pos_t probePos;
   ABL_VAR float measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
   #endif
 
-  #if BOTH(HAS_SOFTWARE_ENDSTOPS, PROBE_MANUALLY)
-    ABL_VAR bool saved_soft_endstops_state = true;
-  #endif
-
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
       ABL_VAR xy_int8_t meshCount;
     #endif
 
     ABL_VAR xy_pos_t probe_position_lf, probe_position_rb;
     ABL_VAR xy_float_t gridSpacing = { 0, 0 };
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -454,42 +450,42 @@ G29_TYPE GcodeSuite::G29() {
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_ECHOLNPGM("Manual G29 aborted");
-      TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
+      SET_SOFT_ENDSTOP_LOOSE(false);
       set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
       TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress) {
         SERIAL_ECHOPAIR("point ", _MIN(abl_probe_index + 1, abl_points));
         SERIAL_ECHOLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
-      TERN_(HAS_SOFTWARE_ENDSTOPS, saved_soft_endstops_state = soft_endstops_enabled);
+      SET_SOFT_ENDSTOP_LOOSE(true);
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
       #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
@@ -545,47 +541,47 @@ G29_TYPE GcodeSuite::G29() {
         // Keep looping till a reachable point is found
         if (position_is_reachable(probePos)) break;
         ++abl_probe_index;
       }
 
       // Is there a next point to move to?
       if (abl_probe_index < abl_points) {
         _manual_goto_xy(probePos); // Can be used here too!
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
-        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = false);
+        SET_SOFT_ENDSTOP_LOOSE(true);
         G29_RETURN(false);
       }
       else {
         // Leveling done! Fall through to G29 finishing code below
         SERIAL_ECHOLNPGM("Grid probing done.");
         // Re-enable software endstops, if needed
-        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
+        SET_SOFT_ENDSTOP_LOOSE(false);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl_probe_index < abl_points) {
         probePos = points[abl_probe_index];
         _manual_goto_xy(probePos);
         // Disable software endstops to allow manual adjustment
         // If G29 is not completed, they will not be re-enabled
-        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = false);
+        SET_SOFT_ENDSTOP_LOOSE(true);
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
-        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
+        SET_SOFT_ENDSTOP_LOOSE(false);
 
         if (!dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) planeNormal *= -1;
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
           // Can't re-enable (on error) until the new grid is written
           abl_should_enable = false;
         }
 

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9bb1ebe238..e9b6e0e3a6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -153,21 +153,20 @@
  *  J  Y index for mesh point
  *  X  X for mesh point, overrides I
  *  Y  Y for mesh point, overrides J
  *  Z  Z for mesh point. Otherwise, raw current Z.
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
- *
  */
 G29_TYPE GcodeSuite::G29() {
 
   reset_stepper_timeout();
 
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;

commit a445746a8b6dd752de725eb67d264153c3b393d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 6 21:40:58 2020 -0500

    Clean up LCD conditionals, DWIN

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e7651cc743..9bb1ebe238 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -54,21 +54,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../../../lcd/dwin/dwin.h"
+  #include "../../../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR meshCount.x
     #define PR_OUTER_END abl_grid_points.x

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f25fe32b07..e7651cc743 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -176,21 +176,21 @@ G29_TYPE GcodeSuite::G29() {
     if (DEBUGGING(LEVELING)) log_machine_info();
     marlin_debug_flags = old_debug_flags;
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   // Don't allow auto-leveling without homing first
-  if (axis_unhomed_error()) G29_RETURN(false);
+  if (homing_needed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #define ABL_VAR TERN_(PROBE_MANUALLY, static)
 
   ABL_VAR int verbose_level;

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index cc3007c54a..f25fe32b07 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * G29.cpp - Auto Bed Leveling
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if HAS_ABL_NOT_UBL

commit c9718504c5f98b09c062f2b56db1ca59e92d27c9
Author: Leo <leo@nutz.de>
Date:   Wed Jul 15 00:02:38 2020 +0200

    Fix leveling "Point n of 3" message (#18639)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9a86118046..cc3007c54a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -678,22 +678,22 @@ G29_TYPE GcodeSuite::G29() {
           idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
-        if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
-        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i)));
+        if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i + 1), "/3.");
+        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i + 1)));
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index dcb465f1d1..9a86118046 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -165,37 +165,35 @@
 G29_TYPE GcodeSuite::G29() {
 
   reset_stepper_timeout();
 
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_POS(">>> G29", current_position);
-      log_machine_info();
-    }
+    DEBUG_SECTION(log_G29, "G29", DEBUGGING(LEVELING));
+    if (DEBUGGING(LEVELING)) log_machine_info();
     marlin_debug_flags = old_debug_flags;
     if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
   const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
          no_action = seenA || seenQ,
               faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   // Don't allow auto-leveling without homing first
   if (axis_unhomed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip\n<<< G29");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip");
     G29_RETURN(false);
   }
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #define ABL_VAR TERN_(PROBE_MANUALLY, static)
 
   ABL_VAR int verbose_level;
   ABL_VAR xy_pos_t probePos;
   ABL_VAR float measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
@@ -409,21 +407,21 @@ G29_TYPE GcodeSuite::G29() {
 
     if (!faux) remember_feedrate_scaling_off();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
       if (ENABLED(BLTOUCH))
-        do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+        do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       else if (probe.deploy()) {
         set_bed_leveling_enabled(abl_should_enable);
         G29_RETURN(false);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (TERN1(PROBE_MANUALLY, !no_action)
         && (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start)
@@ -877,32 +875,30 @@ G29_TYPE GcodeSuite::G29() {
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   // Sync the planner from the current_position
   if (planner.leveling_active) sync_plan_position();
 
-  #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
+  #if HAS_BED_PROBE
     probe.move_z_after_probing();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   #if ENABLED(DWIN_CREALITY_LCD)
     DWIN_CompletedLeveling();
   #endif
 
   report_current_position();
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
-
   G29_RETURN(isnan(measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 67db7c02948a4b1b3b69391881157b843cf5e91f
Author: Oliver Jean Eifler <olli.eifler@gmail.com>
Date:   Sun Jul 5 22:32:04 2020 +0200

    Probing points followup (#18552)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ac991095a2..dcb465f1d1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -219,21 +219,21 @@ G29_TYPE GcodeSuite::G29() {
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR bool do_topography_map;
       ABL_VAR xy_uint8_t abl_grid_points;
     #else // Bilinear
       constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR int abl_points;
-    #elif ENABLED(PROBE_MANUALLY) // Bilinear
+    #else
       int constexpr abl_points = GRID_MAX_POINTS;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       ABL_VAR float zoffset;
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
@@ -637,21 +637,21 @@ G29_TYPE GcodeSuite::G29() {
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(probePos))) continue;
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", abl_points, ".");
-          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS)));
+          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(abl_points)));
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), measured_z);

commit ea520e670a1c5fba9d6c587c944a787dbc09165e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 5 00:59:51 2020 -0500

    Fix "Probing mesh point" message
    
    Closes #17770
    
    Co-Authored-By: Jan-Gerard van der Toorn <jan-gerard@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 99f07bc19b..ac991095a2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -636,21 +636,21 @@ G29_TYPE GcodeSuite::G29() {
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
 
           // Avoid probing outside the round or hexagonal area
           if (TERN0(IS_KINEMATIC, !probe.can_reach(probePos))) continue;
 
-          if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
+          if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", abl_points, ".");
           TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS)));
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)

commit c43bbcce152b4d3b4697e1e188d3bcada76a24a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 1 16:27:28 2020 -0500

    Enforce sensor range for temperature target (#18465)
    
    * Mitigate stepper timeout
    
    * Add CHAMBER PWM code
    
    * Structured thermistor tables
    
    * Fix reversed sensor ranges
    
    * Prevent temps outside sensor range

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 01871ec7e6..99f07bc19b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -157,20 +157,22 @@
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  *
  */
 G29_TYPE GcodeSuite::G29() {
 
+  reset_stepper_timeout();
+
   const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS(">>> G29", current_position);
       log_machine_info();
     }
@@ -668,21 +670,21 @@ G29_TYPE GcodeSuite::G29() {
             incremental_LSF(&lsf_results, probePos, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             z_values[meshCount.x][meshCount.y] = measured_z + zoffset;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, z_values[meshCount.x][meshCount.y]));
 
           #endif
 
           abl_should_enable = false;
-          idle();
+          idle_no_sleep();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");

commit f4c258dc2355fee871bec6e11095c7c4777b160d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 16 01:45:27 2020 -0500

    Creality Ender 3 v2 (#17719)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9c5907a5cc..01871ec7e6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -53,20 +53,24 @@
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #endif
 
+#if ENABLED(DWIN_CREALITY_LCD)
+  #include "../../../lcd/dwin/dwin.h"
+#endif
+
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR meshCount.x
     #define PR_OUTER_END abl_grid_points.x
     #define PR_INNER_VAR meshCount.y
     #define PR_INNER_END abl_grid_points.y
@@ -881,18 +885,22 @@ G29_TYPE GcodeSuite::G29() {
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     probe.move_z_after_probing();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
+  #if ENABLED(DWIN_CREALITY_LCD)
+    DWIN_CompletedLeveling();
+  #endif
+
   report_current_position();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
 
   G29_RETURN(isnan(measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit 6e01079b481665be8e7ffed903dcbefe7f422ea6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 17 20:57:07 2020 -0500

    G29 patch followup

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c48c693b78..9c5907a5cc 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -412,21 +412,21 @@ G29_TYPE GcodeSuite::G29() {
       if (ENABLED(BLTOUCH))
         do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
       else if (probe.deploy()) {
         set_bed_leveling_enabled(abl_should_enable);
         G29_RETURN(false);
       }
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      if (TERN_(PROBE_MANUALLY, !no_action)
+      if (TERN1(PROBE_MANUALLY, !no_action)
         && (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start)
       ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
         bilinear_grid_spacing = gridSpacing;
         bilinear_start = probe_position_lf;
 
         // Can't re-enable (on error) until the new grid is written

commit fac3a7d14788d7f80112d0c6456ae460b18764b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 17 18:43:36 2020 -0500

    Fix ABL G29 early BLTouch deploy

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ead70bc257..c48c693b78 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -71,25 +71,21 @@
     #define PR_INNER_VAR meshCount.y
     #define PR_INNER_END abl_grid_points.y
   #else
     #define PR_OUTER_VAR meshCount.y
     #define PR_OUTER_END abl_grid_points.y
     #define PR_INNER_VAR meshCount.x
     #define PR_INNER_END abl_grid_points.x
   #endif
 #endif
 
-#if ENABLED(G29_RETRY_AND_RECOVER)
-  #define G29_RETURN(b) return b;
-#else
-  #define G29_RETURN(b) return;
-#endif
+#define G29_RETURN(b) return TERN_(G29_RETRY_AND_RECOVER, b)
 
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
  *  O  Auto-level only if needed
  *
  *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
@@ -157,69 +153,48 @@
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  *
  */
 G29_TYPE GcodeSuite::G29() {
 
-  #if EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY)
-    const bool seenQ = parser.seen('Q');
-  #else
-    constexpr bool seenQ = false;
-  #endif
+  const bool seenQ = EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY) && parser.seen('Q');
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS(">>> G29", current_position);
       log_machine_info();
     }
     marlin_debug_flags = old_debug_flags;
-    #if DISABLED(PROBE_MANUALLY)
-      if (seenQ) G29_RETURN(false);
-    #endif
+    if (DISABLED(PROBE_MANUALLY) && seenQ) G29_RETURN(false);
   #endif
 
-  #if ENABLED(PROBE_MANUALLY)
-    const bool seenA = parser.seen('A');
-  #else
-    constexpr bool seenA = false;
-  #endif
-
-  const bool  no_action = seenA || seenQ,
-              faux =
-                #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
-                  parser.boolval('C')
-                #else
-                  no_action
-                #endif
-              ;
+  const bool seenA = TERN0(PROBE_MANUALLY, parser.seen('A')),
+         no_action = seenA || seenQ,
+              faux = ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY) ? parser.boolval('C') : no_action;
 
   // Don't allow auto-leveling without homing first
   if (axis_unhomed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip\n<<< G29");
     G29_RETURN(false);
   }
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
-  #if ENABLED(PROBE_MANUALLY)
-    #define ABL_VAR static
-  #else
-    #define ABL_VAR
-  #endif
+  #define ABL_VAR TERN_(PROBE_MANUALLY, static)
 
   ABL_VAR int verbose_level;
   ABL_VAR xy_pos_t probePos;
   ABL_VAR float measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
   #endif
 
@@ -339,25 +314,21 @@ G29_TYPE GcodeSuite::G29() {
       reset_bed_level();
       G29_RETURN(false);
     }
 
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
       SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
       G29_RETURN(false);
     }
 
-    dryrun = parser.boolval('D')
-      #if ENABLED(PROBE_MANUALLY)
-        || no_action
-      #endif
-    ;
+    dryrun = parser.boolval('D') || TERN0(PROBE_MANUALLY, no_action);
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl_grid_points.set(
         parser.byteval('X', GRID_MAX_POINTS_X),
         parser.byteval('Y', GRID_MAX_POINTS_Y)
@@ -423,40 +394,41 @@ G29_TYPE GcodeSuite::G29() {
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
+    if (!faux) remember_feedrate_scaling_off();
+
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
+    // Deploy certain probes before starting probing
     #if HAS_BED_PROBE
-      // Deploy the probe. Probe will raise if needed.
-      if (probe.deploy()) {
+      if (ENABLED(BLTOUCH))
+        do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+      else if (probe.deploy()) {
         set_bed_leveling_enabled(abl_should_enable);
         G29_RETURN(false);
       }
     #endif
 
-    if (!faux) remember_feedrate_scaling_off();
-
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      #if ENABLED(PROBE_MANUALLY)
-        if (!no_action)
-      #endif
-      if (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start) {
+      if (TERN_(PROBE_MANUALLY, !no_action)
+        && (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start)
+      ) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
         bilinear_grid_spacing = gridSpacing;
         bilinear_start = probe_position_lf;
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
@@ -553,64 +525,56 @@ G29_TYPE GcodeSuite::G29() {
     #if ABL_GRID
 
       // Skip any unreachable points
       while (abl_probe_index < abl_points) {
 
         // Set meshCount.x, meshCount.y based on abl_probe_index, with zig-zag
         PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
         PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
 
         // Probe in reverse order for every other row/column
-        bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
-
+        const bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
         if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
 
         probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
         TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = abl_probe_index);
 
         // Keep looping till a reachable point is found
         if (position_is_reachable(probePos)) break;
         ++abl_probe_index;
       }
 
       // Is there a next point to move to?
       if (abl_probe_index < abl_points) {
         _manual_goto_xy(probePos); // Can be used here too!
-        #if HAS_SOFTWARE_ENDSTOPS
-          // Disable software endstops to allow manual adjustment
-          // If G29 is not completed, they will not be re-enabled
-          soft_endstops_enabled = false;
-        #endif
+        // Disable software endstops to allow manual adjustment
+        // If G29 is not completed, they will not be re-enabled
+        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = false);
         G29_RETURN(false);
       }
       else {
-
         // Leveling done! Fall through to G29 finishing code below
-
         SERIAL_ECHOLNPGM("Grid probing done.");
-
         // Re-enable software endstops, if needed
         TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl_probe_index < abl_points) {
         probePos = points[abl_probe_index];
         _manual_goto_xy(probePos);
-        #if HAS_SOFTWARE_ENDSTOPS
-          // Disable software endstops to allow manual adjustment
-          // If G29 is not completed, they will not be re-enabled
-          soft_endstops_enabled = false;
-        #endif
+        // Disable software endstops to allow manual adjustment
+        // If G29 is not completed, they will not be re-enabled
+        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = false);
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
 
         if (!dryrun) {
@@ -663,24 +627,22 @@ G29_TYPE GcodeSuite::G29() {
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
 
-          #if IS_KINEMATIC
-            // Avoid probing outside the round or hexagonal area
-            if (!probe.can_reach(probePos)) continue;
-          #endif
+          // Avoid probing outside the round or hexagonal area
+          if (TERN0(IS_KINEMATIC, !probe.can_reach(probePos))) continue;
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS)));
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
@@ -891,25 +853,21 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          const float fade_scaling_factor = planner.fade_scaling_factor_for_z(current_position.z);
-        #else
-          constexpr float fade_scaling_factor = 1.0f;
-        #endif
+        const float fade_scaling_factor = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.fade_scaling_factor_for_z(current_position.z), 1);
         current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 165ae88709..ead70bc257 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -216,21 +216,21 @@ G29_TYPE GcodeSuite::G29() {
 
   ABL_VAR int verbose_level;
   ABL_VAR xy_pos_t probePos;
   ABL_VAR float measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
   #endif
 
-  #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
+  #if BOTH(HAS_SOFTWARE_ENDSTOPS, PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
       ABL_VAR xy_int8_t meshCount;
     #endif
 
     ABL_VAR xy_pos_t probe_position_lf, probe_position_rb;

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f316b4a7a1..165ae88709 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -276,23 +276,21 @@ G29_TYPE GcodeSuite::G29() {
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
-    #if HAS_MULTI_HOTEND
-      if (active_extruder != 0) tool_change(0);
-    #endif
+    TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
@@ -315,26 +313,22 @@ G29_TYPE GcodeSuite::G29() {
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start.x + 0.5 * gridSpacing.x) / gridSpacing.x;
           j = (ry - bilinear_start.y + 0.5 * gridSpacing.y) / gridSpacing.y;
           LIMIT(i, 0, GRID_MAX_POINTS_X - 1);
           LIMIT(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
-          #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-            bed_level_virt_interpolate();
-          #endif
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(i, j, rz);
-          #endif
+          TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, rz));
           set_bed_leveling_enabled(abl_should_enable);
           if (abl_should_enable) report_current_position();
         }
         G29_RETURN(false);
       } // parser.seen('W')
 
     #else
 
       constexpr bool seen_w = false;
 
@@ -485,48 +479,42 @@ G29_TYPE GcodeSuite::G29() {
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_ECHOLNPGM("Manual G29 aborted");
-      #if HAS_SOFTWARE_ENDSTOPS
-        soft_endstops_enabled = saved_soft_endstops_state;
-      #endif
+      TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
       set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
-      #if ENABLED(LCD_BED_LEVELING)
-        ui.wait_for_move = false;
-      #endif
+      TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress) {
         SERIAL_ECHOPAIR("point ", _MIN(abl_probe_index + 1, abl_points));
         SERIAL_ECHOLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
-      #if HAS_SOFTWARE_ENDSTOPS
-        saved_soft_endstops_state = soft_endstops_enabled;
-      #endif
+      TERN_(HAS_SOFTWARE_ENDSTOPS, saved_soft_endstops_state = soft_endstops_enabled);
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
       #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
@@ -544,23 +532,21 @@ G29_TYPE GcodeSuite::G29() {
         incremental_LSF(&lsf_results, probePos, measured_z);
 
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
         points[index].z = measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         const float newz = measured_z + zoffset;
         z_values[meshCount.x][meshCount.y] = newz;
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(meshCount, newz);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, newz));
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_P(PSTR("Save X"), meshCount.x, SP_Y_STR, meshCount.y, SP_Z_STR, measured_z + zoffset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
@@ -573,23 +559,21 @@ G29_TYPE GcodeSuite::G29() {
         PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
         PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
 
         // Probe in reverse order for every other row/column
         bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
 
         if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
 
         probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
-        #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-          indexIntoAB[meshCount.x][meshCount.y] = abl_probe_index;
-        #endif
+        TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = abl_probe_index);
 
         // Keep looping till a reachable point is found
         if (position_is_reachable(probePos)) break;
         ++abl_probe_index;
       }
 
       // Is there a next point to move to?
       if (abl_probe_index < abl_points) {
         _manual_goto_xy(probePos); // Can be used here too!
         #if HAS_SOFTWARE_ENDSTOPS
@@ -599,46 +583,42 @@ G29_TYPE GcodeSuite::G29() {
         #endif
         G29_RETURN(false);
       }
       else {
 
         // Leveling done! Fall through to G29 finishing code below
 
         SERIAL_ECHOLNPGM("Grid probing done.");
 
         // Re-enable software endstops, if needed
-        #if HAS_SOFTWARE_ENDSTOPS
-          soft_endstops_enabled = saved_soft_endstops_state;
-        #endif
+        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl_probe_index < abl_points) {
         probePos = points[abl_probe_index];
         _manual_goto_xy(probePos);
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
-        #if HAS_SOFTWARE_ENDSTOPS
-          soft_endstops_enabled = saved_soft_endstops_state;
-        #endif
+        TERN_(HAS_SOFTWARE_ENDSTOPS, soft_endstops_enabled = saved_soft_endstops_state);
 
         if (!dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) planeNormal *= -1;
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
           // Can't re-enable (on error) until the new grid is written
           abl_should_enable = false;
         }
 
@@ -681,83 +661,73 @@ G29_TYPE GcodeSuite::G29() {
 
         // An index to print current state
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
-          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-            indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index; // 0...
-          #endif
+          TERN_(AUTO_BED_LEVELING_LINEAR, indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index); // 0...
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!probe.can_reach(probePos)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
-          #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
-          #endif
+          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS)));
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), measured_z);
             temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), measured_z);
-            #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-              temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), measured_z);
-            #endif
+            TERN_(USE_TEMP_EXT_COMPENSATION, temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), measured_z));
           #endif
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl_points] = probePos.x;
             eqnAMatrix[abl_probe_index + 1 * abl_points] = probePos.y;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
             incremental_LSF(&lsf_results, probePos, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             z_values[meshCount.x][meshCount.y] = measured_z + zoffset;
-            #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(meshCount, z_values[meshCount.x][meshCount.y]);
-            #endif
+            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(meshCount, z_values[meshCount.x][meshCount.y]));
 
           #endif
 
           abl_should_enable = false;
           idle();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       LOOP_L_N(i, 3) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
-        #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i));
-        #endif
+        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i)));
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
@@ -766,23 +736,21 @@ G29_TYPE GcodeSuite::G29() {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
-    #if HAS_DISPLAY
-      ui.reset_status();
-    #endif
+    TERN_(HAS_DISPLAY, ui.reset_status());
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (probe.stow()) {
       set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
@@ -792,37 +760,33 @@ G29_TYPE GcodeSuite::G29() {
   // definitely be enabled after this point.
   //
   // If code above wants to continue leveling, it should
   // return or loop before this point.
   //
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
-    #if ENABLED(LCD_BED_LEVELING)
-      ui.wait_for_move = false;
-    #endif
+    TERN_(LCD_BED_LEVELING, ui.wait_for_move = false);
   #endif
 
   // Calculate leveling, print reports, correct the position
   if (!isnan(measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) extrapolate_unprobed_bed_level();
       print_bilinear_leveling_grid();
 
       refresh_bed_level();
 
-      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-        print_bilinear_leveling_grid_virt();
-      #endif
+      TERN_(ABL_BILINEAR_SUBDIVISION, print_bilinear_leveling_grid_virt());
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       // For LINEAR leveling calculate matrix, print reports, correct the position
 
       /**
        * solve the plane equation ax + by + d = z
        * A is the matrix with rows [x y 1] for all the probed points
        * B is the vector of the Z positions
        * the normal vector to the plane is formed by the coefficients of the

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index de69545983..f316b4a7a1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -53,21 +53,21 @@
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #endif
 
-#if HOTENDS > 1
+#if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR meshCount.x
     #define PR_OUTER_END abl_grid_points.x
     #define PR_INNER_VAR meshCount.y
     #define PR_INNER_END abl_grid_points.y
   #else
@@ -276,21 +276,21 @@ G29_TYPE GcodeSuite::G29() {
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       if (active_extruder != 0) tool_change(0);
     #endif
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)

commit c39873759f1602e30343369bab2a0de7d5165058
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 15 18:14:58 2020 -0500

    Fix Z after ABL Bilinear G29 with fade
    
    Co-Authored-By: Alan T <interstellarmisfit@users.noreply.github.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 2d782e9e33..de69545983 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -927,21 +927,26 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
-        current_position.z -= bilinear_z_offset(current_position);
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          const float fade_scaling_factor = planner.fade_scaling_factor_for_z(current_position.z);
+        #else
+          constexpr float fade_scaling_factor = 1.0f;
+        #endif
+        current_position.z -= fade_scaling_factor * bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 1834f599e6..2d782e9e33 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -739,21 +739,21 @@ G29_TYPE GcodeSuite::G29() {
           abl_should_enable = false;
           idle();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
-      for (uint8_t i = 0; i < 3; ++i) {
+      LOOP_L_N(i, 3) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i));
         #endif
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
@@ -854,21 +854,21 @@ G29_TYPE GcodeSuite::G29() {
         );
 
       // Show the Topography map if enabled
       if (do_topography_map) {
 
         float min_diff = 999;
 
         auto print_topo_map = [&](PGM_P const title, const bool get_min) {
           serialprintPGM(title);
           for (int8_t yy = abl_grid_points.y - 1; yy >= 0; yy--) {
-            for (uint8_t xx = 0; xx < abl_grid_points.x; xx++) {
+            LOOP_L_N(xx, abl_grid_points.x) {
               const int ind = indexIntoAB[xx][yy];
               xyz_float_t tmp = { eqnAMatrix[ind + 0 * abl_points],
                                   eqnAMatrix[ind + 1 * abl_points], 0 };
               apply_rotation_xyz(planner.bed_level_matrix, tmp);
               if (get_min) NOMORE(min_diff, eqnBVector[ind] - tmp.z);
               const float subval = get_min ? mean : tmp.z + min_diff,
                             diff = eqnBVector[ind] - subval;
               SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
               SERIAL_ECHO_F(diff, 5);
             } // xx

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c81e5f0a8a..1834f599e6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -30,41 +30,41 @@
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
-  #include "../../../feature/probe_temp_compensation.h"
+  #include "../../../feature/probe_temp_comp.h"
   #include "../../../module/temperature.h"
 #endif
 
 #if HAS_DISPLAY
   #include "../../../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
-  #include "../../../lcd/extensible_ui/ui_api.h"
+  #include "../../../lcd/extui/ui_api.h"
 #endif
 
 #if HOTENDS > 1
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR meshCount.x
     #define PR_OUTER_END abl_grid_points.x

commit be62ab2d02f58634013a78a2e243a50c1cd4a1c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 06:16:33 2020 -0600

    Move reachable test to Probe class

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5173505164..c81e5f0a8a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -410,31 +410,21 @@ G29_TYPE GcodeSuite::G29() {
         probe_position_lf.set(
           parser.seenval('L') ? RAW_X_POSITION(parser.value_linear_units()) : x_min,
           parser.seenval('F') ? RAW_Y_POSITION(parser.value_linear_units()) : y_min
         );
         probe_position_rb.set(
           parser.seenval('R') ? RAW_X_POSITION(parser.value_linear_units()) : x_max,
           parser.seenval('B') ? RAW_Y_POSITION(parser.value_linear_units()) : y_max
         );
       }
 
-      if (
-        #if IS_SCARA || ENABLED(DELTA)
-             !position_is_reachable_by_probe(probe_position_lf.x, 0)
-          || !position_is_reachable_by_probe(probe_position_rb.x, 0)
-          || !position_is_reachable_by_probe(0, probe_position_lf.y)
-          || !position_is_reachable_by_probe(0, probe_position_rb.y)
-        #else
-             !position_is_reachable_by_probe(probe_position_lf)
-          || !position_is_reachable_by_probe(probe_position_rb)
-        #endif
-      ) {
+      if (!probe.good_bounds(probe_position_lf, probe_position_rb)) {
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false);
       }
 
       // probe at the points of a lattice grid
       gridSpacing.set((probe_position_rb.x - probe_position_lf.x) / (abl_grid_points.x - 1),
                       (probe_position_rb.y - probe_position_lf.y) / (abl_grid_points.y - 1));
 
     #endif // ABL_GRID
 
@@ -697,21 +687,21 @@ G29_TYPE GcodeSuite::G29() {
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
-            if (!position_is_reachable_by_probe(probePos)) continue;
+            if (!probe.can_reach(probePos)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {

commit 130e36d76659182f50565243ad331e8f7765165c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 8 17:47:54 2020 -0600

    Tweak ABL logging, document probing

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a92e368114..5173505164 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -951,31 +951,31 @@ G29_TYPE GcodeSuite::G29() {
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
-
-  if (planner.leveling_active)
-    sync_plan_position();
+  // Sync the planner from the current_position
+  if (planner.leveling_active) sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     probe.move_z_after_probing();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   report_current_position();
 
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
+
   G29_RETURN(isnan(measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ff0581886a..a92e368114 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 7cbaefbf23..ff0581886a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -262,21 +262,21 @@ G29_TYPE GcodeSuite::G29() {
                     mean;
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl_points = 3; // used to show total points
     #endif
 
     vector_3 points[3];
-    get_three_probe_points(points);
+    probe.get_three_points(points);
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
@@ -385,22 +385,22 @@ G29_TYPE GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
-      const float x_min = probe_min_x(), x_max = probe_max_x(),
-                  y_min = probe_min_y(), y_max = probe_max_y();
+      const float x_min = probe.min_x(), x_max = probe.max_x(),
+                  y_min = probe.min_y(), y_max = probe.max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
         probe_position_lf.set(
           _MAX(X_CENTER - size / 2, x_min),
           _MAX(Y_CENTER - size / 2, y_min)
         );
         probe_position_rb.set(
           _MIN(probe_position_lf.x + size, x_max),
           _MIN(probe_position_lf.y + size, y_max)
@@ -445,21 +445,21 @@ G29_TYPE GcodeSuite::G29() {
     }
 
     planner.synchronize();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
-      if (DEPLOY_PROBE()) {
+      if (probe.deploy()) {
         set_bed_leveling_enabled(abl_should_enable);
         G29_RETURN(false);
       }
     #endif
 
     if (!faux) remember_feedrate_scaling_off();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
@@ -705,21 +705,21 @@ G29_TYPE GcodeSuite::G29() {
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(probePos)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
-          measured_z = faux ? 0.001f * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
+          measured_z = faux ? 0.001f * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(PROBE_TEMP_COMPENSATION)
             temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), measured_z);
             temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), measured_z);
             #if ENABLED(USE_TEMP_EXT_COMPENSATION)
@@ -757,21 +757,21 @@ G29_TYPE GcodeSuite::G29() {
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i));
         #endif
 
         // Retain the last probe position
         probePos = points[i];
-        measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
+        measured_z = faux ? 0.001 * random(-100, 101) : probe.probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
@@ -781,21 +781,21 @@ G29_TYPE GcodeSuite::G29() {
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     #if HAS_DISPLAY
       ui.reset_status();
     #endif
 
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
-    if (STOW_PROBE()) {
+    if (probe.stow()) {
       set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
@@ -916,22 +916,22 @@ G29_TYPE GcodeSuite::G29() {
         //
         // Correct the current XYZ position based on the tilted plane.
         //
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         xyze_pos_t converted = current_position;
         planner.force_unapply_leveling(converted); // use conversion machinery
 
         // Use the last measured distance to the bed, if possible
-        if ( NEAR(current_position.x, probePos.x - probe_offset_xy.x)
-          && NEAR(current_position.y, probePos.y - probe_offset_xy.y)
+        if ( NEAR(current_position.x, probePos.x - probe.offset_xy.x)
+          && NEAR(current_position.y, probePos.y - probe.offset_xy.y)
         ) {
           const float simple_z = current_position.z - measured_z;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
           converted.z = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         current_position = converted;
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
@@ -957,21 +957,21 @@ G29_TYPE GcodeSuite::G29() {
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
 
   if (planner.leveling_active)
     sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
-    move_z_after_probing();
+    probe.move_z_after_probing();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     planner.synchronize();
     process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
   #endif
 
   report_current_position();
 

commit 95d5a0c480d655bf96a6989ad3df0f240ae343b2
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Jan 25 22:02:06 2020 -0800

    Fix DELTA_CALIBRATION_MENU recursive call (#16656)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 53c48a62b6..7cbaefbf23 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -501,21 +501,21 @@ G29_TYPE GcodeSuite::G29() {
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_ECHOLNPGM("Manual G29 aborted");
       #if HAS_SOFTWARE_ENDSTOPS
         soft_endstops_enabled = saved_soft_endstops_state;
       #endif
       set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
-        ui.wait_for_bl_move = false;
+        ui.wait_for_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress) {
         SERIAL_ECHOPAIR("point ", _MIN(abl_probe_index + 1, abl_points));
         SERIAL_ECHOLNPAIR(" of ", abl_points);
       }
@@ -803,21 +803,21 @@ G29_TYPE GcodeSuite::G29() {
   //
   // If code above wants to continue leveling, it should
   // return or loop before this point.
   //
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     #if ENABLED(LCD_BED_LEVELING)
-      ui.wait_for_bl_move = false;
+      ui.wait_for_move = false;
     #endif
   #endif
 
   // Calculate leveling, print reports, correct the position
   if (!isnan(measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) extrapolate_unprobed_bed_level();
       print_bilinear_leveling_grid();
 

commit a338dce83f6f3b3348a8422ad8acd7b81cc1cefe
Author: tompe-proj <59094873+tompe-proj@users.noreply.github.com>
Date:   Sat Jan 18 00:16:45 2020 +0100

    PINDA v2 temperature sensor / compensation (#16293)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index cf9cdf58e6..53c48a62b6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,20 +29,25 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
+#if ENABLED(PROBE_TEMP_COMPENSATION)
+  #include "../../../feature/probe_temp_compensation.h"
+  #include "../../../module/temperature.h"
+#endif
+
 #if HAS_DISPLAY
   #include "../../../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
@@ -707,20 +712,28 @@ G29_TYPE GcodeSuite::G29() {
             ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
           measured_z = faux ? 0.001f * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
+          #if ENABLED(PROBE_TEMP_COMPENSATION)
+            temp_comp.compensate_measurement(TSI_BED, thermalManager.degBed(), measured_z);
+            temp_comp.compensate_measurement(TSI_PROBE, thermalManager.degProbe(), measured_z);
+            #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+              temp_comp.compensate_measurement(TSI_EXT, thermalManager.degHotend(), measured_z);
+            #endif
+          #endif
+
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl_points] = probePos.x;
             eqnAMatrix[abl_probe_index + 1 * abl_points] = probePos.y;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
             incremental_LSF(&lsf_results, probePos, measured_z);
 

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 4503a51cb7..cf9cdf58e6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -221,21 +221,21 @@ G29_TYPE GcodeSuite::G29() {
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
       ABL_VAR xy_int8_t meshCount;
     #endif
 
-    ABL_VAR xy_float_t probe_position_lf, probe_position_rb;
+    ABL_VAR xy_pos_t probe_position_lf, probe_position_rb;
     ABL_VAR xy_float_t gridSpacing = { 0, 0 };
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR bool do_topography_map;
       ABL_VAR xy_uint8_t abl_grid_points;
     #else // Bilinear
       constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -396,28 +396,27 @@ G29_TYPE GcodeSuite::G29() {
           _MAX(X_CENTER - size / 2, x_min),
           _MAX(Y_CENTER - size / 2, y_min)
         );
         probe_position_rb.set(
           _MIN(probe_position_lf.x + size, x_max),
           _MIN(probe_position_lf.y + size, y_max)
         );
       }
       else {
         probe_position_lf.set(
-          parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : (_MAX(x_min, X_CENTER - (X_BED_SIZE) / 2)      + MIN_PROBE_EDGE_LEFT),
-          parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : (_MAX(y_min, Y_CENTER - (Y_BED_SIZE) / 2)      + MIN_PROBE_EDGE_FRONT)
+          parser.seenval('L') ? RAW_X_POSITION(parser.value_linear_units()) : x_min,
+          parser.seenval('F') ? RAW_Y_POSITION(parser.value_linear_units()) : y_min
         );
         probe_position_rb.set(
-          parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : (_MIN(x_max, probe_position_lf.x + X_BED_SIZE) - MIN_PROBE_EDGE_RIGHT),
-          parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : (_MIN(y_max, probe_position_lf.y + Y_BED_SIZE) - MIN_PROBE_EDGE_BACK)
+          parser.seenval('R') ? RAW_X_POSITION(parser.value_linear_units()) : x_max,
+          parser.seenval('B') ? RAW_Y_POSITION(parser.value_linear_units()) : y_max
         );
-        SERIAL_ECHOLN("Set Trail 1");
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
              !position_is_reachable_by_probe(probe_position_lf.x, 0)
           || !position_is_reachable_by_probe(probe_position_rb.x, 0)
           || !position_is_reachable_by_probe(0, probe_position_lf.y)
           || !position_is_reachable_by_probe(0, probe_position_rb.y)
         #else
              !position_is_reachable_by_probe(probe_position_lf)
@@ -904,22 +903,22 @@ G29_TYPE GcodeSuite::G29() {
         //
         // Correct the current XYZ position based on the tilted plane.
         //
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         xyze_pos_t converted = current_position;
         planner.force_unapply_leveling(converted); // use conversion machinery
 
         // Use the last measured distance to the bed, if possible
-        if ( NEAR(current_position.x, probePos.x - probe_offset.x)
-          && NEAR(current_position.y, probePos.y - probe_offset.y)
+        if ( NEAR(current_position.x, probePos.x - probe_offset_xy.x)
+          && NEAR(current_position.y, probePos.y - probe_offset_xy.y)
         ) {
           const float simple_z = current_position.z - measured_z;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
           converted.z = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         current_position = converted;
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);

commit 1c9ccce5209cd1727bf80e632f4f781c651e0c35
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Dec 24 01:03:08 2019 -0500

    Add NOZZLE_AS_PROBE (no probe offsets) (#15929)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 41e5fce4d2..4503a51cb7 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -396,27 +396,28 @@ G29_TYPE GcodeSuite::G29() {
           _MAX(X_CENTER - size / 2, x_min),
           _MAX(Y_CENTER - size / 2, y_min)
         );
         probe_position_rb.set(
           _MIN(probe_position_lf.x + size, x_max),
           _MIN(probe_position_lf.y + size, y_max)
         );
       }
       else {
         probe_position_lf.set(
-          parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MAX(X_CENTER - (X_BED_SIZE) / 2,      x_min),
-          parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MAX(Y_CENTER - (Y_BED_SIZE) / 2,      y_min)
+          parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : (_MAX(x_min, X_CENTER - (X_BED_SIZE) / 2)      + MIN_PROBE_EDGE_LEFT),
+          parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : (_MAX(y_min, Y_CENTER - (Y_BED_SIZE) / 2)      + MIN_PROBE_EDGE_FRONT)
         );
         probe_position_rb.set(
-          parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MIN(probe_position_lf.x + X_BED_SIZE, x_max),
-          parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MIN(probe_position_lf.y + Y_BED_SIZE, y_max)
+          parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : (_MIN(x_max, probe_position_lf.x + X_BED_SIZE) - MIN_PROBE_EDGE_RIGHT),
+          parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : (_MIN(y_max, probe_position_lf.y + Y_BED_SIZE) - MIN_PROBE_EDGE_BACK)
         );
+        SERIAL_ECHOLN("Set Trail 1");
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
              !position_is_reachable_by_probe(probe_position_lf.x, 0)
           || !position_is_reachable_by_probe(probe_position_rb.x, 0)
           || !position_is_reachable_by_probe(0, probe_position_lf.y)
           || !position_is_reachable_by_probe(0, probe_position_rb.y)
         #else
              !position_is_reachable_by_probe(probe_position_lf)

commit f83bc0aa13e8cf2d92ec138576cc3a620e74a982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 29 04:45:07 2019 -0600

    Optimize common strings
    
    Saves 128 bytes in testing with `mftest mega 1 -y`

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 1a9fa4bc7b..41e5fce4d2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -553,21 +553,21 @@ G29_TYPE GcodeSuite::G29() {
         points[index].z = measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         const float newz = measured_z + zoffset;
         z_values[meshCount.x][meshCount.y] = newz;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(meshCount, newz);
         #endif
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Save X", meshCount.x, " Y", meshCount.y, " Z", measured_z + zoffset);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_P(PSTR("Save X"), meshCount.x, SP_Y_STR, meshCount.y, SP_Z_STR, measured_z + zoffset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
     #if ABL_GRID
 

commit 752a1e76aba505acc85e2dda0759ae214ed96b32
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 26 23:29:25 2019 -0800

    Float ABL mesh boundaries, no probe position rounding (#16018)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 6aa85b00dc..1a9fa4bc7b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -458,21 +458,21 @@ G29_TYPE GcodeSuite::G29() {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
       if (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
-        bilinear_grid_spacing = gridSpacing.asInt();
+        bilinear_grid_spacing = gridSpacing;
         bilinear_start = probe_position_lf;
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_BILINEAR
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
 
@@ -576,24 +576,21 @@ G29_TYPE GcodeSuite::G29() {
 
         // Set meshCount.x, meshCount.y based on abl_probe_index, with zig-zag
         PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
         PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
 
         // Probe in reverse order for every other row/column
         bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
 
         if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
 
-        const xy_pos_t base = probe_position_lf.asFloat() + gridSpacing * meshCount.asFloat();
-
-        probePos.set(FLOOR(base.x + (base.x < 0 ? 0 : 0.5)),
-                     FLOOR(base.y + (base.y < 0 ? 0 : 0.5)));
+        probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
           indexIntoAB[meshCount.x][meshCount.y] = abl_probe_index;
         #endif
 
         // Keep looping till a reachable point is found
         if (position_is_reachable(probePos)) break;
         ++abl_probe_index;
       }
 
@@ -687,24 +684,21 @@ G29_TYPE GcodeSuite::G29() {
 
         zig ^= true; // zag
 
         // An index to print current state
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
-          const xy_pos_t base = probe_position_lf.asFloat() + gridSpacing * meshCount.asFloat();
-
-          probePos.set(FLOOR(base.x + (base.x < 0 ? 0 : 0.5)),
-                       FLOOR(base.y + (base.y < 0 ? 0 : 0.5)));
+          probePos = probe_position_lf + gridSpacing * meshCount.asFloat();
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(probePos)) continue;
           #endif
 

commit 98f83dc756f896233539d6df0a310bcdd7c1b2ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 26 17:58:31 2019 -0600

    Add comments to G29

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 4f122a256b..6aa85b00dc 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -667,29 +667,29 @@ G29_TYPE GcodeSuite::G29() {
       measured_z = 0;
 
       xy_int8_t meshCount;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
-        if (zig) { // away from origin
-          inStart = 0;
-          inStop = PR_INNER_END;
-          inInc = 1;
+        if (zig) {                    // Zig away from origin
+          inStart = 0;                // Left or front
+          inStop = PR_INNER_END;      // Right or back
+          inInc = 1;                  // Zig right
         }
-        else {     // towards origin
-          inStart = PR_INNER_END - 1;
-          inStop = -1;
-          inInc = -1;
+        else {                        // Zag towards origin
+          inStart = PR_INNER_END - 1; // Right or back
+          inStop = -1;                // Left or front
+          inInc = -1;                 // Zag left
         }
 
         zig ^= true; // zag
 
         // An index to print current state
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {

commit 1d150e41b6c60d2b93eeed5e67aad0f7c624c02f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 26 02:15:31 2019 -0600

    Reduce MMU2 code, add test

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 00e8ab44d7..4f122a256b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -745,21 +745,21 @@ G29_TYPE GcodeSuite::G29() {
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(S_FMT" %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i));
+          ui.status_printf_P(0, PSTR(S_FMT " %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i));
         #endif
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;

commit b904ba0f291cdcb9759464f064f85ba066b778ce
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Nov 21 01:26:00 2019 -0800

    Improve Delta probing / calibration (#15887)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 6aa54b3d2d..00e8ab44d7 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -256,34 +256,22 @@ G29_TYPE GcodeSuite::G29() {
                     eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
                     mean;
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl_points = 3; // used to show total points
     #endif
 
-    // Probe at 3 arbitrary points
-    const float x_min = probe_min_x(), x_max = probe_max_x(), y_min = probe_min_y(), y_max = probe_max_y();
-
-    ABL_VAR vector_3 points[3] = {
-      #if ENABLED(HAS_FIXED_3POINT)
-        { PROBE_PT_1_X, PROBE_PT_1_Y, 0 },
-        { PROBE_PT_2_X, PROBE_PT_2_Y, 0 },
-        { PROBE_PT_3_X, PROBE_PT_3_Y, 0 }
-      #else
-        { x_min, y_min, 0 },
-        { x_max, y_min, 0 },
-        { (x_max - x_min) / 2, y_max, 0 }
-      #endif
-    };
+    vector_3 points[3];
+    get_three_probe_points(points);
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
@@ -757,21 +745,21 @@ G29_TYPE GcodeSuite::G29() {
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(S_FMT" %i/3"), GET_TEXT(MSG_PROBING_MESH)), int(i);
+          ui.status_printf_P(0, PSTR(S_FMT" %i/3"), GET_TEXT(MSG_PROBING_MESH), int(i));
         #endif
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;

commit 4ede13e36a38aa1407a7ca06c1085d36928057a7
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Nov 21 01:19:56 2019 -0800

    Fix G29 for updated meshCount type (#15960)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index d781553750..6aa54b3d2d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -677,31 +677,31 @@ G29_TYPE GcodeSuite::G29() {
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       measured_z = 0;
 
       xy_int8_t meshCount;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
-        uint8_t inStart, inStop, inInc;
+        int8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
           inStop = PR_INNER_END;
           inInc = 1;
         }
         else {     // towards origin
           inStart = PR_INNER_END - 1;
-          inStop = 0xFF;
-          inInc = 0xFF;
+          inStop = -1;
+          inInc = -1;
         }
 
         zig ^= true; // zag
 
         // An index to print current state
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {

commit ab9f0f2c4fcb118323171c3c9d259a4cb494a254
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 20 04:57:04 2019 -0600

    Followup to meshCount patch

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 57ec6193d0..d781553750 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -218,21 +218,21 @@ G29_TYPE GcodeSuite::G29() {
     ABL_VAR int abl_probe_index;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
-      ABL_VAR xy_uint8_t meshCount;
+      ABL_VAR xy_int8_t meshCount;
     #endif
 
     ABL_VAR xy_float_t probe_position_lf, probe_position_rb;
     ABL_VAR xy_float_t gridSpacing = { 0, 0 };
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR bool do_topography_map;
       ABL_VAR xy_uint8_t abl_grid_points;
     #else // Bilinear
       constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };

commit 798f34abcd03fbc23cba91c27e2e3d4513a3eb31
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Nov 20 00:29:52 2019 -0500

    Float XY probe offset followup (probe edge) (#15928)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 448d0d00e4..57ec6193d0 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -221,21 +221,21 @@ G29_TYPE GcodeSuite::G29() {
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
       ABL_VAR xy_uint8_t meshCount;
     #endif
 
-    ABL_VAR xy_int_t probe_position_lf, probe_position_rb;
+    ABL_VAR xy_float_t probe_position_lf, probe_position_rb;
     ABL_VAR xy_float_t gridSpacing = { 0, 0 };
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR bool do_topography_map;
       ABL_VAR xy_uint8_t abl_grid_points;
     #else // Bilinear
       constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)

commit 4d4e692c8159d26713ebff7bf67b2344c74758ef
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Nov 20 00:16:43 2019 -0500

    Match onMeshUpdate() index sign (#15920)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c17150f79d..448d0d00e4 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -671,21 +671,21 @@ G29_TYPE GcodeSuite::G29() {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     measured_z = 0;
 
     #if ABL_GRID
 
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       measured_z = 0;
 
-      xy_uint8_t meshCount;
+      xy_int8_t meshCount;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
         uint8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
           inStop = PR_INNER_END;

commit ad28da7eb4fe720776daf929d0a25ba39e6b6ca8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 1 15:38:41 2019 -0500

    Patch ABL G29 loop
    
    Followup to e3ddf6e81a

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c3e52fe3f9..c17150f79d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -677,31 +677,31 @@ G29_TYPE GcodeSuite::G29() {
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       measured_z = 0;
 
       xy_uint8_t meshCount;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
-        int8_t inStart, inStop, inInc;
+        uint8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
           inStop = PR_INNER_END;
           inInc = 1;
         }
         else {     // towards origin
           inStart = PR_INNER_END - 1;
-          inStop = -1;
-          inInc = -1;
+          inStop = 0xFF;
+          inInc = 0xFF;
         }
 
         zig ^= true; // zag
 
         // An index to print current state
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         // Inner loop is X with PROBE_Y_FIRST disabled
         for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {

commit e3ddf6e81ae8c62632a73e14d3b2d36c98b08a3a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 31 13:13:51 2019 -0500

    Fix meshCount signed-ness

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a662eab07a..c3e52fe3f9 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -218,21 +218,21 @@ G29_TYPE GcodeSuite::G29() {
     ABL_VAR int abl_probe_index;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
-      ABL_VAR xy_int8_t meshCount;
+      ABL_VAR xy_uint8_t meshCount;
     #endif
 
     ABL_VAR xy_int_t probe_position_lf, probe_position_rb;
     ABL_VAR xy_float_t gridSpacing = { 0, 0 };
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR bool do_topography_map;
       ABL_VAR xy_uint8_t abl_grid_points;
     #else // Bilinear
       constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
@@ -671,21 +671,21 @@ G29_TYPE GcodeSuite::G29() {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     measured_z = 0;
 
     #if ABL_GRID
 
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       measured_z = 0;
 
-      xy_int8_t meshCount;
+      xy_uint8_t meshCount;
 
       // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
           inStop = PR_INNER_END;
@@ -739,21 +739,21 @@ G29_TYPE GcodeSuite::G29() {
             eqnAMatrix[abl_probe_index + 0 * abl_points] = probePos.x;
             eqnAMatrix[abl_probe_index + 1 * abl_points] = probePos.y;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
             incremental_LSF(&lsf_results, probePos, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             z_values[meshCount.x][meshCount.y] = measured_z + zoffset;
             #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(meshCount.x, meshCount.y, z_values[meshCount.x][meshCount.y]);
+              ExtUI::onMeshUpdate(meshCount, z_values[meshCount.x][meshCount.y]);
             #endif
 
           #endif
 
           abl_should_enable = false;
           idle();
 
         } // inner
       } // outer
 

commit ab0fe1a7dd8cd6bb91174030a86d93dea892319d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 26 13:39:12 2019 -0500

    Tweak G29 faux point

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9ca621d7cd..a662eab07a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -718,21 +718,21 @@ G29_TYPE GcodeSuite::G29() {
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(probePos)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
-          measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
+          measured_z = faux ? 0.001f * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5f1ef2e9a3..9ca621d7cd 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -715,21 +715,21 @@ G29_TYPE GcodeSuite::G29() {
             indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(probePos)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), PSTR(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
+            ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
           measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -757,21 +757,21 @@ G29_TYPE GcodeSuite::G29() {
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/3"), int(i));
+          ui.status_printf_P(0, PSTR(S_FMT" %i/3"), GET_TEXT(MSG_PROBING_MESH)), int(i);
         #endif
 
         // Retain the last probe position
         probePos = points[i];
         measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 45eec2805d..5f1ef2e9a3 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -54,29 +54,29 @@
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extensible_ui/ui_api.h"
 #endif
 
 #if HOTENDS > 1
   #include "../../../module/tool_change.h"
 #endif
 
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
-    #define PR_OUTER_VAR xCount
-    #define PR_OUTER_END abl_grid_points_x
-    #define PR_INNER_VAR yCount
-    #define PR_INNER_END abl_grid_points_y
+    #define PR_OUTER_VAR meshCount.x
+    #define PR_OUTER_END abl_grid_points.x
+    #define PR_INNER_VAR meshCount.y
+    #define PR_INNER_END abl_grid_points.y
   #else
-    #define PR_OUTER_VAR yCount
-    #define PR_OUTER_END abl_grid_points_y
-    #define PR_INNER_VAR xCount
-    #define PR_INNER_END abl_grid_points_x
+    #define PR_OUTER_VAR meshCount.y
+    #define PR_OUTER_END abl_grid_points.y
+    #define PR_INNER_VAR meshCount.x
+    #define PR_INNER_END abl_grid_points.x
   #endif
 #endif
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
   #define G29_RETURN(b) return b;
 #else
   #define G29_RETURN(b) return;
 #endif
 
 /**
@@ -203,48 +203,46 @@ G29_TYPE GcodeSuite::G29() {
   }
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
   ABL_VAR int verbose_level;
-  ABL_VAR float xProbe, yProbe, measured_z;
+  ABL_VAR xy_pos_t probePos;
+  ABL_VAR float measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
   #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
-      ABL_VAR uint8_t PR_OUTER_VAR;
-      ABL_VAR  int8_t PR_INNER_VAR;
+      ABL_VAR xy_int8_t meshCount;
     #endif
 
-    ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
-    ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
+    ABL_VAR xy_int_t probe_position_lf, probe_position_rb;
+    ABL_VAR xy_float_t gridSpacing = { 0, 0 };
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
-                      abl_grid_points_y = GRID_MAX_POINTS_Y;
       ABL_VAR bool do_topography_map;
+      ABL_VAR xy_uint8_t abl_grid_points;
     #else // Bilinear
-      uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
-                        abl_grid_points_y = GRID_MAX_POINTS_Y;
+      constexpr xy_uint8_t abl_grid_points = { GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y };
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR int abl_points;
     #elif ENABLED(PROBE_MANUALLY) // Bilinear
       int constexpr abl_points = GRID_MAX_POINTS;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
@@ -262,29 +260,29 @@ G29_TYPE GcodeSuite::G29() {
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl_points = 3; // used to show total points
     #endif
 
     // Probe at 3 arbitrary points
     const float x_min = probe_min_x(), x_max = probe_max_x(), y_min = probe_min_y(), y_max = probe_max_y();
 
     ABL_VAR vector_3 points[3] = {
-    #if ENABLED(HAS_FIXED_3POINT)
-      vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
-      vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
-      vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
-    #else
-      vector_3(x_min, y_min, 0),
-      vector_3(x_max, y_min, 0),
-      vector_3((x_max - x_min) / 2, y_max, 0)
-    #endif
+      #if ENABLED(HAS_FIXED_3POINT)
+        { PROBE_PT_1_X, PROBE_PT_1_Y, 0 },
+        { PROBE_PT_2_X, PROBE_PT_2_Y, 0 },
+        { PROBE_PT_3_X, PROBE_PT_3_Y, 0 }
+      #else
+        { x_min, y_min, 0 },
+        { x_max, y_min, 0 },
+        { (x_max - x_min) / 2, y_max, 0 }
+      #endif
     };
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
@@ -304,34 +302,34 @@ G29_TYPE GcodeSuite::G29() {
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_MSG("No bilinear grid");
           G29_RETURN(false);
         }
 
-        const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
+        const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position.z;
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
-          i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
-          j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
+          i = (rx - bilinear_start.x + 0.5 * gridSpacing.x) / gridSpacing.x;
+          j = (ry - bilinear_start.y + 0.5 * gridSpacing.y) / gridSpacing.y;
           LIMIT(i, 0, GRID_MAX_POINTS_X - 1);
           LIMIT(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
           #if ENABLED(EXTENSIBLE_UI)
@@ -366,81 +364,91 @@ G29_TYPE GcodeSuite::G29() {
         || no_action
       #endif
     ;
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
-      abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
-      abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
-      if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
+      abl_grid_points.set(
+        parser.byteval('X', GRID_MAX_POINTS_X),
+        parser.byteval('Y', GRID_MAX_POINTS_Y)
+      );
+      if (parser.seenval('P')) abl_grid_points.x = abl_grid_points.y = parser.value_int();
 
-      if (!WITHIN(abl_grid_points_x, 2, GRID_MAX_POINTS_X)) {
+      if (!WITHIN(abl_grid_points.x, 2, GRID_MAX_POINTS_X)) {
         SERIAL_ECHOLNPGM("?Probe points (X) implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
         G29_RETURN(false);
       }
-      if (!WITHIN(abl_grid_points_y, 2, GRID_MAX_POINTS_Y)) {
+      if (!WITHIN(abl_grid_points.y, 2, GRID_MAX_POINTS_Y)) {
         SERIAL_ECHOLNPGM("?Probe points (Y) implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
         G29_RETURN(false);
       }
 
-      abl_points = abl_grid_points_x * abl_grid_points_y;
+      abl_points = abl_grid_points.x * abl_grid_points.y;
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       const float x_min = probe_min_x(), x_max = probe_max_x(),
                   y_min = probe_min_y(), y_max = probe_max_y();
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        left_probe_bed_position  = _MAX(X_CENTER - size / 2, x_min);
-        right_probe_bed_position = _MIN(left_probe_bed_position + size, x_max);
-        front_probe_bed_position = _MAX(Y_CENTER - size / 2, y_min);
-        back_probe_bed_position  = _MIN(front_probe_bed_position + size, y_max);
+        probe_position_lf.set(
+          _MAX(X_CENTER - size / 2, x_min),
+          _MAX(Y_CENTER - size / 2, y_min)
+        );
+        probe_position_rb.set(
+          _MIN(probe_position_lf.x + size, x_max),
+          _MIN(probe_position_lf.y + size, y_max)
+        );
       }
       else {
-        left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MAX(X_CENTER - X_BED_SIZE / 2, x_min);
-        right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MIN(left_probe_bed_position + X_BED_SIZE, x_max);
-        front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MAX(Y_CENTER - Y_BED_SIZE / 2, y_min);
-        back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MIN(front_probe_bed_position + Y_BED_SIZE, y_max);
+        probe_position_lf.set(
+          parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MAX(X_CENTER - (X_BED_SIZE) / 2,      x_min),
+          parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MAX(Y_CENTER - (Y_BED_SIZE) / 2,      y_min)
+        );
+        probe_position_rb.set(
+          parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MIN(probe_position_lf.x + X_BED_SIZE, x_max),
+          parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MIN(probe_position_lf.y + Y_BED_SIZE, y_max)
+        );
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
-             !position_is_reachable_by_probe(left_probe_bed_position, 0)
-          || !position_is_reachable_by_probe(right_probe_bed_position, 0)
-          || !position_is_reachable_by_probe(0, front_probe_bed_position)
-          || !position_is_reachable_by_probe(0, back_probe_bed_position)
+             !position_is_reachable_by_probe(probe_position_lf.x, 0)
+          || !position_is_reachable_by_probe(probe_position_rb.x, 0)
+          || !position_is_reachable_by_probe(0, probe_position_lf.y)
+          || !position_is_reachable_by_probe(0, probe_position_rb.y)
         #else
-             !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
-          || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)
+             !position_is_reachable_by_probe(probe_position_lf)
+          || !position_is_reachable_by_probe(probe_position_rb)
         #endif
       ) {
         SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false);
       }
 
       // probe at the points of a lattice grid
-      xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
-      yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
+      gridSpacing.set((probe_position_rb.x - probe_position_lf.x) / (abl_grid_points.x - 1),
+                      (probe_position_rb.y - probe_position_lf.y) / (abl_grid_points.y - 1));
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_ECHOPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
@@ -457,33 +465,27 @@ G29_TYPE GcodeSuite::G29() {
       }
     #endif
 
     if (!faux) remember_feedrate_scaling_off();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
-      if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
-        || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
-        || left_probe_bed_position != bilinear_start[X_AXIS]
-        || front_probe_bed_position != bilinear_start[Y_AXIS]
-      ) {
+      if (gridSpacing != bilinear_grid_spacing || probe_position_lf != bilinear_start) {
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
-        bilinear_grid_spacing[X_AXIS] = xGridSpacing;
-        bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
-        bilinear_start[X_AXIS] = left_probe_bed_position;
-        bilinear_start[Y_AXIS] = front_probe_bed_position;
+        bilinear_grid_spacing = gridSpacing.asInt();
+        bilinear_start = probe_position_lf;
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_BILINEAR
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
@@ -539,84 +541,84 @@ G29_TYPE GcodeSuite::G29() {
       do_blocking_move_to_z(0);
     }
     else {
 
       #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
-      measured_z = current_position[Z_AXIS];
+      measured_z = current_position.z;
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
         mean += measured_z;
         eqnBVector[index] = measured_z;
-        eqnAMatrix[index + 0 * abl_points] = xProbe;
-        eqnAMatrix[index + 1 * abl_points] = yProbe;
+        eqnAMatrix[index + 0 * abl_points] = probePos.x;
+        eqnAMatrix[index + 1 * abl_points] = probePos.y;
         eqnAMatrix[index + 2 * abl_points] = 1;
 
-        incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
+        incremental_LSF(&lsf_results, probePos, measured_z);
 
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
         points[index].z = measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-        z_values[xCount][yCount] = measured_z + zoffset;
+        const float newz = measured_z + zoffset;
+        z_values[meshCount.x][meshCount.y] = newz;
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(xCount, yCount, z_values[xCount][yCount]);
+          ExtUI::onMeshUpdate(meshCount, newz);
         #endif
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Save X", xCount, " Y", yCount, " Z", measured_z + zoffset);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Save X", meshCount.x, " Y", meshCount.y, " Z", measured_z + zoffset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
     #if ABL_GRID
 
       // Skip any unreachable points
       while (abl_probe_index < abl_points) {
 
-        // Set xCount, yCount based on abl_probe_index, with zig-zag
+        // Set meshCount.x, meshCount.y based on abl_probe_index, with zig-zag
         PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
         PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
 
         // Probe in reverse order for every other row/column
         bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
 
         if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
 
-        const float xBase = xCount * xGridSpacing + left_probe_bed_position,
-                    yBase = yCount * yGridSpacing + front_probe_bed_position;
+        const xy_pos_t base = probe_position_lf.asFloat() + gridSpacing * meshCount.asFloat();
 
-        xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
-        yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
+        probePos.set(FLOOR(base.x + (base.x < 0 ? 0 : 0.5)),
+                     FLOOR(base.y + (base.y < 0 ? 0 : 0.5)));
 
         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-          indexIntoAB[xCount][yCount] = abl_probe_index;
+          indexIntoAB[meshCount.x][meshCount.y] = abl_probe_index;
         #endif
 
         // Keep looping till a reachable point is found
-        if (position_is_reachable(xProbe, yProbe)) break;
+        if (position_is_reachable(probePos)) break;
         ++abl_probe_index;
       }
 
       // Is there a next point to move to?
       if (abl_probe_index < abl_points) {
-        _manual_goto_xy(xProbe, yProbe); // Can be used here too!
+        _manual_goto_xy(probePos); // Can be used here too!
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         G29_RETURN(false);
       }
       else {
 
         // Leveling done! Fall through to G29 finishing code below
@@ -626,46 +628,41 @@ G29_TYPE GcodeSuite::G29() {
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = saved_soft_endstops_state;
         #endif
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl_probe_index < abl_points) {
-        xProbe = points[abl_probe_index].x;
-        yProbe = points[abl_probe_index].y;
-        _manual_goto_xy(xProbe, yProbe);
+        probePos = points[abl_probe_index];
+        _manual_goto_xy(probePos);
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = saved_soft_endstops_state;
         #endif
 
         if (!dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
-          if (planeNormal.z < 0) {
-            planeNormal.x *= -1;
-            planeNormal.y *= -1;
-            planeNormal.z *= -1;
-          }
+          if (planeNormal.z < 0) planeNormal *= -1;
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
           // Can't re-enable (on error) until the new grid is written
           abl_should_enable = false;
         }
 
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
@@ -674,86 +671,89 @@ G29_TYPE GcodeSuite::G29() {
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     measured_z = 0;
 
     #if ABL_GRID
 
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       measured_z = 0;
 
+      xy_int8_t meshCount;
+
+      // Outer loop is X with PROBE_Y_FIRST enabled
       // Outer loop is Y with PROBE_Y_FIRST disabled
-      for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
+      for (PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
           inStop = PR_INNER_END;
           inInc = 1;
         }
         else {     // towards origin
           inStart = PR_INNER_END - 1;
           inStop = -1;
           inInc = -1;
         }
 
         zig ^= true; // zag
 
         // An index to print current state
         uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
-        for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
+        // Inner loop is X with PROBE_Y_FIRST disabled
+        for (PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
-          const float xBase = left_probe_bed_position + xGridSpacing * xCount,
-                      yBase = front_probe_bed_position + yGridSpacing * yCount;
+          const xy_pos_t base = probe_position_lf.asFloat() + gridSpacing * meshCount.asFloat();
 
-          xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
-          yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
+          probePos.set(FLOOR(base.x + (base.x < 0 ? 0 : 0.5)),
+                       FLOOR(base.y + (base.y < 0 ? 0 : 0.5)));
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-            indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
+            indexIntoAB[meshCount.x][meshCount.y] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
-            if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
+            if (!position_is_reachable_by_probe(probePos)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), PSTR(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
-          measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(xProbe, yProbe, raise_after, verbose_level);
+          measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
-            eqnAMatrix[abl_probe_index + 0 * abl_points] = xProbe;
-            eqnAMatrix[abl_probe_index + 1 * abl_points] = yProbe;
+            eqnAMatrix[abl_probe_index + 0 * abl_points] = probePos.x;
+            eqnAMatrix[abl_probe_index + 1 * abl_points] = probePos.y;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
-            incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
+            incremental_LSF(&lsf_results, probePos, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-            z_values[xCount][yCount] = measured_z + zoffset;
+            z_values[meshCount.x][meshCount.y] = measured_z + zoffset;
             #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(xCount, yCount, z_values[xCount][yCount]);
+              ExtUI::onMeshUpdate(meshCount.x, meshCount.y, z_values[meshCount.x][meshCount.y]);
             #endif
 
           #endif
 
           abl_should_enable = false;
           idle();
 
         } // inner
       } // outer
 
@@ -761,23 +761,22 @@ G29_TYPE GcodeSuite::G29() {
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/3"), int(i));
         #endif
 
         // Retain the last probe position
-        xProbe = points[i].x;
-        yProbe = points[i].y;
-        measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(xProbe, yProbe, raise_after, verbose_level);
+        probePos = points[i];
+        measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(probePos, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;
@@ -838,157 +837,128 @@ G29_TYPE GcodeSuite::G29() {
       // For LINEAR leveling calculate matrix, print reports, correct the position
 
       /**
        * solve the plane equation ax + by + d = z
        * A is the matrix with rows [x y 1] for all the probed points
        * B is the vector of the Z positions
        * the normal vector to the plane is formed by the coefficients of the
        * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
        * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
        */
-      float plane_equation_coefficients[3];
+      struct { float a, b, d; } plane_equation_coefficients;
 
       finish_incremental_LSF(&lsf_results);
-      plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
-      plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
-      plane_equation_coefficients[2] = -lsf_results.D;
+      plane_equation_coefficients.a = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
+      plane_equation_coefficients.b = -lsf_results.B;  // but that is not yet tested.
+      plane_equation_coefficients.d = -lsf_results.D;
 
       mean /= abl_points;
 
       if (verbose_level) {
-        SERIAL_ECHOPAIR_F("Eqn coefficients: a: ", plane_equation_coefficients[0], 8);
-        SERIAL_ECHOPAIR_F(" b: ", plane_equation_coefficients[1], 8);
-        SERIAL_ECHOPAIR_F(" d: ", plane_equation_coefficients[2], 8);
+        SERIAL_ECHOPAIR_F("Eqn coefficients: a: ", plane_equation_coefficients.a, 8);
+        SERIAL_ECHOPAIR_F(" b: ", plane_equation_coefficients.b, 8);
+        SERIAL_ECHOPAIR_F(" d: ", plane_equation_coefficients.d, 8);
         if (verbose_level > 2)
           SERIAL_ECHOPAIR_F("\nMean of sampled points: ", mean, 8);
         SERIAL_EOL();
       }
 
       // Create the matrix but don't correct the position yet
       if (!dryrun)
         planner.bed_level_matrix = matrix_3x3::create_look_at(
-          vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
+          vector_3(-plane_equation_coefficients.a, -plane_equation_coefficients.b, 1)    // We can eliminate the '-' here and up above
         );
 
       // Show the Topography map if enabled
       if (do_topography_map) {
 
-        SERIAL_ECHOLNPGM("\nBed Height Topography:\n"
+        float min_diff = 999;
+
+        auto print_topo_map = [&](PGM_P const title, const bool get_min) {
+          serialprintPGM(title);
+          for (int8_t yy = abl_grid_points.y - 1; yy >= 0; yy--) {
+            for (uint8_t xx = 0; xx < abl_grid_points.x; xx++) {
+              const int ind = indexIntoAB[xx][yy];
+              xyz_float_t tmp = { eqnAMatrix[ind + 0 * abl_points],
+                                  eqnAMatrix[ind + 1 * abl_points], 0 };
+              apply_rotation_xyz(planner.bed_level_matrix, tmp);
+              if (get_min) NOMORE(min_diff, eqnBVector[ind] - tmp.z);
+              const float subval = get_min ? mean : tmp.z + min_diff,
+                            diff = eqnBVector[ind] - subval;
+              SERIAL_CHAR(' '); if (diff >= 0.0) SERIAL_CHAR('+');   // Include + for column alignment
+              SERIAL_ECHO_F(diff, 5);
+            } // xx
+            SERIAL_EOL();
+          } // yy
+          SERIAL_EOL();
+        };
+
+        print_topo_map(PSTR("\nBed Height Topography:\n"
                                "   +--- BACK --+\n"
                                "   |           |\n"
                                " L |    (+)    | R\n"
                                " E |           | I\n"
                                " F | (-) N (+) | G\n"
                                " T |           | H\n"
                                "   |    (-)    | T\n"
                                "   |           |\n"
                                "   O-- FRONT --+\n"
-                               " (0,0)");
+                               " (0,0)\n"), true);
+        if (verbose_level > 3)
+          print_topo_map(PSTR("\nCorrected Bed Height vs. Bed Topology:\n"), false);
 
-        float min_diff = 999;
-
-        for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
-          for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
-            int ind = indexIntoAB[xx][yy];
-            float diff = eqnBVector[ind] - mean,
-                  x_tmp = eqnAMatrix[ind + 0 * abl_points],
-                  y_tmp = eqnAMatrix[ind + 1 * abl_points],
-                  z_tmp = 0;
-
-            apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
-
-            NOMORE(min_diff, eqnBVector[ind] - z_tmp);
-
-            if (diff >= 0.0)
-              SERIAL_ECHOPGM(" +");   // Include + for column alignment
-            else
-              SERIAL_CHAR(' ');
-            SERIAL_ECHO_F(diff, 5);
-          } // xx
-          SERIAL_EOL();
-        } // yy
-        SERIAL_EOL();
-
-        if (verbose_level > 3) {
-          SERIAL_ECHOLNPGM("\nCorrected Bed Height vs. Bed Topology:");
-
-          for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
-            for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
-              int ind = indexIntoAB[xx][yy];
-              float x_tmp = eqnAMatrix[ind + 0 * abl_points],
-                    y_tmp = eqnAMatrix[ind + 1 * abl_points],
-                    z_tmp = 0;
-
-              apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
-
-              float diff = eqnBVector[ind] - z_tmp - min_diff;
-              if (diff >= 0.0)
-                SERIAL_ECHOPGM(" +");
-              // Include + for column alignment
-              else
-                SERIAL_CHAR(' ');
-              SERIAL_ECHO_F(diff, 5);
-            } // xx
-            SERIAL_EOL();
-          } // yy
-          SERIAL_EOL();
-        }
       } //do_topography_map
 
     #endif // AUTO_BED_LEVELING_LINEAR
 
     #if ABL_PLANAR
 
       // For LINEAR and 3POINT leveling correct the current position
 
       if (verbose_level > 0)
         planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
 
       if (!dryrun) {
         //
         // Correct the current XYZ position based on the tilted plane.
         //
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
-        float converted[XYZ];
-        COPY(converted, current_position);
-
-        planner.leveling_active = true;
-        planner.unapply_leveling(converted); // use conversion machinery
-        planner.leveling_active = false;
+        xyze_pos_t converted = current_position;
+        planner.force_unapply_leveling(converted); // use conversion machinery
 
         // Use the last measured distance to the bed, if possible
-        if ( NEAR(current_position[X_AXIS], xProbe - probe_offset[X_AXIS])
-          && NEAR(current_position[Y_AXIS], yProbe - probe_offset[Y_AXIS])
+        if ( NEAR(current_position.x, probePos.x - probe_offset.x)
+          && NEAR(current_position.y, probePos.y - probe_offset.y)
         ) {
-          const float simple_z = current_position[Z_AXIS] - measured_z;
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted[Z_AXIS], "  Discrepancy ", simple_z - converted[Z_AXIS]);
-          converted[Z_AXIS] = simple_z;
+          const float simple_z = current_position.z - measured_z;
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted.z, "  Discrepancy ", simple_z - converted.z);
+          converted.z = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
-        COPY(current_position, converted);
+        current_position = converted;
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position.z);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
-        current_position[Z_AXIS] -= bilinear_z_offset(current_position);
+        current_position.z -= bilinear_z_offset(current_position);
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position.z);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) restore_feedrate_and_scaling();

commit a6b0223eead964237e7920c35bb3c7757b722139
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Sep 28 02:19:11 2019 -0400

    Revive and improve DELTA probe bounds, LRFB options (#15372)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 82dc02502e..45eec2805d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -260,24 +260,31 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl_points = 3; // used to show total points
     #endif
 
     // Probe at 3 arbitrary points
     const float x_min = probe_min_x(), x_max = probe_max_x(), y_min = probe_min_y(), y_max = probe_max_y();
+
     ABL_VAR vector_3 points[3] = {
+    #if ENABLED(HAS_FIXED_3POINT)
+      vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
+      vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
+      vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
+    #else
       vector_3(x_min, y_min, 0),
       vector_3(x_max, y_min, 0),
       vector_3((x_max - x_min) / 2, y_max, 0)
+    #endif
     };
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**

commit a18d16fb8b92c78093e25f8bb88cd0a49074678e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Sep 27 03:38:43 2019 -0600

    Do not implicitly concatenate localized strings (#15383)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 584d3a11c6..82dc02502e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -708,21 +708,21 @@ G29_TYPE GcodeSuite::G29() {
             indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), int(pt_index), int(GRID_MAX_POINTS));
+            ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), PSTR(MSG_PROBING_MESH), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
           measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(xProbe, yProbe, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)

commit e9cf46a9a5d0f6aa5521497d25aab5ff4e12399c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Sep 25 03:43:41 2019 -0400

    M851 XY 3 point followup (incomplete) (#15361)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 01c0cd19b4..584d3a11c6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -259,24 +259,25 @@ G29_TYPE GcodeSuite::G29() {
                     mean;
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl_points = 3; // used to show total points
     #endif
 
     // Probe at 3 arbitrary points
+    const float x_min = probe_min_x(), x_max = probe_max_x(), y_min = probe_min_y(), y_max = probe_max_y();
     ABL_VAR vector_3 points[3] = {
-      vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
-      vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
-      vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
+      vector_3(x_min, y_min, 0),
+      vector_3(x_max, y_min, 0),
+      vector_3((x_max - x_min) / 2, y_max, 0)
     };
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**

commit 5288c399ce780cd3e91ee413d1f92ca9e4da53a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:34:07 2019 -0500

    Patch probe offset name, defines

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e874d37409..01c0cd19b4 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -384,32 +384,35 @@ G29_TYPE GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
+      const float x_min = probe_min_x(), x_max = probe_max_x(),
+                  y_min = probe_min_y(), y_max = probe_max_y();
+
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        left_probe_bed_position  = _MAX(X_CENTER - size / 2, probe_min_x());
-        right_probe_bed_position = _MIN(left_probe_bed_position + size, probe_max_x());
-        front_probe_bed_position = _MAX(Y_CENTER - size / 2, probe_min_y());
-        back_probe_bed_position  = _MIN(front_probe_bed_position + size, probe_max_y());
+        left_probe_bed_position  = _MAX(X_CENTER - size / 2, x_min);
+        right_probe_bed_position = _MIN(left_probe_bed_position + size, x_max);
+        front_probe_bed_position = _MAX(Y_CENTER - size / 2, y_min);
+        back_probe_bed_position  = _MIN(front_probe_bed_position + size, y_max);
       }
       else {
-        left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MAX(X_CENTER - X_BED_SIZE / 2, probe_min_x());
-        right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MIN(left_probe_bed_position + X_BED_SIZE, probe_max_x());
-        front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MAX(Y_CENTER - Y_BED_SIZE / 2, probe_min_y());
-        back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MIN(front_probe_bed_position + Y_BED_SIZE, probe_max_y());
+        left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MAX(X_CENTER - X_BED_SIZE / 2, x_min);
+        right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MIN(left_probe_bed_position + X_BED_SIZE, x_max);
+        front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MAX(Y_CENTER - Y_BED_SIZE / 2, y_min);
+        back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MIN(front_probe_bed_position + Y_BED_SIZE, y_max);
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
              !position_is_reachable_by_probe(left_probe_bed_position, 0)
           || !position_is_reachable_by_probe(right_probe_bed_position, 0)
           || !position_is_reachable_by_probe(0, front_probe_bed_position)
           || !position_is_reachable_by_probe(0, back_probe_bed_position)
         #else
              !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 372ba5b372..e874d37409 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -940,22 +940,22 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         float converted[XYZ];
         COPY(converted, current_position);
 
         planner.leveling_active = true;
         planner.unapply_leveling(converted); // use conversion machinery
         planner.leveling_active = false;
 
         // Use the last measured distance to the bed, if possible
-        if ( NEAR(current_position[X_AXIS], xProbe - zprobe_offset[X_AXIS])
-          && NEAR(current_position[Y_AXIS], yProbe - zprobe_offset[Y_AXIS])
+        if ( NEAR(current_position[X_AXIS], xProbe - probe_offset[X_AXIS])
+          && NEAR(current_position[Y_AXIS], yProbe - probe_offset[Y_AXIS])
         ) {
           const float simple_z = current_position[Z_AXIS] - measured_z;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted[Z_AXIS], "  Discrepancy ", simple_z - converted[Z_AXIS]);
           converted[Z_AXIS] = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         COPY(current_position, converted);
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index b942654a30..372ba5b372 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -386,30 +386,30 @@ G29_TYPE GcodeSuite::G29() {
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        left_probe_bed_position  = _MAX(X_CENTER - size / 2, MIN_PROBE_X);
-        right_probe_bed_position = _MIN(left_probe_bed_position + size, MAX_PROBE_X);
-        front_probe_bed_position = _MAX(Y_CENTER - size / 2, MIN_PROBE_Y);
-        back_probe_bed_position  = _MIN(front_probe_bed_position + size, MAX_PROBE_Y);
+        left_probe_bed_position  = _MAX(X_CENTER - size / 2, probe_min_x());
+        right_probe_bed_position = _MIN(left_probe_bed_position + size, probe_max_x());
+        front_probe_bed_position = _MAX(Y_CENTER - size / 2, probe_min_y());
+        back_probe_bed_position  = _MIN(front_probe_bed_position + size, probe_max_y());
       }
       else {
-        left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
-        right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
-        front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
-        back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
+        left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MAX(X_CENTER - X_BED_SIZE / 2, probe_min_x());
+        right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : _MIN(left_probe_bed_position + X_BED_SIZE, probe_max_x());
+        front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MAX(Y_CENTER - Y_BED_SIZE / 2, probe_min_y());
+        back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : _MIN(front_probe_bed_position + Y_BED_SIZE, probe_max_y());
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
              !position_is_reachable_by_probe(left_probe_bed_position, 0)
           || !position_is_reachable_by_probe(right_probe_bed_position, 0)
           || !position_is_reachable_by_probe(0, front_probe_bed_position)
           || !position_is_reachable_by_probe(0, back_probe_bed_position)
         #else
              !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
@@ -940,22 +940,22 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         float converted[XYZ];
         COPY(converted, current_position);
 
         planner.leveling_active = true;
         planner.unapply_leveling(converted); // use conversion machinery
         planner.leveling_active = false;
 
         // Use the last measured distance to the bed, if possible
-        if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
-          && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
+        if ( NEAR(current_position[X_AXIS], xProbe - zprobe_offset[X_AXIS])
+          && NEAR(current_position[Y_AXIS], yProbe - zprobe_offset[Y_AXIS])
         ) {
           const float simple_z = current_position[Z_AXIS] - measured_z;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted[Z_AXIS], "  Discrepancy ", simple_z - converted[Z_AXIS]);
           converted[Z_AXIS] = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         COPY(current_position, converted);
 
         if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);

commit 5e13fe989f21bcbd4da1a567953dab8a18f96e11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 23 20:58:01 2019 -0500

    Rename some feedrate-oriented functions

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0c08a132d5..b942654a30 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -439,21 +439,21 @@ G29_TYPE GcodeSuite::G29() {
     if (!no_action) set_bed_leveling_enabled(false);
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
         set_bed_leveling_enabled(abl_should_enable);
         G29_RETURN(false);
       }
     #endif
 
-    if (!faux) setup_for_endstop_or_probe_move();
+    if (!faux) remember_feedrate_scaling_off();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
       if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
         || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
         || left_probe_bed_position != bilinear_start[X_AXIS]
         || front_probe_bed_position != bilinear_start[Y_AXIS]
@@ -973,21 +973,21 @@ G29_TYPE GcodeSuite::G29() {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
       }
 
     #endif // ABL_PLANAR
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
-  if (!faux) clean_up_after_endstop_or_probe_move();
+  if (!faux) restore_feedrate_and_scaling();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
 
   if (planner.leveling_active)
     sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 85af12c655..0c08a132d5 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -707,21 +707,21 @@ G29_TYPE GcodeSuite::G29() {
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
           #endif
 
           if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), int(pt_index), int(GRID_MAX_POINTS));
           #endif
 
-          measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
+          measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(xProbe, yProbe, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
@@ -752,21 +752,21 @@ G29_TYPE GcodeSuite::G29() {
 
       for (uint8_t i = 0; i < 3; ++i) {
         if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/3"), int(i));
         #endif
 
         // Retain the last probe position
         xProbe = points[i].x;
         yProbe = points[i].y;
-        measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
+        measured_z = faux ? 0.001 * random(-100, 101) : probe_at_point(xProbe, yProbe, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) planeNormal *= -1;

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f8f51fb174..85af12c655 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -762,25 +762,21 @@ G29_TYPE GcodeSuite::G29() {
         measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
-        if (planeNormal.z < 0) {
-          planeNormal.x *= -1;
-          planeNormal.y *= -1;
-          planeNormal.z *= -1;
-        }
+        if (planeNormal.z < 0) planeNormal *= -1;
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     #if HAS_DISPLAY
       ui.reset_status();

commit f9992c5f33d954da1a70a03acf8b58d86def601b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 11 02:46:52 2019 -0500

    Implausible

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 667bf3e9fc..f8f51fb174 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -342,46 +342,46 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
     // Jettison bed leveling data
     if (!seen_w && parser.seen('J')) {
       reset_bed_level();
       G29_RETURN(false);
     }
 
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
-      SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-4).");
+      SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
       G29_RETURN(false);
     }
 
     dryrun = parser.boolval('D')
       #if ENABLED(PROBE_MANUALLY)
         || no_action
       #endif
     ;
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
       abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
       if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
 
       if (!WITHIN(abl_grid_points_x, 2, GRID_MAX_POINTS_X)) {
-        SERIAL_ECHOLNPGM("?Probe points (X) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
+        SERIAL_ECHOLNPGM("?Probe points (X) implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
         G29_RETURN(false);
       }
       if (!WITHIN(abl_grid_points_y, 2, GRID_MAX_POINTS_Y)) {
-        SERIAL_ECHOLNPGM("?Probe points (Y) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
+        SERIAL_ECHOLNPGM("?Probe points (Y) implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
         G29_RETURN(false);
       }
 
       abl_points = abl_grid_points_x * abl_grid_points_y;
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 

commit f59a7e8b0747b4b1a336f7766ee4cd6f3eab071d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Aug 1 21:11:26 2019 -0400

    Print/display ABL current probe point (#14788)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index b7927b4fa2..667bf3e9fc 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,21 +29,21 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
-#if BOTH(LCD_BED_LEVELING, PROBE_MANUALLY)
+#if HAS_DISPLAY
   #include "../../../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
@@ -247,22 +247,22 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       ABL_VAR float zoffset;
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
 
-      ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
-                    eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
+      ABL_VAR float eqnAMatrix[(GRID_MAX_POINTS) * 3], // "A" matrix of the linear system of equations
+                    eqnBVector[GRID_MAX_POINTS],       // "B" vector of Z points
                     mean;
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl_points = 3; // used to show total points
     #endif
 
     // Probe at 3 arbitrary points
@@ -304,22 +304,21 @@ G29_TYPE GcodeSuite::G29() {
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
-        int8_t i = parser.byteval('I', -1),
-               j = parser.byteval('J', -1);
+        int8_t i = parser.byteval('I', -1), j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
           j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
           LIMIT(i, 0, GRID_MAX_POINTS_X - 1);
           LIMIT(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
@@ -682,43 +681,51 @@ G29_TYPE GcodeSuite::G29() {
           inInc = 1;
         }
         else {     // towards origin
           inStart = PR_INNER_END - 1;
           inStop = -1;
           inInc = -1;
         }
 
         zig ^= true; // zag
 
+        // An index to print current state
+        uint8_t pt_index = (PR_OUTER_VAR) * (PR_INNER_END) + 1;
+
         // Inner loop is Y with PROBE_Y_FIRST enabled
-        for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
+        for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; pt_index++, PR_INNER_VAR += inInc) {
 
           const float xBase = left_probe_bed_position + xGridSpacing * xCount,
                       yBase = front_probe_bed_position + yGridSpacing * yCount;
 
           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
           #endif
 
+          if (verbose_level) SERIAL_ECHOLNPAIR("Probing mesh point ", int(pt_index), "/", int(GRID_MAX_POINTS), ".");
+          #if HAS_DISPLAY
+            ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), int(pt_index), int(GRID_MAX_POINTS));
+          #endif
+
           measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
-            break;
+            break; // Breaks out of both loops
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl_points] = xProbe;
             eqnAMatrix[abl_probe_index + 1 * abl_points] = yProbe;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
@@ -737,20 +744,25 @@ G29_TYPE GcodeSuite::G29() {
           idle();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
+        if (verbose_level) SERIAL_ECHOLNPAIR("Probing point ", int(i), "/3.");
+        #if HAS_DISPLAY
+          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/3"), int(i));
+        #endif
+
         // Retain the last probe position
         xProbe = points[i].x;
         yProbe = points[i].y;
         measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
@@ -763,20 +775,24 @@ G29_TYPE GcodeSuite::G29() {
           planeNormal.z *= -1;
         }
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
+    #if HAS_DISPLAY
+      ui.reset_status();
+    #endif
+
     // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (STOW_PROBE()) {
       set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code

commit e96468566d66b9e7bcf0c4450a7b988523def580
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sun Jul 14 16:28:38 2019 +0700

    Fix Z_PROBE_END_SCRIPT in ABL (#14621)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 64ae54ef21..b7927b4fa2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -956,38 +956,38 @@ G29_TYPE GcodeSuite::G29() {
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
         current_position[Z_AXIS] -= bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
       }
 
     #endif // ABL_PLANAR
 
-    #ifdef Z_PROBE_END_SCRIPT
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
-      planner.synchronize();
-      process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
-    #endif
-
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
 
   if (planner.leveling_active)
     sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
+  #ifdef Z_PROBE_END_SCRIPT
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+    planner.synchronize();
+    process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
+  #endif
+
   report_current_position();
 
   G29_RETURN(isnan(measured_z));
 }
 
 #endif // HAS_ABL_NOT_UBL

commit ed0e6afacbbd5ef8836166feccbd4b50fc9da009
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 10 03:33:28 2019 -0500

    Apply LIMIT macro

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 2a4b4f85bb..64ae54ef21 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -311,22 +311,22 @@ G29_TYPE GcodeSuite::G29() {
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1),
                j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
           j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
-          i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
-          j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
+          LIMIT(i, 0, GRID_MAX_POINTS_X - 1);
+          LIMIT(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(i, j, rz);
           #endif

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 64f5473672..2a4b4f85bb 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -387,24 +387,24 @@ G29_TYPE GcodeSuite::G29() {
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        left_probe_bed_position  = MAX(X_CENTER - size / 2, MIN_PROBE_X);
-        right_probe_bed_position = MIN(left_probe_bed_position + size, MAX_PROBE_X);
-        front_probe_bed_position = MAX(Y_CENTER - size / 2, MIN_PROBE_Y);
-        back_probe_bed_position  = MIN(front_probe_bed_position + size, MAX_PROBE_Y);
+        left_probe_bed_position  = _MAX(X_CENTER - size / 2, MIN_PROBE_X);
+        right_probe_bed_position = _MIN(left_probe_bed_position + size, MAX_PROBE_X);
+        front_probe_bed_position = _MAX(Y_CENTER - size / 2, MIN_PROBE_Y);
+        back_probe_bed_position  = _MIN(front_probe_bed_position + size, MAX_PROBE_Y);
       }
       else {
         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
@@ -504,21 +504,21 @@ G29_TYPE GcodeSuite::G29() {
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         ui.wait_for_bl_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress) {
-        SERIAL_ECHOPAIR("point ", MIN(abl_probe_index + 1, abl_points));
+        SERIAL_ECHOPAIR("point ", _MIN(abl_probe_index + 1, abl_points));
         SERIAL_ECHOLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state

commit d16954dc885f75869b572549c5e90561b89a95bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 29 22:49:50 2019 -0500

    Make KEEPALIVE_STATE a scoped auto-restore (#14446)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f0e4b34ec1..64f5473672 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -971,22 +971,20 @@ G29_TYPE GcodeSuite::G29() {
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
 
-  KEEPALIVE_STATE(IN_HANDLER);
-
   if (planner.leveling_active)
     sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
   report_current_position();
 
   G29_RETURN(isnan(measured_z));

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index d17e1ff627..f0e4b34ec1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit ce656e2a268a120ccef77a7d80cc5c1c4fcc7f7e
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jun 27 16:07:45 2019 -0400

    Update G-code injection, sub-commands (#14418)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index bcef33ec4a..d17e1ff627 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -959,21 +959,21 @@ G29_TYPE GcodeSuite::G29() {
         current_position[Z_AXIS] -= bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
       }
 
     #endif // ABL_PLANAR
 
     #ifdef Z_PROBE_END_SCRIPT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       planner.synchronize();
-      queue.inject_P(PSTR(Z_PROBE_END_SCRIPT));
+      process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f43cfa6a35..bcef33ec4a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -959,21 +959,21 @@ G29_TYPE GcodeSuite::G29() {
         current_position[Z_AXIS] -= bilinear_z_offset(current_position);
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
       }
 
     #endif // ABL_PLANAR
 
     #ifdef Z_PROBE_END_SCRIPT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       planner.synchronize();
-      enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
+      queue.inject_P(PSTR(Z_PROBE_END_SCRIPT));
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");

commit 212860f09073df25c05012805892e134352c13d7
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun May 26 15:53:21 2019 -0400

    Always change to Tool 0 on G29 (#14146)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 22cc0c1754..f43cfa6a35 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -48,20 +48,24 @@
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extensible_ui/ui_api.h"
 #endif
 
+#if HOTENDS > 1
+  #include "../../../module/tool_change.h"
+#endif
+
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR xCount
     #define PR_OUTER_END abl_grid_points_x
     #define PR_INNER_VAR yCount
     #define PR_INNER_END abl_grid_points_y
   #else
     #define PR_OUTER_VAR yCount
     #define PR_OUTER_END abl_grid_points_y
     #define PR_INNER_VAR xCount
@@ -273,21 +277,21 @@ G29_TYPE GcodeSuite::G29() {
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
-    #if ENABLED(DUAL_X_CARRIAGE)
+    #if HOTENDS > 1
       if (active_extruder != 0) tool_change(0);
     #endif
 
     #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)

commit 610fb4668393265bbe2f18fe96a329b832ddc0c3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Apr 26 03:32:01 2019 -0400

    Fix some ExtUI issues (#13799)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 675cd2b88e..22cc0c1754 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -44,20 +44,24 @@
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../../../lcd/extensible_ui/ui_api.h"
+#endif
+
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR xCount
     #define PR_OUTER_END abl_grid_points_x
     #define PR_INNER_VAR yCount
     #define PR_INNER_END abl_grid_points_y
   #else
     #define PR_OUTER_VAR yCount
     #define PR_OUTER_END abl_grid_points_y
     #define PR_INNER_VAR xCount

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index bcfe84e06e..675cd2b88e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -29,21 +29,21 @@
 #if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
-#if ENABLED(LCD_BED_LEVELING) && ENABLED(PROBE_MANUALLY)
+#if BOTH(LCD_BED_LEVELING, PROBE_MANUALLY)
   #include "../../../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
@@ -144,21 +144,21 @@
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  *
  */
 G29_TYPE GcodeSuite::G29() {
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE) || ENABLED(PROBE_MANUALLY)
+  #if EITHER(DEBUG_LEVELING_FEATURE, PROBE_MANUALLY)
     const bool seenQ = parser.seen('Q');
   #else
     constexpr bool seenQ = false;
   #endif
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
@@ -198,21 +198,21 @@ G29_TYPE GcodeSuite::G29() {
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
   ABL_VAR int verbose_level;
   ABL_VAR float xProbe, yProbe, measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
-  #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
+  #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
     ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
@@ -273,21 +273,21 @@ G29_TYPE GcodeSuite::G29() {
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder != 0) tool_change(0);
     #endif
 
-    #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #if EITHER(PROBE_MANUALLY, AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
@@ -515,21 +515,21 @@ G29_TYPE GcodeSuite::G29() {
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
         saved_soft_endstops_state = soft_endstops_enabled;
       #endif
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT)
+      #if EITHER(AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
       measured_z = current_position[Z_AXIS];
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
         mean += measured_z;

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 93c66a60a9..bcfe84e06e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -41,20 +41,23 @@
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_PLANAR
   #include "../../../libs/vector_3.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../../core/debug_out.h"
+
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR xCount
     #define PR_OUTER_END abl_grid_points_x
     #define PR_INNER_VAR yCount
     #define PR_INNER_END abl_grid_points_y
   #else
     #define PR_OUTER_VAR yCount
     #define PR_OUTER_END abl_grid_points_y
     #define PR_INNER_VAR xCount
@@ -180,26 +183,21 @@ G29_TYPE GcodeSuite::G29() {
                   parser.boolval('C')
                 #else
                   no_action
                 #endif
               ;
 
   // Don't allow auto-leveling without homing first
   if (axis_unhomed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("> Auto-level not needed, skip");
-        SERIAL_ECHOLNPGM("<<< G29");
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Auto-level not needed, skip\n<<< G29");
     G29_RETURN(false);
   }
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
@@ -463,23 +461,21 @@ G29_TYPE GcodeSuite::G29() {
         bilinear_start[Y_AXIS] = front_probe_bed_position;
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_BILINEAR
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> 3-point Leveling");
 
       // Probe at 3 arbitrary points
       points[0].z = points[1].z = points[2].z = 0;
 
     #endif // AUTO_BED_LEVELING_3POINT
 
   } // !g29_in_progress
 
   #if ENABLED(PROBE_MANUALLY)
 
@@ -548,27 +544,21 @@ G29_TYPE GcodeSuite::G29() {
 
         points[index].z = measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         z_values[xCount][yCount] = measured_z + zoffset;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(xCount, yCount, z_values[xCount][yCount]);
         #endif
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPAIR("Save X", xCount);
-            SERIAL_ECHOPAIR(" Y", yCount);
-            SERIAL_ECHOLNPAIR(" Z", measured_z + zoffset);
-          }
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Save X", xCount, " Y", yCount, " Z", measured_z + zoffset);
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
     #if ABL_GRID
 
@@ -783,23 +773,21 @@ G29_TYPE GcodeSuite::G29() {
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
   // definitely be enabled after this point.
   //
   // If code above wants to continue leveling, it should
   // return or loop before this point.
   //
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     #if ENABLED(LCD_BED_LEVELING)
       ui.wait_for_bl_move = false;
     #endif
   #endif
 
   // Calculate leveling, print reports, correct the position
   if (!isnan(measured_z)) {
@@ -922,90 +910,72 @@ G29_TYPE GcodeSuite::G29() {
       // For LINEAR and 3POINT leveling correct the current position
 
       if (verbose_level > 0)
         planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
 
       if (!dryrun) {
         //
         // Correct the current XYZ position based on the tilted plane.
         //
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
 
         float converted[XYZ];
         COPY(converted, current_position);
 
         planner.leveling_active = true;
         planner.unapply_leveling(converted); // use conversion machinery
         planner.leveling_active = false;
 
         // Use the last measured distance to the bed, if possible
         if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
           && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
         ) {
           const float simple_z = current_position[Z_AXIS] - measured_z;
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR("Z from Probe:", simple_z);
-              SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
-              SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
-            }
-          #endif
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probed Z", simple_z, "  Matrix Z", converted[Z_AXIS], "  Discrepancy ", simple_z - converted[Z_AXIS]);
           converted[Z_AXIS] = simple_z;
         }
 
         // The rotated XY and corrected Z are now current_position
         COPY(current_position, converted);
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
 
         // Unapply the offset because it is going to be immediately applied
         // and cause compensation movement in Z
         current_position[Z_AXIS] -= bilinear_z_offset(current_position);
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
       }
 
     #endif // ABL_PLANAR
 
     #ifdef Z_PROBE_END_SCRIPT
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       planner.synchronize();
       enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G29");
 
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index a79c35af9a..93c66a60a9 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -205,21 +205,21 @@ G29_TYPE GcodeSuite::G29() {
 
   ABL_VAR int verbose_level;
   ABL_VAR float xProbe, yProbe, measured_z;
   ABL_VAR bool dryrun, abl_should_enable;
 
   #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
     ABL_VAR int abl_probe_index;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
-    ABL_VAR bool enable_soft_endstops = true;
+    ABL_VAR bool saved_soft_endstops_state = true;
   #endif
 
   #if ABL_GRID
 
     #if ENABLED(PROBE_MANUALLY)
       ABL_VAR uint8_t PR_OUTER_VAR;
       ABL_VAR  int8_t PR_INNER_VAR;
     #endif
 
     ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
@@ -487,21 +487,21 @@ G29_TYPE GcodeSuite::G29() {
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_ECHOLNPGM("Manual G29 aborted");
       #if HAS_SOFTWARE_ENDSTOPS
-        soft_endstops_enabled = enable_soft_endstops;
+        soft_endstops_enabled = saved_soft_endstops_state;
       #endif
       set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         ui.wait_for_bl_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
@@ -512,21 +512,21 @@ G29_TYPE GcodeSuite::G29() {
       }
       else
         SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
-        enable_soft_endstops = soft_endstops_enabled;
+        saved_soft_endstops_state = soft_endstops_enabled;
       #endif
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
@@ -610,21 +610,21 @@ G29_TYPE GcodeSuite::G29() {
         G29_RETURN(false);
       }
       else {
 
         // Leveling done! Fall through to G29 finishing code below
 
         SERIAL_ECHOLNPGM("Grid probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
-          soft_endstops_enabled = enable_soft_endstops;
+          soft_endstops_enabled = saved_soft_endstops_state;
         #endif
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl_probe_index < abl_points) {
         xProbe = points[abl_probe_index].x;
         yProbe = points[abl_probe_index].y;
         _manual_goto_xy(xProbe, yProbe);
@@ -634,21 +634,21 @@ G29_TYPE GcodeSuite::G29() {
           soft_endstops_enabled = false;
         #endif
         G29_RETURN(false);
       }
       else {
 
         SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
-          soft_endstops_enabled = enable_soft_endstops;
+          soft_endstops_enabled = saved_soft_endstops_state;
         #endif
 
         if (!dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) {
             planeNormal.x *= -1;
             planeNormal.y *= -1;
             planeNormal.z *= -1;
           }
           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);

commit c03df89921ba0327dda27c5df52aadd3754074aa
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:45:52 2019 -0400

    ExtUI Mesh Leveling Extensions (#13363)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 7d09c41689..a79c35af9a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -314,20 +314,23 @@ G29_TYPE GcodeSuite::G29() {
           j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
           i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
           j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(i, j, rz);
+          #endif
           set_bed_leveling_enabled(abl_should_enable);
           if (abl_should_enable) report_current_position();
         }
         G29_RETURN(false);
       } // parser.seen('W')
 
     #else
 
       constexpr bool seen_w = false;
 
@@ -541,20 +544,23 @@ G29_TYPE GcodeSuite::G29() {
 
         incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
 
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
         points[index].z = measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         z_values[xCount][yCount] = measured_z + zoffset;
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(xCount, yCount, z_values[xCount][yCount]);
+        #endif
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             SERIAL_ECHOPAIR("Save X", xCount);
             SERIAL_ECHOPAIR(" Y", yCount);
             SERIAL_ECHOLNPAIR(" Z", measured_z + zoffset);
           }
         #endif
 
       #endif
@@ -716,20 +722,23 @@ G29_TYPE GcodeSuite::G29() {
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl_points] = xProbe;
             eqnAMatrix[abl_probe_index + 1 * abl_points] = yProbe;
             eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
             incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             z_values[xCount][yCount] = measured_z + zoffset;
+            #if ENABLED(EXTENSIBLE_UI)
+              ExtUI::onMeshUpdate(xCount, yCount, z_values[xCount][yCount]);
+            #endif
 
           #endif
 
           abl_should_enable = false;
           idle();
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)

commit 808b076000e89fd7dae071bd2e4899833c872af6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 24 20:29:03 2019 -0600

    Update some ABL/UBL conditionals

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index b9a67aeb7a..7d09c41689 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * G29.cpp - Auto Bed Leveling
  */
 
 #include "../../../inc/MarlinConfig.h"
 
-#if OLDSCHOOL_ABL
+#if HAS_ABL_NOT_UBL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
 #include "../../queue.h"
 
 #if ENABLED(LCD_BED_LEVELING) && ENABLED(PROBE_MANUALLY)
@@ -998,11 +998,11 @@ G29_TYPE GcodeSuite::G29() {
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
   report_current_position();
 
   G29_RETURN(isnan(measured_z));
 }
 
-#endif // OLDSCHOOL_ABL
+#endif // HAS_ABL_NOT_UBL

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 8d2a3ad60c..b9a67aeb7a 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 3bb8b3529a32a9a4cf9f5e9ebaca8821d35c70c9
Author: MasterPIC <armando_unina@yahoo.it>
Date:   Sun Dec 9 18:24:48 2018 +0100

    Center ABL grid on bed with H parameter. (#12610)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index fc76bf639e..8d2a3ad60c 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -378,24 +378,24 @@ G29_TYPE GcodeSuite::G29() {
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       if (parser.seen('H')) {
         const int16_t size = (int16_t)parser.value_linear_units();
-        left_probe_bed_position  = MAX((MIN_PROBE_X + MAX_PROBE_X - size) / 2, MIN_PROBE_X);
-        right_probe_bed_position = MIN(left_probe_bed_position + size,         MAX_PROBE_X);
-        front_probe_bed_position = MAX((MIN_PROBE_Y + MAX_PROBE_Y - size) / 2, MIN_PROBE_Y);
-        back_probe_bed_position  = MIN(front_probe_bed_position + size,        MAX_PROBE_Y);
+        left_probe_bed_position  = MAX(X_CENTER - size / 2, MIN_PROBE_X);
+        right_probe_bed_position = MIN(left_probe_bed_position + size, MAX_PROBE_X);
+        front_probe_bed_position = MAX(Y_CENTER - size / 2, MIN_PROBE_Y);
+        back_probe_bed_position  = MIN(front_probe_bed_position + size, MAX_PROBE_Y);
       }
       else {
         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
       }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ecc2196923..fc76bf639e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -286,29 +286,27 @@ G29_TYPE GcodeSuite::G29() {
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM("No bilinear grid");
+          SERIAL_ERROR_MSG("No bilinear grid");
           G29_RETURN(false);
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
         if (!WITHIN(rz, -10, 10)) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM("Bad Z value");
+          SERIAL_ERROR_MSG("Bad Z value");
           G29_RETURN(false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1),
                j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
@@ -336,46 +334,46 @@ G29_TYPE GcodeSuite::G29() {
     #endif
 
     // Jettison bed leveling data
     if (!seen_w && parser.seen('J')) {
       reset_bed_level();
       G29_RETURN(false);
     }
 
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
-      SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
+      SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-4).");
       G29_RETURN(false);
     }
 
     dryrun = parser.boolval('D')
       #if ENABLED(PROBE_MANUALLY)
         || no_action
       #endif
     ;
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
       abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
       if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
 
       if (!WITHIN(abl_grid_points_x, 2, GRID_MAX_POINTS_X)) {
-        SERIAL_PROTOCOLLNPGM("?Probe points (X) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
+        SERIAL_ECHOLNPGM("?Probe points (X) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
         G29_RETURN(false);
       }
       if (!WITHIN(abl_grid_points_y, 2, GRID_MAX_POINTS_Y)) {
-        SERIAL_PROTOCOLLNPGM("?Probe points (Y) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
+        SERIAL_ECHOLNPGM("?Probe points (Y) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
         G29_RETURN(false);
       }
 
       abl_points = abl_grid_points_x * abl_grid_points_y;
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
@@ -403,33 +401,33 @@ G29_TYPE GcodeSuite::G29() {
         #if IS_SCARA || ENABLED(DELTA)
              !position_is_reachable_by_probe(left_probe_bed_position, 0)
           || !position_is_reachable_by_probe(right_probe_bed_position, 0)
           || !position_is_reachable_by_probe(0, front_probe_bed_position)
           || !position_is_reachable_by_probe(0, back_probe_bed_position)
         #else
              !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
           || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)
         #endif
       ) {
-        SERIAL_PROTOCOLLNPGM("? (L,R,F,B) out of bounds.");
+        SERIAL_ECHOLNPGM("? (L,R,F,B) out of bounds.");
         G29_RETURN(false);
       }
 
       // probe at the points of a lattice grid
       xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
-      SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
-      if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
+      SERIAL_ECHOPGM("G29 Auto Bed Leveling");
+      if (dryrun) SERIAL_ECHOPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     planner.synchronize();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     #if HAS_BED_PROBE
@@ -484,40 +482,40 @@ G29_TYPE GcodeSuite::G29() {
 
     // For manual probing, get the next index to probe now.
     // On the first probe this will be incremented to 0.
     if (!no_action) {
       ++abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
-      SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
+      SERIAL_ECHOLNPGM("Manual G29 aborted");
       #if HAS_SOFTWARE_ENDSTOPS
         soft_endstops_enabled = enable_soft_endstops;
       #endif
       set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         ui.wait_for_bl_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
-      SERIAL_PROTOCOLPGM("Manual G29 ");
+      SERIAL_ECHOPGM("Manual G29 ");
       if (g29_in_progress) {
-        SERIAL_PROTOCOLPAIR("point ", MIN(abl_probe_index + 1, abl_points));
-        SERIAL_PROTOCOLLNPAIR(" of ", abl_points);
+        SERIAL_ECHOPAIR("point ", MIN(abl_probe_index + 1, abl_points));
+        SERIAL_ECHOLNPAIR(" of ", abl_points);
       }
       else
-        SERIAL_PROTOCOLLNPGM("idle");
+        SERIAL_ECHOLNPGM("idle");
     }
 
     if (no_action) G29_RETURN(false);
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
         enable_soft_endstops = soft_endstops_enabled;
       #endif
       // Move close to the bed before the first point
@@ -546,23 +544,23 @@ G29_TYPE GcodeSuite::G29() {
       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
         points[index].z = measured_z;
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         z_values[xCount][yCount] = measured_z + zoffset;
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
-            SERIAL_PROTOCOLPAIR("Save X", xCount);
-            SERIAL_PROTOCOLPAIR(" Y", yCount);
-            SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
+            SERIAL_ECHOPAIR("Save X", xCount);
+            SERIAL_ECHOPAIR(" Y", yCount);
+            SERIAL_ECHOLNPAIR(" Z", measured_z + zoffset);
           }
         #endif
 
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
@@ -602,21 +600,21 @@ G29_TYPE GcodeSuite::G29() {
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         G29_RETURN(false);
       }
       else {
 
         // Leveling done! Fall through to G29 finishing code below
 
-        SERIAL_PROTOCOLLNPGM("Grid probing done.");
+        SERIAL_ECHOLNPGM("Grid probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
         #endif
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
@@ -626,21 +624,21 @@ G29_TYPE GcodeSuite::G29() {
         _manual_goto_xy(xProbe, yProbe);
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         G29_RETURN(false);
       }
       else {
 
-        SERIAL_PROTOCOLLNPGM("3-point probing done.");
+        SERIAL_ECHOLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
         #endif
 
         if (!dryrun) {
           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
           if (planeNormal.z < 0) {
             planeNormal.x *= -1;
@@ -822,44 +820,38 @@ G29_TYPE GcodeSuite::G29() {
       float plane_equation_coefficients[3];
 
       finish_incremental_LSF(&lsf_results);
       plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
       plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
       plane_equation_coefficients[2] = -lsf_results.D;
 
       mean /= abl_points;
 
       if (verbose_level) {
-        SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
-        SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
-        SERIAL_PROTOCOLPGM(" b: ");
-        SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
-        SERIAL_PROTOCOLPGM(" d: ");
-        SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
+        SERIAL_ECHOPAIR_F("Eqn coefficients: a: ", plane_equation_coefficients[0], 8);
+        SERIAL_ECHOPAIR_F(" b: ", plane_equation_coefficients[1], 8);
+        SERIAL_ECHOPAIR_F(" d: ", plane_equation_coefficients[2], 8);
+        if (verbose_level > 2)
+          SERIAL_ECHOPAIR_F("\nMean of sampled points: ", mean, 8);
         SERIAL_EOL();
-        if (verbose_level > 2) {
-          SERIAL_PROTOCOLPGM("Mean of sampled points: ");
-          SERIAL_PROTOCOL_F(mean, 8);
-          SERIAL_EOL();
-        }
       }
 
       // Create the matrix but don't correct the position yet
       if (!dryrun)
         planner.bed_level_matrix = matrix_3x3::create_look_at(
           vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
         );
 
       // Show the Topography map if enabled
       if (do_topography_map) {
 
-        SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
+        SERIAL_ECHOLNPGM("\nBed Height Topography:\n"
                                "   +--- BACK --+\n"
                                "   |           |\n"
                                " L |    (+)    | R\n"
                                " E |           | I\n"
                                " F | (-) N (+) | G\n"
                                " T |           | H\n"
                                "   |    (-)    | T\n"
                                "   |           |\n"
                                "   O-- FRONT --+\n"
                                " (0,0)");
@@ -872,48 +864,48 @@ G29_TYPE GcodeSuite::G29() {
             float diff = eqnBVector[ind] - mean,
                   x_tmp = eqnAMatrix[ind + 0 * abl_points],
                   y_tmp = eqnAMatrix[ind + 1 * abl_points],
                   z_tmp = 0;
 
             apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
 
             NOMORE(min_diff, eqnBVector[ind] - z_tmp);
 
             if (diff >= 0.0)
-              SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
+              SERIAL_ECHOPGM(" +");   // Include + for column alignment
             else
-              SERIAL_PROTOCOLCHAR(' ');
-            SERIAL_PROTOCOL_F(diff, 5);
+              SERIAL_CHAR(' ');
+            SERIAL_ECHO_F(diff, 5);
           } // xx
           SERIAL_EOL();
         } // yy
         SERIAL_EOL();
 
         if (verbose_level > 3) {
-          SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
+          SERIAL_ECHOLNPGM("\nCorrected Bed Height vs. Bed Topology:");
 
           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
               int ind = indexIntoAB[xx][yy];
               float x_tmp = eqnAMatrix[ind + 0 * abl_points],
                     y_tmp = eqnAMatrix[ind + 1 * abl_points],
                     z_tmp = 0;
 
               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
 
               float diff = eqnBVector[ind] - z_tmp - min_diff;
               if (diff >= 0.0)
-                SERIAL_PROTOCOLPGM(" +");
+                SERIAL_ECHOPGM(" +");
               // Include + for column alignment
               else
-                SERIAL_PROTOCOLCHAR(' ');
-              SERIAL_PROTOCOL_F(diff, 5);
+                SERIAL_CHAR(' ');
+              SERIAL_ECHO_F(diff, 5);
             } // xx
             SERIAL_EOL();
           } // yy
           SERIAL_EOL();
         }
       } //do_topography_map
 
     #endif // AUTO_BED_LEVELING_LINEAR
 
     #if ABL_PLANAR

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 547ef15612..ecc2196923 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -491,21 +491,21 @@ G29_TYPE GcodeSuite::G29() {
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
       #if HAS_SOFTWARE_ENDSTOPS
         soft_endstops_enabled = enable_soft_endstops;
       #endif
       set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
-        lcd_wait_for_move = false;
+        ui.wait_for_bl_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_PROTOCOLPGM("Manual G29 ");
       if (g29_in_progress) {
         SERIAL_PROTOCOLPAIR("point ", MIN(abl_probe_index + 1, abl_points));
         SERIAL_PROTOCOLLNPAIR(" of ", abl_points);
       }
@@ -783,21 +783,21 @@ G29_TYPE GcodeSuite::G29() {
   // return or loop before this point.
   //
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
   #endif
 
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
     #if ENABLED(LCD_BED_LEVELING)
-      lcd_wait_for_move = false;
+      ui.wait_for_bl_move = false;
     #endif
   #endif
 
   // Calculate leveling, print reports, correct the position
   if (!isnan(measured_z)) {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) extrapolate_unprobed_bed_level();
       print_bilinear_leveling_grid();
 

commit b3b4e6dc456f18f933ccfa3d5e88cfa5055f1c41
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Nov 5 22:48:28 2018 -0600

    Change Marlin debug flag names to fix conflicts (#12340)
    
    In reference to #11000

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 4455a440b2..547ef15612 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -150,21 +150,21 @@ G29_TYPE GcodeSuite::G29() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE) || ENABLED(PROBE_MANUALLY)
     const bool seenQ = parser.seen('Q');
   #else
     constexpr bool seenQ = false;
   #endif
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
-    if (seenQ) marlin_debug_flags |= DEBUG_LEVELING;
+    if (seenQ) marlin_debug_flags |= MARLIN_DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS(">>> G29", current_position);
       log_machine_info();
     }
     marlin_debug_flags = old_debug_flags;
     #if DISABLED(PROBE_MANUALLY)
       if (seenQ) G29_RETURN(false);
     #endif
   #endif
 

commit 6fbc87301f628bf859933fc69064008fc9726806
Author: MasterPIC <armando_unina@yahoo.it>
Date:   Sun Oct 28 02:30:21 2018 +0100

    'G29 H' to set a centered square probe area (linear, bilinear) (#12242)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 6f4a2a5635..4455a440b2 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -96,20 +96,24 @@
  *
  *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
  *     This is useful for manual bed leveling and finding flaws in the bed (to
  *     assist with part placement).
  *     Not supported by non-linear delta printer bed leveling.
  *
  * Parameters With LINEAR and BILINEAR leveling only:
  *
  *  S  Set the XY travel speed between probe points (in units/min)
  *
+ *  H  Set bounds to a centered square H x H units in size
+ *
+ *     -or-
+ *
  *  F  Set the Front limit of the probing grid
  *  B  Set the Back limit of the probing grid
  *  L  Set the Left limit of the probing grid
  *  R  Set the Right limit of the probing grid
  *
  * Parameters with DEBUG_LEVELING_FEATURE only:
  *
  *  C  Make a totally fake grid with no actual probing.
  *     For use in testing when no probing is possible.
  *
@@ -374,24 +378,33 @@ G29_TYPE GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
-      left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
-      right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
-      front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
-      back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
+      if (parser.seen('H')) {
+        const int16_t size = (int16_t)parser.value_linear_units();
+        left_probe_bed_position  = MAX((MIN_PROBE_X + MAX_PROBE_X - size) / 2, MIN_PROBE_X);
+        right_probe_bed_position = MIN(left_probe_bed_position + size,         MAX_PROBE_X);
+        front_probe_bed_position = MAX((MIN_PROBE_Y + MAX_PROBE_Y - size) / 2, MIN_PROBE_Y);
+        back_probe_bed_position  = MIN(front_probe_bed_position + size,        MAX_PROBE_Y);
+      }
+      else {
+        left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
+        right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
+        front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
+        back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
+      }
 
       if (
         #if IS_SCARA || ENABLED(DELTA)
              !position_is_reachable_by_probe(left_probe_bed_position, 0)
           || !position_is_reachable_by_probe(right_probe_bed_position, 0)
           || !position_is_reachable_by_probe(0, front_probe_bed_position)
           || !position_is_reachable_by_probe(0, back_probe_bed_position)
         #else
              !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
           || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f6965f18e4..6f4a2a5635 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -670,22 +670,22 @@ G29_TYPE GcodeSuite::G29() {
           inStart = PR_INNER_END - 1;
           inStop = -1;
           inInc = -1;
         }
 
         zig ^= true; // zag
 
         // Inner loop is Y with PROBE_Y_FIRST enabled
         for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
 
-          float xBase = left_probe_bed_position + xGridSpacing * xCount,
-                yBase = front_probe_bed_position + yGridSpacing * yCount;
+          const float xBase = left_probe_bed_position + xGridSpacing * xCount,
+                      yBase = front_probe_bed_position + yGridSpacing * yCount;
 
           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c711b9deed..f6965f18e4 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -982,21 +982,21 @@ G29_TYPE GcodeSuite::G29() {
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   #endif
 
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
-    SYNC_PLAN_POSITION_KINEMATIC();
+    sync_plan_position();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
   report_current_position();
 
   G29_RETURN(isnan(measured_z));
 }
 

commit e05e95cf9721262d241fe313e9a4f15a779c18d9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 25 18:49:32 2018 -0500

    Clean trailing whitespace

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 50faafc362..c711b9deed 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -59,21 +59,21 @@
     #define PR_OUTER_END abl_grid_points_y
     #define PR_INNER_VAR xCount
     #define PR_INNER_END abl_grid_points_x
   #endif
 #endif
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
   #define G29_RETURN(b) return b;
 #else
   #define G29_RETURN(b) return;
-#endif 
+#endif
 
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
  *  O  Auto-level only if needed
  *
  *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
@@ -989,15 +989,15 @@ G29_TYPE GcodeSuite::G29() {
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
   report_current_position();
-  
+
   G29_RETURN(isnan(measured_z));
 }
 
 #endif // OLDSCHOOL_ABL

commit 0fff79c24b1fbf890c9d5b25172a6f0a6274ad34
Author: Colin Gilgenbach <colin@gilgenbach.net>
Date:   Fri Jun 29 19:48:11 2018 -0600

    Fixes G29_with_retry behavior (#11045)
    
    * Fix G29 (ABL) retry behavior

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c98bc6b9fa..50faafc362 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -55,20 +55,26 @@
     #define PR_INNER_VAR yCount
     #define PR_INNER_END abl_grid_points_y
   #else
     #define PR_OUTER_VAR yCount
     #define PR_OUTER_END abl_grid_points_y
     #define PR_INNER_VAR xCount
     #define PR_INNER_END abl_grid_points_x
   #endif
 #endif
 
+#if ENABLED(G29_RETRY_AND_RECOVER)
+  #define G29_RETURN(b) return b;
+#else
+  #define G29_RETURN(b) return;
+#endif 
+
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
  *  O  Auto-level only if needed
  *
  *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
  *     or alter the bed level data. Useful to check the topology
@@ -129,68 +135,68 @@
  *  Y  Y for mesh point, overrides J
  *  Z  Z for mesh point. Otherwise, raw current Z.
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  *
  */
-void GcodeSuite::G29() {
+G29_TYPE GcodeSuite::G29() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE) || ENABLED(PROBE_MANUALLY)
     const bool seenQ = parser.seen('Q');
   #else
     constexpr bool seenQ = false;
   #endif
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (seenQ) marlin_debug_flags |= DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS(">>> G29", current_position);
       log_machine_info();
     }
     marlin_debug_flags = old_debug_flags;
     #if DISABLED(PROBE_MANUALLY)
-      if (seenQ) return;
+      if (seenQ) G29_RETURN(false);
     #endif
   #endif
 
   #if ENABLED(PROBE_MANUALLY)
     const bool seenA = parser.seen('A');
   #else
     constexpr bool seenA = false;
   #endif
 
   const bool  no_action = seenA || seenQ,
               faux =
                 #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
                   parser.boolval('C')
                 #else
                   no_action
                 #endif
               ;
 
   // Don't allow auto-leveling without homing first
-  if (axis_unhomed_error()) return;
+  if (axis_unhomed_error()) G29_RETURN(false);
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("> Auto-level not needed, skip");
         SERIAL_ECHOLNPGM("<<< G29");
       }
     #endif
-    return;
+    G29_RETURN(false);
   }
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
   ABL_VAR int verbose_level;
@@ -278,28 +284,28 @@ void GcodeSuite::G29() {
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
       if (seen_w) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("No bilinear grid");
-          return;
+          G29_RETURN(false);
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("Bad Z value");
-          return;
+          G29_RETURN(false);
         }
 
         const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
                     ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1),
                j = parser.byteval('J', -1);
 
         if (!isnan(rx) && !isnan(ry)) {
           // Get nearest i / j from rx / ry
           i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
@@ -309,64 +315,64 @@ void GcodeSuite::G29() {
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
           set_bed_leveling_enabled(abl_should_enable);
           if (abl_should_enable) report_current_position();
         }
-        return;
+        G29_RETURN(false);
       } // parser.seen('W')
 
     #else
 
       constexpr bool seen_w = false;
 
     #endif
 
     // Jettison bed leveling data
     if (!seen_w && parser.seen('J')) {
       reset_bed_level();
-      return;
+      G29_RETURN(false);
     }
 
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
-      return;
+      G29_RETURN(false);
     }
 
     dryrun = parser.boolval('D')
       #if ENABLED(PROBE_MANUALLY)
         || no_action
       #endif
     ;
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
       abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
       if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
 
       if (!WITHIN(abl_grid_points_x, 2, GRID_MAX_POINTS_X)) {
         SERIAL_PROTOCOLLNPGM("?Probe points (X) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
-        return;
+        G29_RETURN(false);
       }
       if (!WITHIN(abl_grid_points_y, 2, GRID_MAX_POINTS_Y)) {
         SERIAL_PROTOCOLLNPGM("?Probe points (Y) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
-        return;
+        G29_RETURN(false);
       }
 
       abl_points = abl_grid_points_x * abl_grid_points_y;
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
@@ -385,21 +391,21 @@ void GcodeSuite::G29() {
              !position_is_reachable_by_probe(left_probe_bed_position, 0)
           || !position_is_reachable_by_probe(right_probe_bed_position, 0)
           || !position_is_reachable_by_probe(0, front_probe_bed_position)
           || !position_is_reachable_by_probe(0, back_probe_bed_position)
         #else
              !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
           || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)
         #endif
       ) {
         SERIAL_PROTOCOLLNPGM("? (L,R,F,B) out of bounds.");
-        return;
+        G29_RETURN(false);
       }
 
       // probe at the points of a lattice grid
       xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
@@ -410,21 +416,21 @@ void GcodeSuite::G29() {
     planner.synchronize();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
         set_bed_leveling_enabled(abl_should_enable);
-        return;
+        G29_RETURN(false);
       }
     #endif
 
     if (!faux) setup_for_endstop_or_probe_move();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
@@ -487,21 +493,21 @@ void GcodeSuite::G29() {
     if (verbose_level || seenQ) {
       SERIAL_PROTOCOLPGM("Manual G29 ");
       if (g29_in_progress) {
         SERIAL_PROTOCOLPAIR("point ", MIN(abl_probe_index + 1, abl_points));
         SERIAL_PROTOCOLLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_PROTOCOLLNPGM("idle");
     }
 
-    if (no_action) return;
+    if (no_action) G29_RETURN(false);
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
         enable_soft_endstops = soft_endstops_enabled;
       #endif
       // Move close to the bed before the first point
       do_blocking_move_to_z(0);
     }
     else {
@@ -577,21 +583,21 @@ void GcodeSuite::G29() {
       }
 
       // Is there a next point to move to?
       if (abl_probe_index < abl_points) {
         _manual_goto_xy(xProbe, yProbe); // Can be used here too!
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
-        return;
+        G29_RETURN(false);
       }
       else {
 
         // Leveling done! Fall through to G29 finishing code below
 
         SERIAL_PROTOCOLLNPGM("Grid probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
@@ -603,21 +609,21 @@ void GcodeSuite::G29() {
       // Probe at 3 arbitrary points
       if (abl_probe_index < abl_points) {
         xProbe = points[abl_probe_index].x;
         yProbe = points[abl_probe_index].y;
         _manual_goto_xy(xProbe, yProbe);
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
-        return;
+        G29_RETURN(false);
       }
       else {
 
         SERIAL_PROTOCOLLNPGM("3-point probing done.");
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
         #endif
 
@@ -983,13 +989,15 @@ void GcodeSuite::G29() {
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
   report_current_position();
+  
+  G29_RETURN(isnan(measured_z));
 }
 
 #endif // OLDSCHOOL_ABL

commit a2a30ff0ac2be6c915d7b0193c827bae3395638c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 19 22:54:20 2018 -0500

    Use Tool 0 for Dual X Axis G29
    
    See https://github.com/MarlinFirmware/Marlin/issues/5597#issuecomment-397683325

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index fb8a2e55ff..c98bc6b9fa 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -261,20 +261,24 @@ void GcodeSuite::G29() {
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (active_extruder != 0) tool_change(0);
+    #endif
+
     #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       const bool seen_w = parser.seen('W');
       if (seen_w) {

commit 4832be52d769304d9c92b470a88b47296b9af50b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:57:26 2018 -0500

    Followup to G29 O

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index ff46574bd5..fb8a2e55ff 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -178,20 +178,21 @@ void GcodeSuite::G29() {
 
   if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("> Auto-level not needed, skip");
         SERIAL_ECHOLNPGM("<<< G29");
       }
     #endif
     return;
   }
+
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
   ABL_VAR int verbose_level;
   ABL_VAR float xProbe, yProbe, measured_z;
   ABL_VAR bool dryrun, abl_should_enable;

commit 86170e6a66b115ab6fa4def988e8154f729c0900
Author: Robert Mendon <gibben@gmail.com>
Date:   Mon Jun 11 20:51:48 2018 -0600

    [2.0.x] Add O (optional) flag to G28/G29 (#10913)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 552c5d36ef..ff46574bd5 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -61,20 +61,22 @@
     #define PR_INNER_END abl_grid_points_x
   #endif
 #endif
 
 /**
  * G29: Detailed Z probe, probes the bed at 3 or more points.
  *      Will fail if the printer has not been homed with G28.
  *
  * Enhanced G29 Auto Bed Leveling Probe Routine
  *
+ *  O  Auto-level only if needed
+ *
  *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
  *     or alter the bed level data. Useful to check the topology
  *     after a first run of G29.
  *
  *  J  Jettison current bed leveling data
  *
  *  V  Set the verbose level (0-4). Example: "G29 V3"
  *
  * Parameters With LINEAR leveling only:
  *
@@ -167,20 +169,29 @@ void GcodeSuite::G29() {
                 #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
                   parser.boolval('C')
                 #else
                   no_action
                 #endif
               ;
 
   // Don't allow auto-leveling without homing first
   if (axis_unhomed_error()) return;
 
+  if (!no_action && planner.leveling_active && parser.boolval('O')) { // Auto-level only if needed
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM("> Auto-level not needed, skip");
+        SERIAL_ECHOLNPGM("<<< G29");
+      }
+    #endif
+    return;
+  }
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
   ABL_VAR int verbose_level;
   ABL_VAR float xProbe, yProbe, measured_z;
   ABL_VAR bool dryrun, abl_should_enable;

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e4a597da2c..552c5d36ef 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -464,21 +464,21 @@ void GcodeSuite::G29() {
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         lcd_wait_for_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_PROTOCOLPGM("Manual G29 ");
       if (g29_in_progress) {
-        SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl_points));
+        SERIAL_PROTOCOLPAIR("point ", MIN(abl_probe_index + 1, abl_points));
         SERIAL_PROTOCOLLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_PROTOCOLLNPGM("idle");
     }
 
     if (no_action) return;
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 8f33033af9..e4a597da2c 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -384,21 +384,21 @@ void GcodeSuite::G29() {
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
-    stepper.synchronize();
+    planner.synchronize();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     if (!no_action) set_bed_leveling_enabled(false);
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
         set_bed_leveling_enabled(abl_should_enable);
         return;
@@ -942,21 +942,21 @@ void GcodeSuite::G29() {
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
         #endif
       }
 
     #endif // ABL_PLANAR
 
     #ifdef Z_PROBE_END_SCRIPT
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       #endif
-      stepper.synchronize();
+      planner.synchronize();
       enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 

commit bfe223e1209af4e50917e752124c7215a4c38953
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 20:51:10 2018 -0500

    Adjust usage of stepper.synchronize

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 49b1fa7cb1..8f33033af9 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -942,22 +942,22 @@ void GcodeSuite::G29() {
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
         #endif
       }
 
     #endif // ABL_PLANAR
 
     #ifdef Z_PROBE_END_SCRIPT
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       #endif
-      enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
       stepper.synchronize();
+      enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)

commit d7b699ec340caf0c14efda13c7ced4fec78ecff9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 07:05:18 2018 -0500

    Fewer includes of vector_3.h

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index c37c5e7906..49b1fa7cb1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -37,20 +37,24 @@
 #include "../../queue.h"
 
 #if ENABLED(LCD_BED_LEVELING) && ENABLED(PROBE_MANUALLY)
   #include "../../../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
+#if ABL_PLANAR
+  #include "../../../libs/vector_3.h"
+#endif
+
 #if ABL_GRID
   #if ENABLED(PROBE_Y_FIRST)
     #define PR_OUTER_VAR xCount
     #define PR_OUTER_END abl_grid_points_x
     #define PR_INNER_VAR yCount
     #define PR_INNER_END abl_grid_points_y
   #else
     #define PR_OUTER_VAR yCount
     #define PR_OUTER_END abl_grid_points_y
     #define PR_INNER_VAR xCount

commit 59fda986ea429c83b0e20cd8b1a172fd2a550852
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 03:25:47 2018 -0500

    Allow Z_AFTER_PROBING to be 0

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 4d6206c6ad..c37c5e7906 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -958,18 +958,18 @@ void GcodeSuite::G29() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   #endif
 
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
 
-  #if HAS_BED_PROBE && Z_AFTER_PROBING
+  #if HAS_BED_PROBE && defined(Z_AFTER_PROBING)
     move_z_after_probing();
   #endif
 
   report_current_position();
 }
 
 #endif // OLDSCHOOL_ABL

commit a51ba6e3f64c38f22260aaea7e52ac3f37fce8ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 27 00:33:58 2018 -0500

    Fix ABL grid bounds test for Delta/SCARA
    
    Addressing #10538

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5fd9745d9d..4d6206c6ad 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -353,22 +353,31 @@ void GcodeSuite::G29() {
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
       right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
       front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
       back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
 
-      if ( !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
-        || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)) {
+      if (
+        #if IS_SCARA || ENABLED(DELTA)
+             !position_is_reachable_by_probe(left_probe_bed_position, 0)
+          || !position_is_reachable_by_probe(right_probe_bed_position, 0)
+          || !position_is_reachable_by_probe(0, front_probe_bed_position)
+          || !position_is_reachable_by_probe(0, back_probe_bed_position)
+        #else
+             !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
+          || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)
+        #endif
+      ) {
         SERIAL_PROTOCOLLNPGM("? (L,R,F,B) out of bounds.");
         return;
       }
 
       // probe at the points of a lattice grid
       xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 

commit df2f24617bc110ee9fc19c1c60d1f83f8e1b8f6f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 17 20:32:56 2018 -0500

    Use 0 as the bed position (not Z_MIN_POS)

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 28e356bead..5fd9745d9d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -466,21 +466,21 @@ void GcodeSuite::G29() {
     }
 
     if (no_action) return;
 
     if (abl_probe_index == 0) {
       // For the initial G29 S2 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
         enable_soft_endstops = soft_endstops_enabled;
       #endif
       // Move close to the bed before the first point
-      do_blocking_move_to_z(Z_MIN_POS);
+      do_blocking_move_to_z(0);
     }
     else {
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
       measured_z = current_position[Z_AXIS];

commit 99282a46e9db3ef923dd5aead6f1f128561ca121
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 13 20:19:18 2018 -0500

    Make sure ABL (manual) starts close to the bed

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 66d17e1f35..28e356bead 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -461,24 +461,26 @@ void GcodeSuite::G29() {
         SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl_points));
         SERIAL_PROTOCOLLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_PROTOCOLLNPGM("idle");
     }
 
     if (no_action) return;
 
     if (abl_probe_index == 0) {
-      // For the initial G29 save software endstop state
+      // For the initial G29 S2 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
         enable_soft_endstops = soft_endstops_enabled;
       #endif
+      // Move close to the bed before the first point
+      do_blocking_move_to_z(Z_MIN_POS);
     }
     else {
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT)
         const uint16_t index = abl_probe_index - 1;
       #endif
 
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
       measured_z = current_position[Z_AXIS];

commit aa20b3ef7ce6823f64159958b55d13bc22d2a9ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 28 18:37:08 2018 -0500

    Fix linear/3-point manual leveling buffer overrun
    
    Fixes #10137

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 5f009fc72d..66d17e1f35 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -202,42 +202,42 @@ void GcodeSuite::G29() {
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
       ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
                       abl_grid_points_y = GRID_MAX_POINTS_Y;
       ABL_VAR bool do_topography_map;
     #else // Bilinear
       uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
                         abl_grid_points_y = GRID_MAX_POINTS_Y;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      ABL_VAR int abl2;
+      ABL_VAR int abl_points;
     #elif ENABLED(PROBE_MANUALLY) // Bilinear
-      int constexpr abl2 = GRID_MAX_POINTS;
+      int constexpr abl_points = GRID_MAX_POINTS;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       ABL_VAR float zoffset;
 
     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
 
       ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
                     eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
                     mean;
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
-      int constexpr abl2 = 3; // used to show total points
+      int constexpr abl_points = 3; // used to show total points
     #endif
 
     // Probe at 3 arbitrary points
     ABL_VAR vector_3 points[3] = {
       vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
       vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
       vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
     };
 
   #endif // AUTO_BED_LEVELING_3POINT
@@ -335,21 +335,21 @@ void GcodeSuite::G29() {
 
       if (!WITHIN(abl_grid_points_x, 2, GRID_MAX_POINTS_X)) {
         SERIAL_PROTOCOLLNPGM("?Probe points (X) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
         return;
       }
       if (!WITHIN(abl_grid_points_y, 2, GRID_MAX_POINTS_Y)) {
         SERIAL_PROTOCOLLNPGM("?Probe points (Y) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
         return;
       }
 
-      abl2 = abl_grid_points_x * abl_grid_points_y;
+      abl_points = abl_grid_points_x * abl_grid_points_y;
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
@@ -451,77 +451,82 @@ void GcodeSuite::G29() {
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         lcd_wait_for_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_PROTOCOLPGM("Manual G29 ");
       if (g29_in_progress) {
-        SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
-        SERIAL_PROTOCOLLNPAIR(" of ", abl2);
+        SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl_points));
+        SERIAL_PROTOCOLLNPAIR(" of ", abl_points);
       }
       else
         SERIAL_PROTOCOLLNPGM("idle");
     }
 
     if (no_action) return;
 
     if (abl_probe_index == 0) {
       // For the initial G29 save software endstop state
       #if HAS_SOFTWARE_ENDSTOPS
         enable_soft_endstops = soft_endstops_enabled;
       #endif
     }
     else {
+
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT)
+        const uint16_t index = abl_probe_index - 1;
+      #endif
+
       // For G29 after adjusting Z.
       // Save the previous Z before going to the next point
       measured_z = current_position[Z_AXIS];
 
       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
         mean += measured_z;
-        eqnBVector[abl_probe_index] = measured_z;
-        eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
-        eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
-        eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
+        eqnBVector[index] = measured_z;
+        eqnAMatrix[index + 0 * abl_points] = xProbe;
+        eqnAMatrix[index + 1 * abl_points] = yProbe;
+        eqnAMatrix[index + 2 * abl_points] = 1;
 
         incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
 
+      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+        points[index].z = measured_z;
+
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         z_values[xCount][yCount] = measured_z + zoffset;
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             SERIAL_PROTOCOLPAIR("Save X", xCount);
             SERIAL_PROTOCOLPAIR(" Y", yCount);
             SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
           }
         #endif
 
-      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-
-        points[abl_probe_index].z = measured_z;
-
       #endif
     }
 
     //
     // If there's another point to sample, move there with optional lift.
     //
 
     #if ABL_GRID
 
       // Skip any unreachable points
-      while (abl_probe_index < abl2) {
+      while (abl_probe_index < abl_points) {
 
         // Set xCount, yCount based on abl_probe_index, with zig-zag
         PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
         PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
 
         // Probe in reverse order for every other row/column
         bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
 
         if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
 
@@ -534,21 +539,21 @@ void GcodeSuite::G29() {
         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
           indexIntoAB[xCount][yCount] = abl_probe_index;
         #endif
 
         // Keep looping till a reachable point is found
         if (position_is_reachable(xProbe, yProbe)) break;
         ++abl_probe_index;
       }
 
       // Is there a next point to move to?
-      if (abl_probe_index < abl2) {
+      if (abl_probe_index < abl_points) {
         _manual_goto_xy(xProbe, yProbe); // Can be used here too!
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         return;
       }
       else {
 
@@ -558,21 +563,21 @@ void GcodeSuite::G29() {
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
         #endif
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
-      if (abl_probe_index < abl2) {
+      if (abl_probe_index < abl_points) {
         xProbe = points[abl_probe_index].x;
         yProbe = points[abl_probe_index].y;
         _manual_goto_xy(xProbe, yProbe);
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         return;
       }
@@ -654,23 +659,23 @@ void GcodeSuite::G29() {
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break;
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
-            eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
-            eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
-            eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
+            eqnAMatrix[abl_probe_index + 0 * abl_points] = xProbe;
+            eqnAMatrix[abl_probe_index + 1 * abl_points] = yProbe;
+            eqnAMatrix[abl_probe_index + 2 * abl_points] = 1;
 
             incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             z_values[xCount][yCount] = measured_z + zoffset;
 
           #endif
 
           abl_should_enable = false;
@@ -764,21 +769,21 @@ void GcodeSuite::G29() {
        * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
        * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
        */
       float plane_equation_coefficients[3];
 
       finish_incremental_LSF(&lsf_results);
       plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
       plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
       plane_equation_coefficients[2] = -lsf_results.D;
 
-      mean /= abl2;
+      mean /= abl_points;
 
       if (verbose_level) {
         SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
         SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
         SERIAL_PROTOCOLPGM(" b: ");
         SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
         SERIAL_PROTOCOLPGM(" d: ");
         SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
         SERIAL_EOL();
         if (verbose_level > 2) {
@@ -808,22 +813,22 @@ void GcodeSuite::G29() {
                                "   |           |\n"
                                "   O-- FRONT --+\n"
                                " (0,0)");
 
         float min_diff = 999;
 
         for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
           for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
             int ind = indexIntoAB[xx][yy];
             float diff = eqnBVector[ind] - mean,
-                  x_tmp = eqnAMatrix[ind + 0 * abl2],
-                  y_tmp = eqnAMatrix[ind + 1 * abl2],
+                  x_tmp = eqnAMatrix[ind + 0 * abl_points],
+                  y_tmp = eqnAMatrix[ind + 1 * abl_points],
                   z_tmp = 0;
 
             apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
 
             NOMORE(min_diff, eqnBVector[ind] - z_tmp);
 
             if (diff >= 0.0)
               SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
             else
               SERIAL_PROTOCOLCHAR(' ');
@@ -832,22 +837,22 @@ void GcodeSuite::G29() {
           SERIAL_EOL();
         } // yy
         SERIAL_EOL();
 
         if (verbose_level > 3) {
           SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
 
           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
               int ind = indexIntoAB[xx][yy];
-              float x_tmp = eqnAMatrix[ind + 0 * abl2],
-                    y_tmp = eqnAMatrix[ind + 1 * abl2],
+              float x_tmp = eqnAMatrix[ind + 0 * abl_points],
+                    y_tmp = eqnAMatrix[ind + 1 * abl_points],
                     z_tmp = 0;
 
               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
 
               float diff = eqnBVector[ind] - z_tmp - min_diff;
               if (diff >= 0.0)
                 SERIAL_PROTOCOLPGM(" +");
               // Include + for column alignment
               else
                 SERIAL_PROTOCOLCHAR(' ');

commit bc45fb6b131598403c8fdc5089697d98dc878299
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:08:44 2018 -0500

    Tweak use of move_z_after_probing

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 33afac494f..5f009fc72d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -942,18 +942,18 @@ void GcodeSuite::G29() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   #endif
 
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
 
-  #if HAS_BED_PROBE
+  #if HAS_BED_PROBE && Z_AFTER_PROBING
     move_z_after_probing();
   #endif
 
   report_current_position();
 }
 
 #endif // OLDSCHOOL_ABL

commit c352954882bc931377ece338b3f5fa459c55ea07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:01:43 2018 -0500

    Allow no raise after run_z_probe in probe_pt

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 3d8a88c6bc..33afac494f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -597,21 +597,21 @@ void GcodeSuite::G29() {
           // Can't re-enable (on error) until the new grid is written
           abl_should_enable = false;
         }
 
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
   #else // !PROBE_MANUALLY
   {
-    const bool stow_probe_after_each = parser.boolval('E');
+    const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     measured_z = 0;
 
     #if ABL_GRID
 
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       measured_z = 0;
 
       // Outer loop is Y with PROBE_Y_FIRST disabled
@@ -643,21 +643,21 @@ void GcodeSuite::G29() {
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
           #endif
 
-          measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
+          measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
 
           if (isnan(measured_z)) {
             set_bed_leveling_enabled(abl_should_enable);
             break;
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
@@ -680,21 +680,21 @@ void GcodeSuite::G29() {
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         // Retain the last probe position
         xProbe = points[i].x;
         yProbe = points[i].y;
-        measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
+        measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, raise_after, verbose_level);
         if (isnan(measured_z)) {
           set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) {

commit dd2949922bfbfec08c3f77714325cb88b7df61de
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 19 01:22:21 2018 -0500

    Consolidate 3-point leveling point options

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 19618b23e1..3d8a88c6bc 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -228,23 +228,23 @@ void GcodeSuite::G29() {
     #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
     #if ENABLED(PROBE_MANUALLY)
       int constexpr abl2 = 3; // used to show total points
     #endif
 
     // Probe at 3 arbitrary points
     ABL_VAR vector_3 points[3] = {
-      vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
-      vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
-      vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
+      vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
+      vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
+      vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
     };
 
   #endif // AUTO_BED_LEVELING_3POINT
 
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
   #endif
 
   /**

commit 14c03cb6f4bf20b06ba5d6c849cd1a15341627df
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 13 01:15:22 2018 -0500

    [2.0.x] Make MIN_PROBE_EDGE a general option (for electronic probes) (#10069)
    
    Some probes don't work near the edges of the bed. This change promotes MIN_PROBE_EDGE to a general setting that applies to all probing functions.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 53d92160ec..19618b23e1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -353,46 +353,23 @@ void GcodeSuite::G29() {
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
       right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
       front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
       back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
 
-      const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
-                 left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
-                 right_out_r = right_probe_bed_position > MAX_PROBE_X,
-                 right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
-                 front_out_f = front_probe_bed_position < MIN_PROBE_Y,
-                 front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
-                 back_out_b = back_probe_bed_position > MAX_PROBE_Y,
-                 back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
-
-      if (left_out || right_out || front_out || back_out) {
-        if (left_out) {
-          out_of_range_error(PSTR("(L)eft"));
-          left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
-        }
-        if (right_out) {
-          out_of_range_error(PSTR("(R)ight"));
-          right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
-        }
-        if (front_out) {
-          out_of_range_error(PSTR("(F)ront"));
-          front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
-        }
-        if (back_out) {
-          out_of_range_error(PSTR("(B)ack"));
-          back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
-        }
+      if ( !position_is_reachable_by_probe(left_probe_bed_position, front_probe_bed_position)
+        || !position_is_reachable_by_probe(right_probe_bed_position, back_probe_bed_position)) {
+        SERIAL_PROTOCOLLNPGM("? (L,R,F,B) out of bounds.");
         return;
       }
 
       // probe at the points of a lattice grid
       xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {

commit 28f1276286da94f4a1b3a7bffa103a35a3ee8352
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 11 13:07:55 2018 -0500

    [2.0.x] Add Z_AFTER_PROBING option (#10058)
    
    Some "fix-mounted" probes need manual stowing. And after probing some may prefer to raise or lower the nozzle. This restores an old option but tailors it to allow raise or lower as preferred.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9285b46ed6..53d92160ec 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -726,21 +726,21 @@ void GcodeSuite::G29() {
           planeNormal.z *= -1;
         }
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
-    // Stow the probe, raising if not fix-mounted.
+    // Stow the probe. No raise for FIX_MOUNTED_PROBE.
     if (STOW_PROBE()) {
       set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
@@ -960,19 +960,23 @@ void GcodeSuite::G29() {
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   #endif
 
-  report_current_position();
-
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
+
+  #if HAS_BED_PROBE
+    move_z_after_probing();
+  #endif
+
+  report_current_position();
 }
 
 #endif // OLDSCHOOL_ABL

commit 3f89bbeab546f15fb1a3eb99964b194b862fb9c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 24 16:35:31 2018 -0600

    Drop a conditional only used once

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index f8e2a5826d..9285b46ed6 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -726,21 +726,21 @@ void GcodeSuite::G29() {
           planeNormal.z *= -1;
         }
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
-    // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
+    // Stow the probe, raising if not fix-mounted.
     if (STOW_PROBE()) {
       set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //

commit e3043d7ac7cac0e3ed4e113b154d7e831b0984ac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 10 16:53:58 2018 -0600

    Fix #8744

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index dc0b5cf4ca..f8e2a5826d 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -326,22 +326,26 @@ void GcodeSuite::G29() {
     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       do_topography_map = verbose_level > 2 || parser.boolval('T');
 
       // X and Y specify points in each direction, overriding the default
       // These values may be saved with the completed mesh
       abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
       abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
       if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
 
-      if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
-        SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
+      if (!WITHIN(abl_grid_points_x, 2, GRID_MAX_POINTS_X)) {
+        SERIAL_PROTOCOLLNPGM("?Probe points (X) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_X) ").");
+        return;
+      }
+      if (!WITHIN(abl_grid_points_y, 2, GRID_MAX_POINTS_Y)) {
+        SERIAL_PROTOCOLLNPGM("?Probe points (Y) is implausible (2-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
         return;
       }
 
       abl2 = abl_grid_points_x * abl_grid_points_y;
       mean = 0;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 

commit 34160806c0e7c199d11c06b56722ee500d97011d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 1 03:17:42 2018 -0600

    Fix broken G29 W I J

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index e4269579fd..dc0b5cf4ca 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -253,21 +253,22 @@ void GcodeSuite::G29() {
   if (!g29_in_progress) {
 
     #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
     abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      if (parser.seen('W')) {
+      const bool seen_w = parser.seen('W');
+      if (seen_w) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("No bilinear grid");
           return;
         }
 
         const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
         if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("Bad Z value");
@@ -291,24 +292,28 @@ void GcodeSuite::G29() {
           z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
           set_bed_leveling_enabled(abl_should_enable);
           if (abl_should_enable) report_current_position();
         }
         return;
       } // parser.seen('W')
 
+    #else
+
+      constexpr bool seen_w = false;
+
     #endif
 
     // Jettison bed leveling data
-    if (parser.seen('J')) {
+    if (!seen_w && parser.seen('J')) {
       reset_bed_level();
       return;
     }
 
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
       return;
     }
 

commit e5ca60acf593416ebdca29d60f98c02d3fc1644c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 13:08:46 2018 -0600

    Patch G29 no_action for A and Q

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 88336d1e42..e4269579fd 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -125,47 +125,55 @@
  *
  * Without PROBE_MANUALLY:
  *
  *  E  By default G29 will engage the Z probe, test the bed, then disengage.
  *     Include "E" to engage/disengage the Z probe for each sample.
  *     There's no extra effect if you have a fixed Z probe.
  *
  */
 void GcodeSuite::G29() {
 
+  #if ENABLED(DEBUG_LEVELING_FEATURE) || ENABLED(PROBE_MANUALLY)
+    const bool seenQ = parser.seen('Q');
+  #else
+    constexpr bool seenQ = false;
+  #endif
+
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    const bool query = parser.seen('Q');
     const uint8_t old_debug_flags = marlin_debug_flags;
-    if (query) marlin_debug_flags |= DEBUG_LEVELING;
+    if (seenQ) marlin_debug_flags |= DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS(">>> G29", current_position);
       log_machine_info();
     }
     marlin_debug_flags = old_debug_flags;
     #if DISABLED(PROBE_MANUALLY)
-      if (query) return;
+      if (seenQ) return;
     #endif
   #endif
 
   #if ENABLED(PROBE_MANUALLY)
-    const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
-  #endif
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
-    const bool faux = parser.boolval('C');
-  #elif ENABLED(PROBE_MANUALLY)
-    const bool faux = no_action;
+    const bool seenA = parser.seen('A');
   #else
-    bool constexpr faux = false;
+    constexpr bool seenA = false;
   #endif
 
+  const bool  no_action = seenA || seenQ,
+              faux =
+                #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
+                  parser.boolval('C')
+                #else
+                  no_action
+                #endif
+              ;
+
   // Don't allow auto-leveling without homing first
   if (axis_unhomed_error()) return;
 
   // Define local vars 'static' for manual probing, 'auto' otherwise
   #if ENABLED(PROBE_MANUALLY)
     #define ABL_VAR static
   #else
     #define ABL_VAR
   #endif
 
@@ -381,21 +389,21 @@ void GcodeSuite::G29() {
     if (verbose_level > 0) {
       SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
       SERIAL_EOL();
     }
 
     stepper.synchronize();
 
     // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
-    set_bed_leveling_enabled(false);
+    if (!no_action) set_bed_leveling_enabled(false);
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
         set_bed_leveling_enabled(abl_should_enable);
         return;
       }
     #endif
 
     if (!faux) setup_for_endstop_or_probe_move();

commit 9e8008c49cf9a4081750d3c1b150c034d1493ef4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 08:29:31 2017 -0600

    Fixes for G29, esp. 3POINT

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 9660322ed1..88336d1e42 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -285,29 +285,25 @@ void GcodeSuite::G29() {
             bed_level_virt_interpolate();
           #endif
           set_bed_leveling_enabled(abl_should_enable);
           if (abl_should_enable) report_current_position();
         }
         return;
       } // parser.seen('W')
 
     #endif
 
-    #if HAS_LEVELING
-
-      // Jettison bed leveling data
-      if (parser.seen('J')) {
-        reset_bed_level();
-        return;
-      }
-
-    #endif
+    // Jettison bed leveling data
+    if (parser.seen('J')) {
+      reset_bed_level();
+      return;
+    }
 
     verbose_level = parser.intval('V');
     if (!WITHIN(verbose_level, 0, 4)) {
       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
       return;
     }
 
     dryrun = parser.boolval('D')
       #if ENABLED(PROBE_MANUALLY)
         || no_action
@@ -376,39 +372,31 @@ void GcodeSuite::G29() {
         return;
       }
 
       // probe at the points of a lattice grid
       xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
-      SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
-      if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
+      SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
+      if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
+      SERIAL_EOL();
     }
 
     stepper.synchronize();
 
-    // Disable auto bed leveling during G29
+    // Disable auto bed leveling during G29.
     // Be formal so G29 can be done successively without G28.
     set_bed_leveling_enabled(false);
 
-    if (!dryrun) {
-      // Re-orient the current position without leveling
-      // based on where the steppers are positioned.
-      set_current_from_steppers_for_axis(ALL_AXES);
-
-      // Sync the planner to where the steppers stopped
-      SYNC_PLAN_POSITION_KINEMATIC();
-    }
-
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
         set_bed_leveling_enabled(abl_should_enable);
         return;
       }
     #endif
 
     if (!faux) setup_for_endstop_or_probe_move();
 
@@ -576,23 +564,24 @@ void GcodeSuite::G29() {
 
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
         #endif
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
-      if (abl_probe_index < 3) {
+      if (abl_probe_index < abl2) {
         xProbe = points[abl_probe_index].x;
         yProbe = points[abl_probe_index].y;
+        _manual_goto_xy(xProbe, yProbe);
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         return;
       }
       else {
 
         SERIAL_PROTOCOLLNPGM("3-point probing done.");

commit f2731c9f9355f0f3d6c029fd1f5929251fdd7179
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 06:32:33 2017 -0600

    Allow consecutive uses of G29

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0b32d8144f..9660322ed1 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -383,55 +383,52 @@ void GcodeSuite::G29() {
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
     }
 
     stepper.synchronize();
 
     // Disable auto bed leveling during G29
-    planner.leveling_active = false;
+    // Be formal so G29 can be done successively without G28.
+    set_bed_leveling_enabled(false);
 
     if (!dryrun) {
       // Re-orient the current position without leveling
       // based on where the steppers are positioned.
       set_current_from_steppers_for_axis(ALL_AXES);
 
       // Sync the planner to where the steppers stopped
       SYNC_PLAN_POSITION_KINEMATIC();
     }
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
-        planner.leveling_active = abl_should_enable;
+        set_bed_leveling_enabled(abl_should_enable);
         return;
       }
     #endif
 
     if (!faux) setup_for_endstop_or_probe_move();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
       if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
         || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
         || left_probe_bed_position != bilinear_start[X_AXIS]
         || front_probe_bed_position != bilinear_start[Y_AXIS]
       ) {
-        if (dryrun) {
-          // Before reset bed level, re-enable to correct the position
-          planner.leveling_active = abl_should_enable;
-        }
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
         bilinear_grid_spacing[X_AXIS] = xGridSpacing;
         bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
         bilinear_start[X_AXIS] = left_probe_bed_position;
         bilinear_start[Y_AXIS] = front_probe_bed_position;
 
         // Can't re-enable (on error) until the new grid is written
@@ -461,21 +458,21 @@ void GcodeSuite::G29() {
       ++abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
       #if HAS_SOFTWARE_ENDSTOPS
         soft_endstops_enabled = enable_soft_endstops;
       #endif
-      planner.leveling_active = abl_should_enable;
+      set_bed_leveling_enabled(abl_should_enable);
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         lcd_wait_for_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_PROTOCOLPGM("Manual G29 ");
       if (g29_in_progress) {
@@ -666,21 +663,21 @@ void GcodeSuite::G29() {
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
           #endif
 
           measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
 
           if (isnan(measured_z)) {
-            planner.leveling_active = abl_should_enable;
+            set_bed_leveling_enabled(abl_should_enable);
             break;
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
             eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
             eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
@@ -702,21 +699,21 @@ void GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         // Retain the last probe position
         xProbe = points[i].x;
         yProbe = points[i].y;
         measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
         if (isnan(measured_z)) {
-          planner.leveling_active = abl_should_enable;
+          set_bed_leveling_enabled(abl_should_enable);
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) {
           planeNormal.x *= -1;
           planeNormal.y *= -1;
@@ -725,21 +722,21 @@ void GcodeSuite::G29() {
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
     if (STOW_PROBE()) {
-      planner.leveling_active = abl_should_enable;
+      set_bed_leveling_enabled(abl_should_enable);
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
   // definitely be enabled after this point.

commit 03ba79f1446034d3313e86bfd5d2790728772392
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 10 21:17:07 2017 -0600

    Sync and report changed position

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 892d71030b..0b32d8144f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -278,20 +278,21 @@ void GcodeSuite::G29() {
           i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
           j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
           z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
           set_bed_leveling_enabled(abl_should_enable);
+          if (abl_should_enable) report_current_position();
         }
         return;
       } // parser.seen('W')
 
     #endif
 
     #if HAS_LEVELING
 
       // Jettison bed leveling data
       if (parser.seen('J')) {

commit a6160916b0a23f8ccac731380ce81554c94bab7c
Author: Colten Edwards <cd.edwards@sasktel.net>
Date:   Tue Nov 7 15:36:33 2017 -0600

    [2.0] Fix M48 for delta printers/ABL compile issue (#8286)
    
    * fix M48 for delta printers
    
    fix M48 for delta printers. home printer if not already homed.
    
    * remove ENABLED(DELTA)
    
    remove ENABLED(DELTA) as it is not needed.
    
    * Update M48.cpp
    
    * abl needs queue.h
    
    without queue.h abl will not compile since there is a script that runs at the end of it and we need to queue it up.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 0cb57ea0b5..892d71030b 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -27,20 +27,21 @@
 #include "../../../inc/MarlinConfig.h"
 
 #if OLDSCHOOL_ABL
 
 #include "../../gcode.h"
 #include "../../../feature/bedlevel/bedlevel.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../module/probe.h"
+#include "../../queue.h"
 
 #if ENABLED(LCD_BED_LEVELING) && ENABLED(PROBE_MANUALLY)
   #include "../../../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   #include "../../../libs/least_squares_fit.h"
 #endif
 
 #if ABL_GRID
@@ -337,21 +338,21 @@ void GcodeSuite::G29() {
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
       left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
       right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
       front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
       back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
-  
+
       const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
                  left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
                  right_out_r = right_probe_bed_position > MAX_PROBE_X,
                  right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
                  front_out_f = front_probe_bed_position < MIN_PROBE_Y,
                  front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
                  back_out_b = back_probe_bed_position > MAX_PROBE_Y,
                  back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
 
       if (left_out || right_out || front_out || back_out) {

commit 85a62bbf46c13b4e01ecafc9f3ce50ed92f67f3c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 6 22:57:05 2017 -0600

    Misc. fixes to compiler warnings, etc.

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 8a30f3d959..0cb57ea0b5 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -623,20 +623,22 @@ void GcodeSuite::G29() {
   #else // !PROBE_MANUALLY
   {
     const bool stow_probe_after_each = parser.boolval('E');
 
     measured_z = 0;
 
     #if ABL_GRID
 
       bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
+      measured_z = 0;
+
       // Outer loop is Y with PROBE_Y_FIRST disabled
       for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
           inStop = PR_INNER_END;
           inInc = 1;
         }

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 7f6289ce8f..8a30f3d959 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -251,42 +251,42 @@ void GcodeSuite::G29() {
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (parser.seen('W')) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("No bilinear grid");
           return;
         }
 
-        const float z = parser.floatval('Z', RAW_CURRENT_POSITION(Z));
-        if (!WITHIN(z, -10, 10)) {
+        const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
+        if (!WITHIN(rz, -10, 10)) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("Bad Z value");
           return;
         }
 
-        const float x = parser.floatval('X', NAN),
-                    y = parser.floatval('Y', NAN);
+        const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
+                    ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
         int8_t i = parser.byteval('I', -1),
                j = parser.byteval('J', -1);
 
-        if (!isnan(x) && !isnan(y)) {
-          // Get nearest i / j from x / y
-          i = (x - LOGICAL_X_POSITION(bilinear_start[X_AXIS]) + 0.5 * xGridSpacing) / xGridSpacing;
-          j = (y - LOGICAL_Y_POSITION(bilinear_start[Y_AXIS]) + 0.5 * yGridSpacing) / yGridSpacing;
+        if (!isnan(rx) && !isnan(ry)) {
+          // Get nearest i / j from rx / ry
+          i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
+          j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
           i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
           j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
         }
         if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
           set_bed_leveling_enabled(false);
-          z_values[i][j] = z;
+          z_values[i][j] = rz;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif
           set_bed_leveling_enabled(abl_should_enable);
         }
         return;
       } // parser.seen('W')
 
     #endif
 
@@ -333,50 +333,50 @@ void GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       zoffset = parser.linearval('Z');
 
     #endif
 
     #if ABL_GRID
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
 
-      left_probe_bed_position = (int)parser.linearval('L', LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION));
-      right_probe_bed_position = (int)parser.linearval('R', LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION));
-      front_probe_bed_position = (int)parser.linearval('F', LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION));
-      back_probe_bed_position = (int)parser.linearval('B', LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION));
-
-      const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
+      left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
+      right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
+      front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
+      back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
+  
+      const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
                  left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
-                 right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
+                 right_out_r = right_probe_bed_position > MAX_PROBE_X,
                  right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
-                 front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
+                 front_out_f = front_probe_bed_position < MIN_PROBE_Y,
                  front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
-                 back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
+                 back_out_b = back_probe_bed_position > MAX_PROBE_Y,
                  back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
 
       if (left_out || right_out || front_out || back_out) {
         if (left_out) {
           out_of_range_error(PSTR("(L)eft"));
-          left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
+          left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
         }
         if (right_out) {
           out_of_range_error(PSTR("(R)ight"));
-          right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
+          right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
         }
         if (front_out) {
           out_of_range_error(PSTR("(F)ront"));
-          front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
+          front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
         }
         if (back_out) {
           out_of_range_error(PSTR("(B)ack"));
-          back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
+          back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
         }
         return;
       }
 
       // probe at the points of a lattice grid
       xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
       yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
     #endif // ABL_GRID
 
@@ -409,35 +409,35 @@ void GcodeSuite::G29() {
 
     if (!faux) setup_for_endstop_or_probe_move();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
       if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
         || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
-        || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
-        || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
+        || left_probe_bed_position != bilinear_start[X_AXIS]
+        || front_probe_bed_position != bilinear_start[Y_AXIS]
       ) {
         if (dryrun) {
           // Before reset bed level, re-enable to correct the position
           planner.leveling_active = abl_should_enable;
         }
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
         bilinear_grid_spacing[X_AXIS] = xGridSpacing;
         bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
-        bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
-        bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
+        bilinear_start[X_AXIS] = left_probe_bed_position;
+        bilinear_start[Y_AXIS] = front_probe_bed_position;
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_BILINEAR
 
     #if ENABLED(AUTO_BED_LEVELING_3POINT)
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -548,21 +548,21 @@ void GcodeSuite::G29() {
                     yBase = yCount * yGridSpacing + front_probe_bed_position;
 
         xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
         yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
 
         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
           indexIntoAB[xCount][yCount] = abl_probe_index;
         #endif
 
         // Keep looping till a reachable point is found
-        if (position_is_reachable_xy(xProbe, yProbe)) break;
+        if (position_is_reachable(xProbe, yProbe)) break;
         ++abl_probe_index;
       }
 
       // Is there a next point to move to?
       if (abl_probe_index < abl2) {
         _manual_goto_xy(xProbe, yProbe); // Can be used here too!
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
@@ -578,22 +578,22 @@ void GcodeSuite::G29() {
         // Re-enable software endstops, if needed
         #if HAS_SOFTWARE_ENDSTOPS
           soft_endstops_enabled = enable_soft_endstops;
         #endif
       }
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
       if (abl_probe_index < 3) {
-        xProbe = LOGICAL_X_POSITION(points[abl_probe_index].x);
-        yProbe = LOGICAL_Y_POSITION(points[abl_probe_index].y);
+        xProbe = points[abl_probe_index].x;
+        yProbe = points[abl_probe_index].y;
         #if HAS_SOFTWARE_ENDSTOPS
           // Disable software endstops to allow manual adjustment
           // If G29 is not completed, they will not be re-enabled
           soft_endstops_enabled = false;
         #endif
         return;
       }
       else {
 
         SERIAL_PROTOCOLLNPGM("3-point probing done.");
@@ -656,21 +656,21 @@ void GcodeSuite::G29() {
 
           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
-            if (!position_is_reachable_by_probe_xy(xProbe, yProbe)) continue;
+            if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
           #endif
 
           measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
 
           if (isnan(measured_z)) {
             planner.leveling_active = abl_should_enable;
             break;
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -694,22 +694,22 @@ void GcodeSuite::G29() {
 
         } // inner
       } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         // Retain the last probe position
-        xProbe = LOGICAL_X_POSITION(points[i].x);
-        yProbe = LOGICAL_Y_POSITION(points[i].y);
+        xProbe = points[i].x;
+        yProbe = points[i].y;
         measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
         if (isnan(measured_z)) {
           planner.leveling_active = abl_should_enable;
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();

commit c0dddd4233d12b52a71e93d50b7ab648f86ff9a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 14 02:46:05 2017 -0500

    Tweaks to tool_change, GcodeSuite::T()

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index dfd3734e59..7f6289ce8f 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -130,21 +130,21 @@
  *
  */
 void GcodeSuite::G29() {
 
   // G29 Q is also available if debugging
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     const bool query = parser.seen('Q');
     const uint8_t old_debug_flags = marlin_debug_flags;
     if (query) marlin_debug_flags |= DEBUG_LEVELING;
     if (DEBUGGING(LEVELING)) {
-      DEBUG_POS(">>> gcode_G29", current_position);
+      DEBUG_POS(">>> G29", current_position);
       log_machine_info();
     }
     marlin_debug_flags = old_debug_flags;
     #if DISABLED(PROBE_MANUALLY)
       if (query) return;
     #endif
   #endif
 
   #if ENABLED(PROBE_MANUALLY)
     const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
@@ -950,21 +950,21 @@ void GcodeSuite::G29() {
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
     planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   #endif
 
   report_current_position();
 
   KEEPALIVE_STATE(IN_HANDLER);
 
   if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
 }
 

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index 218a1c6d3e..dfd3734e59 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -240,21 +240,21 @@ void GcodeSuite::G29() {
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
-    abl_should_enable = LEVELING_IS_ACTIVE();
+    abl_should_enable = planner.leveling_active;
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (parser.seen('W')) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("No bilinear grid");
           return;
         }
 
@@ -381,54 +381,54 @@ void GcodeSuite::G29() {
     #endif // ABL_GRID
 
     if (verbose_level > 0) {
       SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
       if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
     }
 
     stepper.synchronize();
 
     // Disable auto bed leveling during G29
-    planner.abl_enabled = false;
+    planner.leveling_active = false;
 
     if (!dryrun) {
       // Re-orient the current position without leveling
       // based on where the steppers are positioned.
       set_current_from_steppers_for_axis(ALL_AXES);
 
       // Sync the planner to where the steppers stopped
       SYNC_PLAN_POSITION_KINEMATIC();
     }
 
     #if HAS_BED_PROBE
       // Deploy the probe. Probe will raise if needed.
       if (DEPLOY_PROBE()) {
-        planner.abl_enabled = abl_should_enable;
+        planner.leveling_active = abl_should_enable;
         return;
       }
     #endif
 
     if (!faux) setup_for_endstop_or_probe_move();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!no_action)
       #endif
       if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
         || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
         || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
         || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
       ) {
         if (dryrun) {
           // Before reset bed level, re-enable to correct the position
-          planner.abl_enabled = abl_should_enable;
+          planner.leveling_active = abl_should_enable;
         }
         // Reset grid to 0.0 or "not probed". (Also disables ABL)
         reset_bed_level();
 
         // Initialize a grid with the given dimensions
         bilinear_grid_spacing[X_AXIS] = xGridSpacing;
         bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
         bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
         bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
 
@@ -459,21 +459,21 @@ void GcodeSuite::G29() {
       ++abl_probe_index;
       g29_in_progress = true;
     }
 
     // Abort current G29 procedure, go back to idle state
     if (seenA && g29_in_progress) {
       SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
       #if HAS_SOFTWARE_ENDSTOPS
         soft_endstops_enabled = enable_soft_endstops;
       #endif
-      planner.abl_enabled = abl_should_enable;
+      planner.leveling_active = abl_should_enable;
       g29_in_progress = false;
       #if ENABLED(LCD_BED_LEVELING)
         lcd_wait_for_move = false;
       #endif
     }
 
     // Query G29 status
     if (verbose_level || seenQ) {
       SERIAL_PROTOCOLPGM("Manual G29 ");
       if (g29_in_progress) {
@@ -662,21 +662,21 @@ void GcodeSuite::G29() {
           #endif
 
           #if IS_KINEMATIC
             // Avoid probing outside the round or hexagonal area
             if (!position_is_reachable_by_probe_xy(xProbe, yProbe)) continue;
           #endif
 
           measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
 
           if (isnan(measured_z)) {
-            planner.abl_enabled = abl_should_enable;
+            planner.leveling_active = abl_should_enable;
             break;
           }
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[abl_probe_index] = measured_z;
             eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
             eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
             eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
@@ -698,21 +698,21 @@ void GcodeSuite::G29() {
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
       // Probe at 3 arbitrary points
 
       for (uint8_t i = 0; i < 3; ++i) {
         // Retain the last probe position
         xProbe = LOGICAL_X_POSITION(points[i].x);
         yProbe = LOGICAL_Y_POSITION(points[i].y);
         measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
         if (isnan(measured_z)) {
-          planner.abl_enabled = abl_should_enable;
+          planner.leveling_active = abl_should_enable;
           break;
         }
         points[i].z = measured_z;
       }
 
       if (!dryrun && !isnan(measured_z)) {
         vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
         if (planeNormal.z < 0) {
           planeNormal.x *= -1;
           planeNormal.y *= -1;
@@ -721,21 +721,21 @@ void GcodeSuite::G29() {
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
         abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
     if (STOW_PROBE()) {
-      planner.abl_enabled = abl_should_enable;
+      planner.leveling_active = abl_should_enable;
       measured_z = NAN;
     }
   }
   #endif // !PROBE_MANUALLY
 
   //
   // G29 Finishing Code
   //
   // Unless this is a dry run, auto bed leveling will
   // definitely be enabled after this point.
@@ -889,23 +889,23 @@ void GcodeSuite::G29() {
         // Correct the current XYZ position based on the tilted plane.
         //
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
         #endif
 
         float converted[XYZ];
         COPY(converted, current_position);
 
-        planner.abl_enabled = true;
+        planner.leveling_active = true;
         planner.unapply_leveling(converted); // use conversion machinery
-        planner.abl_enabled = false;
+        planner.leveling_active = false;
 
         // Use the last measured distance to the bed, if possible
         if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
           && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
         ) {
           const float simple_z = current_position[Z_AXIS] - measured_z;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Z from Probe:", simple_z);
               SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
@@ -943,29 +943,29 @@ void GcodeSuite::G29() {
 
     #ifdef Z_PROBE_END_SCRIPT
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       #endif
       enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
       stepper.synchronize();
     #endif
 
     // Auto Bed Leveling is complete! Enable if possible.
-    planner.abl_enabled = dryrun ? abl_should_enable : true;
+    planner.leveling_active = dryrun ? abl_should_enable : true;
   } // !isnan(measured_z)
 
   // Restore state after probing
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
   #endif
 
   report_current_position();
 
   KEEPALIVE_STATE(IN_HANDLER);
 
-  if (LEVELING_IS_ACTIVE())
+  if (planner.leveling_active)
     SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 #endif // OLDSCHOOL_ABL

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
index fa1c70c85c..218a1c6d3e 100644
--- a/Marlin/src/gcode/bedlevel/abl/G29.cpp
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -240,21 +240,21 @@ void GcodeSuite::G29() {
 
   /**
    * On the initial G29 fetch command parameters.
    */
   if (!g29_in_progress) {
 
     #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
       abl_probe_index = -1;
     #endif
 
-    abl_should_enable = leveling_is_active();
+    abl_should_enable = LEVELING_IS_ACTIVE();
 
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (parser.seen('W')) {
         if (!leveling_is_valid()) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM("No bilinear grid");
           return;
         }
 
@@ -957,15 +957,15 @@ void GcodeSuite::G29() {
   if (!faux) clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
   #endif
 
   report_current_position();
 
   KEEPALIVE_STATE(IN_HANDLER);
 
-  if (planner.abl_enabled)
+  if (LEVELING_IS_ACTIVE())
     SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 #endif // OLDSCHOOL_ABL

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/gcode/bedlevel/abl/G29.cpp b/Marlin/src/gcode/bedlevel/abl/G29.cpp
new file mode 100644
index 0000000000..fa1c70c85c
--- /dev/null
+++ b/Marlin/src/gcode/bedlevel/abl/G29.cpp
@@ -0,0 +1,971 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * G29.cpp - Auto Bed Leveling
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if OLDSCHOOL_ABL
+
+#include "../../gcode.h"
+#include "../../../feature/bedlevel/bedlevel.h"
+#include "../../../module/motion.h"
+#include "../../../module/planner.h"
+#include "../../../module/stepper.h"
+#include "../../../module/probe.h"
+
+#if ENABLED(LCD_BED_LEVELING) && ENABLED(PROBE_MANUALLY)
+  #include "../../../lcd/ultralcd.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_LINEAR)
+  #include "../../../libs/least_squares_fit.h"
+#endif
+
+#if ABL_GRID
+  #if ENABLED(PROBE_Y_FIRST)
+    #define PR_OUTER_VAR xCount
+    #define PR_OUTER_END abl_grid_points_x
+    #define PR_INNER_VAR yCount
+    #define PR_INNER_END abl_grid_points_y
+  #else
+    #define PR_OUTER_VAR yCount
+    #define PR_OUTER_END abl_grid_points_y
+    #define PR_INNER_VAR xCount
+    #define PR_INNER_END abl_grid_points_x
+  #endif
+#endif
+
+/**
+ * G29: Detailed Z probe, probes the bed at 3 or more points.
+ *      Will fail if the printer has not been homed with G28.
+ *
+ * Enhanced G29 Auto Bed Leveling Probe Routine
+ *
+ *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
+ *     or alter the bed level data. Useful to check the topology
+ *     after a first run of G29.
+ *
+ *  J  Jettison current bed leveling data
+ *
+ *  V  Set the verbose level (0-4). Example: "G29 V3"
+ *
+ * Parameters With LINEAR leveling only:
+ *
+ *  P  Set the size of the grid that will be probed (P x P points).
+ *     Example: "G29 P4"
+ *
+ *  X  Set the X size of the grid that will be probed (X x Y points).
+ *     Example: "G29 X7 Y5"
+ *
+ *  Y  Set the Y size of the grid that will be probed (X x Y points).
+ *
+ *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
+ *     This is useful for manual bed leveling and finding flaws in the bed (to
+ *     assist with part placement).
+ *     Not supported by non-linear delta printer bed leveling.
+ *
+ * Parameters With LINEAR and BILINEAR leveling only:
+ *
+ *  S  Set the XY travel speed between probe points (in units/min)
+ *
+ *  F  Set the Front limit of the probing grid
+ *  B  Set the Back limit of the probing grid
+ *  L  Set the Left limit of the probing grid
+ *  R  Set the Right limit of the probing grid
+ *
+ * Parameters with DEBUG_LEVELING_FEATURE only:
+ *
+ *  C  Make a totally fake grid with no actual probing.
+ *     For use in testing when no probing is possible.
+ *
+ * Parameters with BILINEAR leveling only:
+ *
+ *  Z  Supply an additional Z probe offset
+ *
+ * Extra parameters with PROBE_MANUALLY:
+ *
+ *  To do manual probing simply repeat G29 until the procedure is complete.
+ *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
+ *
+ *  Q  Query leveling and G29 state
+ *
+ *  A  Abort current leveling procedure
+ *
+ * Extra parameters with BILINEAR only:
+ *
+ *  W  Write a mesh point. (If G29 is idle.)
+ *  I  X index for mesh point
+ *  J  Y index for mesh point
+ *  X  X for mesh point, overrides I
+ *  Y  Y for mesh point, overrides J
+ *  Z  Z for mesh point. Otherwise, raw current Z.
+ *
+ * Without PROBE_MANUALLY:
+ *
+ *  E  By default G29 will engage the Z probe, test the bed, then disengage.
+ *     Include "E" to engage/disengage the Z probe for each sample.
+ *     There's no extra effect if you have a fixed Z probe.
+ *
+ */
+void GcodeSuite::G29() {
+
+  // G29 Q is also available if debugging
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    const bool query = parser.seen('Q');
+    const uint8_t old_debug_flags = marlin_debug_flags;
+    if (query) marlin_debug_flags |= DEBUG_LEVELING;
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_POS(">>> gcode_G29", current_position);
+      log_machine_info();
+    }
+    marlin_debug_flags = old_debug_flags;
+    #if DISABLED(PROBE_MANUALLY)
+      if (query) return;
+    #endif
+  #endif
+
+  #if ENABLED(PROBE_MANUALLY)
+    const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
+    const bool faux = parser.boolval('C');
+  #elif ENABLED(PROBE_MANUALLY)
+    const bool faux = no_action;
+  #else
+    bool constexpr faux = false;
+  #endif
+
+  // Don't allow auto-leveling without homing first
+  if (axis_unhomed_error()) return;
+
+  // Define local vars 'static' for manual probing, 'auto' otherwise
+  #if ENABLED(PROBE_MANUALLY)
+    #define ABL_VAR static
+  #else
+    #define ABL_VAR
+  #endif
+
+  ABL_VAR int verbose_level;
+  ABL_VAR float xProbe, yProbe, measured_z;
+  ABL_VAR bool dryrun, abl_should_enable;
+
+  #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
+    ABL_VAR int abl_probe_index;
+  #endif
+
+  #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
+    ABL_VAR bool enable_soft_endstops = true;
+  #endif
+
+  #if ABL_GRID
+
+    #if ENABLED(PROBE_MANUALLY)
+      ABL_VAR uint8_t PR_OUTER_VAR;
+      ABL_VAR  int8_t PR_INNER_VAR;
+    #endif
+
+    ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
+    ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+      ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
+                      abl_grid_points_y = GRID_MAX_POINTS_Y;
+      ABL_VAR bool do_topography_map;
+    #else // Bilinear
+      uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
+                        abl_grid_points_y = GRID_MAX_POINTS_Y;
+    #endif
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+      ABL_VAR int abl2;
+    #elif ENABLED(PROBE_MANUALLY) // Bilinear
+      int constexpr abl2 = GRID_MAX_POINTS;
+    #endif
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      ABL_VAR float zoffset;
+
+    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+      ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+
+      ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
+                    eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
+                    mean;
+    #endif
+
+  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+    #if ENABLED(PROBE_MANUALLY)
+      int constexpr abl2 = 3; // used to show total points
+    #endif
+
+    // Probe at 3 arbitrary points
+    ABL_VAR vector_3 points[3] = {
+      vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
+      vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
+      vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
+    };
+
+  #endif // AUTO_BED_LEVELING_3POINT
+
+  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+    struct linear_fit_data lsf_results;
+    incremental_LSF_reset(&lsf_results);
+  #endif
+
+  /**
+   * On the initial G29 fetch command parameters.
+   */
+  if (!g29_in_progress) {
+
+    #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
+      abl_probe_index = -1;
+    #endif
+
+    abl_should_enable = leveling_is_active();
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      if (parser.seen('W')) {
+        if (!leveling_is_valid()) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM("No bilinear grid");
+          return;
+        }
+
+        const float z = parser.floatval('Z', RAW_CURRENT_POSITION(Z));
+        if (!WITHIN(z, -10, 10)) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM("Bad Z value");
+          return;
+        }
+
+        const float x = parser.floatval('X', NAN),
+                    y = parser.floatval('Y', NAN);
+        int8_t i = parser.byteval('I', -1),
+               j = parser.byteval('J', -1);
+
+        if (!isnan(x) && !isnan(y)) {
+          // Get nearest i / j from x / y
+          i = (x - LOGICAL_X_POSITION(bilinear_start[X_AXIS]) + 0.5 * xGridSpacing) / xGridSpacing;
+          j = (y - LOGICAL_Y_POSITION(bilinear_start[Y_AXIS]) + 0.5 * yGridSpacing) / yGridSpacing;
+          i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
+          j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
+        }
+        if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
+          set_bed_leveling_enabled(false);
+          z_values[i][j] = z;
+          #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+            bed_level_virt_interpolate();
+          #endif
+          set_bed_leveling_enabled(abl_should_enable);
+        }
+        return;
+      } // parser.seen('W')
+
+    #endif
+
+    #if HAS_LEVELING
+
+      // Jettison bed leveling data
+      if (parser.seen('J')) {
+        reset_bed_level();
+        return;
+      }
+
+    #endif
+
+    verbose_level = parser.intval('V');
+    if (!WITHIN(verbose_level, 0, 4)) {
+      SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
+      return;
+    }
+
+    dryrun = parser.boolval('D')
+      #if ENABLED(PROBE_MANUALLY)
+        || no_action
+      #endif
+    ;
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+      do_topography_map = verbose_level > 2 || parser.boolval('T');
+
+      // X and Y specify points in each direction, overriding the default
+      // These values may be saved with the completed mesh
+      abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
+      abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
+      if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
+
+      if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
+        SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
+        return;
+      }
+
+      abl2 = abl_grid_points_x * abl_grid_points_y;
+      mean = 0;
+
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      zoffset = parser.linearval('Z');
+
+    #endif
+
+    #if ABL_GRID
+
+      xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
+
+      left_probe_bed_position = (int)parser.linearval('L', LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION));
+      right_probe_bed_position = (int)parser.linearval('R', LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION));
+      front_probe_bed_position = (int)parser.linearval('F', LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION));
+      back_probe_bed_position = (int)parser.linearval('B', LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION));
+
+      const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
+                 left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
+                 right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
+                 right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
+                 front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
+                 front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
+                 back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
+                 back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
+
+      if (left_out || right_out || front_out || back_out) {
+        if (left_out) {
+          out_of_range_error(PSTR("(L)eft"));
+          left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
+        }
+        if (right_out) {
+          out_of_range_error(PSTR("(R)ight"));
+          right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
+        }
+        if (front_out) {
+          out_of_range_error(PSTR("(F)ront"));
+          front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
+        }
+        if (back_out) {
+          out_of_range_error(PSTR("(B)ack"));
+          back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
+        }
+        return;
+      }
+
+      // probe at the points of a lattice grid
+      xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
+      yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
+
+    #endif // ABL_GRID
+
+    if (verbose_level > 0) {
+      SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
+      if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
+    }
+
+    stepper.synchronize();
+
+    // Disable auto bed leveling during G29
+    planner.abl_enabled = false;
+
+    if (!dryrun) {
+      // Re-orient the current position without leveling
+      // based on where the steppers are positioned.
+      set_current_from_steppers_for_axis(ALL_AXES);
+
+      // Sync the planner to where the steppers stopped
+      SYNC_PLAN_POSITION_KINEMATIC();
+    }
+
+    #if HAS_BED_PROBE
+      // Deploy the probe. Probe will raise if needed.
+      if (DEPLOY_PROBE()) {
+        planner.abl_enabled = abl_should_enable;
+        return;
+      }
+    #endif
+
+    if (!faux) setup_for_endstop_or_probe_move();
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      #if ENABLED(PROBE_MANUALLY)
+        if (!no_action)
+      #endif
+      if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
+        || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
+        || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
+        || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
+      ) {
+        if (dryrun) {
+          // Before reset bed level, re-enable to correct the position
+          planner.abl_enabled = abl_should_enable;
+        }
+        // Reset grid to 0.0 or "not probed". (Also disables ABL)
+        reset_bed_level();
+
+        // Initialize a grid with the given dimensions
+        bilinear_grid_spacing[X_AXIS] = xGridSpacing;
+        bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
+        bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
+        bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
+
+        // Can't re-enable (on error) until the new grid is written
+        abl_should_enable = false;
+      }
+
+    #endif // AUTO_BED_LEVELING_BILINEAR
+
+    #if ENABLED(AUTO_BED_LEVELING_3POINT)
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
+      #endif
+
+      // Probe at 3 arbitrary points
+      points[0].z = points[1].z = points[2].z = 0;
+
+    #endif // AUTO_BED_LEVELING_3POINT
+
+  } // !g29_in_progress
+
+  #if ENABLED(PROBE_MANUALLY)
+
+    // For manual probing, get the next index to probe now.
+    // On the first probe this will be incremented to 0.
+    if (!no_action) {
+      ++abl_probe_index;
+      g29_in_progress = true;
+    }
+
+    // Abort current G29 procedure, go back to idle state
+    if (seenA && g29_in_progress) {
+      SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
+      #if HAS_SOFTWARE_ENDSTOPS
+        soft_endstops_enabled = enable_soft_endstops;
+      #endif
+      planner.abl_enabled = abl_should_enable;
+      g29_in_progress = false;
+      #if ENABLED(LCD_BED_LEVELING)
+        lcd_wait_for_move = false;
+      #endif
+    }
+
+    // Query G29 status
+    if (verbose_level || seenQ) {
+      SERIAL_PROTOCOLPGM("Manual G29 ");
+      if (g29_in_progress) {
+        SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
+        SERIAL_PROTOCOLLNPAIR(" of ", abl2);
+      }
+      else
+        SERIAL_PROTOCOLLNPGM("idle");
+    }
+
+    if (no_action) return;
+
+    if (abl_probe_index == 0) {
+      // For the initial G29 save software endstop state
+      #if HAS_SOFTWARE_ENDSTOPS
+        enable_soft_endstops = soft_endstops_enabled;
+      #endif
+    }
+    else {
+      // For G29 after adjusting Z.
+      // Save the previous Z before going to the next point
+      measured_z = current_position[Z_AXIS];
+
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+        mean += measured_z;
+        eqnBVector[abl_probe_index] = measured_z;
+        eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
+        eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
+        eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
+
+        incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
+
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        z_values[xCount][yCount] = measured_z + zoffset;
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_PROTOCOLPAIR("Save X", xCount);
+            SERIAL_PROTOCOLPAIR(" Y", yCount);
+            SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
+          }
+        #endif
+
+      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+        points[abl_probe_index].z = measured_z;
+
+      #endif
+    }
+
+    //
+    // If there's another point to sample, move there with optional lift.
+    //
+
+    #if ABL_GRID
+
+      // Skip any unreachable points
+      while (abl_probe_index < abl2) {
+
+        // Set xCount, yCount based on abl_probe_index, with zig-zag
+        PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
+        PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
+
+        // Probe in reverse order for every other row/column
+        bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
+
+        if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
+
+        const float xBase = xCount * xGridSpacing + left_probe_bed_position,
+                    yBase = yCount * yGridSpacing + front_probe_bed_position;
+
+        xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
+        yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
+
+        #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+          indexIntoAB[xCount][yCount] = abl_probe_index;
+        #endif
+
+        // Keep looping till a reachable point is found
+        if (position_is_reachable_xy(xProbe, yProbe)) break;
+        ++abl_probe_index;
+      }
+
+      // Is there a next point to move to?
+      if (abl_probe_index < abl2) {
+        _manual_goto_xy(xProbe, yProbe); // Can be used here too!
+        #if HAS_SOFTWARE_ENDSTOPS
+          // Disable software endstops to allow manual adjustment
+          // If G29 is not completed, they will not be re-enabled
+          soft_endstops_enabled = false;
+        #endif
+        return;
+      }
+      else {
+
+        // Leveling done! Fall through to G29 finishing code below
+
+        SERIAL_PROTOCOLLNPGM("Grid probing done.");
+
+        // Re-enable software endstops, if needed
+        #if HAS_SOFTWARE_ENDSTOPS
+          soft_endstops_enabled = enable_soft_endstops;
+        #endif
+      }
+
+    #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+      // Probe at 3 arbitrary points
+      if (abl_probe_index < 3) {
+        xProbe = LOGICAL_X_POSITION(points[abl_probe_index].x);
+        yProbe = LOGICAL_Y_POSITION(points[abl_probe_index].y);
+        #if HAS_SOFTWARE_ENDSTOPS
+          // Disable software endstops to allow manual adjustment
+          // If G29 is not completed, they will not be re-enabled
+          soft_endstops_enabled = false;
+        #endif
+        return;
+      }
+      else {
+
+        SERIAL_PROTOCOLLNPGM("3-point probing done.");
+
+        // Re-enable software endstops, if needed
+        #if HAS_SOFTWARE_ENDSTOPS
+          soft_endstops_enabled = enable_soft_endstops;
+        #endif
+
+        if (!dryrun) {
+          vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
+          if (planeNormal.z < 0) {
+            planeNormal.x *= -1;
+            planeNormal.y *= -1;
+            planeNormal.z *= -1;
+          }
+          planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
+
+          // Can't re-enable (on error) until the new grid is written
+          abl_should_enable = false;
+        }
+
+      }
+
+    #endif // AUTO_BED_LEVELING_3POINT
+
+  #else // !PROBE_MANUALLY
+  {
+    const bool stow_probe_after_each = parser.boolval('E');
+
+    measured_z = 0;
+
+    #if ABL_GRID
+
+      bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
+
+      // Outer loop is Y with PROBE_Y_FIRST disabled
+      for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
+
+        int8_t inStart, inStop, inInc;
+
+        if (zig) { // away from origin
+          inStart = 0;
+          inStop = PR_INNER_END;
+          inInc = 1;
+        }
+        else {     // towards origin
+          inStart = PR_INNER_END - 1;
+          inStop = -1;
+          inInc = -1;
+        }
+
+        zig ^= true; // zag
+
+        // Inner loop is Y with PROBE_Y_FIRST enabled
+        for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
+
+          float xBase = left_probe_bed_position + xGridSpacing * xCount,
+                yBase = front_probe_bed_position + yGridSpacing * yCount;
+
+          xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
+          yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
+
+          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+            indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
+          #endif
+
+          #if IS_KINEMATIC
+            // Avoid probing outside the round or hexagonal area
+            if (!position_is_reachable_by_probe_xy(xProbe, yProbe)) continue;
+          #endif
+
+          measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
+
+          if (isnan(measured_z)) {
+            planner.abl_enabled = abl_should_enable;
+            break;
+          }
+
+          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+            mean += measured_z;
+            eqnBVector[abl_probe_index] = measured_z;
+            eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
+            eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
+            eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
+
+            incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
+
+          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+            z_values[xCount][yCount] = measured_z + zoffset;
+
+          #endif
+
+          abl_should_enable = false;
+          idle();
+
+        } // inner
+      } // outer
+
+    #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+      // Probe at 3 arbitrary points
+
+      for (uint8_t i = 0; i < 3; ++i) {
+        // Retain the last probe position
+        xProbe = LOGICAL_X_POSITION(points[i].x);
+        yProbe = LOGICAL_Y_POSITION(points[i].y);
+        measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
+        if (isnan(measured_z)) {
+          planner.abl_enabled = abl_should_enable;
+          break;
+        }
+        points[i].z = measured_z;
+      }
+
+      if (!dryrun && !isnan(measured_z)) {
+        vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
+        if (planeNormal.z < 0) {
+          planeNormal.x *= -1;
+          planeNormal.y *= -1;
+          planeNormal.z *= -1;
+        }
+        planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
+
+        // Can't re-enable (on error) until the new grid is written
+        abl_should_enable = false;
+      }
+
+    #endif // AUTO_BED_LEVELING_3POINT
+
+    // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
+    if (STOW_PROBE()) {
+      planner.abl_enabled = abl_should_enable;
+      measured_z = NAN;
+    }
+  }
+  #endif // !PROBE_MANUALLY
+
+  //
+  // G29 Finishing Code
+  //
+  // Unless this is a dry run, auto bed leveling will
+  // definitely be enabled after this point.
+  //
+  // If code above wants to continue leveling, it should
+  // return or loop before this point.
+  //
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
+  #endif
+
+  #if ENABLED(PROBE_MANUALLY)
+    g29_in_progress = false;
+    #if ENABLED(LCD_BED_LEVELING)
+      lcd_wait_for_move = false;
+    #endif
+  #endif
+
+  // Calculate leveling, print reports, correct the position
+  if (!isnan(measured_z)) {
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      if (!dryrun) extrapolate_unprobed_bed_level();
+      print_bilinear_leveling_grid();
+
+      refresh_bed_level();
+
+      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+        print_bilinear_leveling_grid_virt();
+      #endif
+
+    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+      // For LINEAR leveling calculate matrix, print reports, correct the position
+
+      /**
+       * solve the plane equation ax + by + d = z
+       * A is the matrix with rows [x y 1] for all the probed points
+       * B is the vector of the Z positions
+       * the normal vector to the plane is formed by the coefficients of the
+       * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
+       * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
+       */
+      float plane_equation_coefficients[3];
+
+      finish_incremental_LSF(&lsf_results);
+      plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
+      plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
+      plane_equation_coefficients[2] = -lsf_results.D;
+
+      mean /= abl2;
+
+      if (verbose_level) {
+        SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
+        SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
+        SERIAL_PROTOCOLPGM(" b: ");
+        SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
+        SERIAL_PROTOCOLPGM(" d: ");
+        SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
+        SERIAL_EOL();
+        if (verbose_level > 2) {
+          SERIAL_PROTOCOLPGM("Mean of sampled points: ");
+          SERIAL_PROTOCOL_F(mean, 8);
+          SERIAL_EOL();
+        }
+      }
+
+      // Create the matrix but don't correct the position yet
+      if (!dryrun)
+        planner.bed_level_matrix = matrix_3x3::create_look_at(
+          vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
+        );
+
+      // Show the Topography map if enabled
+      if (do_topography_map) {
+
+        SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
+                               "   +--- BACK --+\n"
+                               "   |           |\n"
+                               " L |    (+)    | R\n"
+                               " E |           | I\n"
+                               " F | (-) N (+) | G\n"
+                               " T |           | H\n"
+                               "   |    (-)    | T\n"
+                               "   |           |\n"
+                               "   O-- FRONT --+\n"
+                               " (0,0)");
+
+        float min_diff = 999;
+
+        for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
+          for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
+            int ind = indexIntoAB[xx][yy];
+            float diff = eqnBVector[ind] - mean,
+                  x_tmp = eqnAMatrix[ind + 0 * abl2],
+                  y_tmp = eqnAMatrix[ind + 1 * abl2],
+                  z_tmp = 0;
+
+            apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
+
+            NOMORE(min_diff, eqnBVector[ind] - z_tmp);
+
+            if (diff >= 0.0)
+              SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
+            else
+              SERIAL_PROTOCOLCHAR(' ');
+            SERIAL_PROTOCOL_F(diff, 5);
+          } // xx
+          SERIAL_EOL();
+        } // yy
+        SERIAL_EOL();
+
+        if (verbose_level > 3) {
+          SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
+
+          for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
+            for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
+              int ind = indexIntoAB[xx][yy];
+              float x_tmp = eqnAMatrix[ind + 0 * abl2],
+                    y_tmp = eqnAMatrix[ind + 1 * abl2],
+                    z_tmp = 0;
+
+              apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
+
+              float diff = eqnBVector[ind] - z_tmp - min_diff;
+              if (diff >= 0.0)
+                SERIAL_PROTOCOLPGM(" +");
+              // Include + for column alignment
+              else
+                SERIAL_PROTOCOLCHAR(' ');
+              SERIAL_PROTOCOL_F(diff, 5);
+            } // xx
+            SERIAL_EOL();
+          } // yy
+          SERIAL_EOL();
+        }
+      } //do_topography_map
+
+    #endif // AUTO_BED_LEVELING_LINEAR
+
+    #if ABL_PLANAR
+
+      // For LINEAR and 3POINT leveling correct the current position
+
+      if (verbose_level > 0)
+        planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
+
+      if (!dryrun) {
+        //
+        // Correct the current XYZ position based on the tilted plane.
+        //
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
+        #endif
+
+        float converted[XYZ];
+        COPY(converted, current_position);
+
+        planner.abl_enabled = true;
+        planner.unapply_leveling(converted); // use conversion machinery
+        planner.abl_enabled = false;
+
+        // Use the last measured distance to the bed, if possible
+        if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
+          && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
+        ) {
+          const float simple_z = current_position[Z_AXIS] - measured_z;
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPAIR("Z from Probe:", simple_z);
+              SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
+              SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
+            }
+          #endif
+          converted[Z_AXIS] = simple_z;
+        }
+
+        // The rotated XY and corrected Z are now current_position
+        COPY(current_position, converted);
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
+        #endif
+      }
+
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      if (!dryrun) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
+        #endif
+
+        // Unapply the offset because it is going to be immediately applied
+        // and cause compensation movement in Z
+        current_position[Z_AXIS] -= bilinear_z_offset(current_position);
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
+        #endif
+      }
+
+    #endif // ABL_PLANAR
+
+    #ifdef Z_PROBE_END_SCRIPT
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+      #endif
+      enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
+      stepper.synchronize();
+    #endif
+
+    // Auto Bed Leveling is complete! Enable if possible.
+    planner.abl_enabled = dryrun ? abl_should_enable : true;
+  } // !isnan(measured_z)
+
+  // Restore state after probing
+  if (!faux) clean_up_after_endstop_or_probe_move();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
+  #endif
+
+  report_current_position();
+
+  KEEPALIVE_STATE(IN_HANDLER);
+
+  if (planner.abl_enabled)
+    SYNC_PLAN_POSITION_KINEMATIC();
+}
+
+#endif // OLDSCHOOL_ABL
