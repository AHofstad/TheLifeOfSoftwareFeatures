commit 709def5e7baa57911d604ffec701c3ba7ef61ffa
Author: Aleks <96996458+alx3dev@users.noreply.github.com>
Date:   Mon Aug 7 11:09:26 2023 +0200

    ü©π Fix M3 `uninitialized` warning (#26091)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 5d5d44e8bf..ec24cf8a65 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -32,21 +32,18 @@
  * Laser:
  *  M3 - Laser ON/Power (Ramped power)
  *  M4 - Laser ON/Power (Ramped power)
- *  M5 - Set power output to 0 (leaving inline mode unchanged).
  *
  *  M3I - Enable continuous inline power to be processed by the planner, with power
  *        calculated and set in the planner blocks, processed inline during stepping.
- *        Within inline mode M3 S-Values will set the power for the next moves e.g. G1 X10 Y10 powers on with the last S-Value.
+ *        In inline mode M3 S-Values will set the power for the next moves.
+ *        (e.g., G1 X10 Y10 powers on with the last S-Value.)
  *        M3I must be set before using planner-synced M3 inline S-Values (LASER_POWER_SYNC).
  *
  *  M4I - Set dynamic mode which calculates laser power OCR based on the current feedrate.
  *
- *  M5I - Clear inline mode and set power to 0.
- *
  * Spindle:
  *  M3 - Spindle ON (Clockwise)
  *  M4 - Spindle ON (Counter-clockwise)
- *  M5 - Spindle OFF
  *
  * Parameters:
  *  S<power> - Set power. S0 will turn the spindle/laser off.
@@ -92,19 +89,15 @@ void GcodeSuite::M3_M4(const bool is_M4) {
   #endif
 
   auto get_s_power = [] {
-    float u;
     if (parser.seenval('S')) {
       const float v = parser.value_float();
-      u = TERN(LASER_POWER_TRAP, v, cutter.power_to_range(v));
+      cutter.menuPower = cutter.unitPower = TERN(LASER_POWER_TRAP, v, cutter.power_to_range(v));
     }
     else if (cutter.cutter_mode == CUTTER_MODE_STANDARD)
-      u = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
-
-    cutter.menuPower = cutter.unitPower = u;
+      cutter.menuPower = cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
 
     // PWM not implied, power converted to OCR from unit definition and on/off if not PWM.
-    cutter.power = TERN(SPINDLE_LASER_USE_PWM, cutter.upower_to_ocr(u), u > 0 ? 255 : 0);
-    return u;
+    cutter.power = TERN(SPINDLE_LASER_USE_PWM, cutter.upower_to_ocr(cutter.unitPower), cutter.unitPower > 0 ? 255 : 0);
   };
 
   if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS || cutter.cutter_mode == CUTTER_MODE_DYNAMIC) {  // Laser power in inline mode
@@ -138,6 +131,13 @@ void GcodeSuite::M3_M4(const bool is_M4) {
 
 /**
  * M5 - Cutter OFF (when moves are complete)
+ *
+ * Laser:
+ *  M5  - Set power output to 0 (leaving inline mode unchanged).
+ *  M5I - Clear inline mode and set power to 0.
+ *
+ * Spindle:
+ *  M5 - Spindle OFF
  */
 void GcodeSuite::M5() {
   planner.synchronize();

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    üßë‚Äçüíª  Update planner/stepper includes

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 3c51de6f6f..5d5d44e8bf 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -26,7 +26,7 @@
 
 #include "../gcode.h"
 #include "../../feature/spindle_laser.h"
-#include "../../module/stepper.h"
+#include "../../module/planner.h"
 
 /**
  * Laser:

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ‚ö°Ô∏è Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 817ed4fcb4..3c51de6f6f 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -31,17 +31,27 @@
 /**
  * Laser:
  *  M3 - Laser ON/Power (Ramped power)
- *  M4 - Laser ON/Power (Continuous power)
+ *  M4 - Laser ON/Power (Ramped power)
+ *  M5 - Set power output to 0 (leaving inline mode unchanged).
+ *
+ *  M3I - Enable continuous inline power to be processed by the planner, with power
+ *        calculated and set in the planner blocks, processed inline during stepping.
+ *        Within inline mode M3 S-Values will set the power for the next moves e.g. G1 X10 Y10 powers on with the last S-Value.
+ *        M3I must be set before using planner-synced M3 inline S-Values (LASER_POWER_SYNC).
+ *
+ *  M4I - Set dynamic mode which calculates laser power OCR based on the current feedrate.
+ *
+ *  M5I - Clear inline mode and set power to 0.
  *
  * Spindle:
  *  M3 - Spindle ON (Clockwise)
  *  M4 - Spindle ON (Counter-clockwise)
+ *  M5 - Spindle OFF
  *
  * Parameters:
- *  S<power> - Set power. S0 will turn the spindle/laser off, except in relative mode.
- *  O<ocr>   - Set power and OCR (oscillator count register)
+ *  S<power> - Set power. S0 will turn the spindle/laser off.
  *
- *  If no PWM pin is defined then M3/M4 just turns it on.
+ *  If no PWM pin is defined then M3/M4 just turns it on or off.
  *
  *  At least 12.8kHz (50Hz * 256) is needed for Spindle PWM.
  *  Hardware PWM is required on AVR. ISRs are too slow.
@@ -70,77 +80,77 @@ void GcodeSuite::M3_M4(const bool is_M4) {
     reset_stepper_timeout(); // Reset timeout to allow subsequent G-code to power the laser (imm.)
   #endif
 
-  #if EITHER(SPINDLE_LASER_USE_PWM, SPINDLE_SERVO)
-    auto get_s_power = [] {
-      if (parser.seenval('S')) {
-        const float spwr = parser.value_float();
-        #if ENABLED(SPINDLE_SERVO)
-          cutter.unitPower = spwr;
-        #else
-          cutter.unitPower = TERN(SPINDLE_LASER_USE_PWM,
-                                cutter.power_to_range(cutter_power_t(round(spwr))),
-                                spwr > 0 ? 255 : 0);
-        #endif
-      }
-      else
-        cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
-      return cutter.unitPower;
-    };
-  #endif
+  if (cutter.cutter_mode == CUTTER_MODE_STANDARD)
+    planner.synchronize();   // Wait for previous movement commands (G0/G1/G2/G3) to complete before changing power
 
-  #if ENABLED(LASER_POWER_INLINE)
-    if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
-      // Laser power in inline mode
-      cutter.inline_direction(is_M4); // Should always be unused
-      #if ENABLED(SPINDLE_LASER_USE_PWM)
-        if (parser.seenval('O')) {
-          cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
-          cutter.inline_ocr_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
-        }
-        else
-          cutter.inline_power(cutter.upower_to_ocr(get_s_power()));
-      #else
-        cutter.set_inline_enabled(true);
-      #endif
-      return;
+  #if ENABLED(LASER_FEATURE)
+    if (parser.seen_test('I')) {
+      cutter.cutter_mode = is_M4 ? CUTTER_MODE_DYNAMIC : CUTTER_MODE_CONTINUOUS;
+      cutter.inline_power(0);
+      cutter.set_enabled(true);
     }
-    // Non-inline, standard case
-    cutter.inline_disable(); // Prevent future blocks re-setting the power
   #endif
 
-  planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
-  cutter.set_reverse(is_M4);
-
-  #if ENABLED(SPINDLE_LASER_USE_PWM)
-    if (parser.seenval('O')) {
-      cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
-      cutter.ocr_set_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
+  auto get_s_power = [] {
+    float u;
+    if (parser.seenval('S')) {
+      const float v = parser.value_float();
+      u = TERN(LASER_POWER_TRAP, v, cutter.power_to_range(v));
     }
-    else
-      cutter.set_power(cutter.upower_to_ocr(get_s_power()));
-  #elif ENABLED(SPINDLE_SERVO)
-    cutter.set_power(get_s_power());
-  #else
+    else if (cutter.cutter_mode == CUTTER_MODE_STANDARD)
+      u = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
+
+    cutter.menuPower = cutter.unitPower = u;
+
+    // PWM not implied, power converted to OCR from unit definition and on/off if not PWM.
+    cutter.power = TERN(SPINDLE_LASER_USE_PWM, cutter.upower_to_ocr(u), u > 0 ? 255 : 0);
+    return u;
+  };
+
+  if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS || cutter.cutter_mode == CUTTER_MODE_DYNAMIC) {  // Laser power in inline mode
+    #if ENABLED(LASER_FEATURE)
+      planner.laser_inline.status.isPowered = true;                                                 // M3 or M4 is powered either way
+      get_s_power();                                                                                // Update cutter.power if seen
+      #if ENABLED(LASER_POWER_SYNC)
+        // With power sync we only set power so it does not effect queued inline power sets
+        planner.buffer_sync_block(BLOCK_BIT_LASER_PWR);                                            // Send the flag, queueing inline power
+      #else
+        planner.synchronize();
+        cutter.inline_power(cutter.power);
+      #endif
+    #endif
+  }
+  else {
     cutter.set_enabled(true);
-  #endif
-  cutter.menuPower = cutter.unitPower;
+    get_s_power();
+    cutter.apply_power(
+      #if ENABLED(SPINDLE_SERVO)
+        cutter.unitPower
+      #elif ENABLED(SPINDLE_LASER_USE_PWM)
+        cutter.upower_to_ocr(cutter.unitPower)
+      #else
+        cutter.unitPower > 0 ? 255 : 0
+      #endif
+    );
+    TERN_(SPINDLE_CHANGE_DIR, cutter.set_reverse(is_M4));
+  }
 }
 
 /**
  * M5 - Cutter OFF (when moves are complete)
  */
 void GcodeSuite::M5() {
-  #if ENABLED(LASER_POWER_INLINE)
-    if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
-      cutter.set_inline_enabled(false); // Laser power in inline mode
-      return;
-    }
-    // Non-inline, standard case
-    cutter.inline_disable(); // Prevent future blocks re-setting the power
-  #endif
   planner.synchronize();
-  cutter.set_enabled(false);
-  cutter.menuPower = cutter.unitPower;
+  cutter.power = 0;
+  cutter.apply_power(0);                          // M5 just kills power, leaving inline mode unchanged
+  if (cutter.cutter_mode != CUTTER_MODE_STANDARD) {
+    if (parser.seen_test('I')) {
+      TERN_(LASER_FEATURE, cutter.inline_power(cutter.power));
+      cutter.set_enabled(false);                  // Needs to happen while we are in inline mode to clear inline power.
+      cutter.cutter_mode = CUTTER_MODE_STANDARD;  // Switch from inline to standard mode.
+    }
+  }
+  cutter.set_enabled(false);                      // Disable enable output setting
 }
 
 #endif // HAS_CUTTER

commit 85c0875db28477d7ed6515c39376b93407353b27
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue May 31 23:09:44 2022 +0100

    ‚ú® Laser Safety Timeout (#24189)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index cdb37a1207..817ed4fcb4 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -66,6 +66,10 @@
  *  PWM duty cycle goes from 0 (off) to 255 (always on).
  */
 void GcodeSuite::M3_M4(const bool is_M4) {
+  #if LASER_SAFETY_TIMEOUT_MS > 0
+    reset_stepper_timeout(); // Reset timeout to allow subsequent G-code to power the laser (imm.)
+  #endif
+
   #if EITHER(SPINDLE_LASER_USE_PWM, SPINDLE_SERVO)
     auto get_s_power = [] {
       if (parser.seenval('S')) {

commit 2ee39b62f33027f49fc1c62a05379a37fc52077c
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Apr 18 06:03:39 2022 +0200

    ü©π Fix some parameters w/out values (#24051)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 2cf22e81ce..cdb37a1207 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -89,7 +89,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
       // Laser power in inline mode
       cutter.inline_direction(is_M4); // Should always be unused
       #if ENABLED(SPINDLE_LASER_USE_PWM)
-        if (parser.seen('O')) {
+        if (parser.seenval('O')) {
           cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
           cutter.inline_ocr_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
         }

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index ddbbc4ab68..2cf22e81ce 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -43,7 +43,7 @@
  *
  *  If no PWM pin is defined then M3/M4 just turns it on.
  *
- *  At least 12.8KHz (50Hz * 256) is needed for Spindle PWM.
+ *  At least 12.8kHz (50Hz * 256) is needed for Spindle PWM.
  *  Hardware PWM is required on AVR. ISRs are too slow.
  *
  * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.

commit ea0d0e8e8b4552aff660be36a9b70c2c8960cdc3
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon Dec 6 15:52:18 2021 -0600

    ü©π Fix non-PWM cutter compile (#23169)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index ecae8b06c6..ddbbc4ab68 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -66,21 +66,23 @@
  *  PWM duty cycle goes from 0 (off) to 255 (always on).
  */
 void GcodeSuite::M3_M4(const bool is_M4) {
-  auto get_s_power = [] {
-    if (parser.seenval('S')) {
-      const float spwr = parser.value_float();
-      #if ENABLED(SPINDLE_SERVO)
-        cutter.unitPower = spwr;
-      #else
-        cutter.unitPower = TERN(SPINDLE_LASER_USE_PWM,
-                              cutter.power_to_range(cutter_power_t(round(spwr))),
-                              spwr > 0 ? 255 : 0);
-      #endif
-    }
-    else
-      cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
-    return cutter.unitPower;
-  };
+  #if EITHER(SPINDLE_LASER_USE_PWM, SPINDLE_SERVO)
+    auto get_s_power = [] {
+      if (parser.seenval('S')) {
+        const float spwr = parser.value_float();
+        #if ENABLED(SPINDLE_SERVO)
+          cutter.unitPower = spwr;
+        #else
+          cutter.unitPower = TERN(SPINDLE_LASER_USE_PWM,
+                                cutter.power_to_range(cutter_power_t(round(spwr))),
+                                spwr > 0 ? 255 : 0);
+        #endif
+      }
+      else
+        cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
+      return cutter.unitPower;
+    };
+  #endif
 
   #if ENABLED(LASER_POWER_INLINE)
     if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {

commit 798a8a7a0852c12fb8640c4a531fac70fbc57eda
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 13 16:28:12 2021 -0500

    üîß SPINDLE_LASER_PWM => SPINDLE_LASER_USE_PWM

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index ff5ab5086e..ecae8b06c6 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -72,7 +72,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
       #if ENABLED(SPINDLE_SERVO)
         cutter.unitPower = spwr;
       #else
-        cutter.unitPower = TERN(SPINDLE_LASER_PWM,
+        cutter.unitPower = TERN(SPINDLE_LASER_USE_PWM,
                               cutter.power_to_range(cutter_power_t(round(spwr))),
                               spwr > 0 ? 255 : 0);
       #endif
@@ -86,7 +86,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
     if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
       // Laser power in inline mode
       cutter.inline_direction(is_M4); // Should always be unused
-      #if ENABLED(SPINDLE_LASER_PWM)
+      #if ENABLED(SPINDLE_LASER_USE_PWM)
         if (parser.seen('O')) {
           cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
           cutter.inline_ocr_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
@@ -105,7 +105,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
   planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
   cutter.set_reverse(is_M4);
 
-  #if ENABLED(SPINDLE_LASER_PWM)
+  #if ENABLED(SPINDLE_LASER_USE_PWM)
     if (parser.seenval('O')) {
       cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
       cutter.ocr_set_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)

commit 845d42ef40e1adc04315779d31eb55dac2218689
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 6 15:34:12 2021 -0500

    üé® Misc. Spindle/Laser (etc.) cleanup

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 711bb7e5e4..ff5ab5086e 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -108,7 +108,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
   #if ENABLED(SPINDLE_LASER_PWM)
     if (parser.seenval('O')) {
       cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
-      cutter.set_ocr_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
+      cutter.ocr_set_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
     }
     else
       cutter.set_power(cutter.upower_to_ocr(get_s_power()));

commit 3e68e4b4185dfad5dfb4fb78400783c716edc52c
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Dec 9 04:29:33 2020 -0600

    Fix Spindle/Laser Control menu (#20347)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 4ca103da5b..711bb7e5e4 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -103,7 +103,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
   #endif
 
   planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
-  cutter.set_direction(is_M4);
+  cutter.set_reverse(is_M4);
 
   #if ENABLED(SPINDLE_LASER_PWM)
     if (parser.seenval('O')) {

commit 1f6612dfc411d777c1e12df153b6f35703e54213
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 5 17:16:27 2020 -0600

    Comment, spacing cleanup

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 6f2409f69f..4ca103da5b 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -113,7 +113,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
     else
       cutter.set_power(cutter.upower_to_ocr(get_s_power()));
   #elif ENABLED(SPINDLE_SERVO)
-    cutter.set_power(get_s_power()); 
+    cutter.set_power(get_s_power());
   #else
     cutter.set_enabled(true);
   #endif

commit cd89fa141b45dd84644543321994b9b83f159ec4
Author: Alexander Semion <spin7ion@gmail.com>
Date:   Sun Nov 1 01:42:05 2020 +0300

    Add SPINDLE_SERVO option (#19971)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 1326c30669..6f2409f69f 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -69,9 +69,13 @@ void GcodeSuite::M3_M4(const bool is_M4) {
   auto get_s_power = [] {
     if (parser.seenval('S')) {
       const float spwr = parser.value_float();
-      cutter.unitPower = TERN(SPINDLE_LASER_PWM,
+      #if ENABLED(SPINDLE_SERVO)
+        cutter.unitPower = spwr;
+      #else
+        cutter.unitPower = TERN(SPINDLE_LASER_PWM,
                               cutter.power_to_range(cutter_power_t(round(spwr))),
                               spwr > 0 ? 255 : 0);
+      #endif
     }
     else
       cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
@@ -108,6 +112,8 @@ void GcodeSuite::M3_M4(const bool is_M4) {
     }
     else
       cutter.set_power(cutter.upower_to_ocr(get_s_power()));
+  #elif ENABLED(SPINDLE_SERVO)
+    cutter.set_power(get_s_power()); 
   #else
     cutter.set_enabled(true);
   #endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 2ddccde0d2..1326c30669 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 23806aeb3c5db7248ca8a390d1954f444ad2dced
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Jun 16 16:49:32 2020 -0400

    Fix non-PWM spindle/laser compile (#18311)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Luu Lac <45380455+shitcreek@users.noreply.github.com>

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 0ef385221b..2ddccde0d2 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -67,8 +67,12 @@
  */
 void GcodeSuite::M3_M4(const bool is_M4) {
   auto get_s_power = [] {
-    if (parser.seen('S'))
-      cutter.unitPower = cutter.power_to_range(cutter_power_t(round(parser.value_float())));
+    if (parser.seenval('S')) {
+      const float spwr = parser.value_float();
+      cutter.unitPower = TERN(SPINDLE_LASER_PWM,
+                              cutter.power_to_range(cutter_power_t(round(spwr))),
+                              spwr > 0 ? 255 : 0);
+    }
     else
       cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
     return cutter.unitPower;
@@ -86,7 +90,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
         else
           cutter.inline_power(cutter.upower_to_ocr(get_s_power()));
       #else
-        cutter.inline_enabled(true);
+        cutter.set_inline_enabled(true);
       #endif
       return;
     }

commit eda2fd8dbea69cb8f571f2992cb11334b2cb7a2f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 00:47:31 2020 -0500

    Improvements for Laser / Spindle (#17661)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 9c897abf01..0ef385221b 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -28,28 +28,18 @@
 #include "../../feature/spindle_laser.h"
 #include "../../module/stepper.h"
 
-inline cutter_power_t get_s_power() {
-  return cutter_power_t(
-    parser.intval('S', cutter.interpret_power(SPEED_POWER_STARTUP))
-  );
-}
-
 /**
  * Laser:
- *
  *  M3 - Laser ON/Power (Ramped power)
  *  M4 - Laser ON/Power (Continuous power)
  *
- *    S<power> - Set power. S0 will turn the laser off.
- *    O<ocr>   - Set power and OCR
- *
  * Spindle:
- *
  *  M3 - Spindle ON (Clockwise)
  *  M4 - Spindle ON (Counter-clockwise)
  *
- *    S<power> - Set power. S0 will turn the spindle off.
- *    O<ocr>   - Set power and OCR
+ * Parameters:
+ *  S<power> - Set power. S0 will turn the spindle/laser off, except in relative mode.
+ *  O<ocr>   - Set power and OCR (oscillator count register)
  *
  *  If no PWM pin is defined then M3/M4 just turns it on.
  *
@@ -76,17 +66,25 @@ inline cutter_power_t get_s_power() {
  *  PWM duty cycle goes from 0 (off) to 255 (always on).
  */
 void GcodeSuite::M3_M4(const bool is_M4) {
+  auto get_s_power = [] {
+    if (parser.seen('S'))
+      cutter.unitPower = cutter.power_to_range(cutter_power_t(round(parser.value_float())));
+    else
+      cutter.unitPower = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
+    return cutter.unitPower;
+  };
 
   #if ENABLED(LASER_POWER_INLINE)
     if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
       // Laser power in inline mode
       cutter.inline_direction(is_M4); // Should always be unused
-
       #if ENABLED(SPINDLE_LASER_PWM)
-        if (parser.seen('O'))
-          cutter.inline_ocr_power(parser.value_byte()); // The OCR is a value from 0 to 255 (uint8_t)
+        if (parser.seen('O')) {
+          cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
+          cutter.inline_ocr_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
+        }
         else
-          cutter.inline_power(get_s_power());
+          cutter.inline_power(cutter.upower_to_ocr(get_s_power()));
       #else
         cutter.inline_enabled(true);
       #endif
@@ -97,17 +95,19 @@ void GcodeSuite::M3_M4(const bool is_M4) {
   #endif
 
   planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
-
   cutter.set_direction(is_M4);
 
   #if ENABLED(SPINDLE_LASER_PWM)
-    if (parser.seenval('O'))
-      cutter.set_ocr_power(parser.value_byte()); // The OCR is a value from 0 to 255 (uint8_t)
+    if (parser.seenval('O')) {
+      cutter.unitPower = cutter.power_to_range(parser.value_byte(), 0);
+      cutter.set_ocr_power(cutter.unitPower); // The OCR is a value from 0 to 255 (uint8_t)
+    }
     else
-      cutter.set_power(get_s_power());
+      cutter.set_power(cutter.upower_to_ocr(get_s_power()));
   #else
     cutter.set_enabled(true);
   #endif
+  cutter.menuPower = cutter.unitPower;
 }
 
 /**
@@ -116,7 +116,7 @@ void GcodeSuite::M3_M4(const bool is_M4) {
 void GcodeSuite::M5() {
   #if ENABLED(LASER_POWER_INLINE)
     if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
-      cutter.inline_enabled(false); // Laser power in inline mode
+      cutter.set_inline_enabled(false); // Laser power in inline mode
       return;
     }
     // Non-inline, standard case
@@ -124,6 +124,7 @@ void GcodeSuite::M5() {
   #endif
   planner.synchronize();
   cutter.set_enabled(false);
+  cutter.menuPower = cutter.unitPower;
 }
 
 #endif // HAS_CUTTER

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 56e1e0e4ec..9c897abf01 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -28,6 +28,12 @@
 #include "../../feature/spindle_laser.h"
 #include "../../module/stepper.h"
 
+inline cutter_power_t get_s_power() {
+  return cutter_power_t(
+    parser.intval('S', cutter.interpret_power(SPEED_POWER_STARTUP))
+  );
+}
+
 /**
  * Laser:
  *
@@ -71,29 +77,52 @@
  */
 void GcodeSuite::M3_M4(const bool is_M4) {
 
-  #if ENABLED(SPINDLE_FEATURE)
-    planner.synchronize();   // Wait for movement to complete before changing power
+  #if ENABLED(LASER_POWER_INLINE)
+    if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
+      // Laser power in inline mode
+      cutter.inline_direction(is_M4); // Should always be unused
+
+      #if ENABLED(SPINDLE_LASER_PWM)
+        if (parser.seen('O'))
+          cutter.inline_ocr_power(parser.value_byte()); // The OCR is a value from 0 to 255 (uint8_t)
+        else
+          cutter.inline_power(get_s_power());
+      #else
+        cutter.inline_enabled(true);
+      #endif
+      return;
+    }
+    // Non-inline, standard case
+    cutter.inline_disable(); // Prevent future blocks re-setting the power
   #endif
 
+  planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
+
   cutter.set_direction(is_M4);
 
   #if ENABLED(SPINDLE_LASER_PWM)
     if (parser.seenval('O'))
       cutter.set_ocr_power(parser.value_byte()); // The OCR is a value from 0 to 255 (uint8_t)
     else
-      cutter.set_power(parser.intval('S', 255));
+      cutter.set_power(get_s_power());
   #else
     cutter.set_enabled(true);
   #endif
 }
 
 /**
- * M5 - Cutter OFF
+ * M5 - Cutter OFF (when moves are complete)
  */
 void GcodeSuite::M5() {
-  #if ENABLED(SPINDLE_FEATURE)
-    planner.synchronize();
+  #if ENABLED(LASER_POWER_INLINE)
+    if (parser.seen('I') == DISABLED(LASER_POWER_INLINE_INVERT)) {
+      cutter.inline_enabled(false); // Laser power in inline mode
+      return;
+    }
+    // Non-inline, standard case
+    cutter.inline_disable(); // Prevent future blocks re-setting the power
   #endif
+  planner.synchronize();
   cutter.set_enabled(false);
 }
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 81e1645193..56e1e0e4ec 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit b7b303f4bfbced9f7a242a87af0f50d4cb24d8ae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 15 16:10:20 2019 -0500

    Spindle/Laser power in planner blocks (#14437)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index b5e789a92f..81e1645193 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -29,10 +29,20 @@
 #include "../../module/stepper.h"
 
 /**
- *  M3 - Cutter ON (Clockwise)
- *  M4 - Cutter ON (Counter-clockwise)
+ * Laser:
  *
- *    S<power> - Set power. S0 turns it off.
+ *  M3 - Laser ON/Power (Ramped power)
+ *  M4 - Laser ON/Power (Continuous power)
+ *
+ *    S<power> - Set power. S0 will turn the laser off.
+ *    O<ocr>   - Set power and OCR
+ *
+ * Spindle:
+ *
+ *  M3 - Spindle ON (Clockwise)
+ *  M4 - Spindle ON (Counter-clockwise)
+ *
+ *    S<power> - Set power. S0 will turn the spindle off.
  *    O<ocr>   - Set power and OCR
  *
  *  If no PWM pin is defined then M3/M4 just turns it on.
@@ -61,12 +71,14 @@
  */
 void GcodeSuite::M3_M4(const bool is_M4) {
 
-  planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
+  #if ENABLED(SPINDLE_FEATURE)
+    planner.synchronize();   // Wait for movement to complete before changing power
+  #endif
 
   cutter.set_direction(is_M4);
 
   #if ENABLED(SPINDLE_LASER_PWM)
-    if (parser.seen('O'))
+    if (parser.seenval('O'))
       cutter.set_ocr_power(parser.value_byte()); // The OCR is a value from 0 to 255 (uint8_t)
     else
       cutter.set_power(parser.intval('S', 255));
@@ -79,7 +91,9 @@ void GcodeSuite::M3_M4(const bool is_M4) {
  * M5 - Cutter OFF
  */
 void GcodeSuite::M5() {
-  planner.synchronize();
+  #if ENABLED(SPINDLE_FEATURE)
+    planner.synchronize();
+  #endif
   cutter.set_enabled(false);
 }
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 6b8497ea40..b5e789a92f 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit d7d80418aedad1c89e27fcba6aab9aa48187b5cc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 27 23:06:49 2019 -0500

    Singleton for cutting tools (#14429)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 132f7bb399..6b8497ea40 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -22,23 +22,23 @@
 
 #include "../../inc/MarlinConfig.h"
 
-#if ENABLED(SPINDLE_LASER_ENABLE)
+#if HAS_CUTTER
 
 #include "../gcode.h"
+#include "../../feature/spindle_laser.h"
 #include "../../module/stepper.h"
 
-uint8_t spindle_laser_power; // = 0
-
 /**
- * M3: Spindle Clockwise
- * M4: Spindle Counter-clockwise
+ *  M3 - Cutter ON (Clockwise)
+ *  M4 - Cutter ON (Counter-clockwise)
  *
- *  S0 turns off spindle.
+ *    S<power> - Set power. S0 turns it off.
+ *    O<ocr>   - Set power and OCR
  *
- *  If no speed PWM output is defined then M3/M4 just turns it on.
+ *  If no PWM pin is defined then M3/M4 just turns it on.
  *
- *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
- *  Hardware PWM is required. ISRs are too slow.
+ *  At least 12.8KHz (50Hz * 256) is needed for Spindle PWM.
+ *  Hardware PWM is required on AVR. ISRs are too slow.
  *
  * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
  *       No other settings give a PWM signal that goes from 0 to 5 volts.
@@ -59,114 +59,28 @@ uint8_t spindle_laser_power; // = 0
  *
  *  PWM duty cycle goes from 0 (off) to 255 (always on).
  */
-
-// Wait for spindle to come up to speed
-inline void delay_for_power_up() { safe_delay(SPINDLE_LASER_POWERUP_DELAY); }
-
-// Wait for spindle to stop turning
-inline void delay_for_power_down() { safe_delay(SPINDLE_LASER_POWERDOWN_DELAY); }
-
-/**
- * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
- *
- * it accepts inputs of 0-255
- */
-
-inline void set_spindle_laser_ocr(const uint8_t ocr) {
-  WRITE(SPINDLE_LASER_ENA_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
-  #if ENABLED(SPINDLE_LASER_PWM)
-    analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
-  #endif
-}
-
-#if ENABLED(SPINDLE_LASER_PWM)
-
-  void update_spindle_laser_power() {
-    if (spindle_laser_power == 0) {
-      WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);                      // turn spindle off (active low)
-      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
-      delay_for_power_down();
-    }
-    else {                                                                                // Convert RPM to PWM duty cycle
-      constexpr float inv_slope = 1.0f / (SPEED_POWER_SLOPE),
-                      min_ocr = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * inv_slope,  // Minimum allowed
-                      max_ocr = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * inv_slope;  // Maximum allowed
-      int16_t ocr_val;
-           if (spindle_laser_power <= SPEED_POWER_MIN) ocr_val = min_ocr;                 // Use minimum if set below
-      else if (spindle_laser_power >= SPEED_POWER_MAX) ocr_val = max_ocr;                 // Use maximum if set above
-      else ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * inv_slope;         // Use calculated OCR value
-      set_spindle_laser_ocr(ocr_val & 0xFF);                                              // ...limited to Atmel PWM max
-      delay_for_power_up();
-    }
-  }
-
-#endif // SPINDLE_LASER_PWM
-
-bool spindle_laser_enabled() {
-  return !!spindle_laser_power; // READ(SPINDLE_LASER_ENA_PIN) == SPINDLE_LASER_ENABLE_INVERT;
-}
-
-void set_spindle_laser_enabled(const bool enable) {
-  // Enabled by PWM setting elsewhere
-  spindle_laser_power = enable ? 255 : 0;
-  #if ENABLED(SPINDLE_LASER_PWM)
-    update_spindle_laser_power();
-  #else
-    if (enable) {
-      WRITE(SPINDLE_LASER_ENA_PIN, SPINDLE_LASER_ENABLE_INVERT);
-      delay_for_power_up();
-    }
-    else {
-      WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);
-      delay_for_power_down();
-    }
-  #endif
-}
-
-#if SPINDLE_DIR_CHANGE
-
-  void set_spindle_direction(const bool reverse_dir) {
-    const bool dir_state = (reverse_dir == SPINDLE_INVERT_DIR); // Forward (M3) HIGH when not inverted
-    if (SPINDLE_STOP_ON_DIR_CHANGE && spindle_laser_enabled() && READ(SPINDLE_DIR_PIN) != dir_state)
-      set_spindle_laser_enabled(false);
-    WRITE(SPINDLE_DIR_PIN, dir_state);
-  }
-
-#endif
-
 void GcodeSuite::M3_M4(const bool is_M4) {
 
-  planner.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
+  planner.synchronize();   // Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
 
-  #if SPINDLE_DIR_CHANGE
-    set_spindle_direction(is_M4);
-  #endif
+  cutter.set_direction(is_M4);
 
-  /**
-   * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
-   * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
-   * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
-   */
   #if ENABLED(SPINDLE_LASER_PWM)
-    if (parser.seen('O')) {
-      spindle_laser_power = parser.value_byte();
-      set_spindle_laser_ocr(spindle_laser_power);
-    }
-    else {
-      spindle_laser_power = parser.intval('S', 255);
-      update_spindle_laser_power();
-    }
+    if (parser.seen('O'))
+      cutter.set_ocr_power(parser.value_byte()); // The OCR is a value from 0 to 255 (uint8_t)
+    else
+      cutter.set_power(parser.intval('S', 255));
   #else
-    set_spindle_laser_enabled(true);
+    cutter.set_enabled(true);
   #endif
 }
 
 /**
- * M5 turn off spindle
+ * M5 - Cutter OFF
  */
 void GcodeSuite::M5() {
   planner.synchronize();
-  set_spindle_laser_enabled(false);
+  cutter.set_enabled(false);
 }
 
-#endif // SPINDLE_LASER_ENABLE
+#endif // HAS_CUTTER

commit aa0f7afbe67e95541134878b9520aec329492cc0
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Apr 15 16:57:34 2019 -0400

    Fix call to uninitialized PWM pin, heater 2 overlap (#13674)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 8612e0c03f..132f7bb399 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -74,7 +74,9 @@ inline void delay_for_power_down() { safe_delay(SPINDLE_LASER_POWERDOWN_DELAY);
 
 inline void set_spindle_laser_ocr(const uint8_t ocr) {
   WRITE(SPINDLE_LASER_ENA_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
-  analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
+  #if ENABLED(SPINDLE_LASER_PWM)
+    analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
+  #endif
 }
 
 #if ENABLED(SPINDLE_LASER_PWM)

commit c8a83fb1228d0c263b195b7f3f358345d4893a39
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 8 17:52:33 2019 -0500

    SPINDLE_LASER_ENABLE => SPINDLE_LASER_ENA

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 39405e1cbe..8612e0c03f 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -53,7 +53,7 @@ uint8_t spindle_laser_power; // = 0
  * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
  *       factors for timers 2, 3, 4, and 5 are acceptable.
  *
- *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
+ *  SPINDLE_LASER_ENA_PIN needs an external pullup or it may power on
  *  the spindle/laser during power-up or when connecting to the host
  *  (usually goes through a reset which sets all I/O pins to tri-state)
  *
@@ -73,7 +73,7 @@ inline void delay_for_power_down() { safe_delay(SPINDLE_LASER_POWERDOWN_DELAY);
  */
 
 inline void set_spindle_laser_ocr(const uint8_t ocr) {
-  WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
+  WRITE(SPINDLE_LASER_ENA_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
   analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
 }
 
@@ -81,7 +81,7 @@ inline void set_spindle_laser_ocr(const uint8_t ocr) {
 
   void update_spindle_laser_power() {
     if (spindle_laser_power == 0) {
-      WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                      // turn spindle off (active low)
+      WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);                      // turn spindle off (active low)
       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
       delay_for_power_down();
     }
@@ -101,7 +101,7 @@ inline void set_spindle_laser_ocr(const uint8_t ocr) {
 #endif // SPINDLE_LASER_PWM
 
 bool spindle_laser_enabled() {
-  return !!spindle_laser_power; // READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT;
+  return !!spindle_laser_power; // READ(SPINDLE_LASER_ENA_PIN) == SPINDLE_LASER_ENABLE_INVERT;
 }
 
 void set_spindle_laser_enabled(const bool enable) {
@@ -111,11 +111,11 @@ void set_spindle_laser_enabled(const bool enable) {
     update_spindle_laser_power();
   #else
     if (enable) {
-      WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);
+      WRITE(SPINDLE_LASER_ENA_PIN, SPINDLE_LASER_ENABLE_INVERT);
       delay_for_power_up();
     }
     else {
-      WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
+      WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);
       delay_for_power_down();
     }
   #endif

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index c133cd2802..39405e1cbe 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -74,7 +74,7 @@ inline void delay_for_power_down() { safe_delay(SPINDLE_LASER_POWERDOWN_DELAY);
 
 inline void set_spindle_laser_ocr(const uint8_t ocr) {
   WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
-  ANALOG_WRITE(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
+  analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
 }
 
 #if ENABLED(SPINDLE_LASER_PWM)
@@ -82,7 +82,7 @@ inline void set_spindle_laser_ocr(const uint8_t ocr) {
   void update_spindle_laser_power() {
     if (spindle_laser_power == 0) {
       WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                      // turn spindle off (active low)
-      ANALOG_WRITE(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
+      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
       delay_for_power_down();
     }
     else {                                                                                // Convert RPM to PWM duty cycle

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 39405e1cbe..c133cd2802 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -74,7 +74,7 @@ inline void delay_for_power_down() { safe_delay(SPINDLE_LASER_POWERDOWN_DELAY);
 
 inline void set_spindle_laser_ocr(const uint8_t ocr) {
   WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
-  analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
+  ANALOG_WRITE(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
 }
 
 #if ENABLED(SPINDLE_LASER_PWM)
@@ -82,7 +82,7 @@ inline void set_spindle_laser_ocr(const uint8_t ocr) {
   void update_spindle_laser_power() {
     if (spindle_laser_power == 0) {
       WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                      // turn spindle off (active low)
-      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
+      ANALOG_WRITE(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
       delay_for_power_down();
     }
     else {                                                                                // Convert RPM to PWM duty cycle

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 52dbd575c9..39405e1cbe 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit a1cf49935ded121d5db26175f706a01dda9d6feb
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 21 00:41:47 2019 -0500

    Add laser control menu (#12883)

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 213d17450a..52dbd575c9 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -27,6 +27,8 @@
 #include "../gcode.h"
 #include "../../module/stepper.h"
 
+uint8_t spindle_laser_power; // = 0
+
 /**
  * M3: Spindle Clockwise
  * M4: Spindle Counter-clockwise
@@ -59,10 +61,10 @@
  */
 
 // Wait for spindle to come up to speed
-inline void delay_for_power_up() { gcode.dwell(SPINDLE_LASER_POWERUP_DELAY); }
+inline void delay_for_power_up() { safe_delay(SPINDLE_LASER_POWERUP_DELAY); }
 
 // Wait for spindle to stop turning
-inline void delay_for_power_down() { gcode.dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
+inline void delay_for_power_down() { safe_delay(SPINDLE_LASER_POWERDOWN_DELAY); }
 
 /**
  * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
@@ -70,26 +72,72 @@ inline void delay_for_power_down() { gcode.dwell(SPINDLE_LASER_POWERDOWN_DELAY);
  * it accepts inputs of 0-255
  */
 
-inline void ocr_val_mode() {
-  uint8_t spindle_laser_power = parser.value_byte();
+inline void set_spindle_laser_ocr(const uint8_t ocr) {
   WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
-  if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
-  analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
+  analogWrite(SPINDLE_LASER_PWM_PIN, (SPINDLE_LASER_PWM_INVERT) ? 255 - ocr : ocr);
 }
 
-void GcodeSuite::M3_M4(bool is_M3) {
+#if ENABLED(SPINDLE_LASER_PWM)
 
-  planner.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
-  #if SPINDLE_DIR_CHANGE
-    const bool rotation_dir = (is_M3 != SPINDLE_INVERT_DIR);
-    if (SPINDLE_STOP_ON_DIR_CHANGE \
-       && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
-       && READ(SPINDLE_DIR_PIN) != rotation_dir
-    ) {
-      WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
+  void update_spindle_laser_power() {
+    if (spindle_laser_power == 0) {
+      WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                      // turn spindle off (active low)
+      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);             // only write low byte
+      delay_for_power_down();
+    }
+    else {                                                                                // Convert RPM to PWM duty cycle
+      constexpr float inv_slope = 1.0f / (SPEED_POWER_SLOPE),
+                      min_ocr = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * inv_slope,  // Minimum allowed
+                      max_ocr = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * inv_slope;  // Maximum allowed
+      int16_t ocr_val;
+           if (spindle_laser_power <= SPEED_POWER_MIN) ocr_val = min_ocr;                 // Use minimum if set below
+      else if (spindle_laser_power >= SPEED_POWER_MAX) ocr_val = max_ocr;                 // Use maximum if set above
+      else ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * inv_slope;         // Use calculated OCR value
+      set_spindle_laser_ocr(ocr_val & 0xFF);                                              // ...limited to Atmel PWM max
+      delay_for_power_up();
+    }
+  }
+
+#endif // SPINDLE_LASER_PWM
+
+bool spindle_laser_enabled() {
+  return !!spindle_laser_power; // READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT;
+}
+
+void set_spindle_laser_enabled(const bool enable) {
+  // Enabled by PWM setting elsewhere
+  spindle_laser_power = enable ? 255 : 0;
+  #if ENABLED(SPINDLE_LASER_PWM)
+    update_spindle_laser_power();
+  #else
+    if (enable) {
+      WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);
+      delay_for_power_up();
+    }
+    else {
+      WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
       delay_for_power_down();
     }
-    WRITE(SPINDLE_DIR_PIN, rotation_dir);
+  #endif
+}
+
+#if SPINDLE_DIR_CHANGE
+
+  void set_spindle_direction(const bool reverse_dir) {
+    const bool dir_state = (reverse_dir == SPINDLE_INVERT_DIR); // Forward (M3) HIGH when not inverted
+    if (SPINDLE_STOP_ON_DIR_CHANGE && spindle_laser_enabled() && READ(SPINDLE_DIR_PIN) != dir_state)
+      set_spindle_laser_enabled(false);
+    WRITE(SPINDLE_DIR_PIN, dir_state);
+  }
+
+#endif
+
+void GcodeSuite::M3_M4(const bool is_M4) {
+
+  planner.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
+
+  #if SPINDLE_DIR_CHANGE
+    set_spindle_direction(is_M4);
   #endif
 
   /**
@@ -98,30 +146,16 @@ void GcodeSuite::M3_M4(bool is_M3) {
    * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
    */
   #if ENABLED(SPINDLE_LASER_PWM)
-    if (parser.seen('O')) ocr_val_mode();
+    if (parser.seen('O')) {
+      spindle_laser_power = parser.value_byte();
+      set_spindle_laser_ocr(spindle_laser_power);
+    }
     else {
-      const float spindle_laser_power = parser.floatval('S');
-      if (spindle_laser_power == 0) {
-        WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
-        analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
-        delay_for_power_down();
-      }
-      else {
-        int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0f / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
-        NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
-        if (spindle_laser_power <= SPEED_POWER_MIN)
-          ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0f / (SPEED_POWER_SLOPE));            // minimum setting
-        if (spindle_laser_power >= SPEED_POWER_MAX)
-          ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0f / (SPEED_POWER_SLOPE));            // limit to max RPM
-        if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
-        WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
-        analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
-        delay_for_power_up();
-      }
+      spindle_laser_power = parser.intval('S', 255);
+      update_spindle_laser_power();
     }
   #else
-    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
-    delay_for_power_up();
+    set_spindle_laser_enabled(true);
   #endif
 }
 
@@ -130,11 +164,7 @@ void GcodeSuite::M3_M4(bool is_M3) {
  */
 void GcodeSuite::M5() {
   planner.synchronize();
-  WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
-  #if ENABLED(SPINDLE_LASER_PWM)
-    analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);
-  #endif
-  delay_for_power_down();
+  set_spindle_laser_enabled(false);
 }
 
 #endif // SPINDLE_LASER_ENABLE

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 980fc26a1a..213d17450a 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -107,12 +107,12 @@ void GcodeSuite::M3_M4(bool is_M3) {
         delay_for_power_down();
       }
       else {
-        int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
+        int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0f / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
         NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
         if (spindle_laser_power <= SPEED_POWER_MIN)
-          ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
+          ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0f / (SPEED_POWER_SLOPE));            // minimum setting
         if (spindle_laser_power >= SPEED_POWER_MAX)
-          ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
+          ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0f / (SPEED_POWER_SLOPE));            // limit to max RPM
         if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
         WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
         analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 1fea7e56f1..980fc26a1a 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -79,7 +79,7 @@ inline void ocr_val_mode() {
 
 void GcodeSuite::M3_M4(bool is_M3) {
 
-  stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
+  planner.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
   #if SPINDLE_DIR_CHANGE
     const bool rotation_dir = (is_M3 != SPINDLE_INVERT_DIR);
     if (SPINDLE_STOP_ON_DIR_CHANGE \
@@ -129,7 +129,7 @@ void GcodeSuite::M3_M4(bool is_M3) {
  * M5 turn off spindle
  */
 void GcodeSuite::M5() {
-  stepper.synchronize();
+  planner.synchronize();
   WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
   #if ENABLED(SPINDLE_LASER_PWM)
     analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);

commit cf2922f1645614ede75d9cba68cdaa87612b17a1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 6 15:29:22 2018 -0600

    Laser/spindle PWM off on M5

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 7cfa4472d9..1fea7e56f1 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -131,6 +131,9 @@ void GcodeSuite::M3_M4(bool is_M3) {
 void GcodeSuite::M5() {
   stepper.synchronize();
   WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
+  #if ENABLED(SPINDLE_LASER_PWM)
+    analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);
+  #endif
   delay_for_power_down();
 }
 

commit 98c1265e3bbac7cc56fdc9a91f7044c70d77ea22
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 11 21:58:37 2017 -0600

    Disable laser power when PWM goes to 0

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index e361dc1262..7cfa4472d9 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -103,6 +103,7 @@ void GcodeSuite::M3_M4(bool is_M3) {
       const float spindle_laser_power = parser.floatval('S');
       if (spindle_laser_power == 0) {
         WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
+        analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
         delay_for_power_down();
       }
       else {

commit 33e00b6cd60248d0399e63aa637eaca0b8f3e112
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 01:07:00 2017 -0500

    Move M3-M5 to cpp

diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
new file mode 100644
index 0000000000..e361dc1262
--- /dev/null
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -0,0 +1,136 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(SPINDLE_LASER_ENABLE)
+
+#include "../gcode.h"
+#include "../../module/stepper.h"
+
+/**
+ * M3: Spindle Clockwise
+ * M4: Spindle Counter-clockwise
+ *
+ *  S0 turns off spindle.
+ *
+ *  If no speed PWM output is defined then M3/M4 just turns it on.
+ *
+ *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
+ *  Hardware PWM is required. ISRs are too slow.
+ *
+ * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
+ *       No other settings give a PWM signal that goes from 0 to 5 volts.
+ *
+ *       The system automatically sets WGM to Mode 1, so no special
+ *       initialization is needed.
+ *
+ *       WGM bits for timer 2 are automatically set by the system to
+ *       Mode 1. This produces an acceptable 0 to 5 volt signal.
+ *       No special initialization is needed.
+ *
+ * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
+ *       factors for timers 2, 3, 4, and 5 are acceptable.
+ *
+ *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
+ *  the spindle/laser during power-up or when connecting to the host
+ *  (usually goes through a reset which sets all I/O pins to tri-state)
+ *
+ *  PWM duty cycle goes from 0 (off) to 255 (always on).
+ */
+
+// Wait for spindle to come up to speed
+inline void delay_for_power_up() { gcode.dwell(SPINDLE_LASER_POWERUP_DELAY); }
+
+// Wait for spindle to stop turning
+inline void delay_for_power_down() { gcode.dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
+
+/**
+ * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
+ *
+ * it accepts inputs of 0-255
+ */
+
+inline void ocr_val_mode() {
+  uint8_t spindle_laser_power = parser.value_byte();
+  WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
+  if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
+  analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
+}
+
+void GcodeSuite::M3_M4(bool is_M3) {
+
+  stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
+  #if SPINDLE_DIR_CHANGE
+    const bool rotation_dir = (is_M3 != SPINDLE_INVERT_DIR);
+    if (SPINDLE_STOP_ON_DIR_CHANGE \
+       && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
+       && READ(SPINDLE_DIR_PIN) != rotation_dir
+    ) {
+      WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
+      delay_for_power_down();
+    }
+    WRITE(SPINDLE_DIR_PIN, rotation_dir);
+  #endif
+
+  /**
+   * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
+   * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
+   * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
+   */
+  #if ENABLED(SPINDLE_LASER_PWM)
+    if (parser.seen('O')) ocr_val_mode();
+    else {
+      const float spindle_laser_power = parser.floatval('S');
+      if (spindle_laser_power == 0) {
+        WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
+        delay_for_power_down();
+      }
+      else {
+        int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
+        NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
+        if (spindle_laser_power <= SPEED_POWER_MIN)
+          ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
+        if (spindle_laser_power >= SPEED_POWER_MAX)
+          ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
+        if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
+        WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
+        analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
+        delay_for_power_up();
+      }
+    }
+  #else
+    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
+    delay_for_power_up();
+  #endif
+}
+
+/**
+ * M5 turn off spindle
+ */
+void GcodeSuite::M5() {
+  stepper.synchronize();
+  WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
+  delay_for_power_down();
+}
+
+#endif // SPINDLE_LASER_ENABLE
