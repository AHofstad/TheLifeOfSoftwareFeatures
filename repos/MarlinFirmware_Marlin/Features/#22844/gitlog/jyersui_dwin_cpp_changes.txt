commit 1f9fc665ec21f95666801aa4fccc4f4f71932018
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 26 18:27:05 2024 -0500

    🚸 MarlinUI:: clear_for_drawing

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 1c641817b8..2edc03dfd6 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -5148,20 +5148,22 @@ void MarlinUI::init_lcd() {
     dwinDrawRectangle(1, COLOR_BG_BLACK, 15 + t * 242 / 100, 260, 257, 280);
     dwinUpdateLCD();
     delay(20);
   }
 
   dwinJPGShowAndCache(3);
   dwinJPGCacheTo1(Language_English);
   jyersDWIN.redrawScreen();
 }
 
+void MarlinUI::clear_lcd() {}
+
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     if (mode != PAUSE_MODE_SAME) pause_mode = mode;
     switch (message) {
       case PAUSE_MESSAGE_INSERT:  jyersDWIN.confirmHandler(Popup_FilInsert);  break;
       case PAUSE_MESSAGE_PURGE:
       case PAUSE_MESSAGE_OPTION:  jyersDWIN.popupHandler(Popup_PurgeMore);  break;
       case PAUSE_MESSAGE_HEAT:    jyersDWIN.confirmHandler(Popup_HeaterTime); break;
       case PAUSE_MESSAGE_WAITING: jyersDWIN.drawPrintScreen();          break;
       default: break;

commit 9a6d4b5e56e8dd6c2dda4a7c510b4ed34d19835c
Author: Ben <92957639+buppgard@users.noreply.github.com>
Date:   Tue Jun 25 23:34:33 2024 -0400

    🚸 PLR: Add FR and Flow (#27201)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index c9191dd31d..1c641817b8 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -821,21 +821,21 @@ void JyersDWIN::drawStatusArea(const bool icons/*=false*/) {
       dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 384, hotendtarget);
       dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 4 * STAT_CHR_W + 39, 386);
     }
     if (icons) {
       flow = -1;
       dwinIconShow(ICON, ICON_StepE, 112, 417);
       dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
     }
     if (planner.flow_percentage[0] != flow) {
       flow = planner.flow_percentage[0];
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 116 + 2 * STAT_CHR_W, 417, flow);
     }
   #endif
 
   #if HAS_HEATED_BED
     static float bed = -1;
     static int16_t bedtarget = -1;
     if (icons) {
       bed = -1;
       bedtarget = -1;
       dwinIconShow(ICON, ICON_BedTemp, 10, 416);

commit a3960dfa53394f9d105cbd23dc260ed81ff884f4
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Thu May 9 23:20:57 2024 +0200

    🚸 New encoder logic & debounce (#26723)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index a29f5fc42f..c9191dd31d 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -5136,21 +5136,20 @@ void JyersDWIN::resetSettings() {
   TERN_(SOUND_MENU_ITEM, ui.sound_on = ENABLED(SOUND_ON_DEFAULT));
   redrawScreen();
 }
 
 void MarlinUI::init_lcd() {
   delay(800);
   SERIAL_ECHOPGM("\nDWIN handshake ");
   if (dwinHandshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
   dwinFrameSetDir(1); // Orientation 90°
   dwinUpdateLCD();     // Show bootscreen (first image)
-  encoderConfiguration();
   for (uint16_t t = 0; t <= 100; t += 2) {
     dwinIconShow(ICON, ICON_Bar, 15, 260);
     dwinDrawRectangle(1, COLOR_BG_BLACK, 15 + t * 242 / 100, 260, 257, 280);
     dwinUpdateLCD();
     delay(20);
   }
 
   dwinJPGShowAndCache(3);
   dwinJPGCacheTo1(Language_English);
   jyersDWIN.redrawScreen();

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    🩹 Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 856229b0d8..a29f5fc42f 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -5151,20 +5151,21 @@ void MarlinUI::init_lcd() {
     delay(20);
   }
 
   dwinJPGShowAndCache(3);
   dwinJPGCacheTo1(Language_English);
   jyersDWIN.redrawScreen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
+    if (mode != PAUSE_MODE_SAME) pause_mode = mode;
     switch (message) {
       case PAUSE_MESSAGE_INSERT:  jyersDWIN.confirmHandler(Popup_FilInsert);  break;
       case PAUSE_MESSAGE_PURGE:
       case PAUSE_MESSAGE_OPTION:  jyersDWIN.popupHandler(Popup_PurgeMore);  break;
       case PAUSE_MESSAGE_HEAT:    jyersDWIN.confirmHandler(Popup_HeaterTime); break;
       case PAUSE_MESSAGE_WAITING: jyersDWIN.drawPrintScreen();          break;
       default: break;
     }
   }
 #endif

commit 854f3315af645775e7b0aa39bd05db66187bcc38
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 10 07:33:54 2024 +0100

    ✨ EDITABLE_STEPS_PER_UNIT (#26618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 8d0482f410..856229b0d8 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2357,44 +2357,50 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawMenuItem(row, ICON_MaxSpeed, GET_TEXT_F(MSG_MAX_SPEED), nullptr, true);
           else
             drawMenu(ID_MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
             drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ACCELERATION), nullptr, true);
           else
             drawMenu(ID_MaxAcceleration);
           break;
+
         #if ENABLED(CLASSIC_JERK)
           case MOTION_JERK:
             if (draw)
               drawMenuItem(row, ICON_MaxJerk, GET_TEXT_F(MSG_JERK), nullptr, true);
             else
               drawMenu(ID_MaxJerk);
             break;
         #endif
-        case MOTION_STEPS:
-          if (draw)
-            drawMenuItem(row, ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), nullptr, true);
-          else
-            drawMenu(ID_Steps);
-          break;
+
+        #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+          case MOTION_STEPS:
+            if (draw)
+              drawMenuItem(row, ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), nullptr, true);
+            else
+              drawMenu(ID_Steps);
+            break;
+        #endif
+
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
               drawMenuItem(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
               drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
               modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
         #endif
+
         #if ENABLED(LIN_ADVANCE)
           case MOTION_LA:
             if (draw) {
               drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K));
               drawFloat(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
@@ -2606,78 +2612,83 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawMenuItem(row, ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK));
                 drawFloat(planner.max_jerk.e, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.e, min_jerk_edit_values.e, max_jerk_edit_values.e, JERK_UNIT);
               break;
           #endif
         }
         break;
     #endif
-    case ID_Steps:
 
-      #define STEPS_BACK 0
-      #define STEPS_X (STEPS_BACK + ENABLED(HAS_X_AXIS))
-      #define STEPS_Y (STEPS_X + ENABLED(HAS_Y_AXIS))
-      #define STEPS_Z (STEPS_Y + ENABLED(HAS_Z_AXIS))
-      #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
-      #define STEPS_TOTAL STEPS_E
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
 
-      switch (item) {
-        case STEPS_BACK:
-          if (draw)
-            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            drawMenu(ID_Motion, MOTION_STEPS);
-          break;
-        #if HAS_X_AXIS
-          case STEPS_X:
-            if (draw) {
-              drawMenuItem(row, ICON_StepX, GET_TEXT_F(MSG_A_STEPS));
-              drawFloat(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
-            }
-            else
-              modifyValue(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
-            break;
-        #endif
-        #if HAS_Y_AXIS
-          case STEPS_Y:
-            if (draw) {
-              drawMenuItem(row, ICON_StepY, GET_TEXT_F(MSG_B_STEPS));
-              drawFloat(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, STEPS_UNIT);
-            }
-            else
-              modifyValue(planner.settings.axis_steps_per_mm[Y_AXIS], min_steps_edit_values.y, max_steps_edit_values.y, STEPS_UNIT);
-            break;
-        #endif
-        #if HAS_Z_AXIS
-          case STEPS_Z:
-            if (draw) {
-              drawMenuItem(row, ICON_StepZ, GET_TEXT_F(MSG_C_STEPS));
-              drawFloat(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, STEPS_UNIT);
-            }
-            else
-              modifyValue(planner.settings.axis_steps_per_mm[Z_AXIS], min_steps_edit_values.z, max_steps_edit_values.z, STEPS_UNIT);
-            break;
-        #endif
-        #if HAS_HOTEND
-          case STEPS_E:
-            if (draw) {
-              drawMenuItem(row, ICON_StepE, GET_TEXT_F(MSG_E_STEPS));
-              drawFloat(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
-            }
+      case ID_Steps:
+
+        #define STEPS_BACK 0
+        #define STEPS_X (STEPS_BACK + ENABLED(HAS_X_AXIS))
+        #define STEPS_Y (STEPS_X + ENABLED(HAS_Y_AXIS))
+        #define STEPS_Z (STEPS_Y + ENABLED(HAS_Z_AXIS))
+        #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
+        #define STEPS_TOTAL STEPS_E
+
+        switch (item) {
+          case STEPS_BACK:
+            if (draw)
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
-              modifyValue(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
+              drawMenu(ID_Motion, MOTION_STEPS);
             break;
-        #endif
-      }
-      break;
+          #if HAS_X_AXIS
+            case STEPS_X:
+              if (draw) {
+                drawMenuItem(row, ICON_StepX, GET_TEXT_F(MSG_A_STEPS));
+                drawFloat(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
+              }
+              else
+                modifyValue(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
+              break;
+          #endif
+          #if HAS_Y_AXIS
+            case STEPS_Y:
+              if (draw) {
+                drawMenuItem(row, ICON_StepY, GET_TEXT_F(MSG_B_STEPS));
+                drawFloat(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, STEPS_UNIT);
+              }
+              else
+                modifyValue(planner.settings.axis_steps_per_mm[Y_AXIS], min_steps_edit_values.y, max_steps_edit_values.y, STEPS_UNIT);
+              break;
+          #endif
+          #if HAS_Z_AXIS
+            case STEPS_Z:
+              if (draw) {
+                drawMenuItem(row, ICON_StepZ, GET_TEXT_F(MSG_C_STEPS));
+                drawFloat(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, STEPS_UNIT);
+              }
+              else
+                modifyValue(planner.settings.axis_steps_per_mm[Z_AXIS], min_steps_edit_values.z, max_steps_edit_values.z, STEPS_UNIT);
+              break;
+          #endif
+          #if HAS_HOTEND
+            case STEPS_E:
+              if (draw) {
+                drawMenuItem(row, ICON_StepE, GET_TEXT_F(MSG_E_STEPS));
+                drawFloat(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
+              }
+              else
+                modifyValue(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
+              break;
+          #endif
+        }
+        break;
+
+    #endif // EDITABLE_STEPS_PER_UNIT
 
     case ID_Visual:
 
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
       #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
       #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
       #define VISUAL_TOTAL VISUAL_COLOR_THEMES
 
@@ -4166,21 +4177,23 @@ FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
       #define _PREHEAT_TITLE_CASE(N) case ID_Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
     case ID_Motion:         return GET_TEXT_F(MSG_MOTION);
     case ID_HomeOffsets:    return GET_TEXT_F(MSG_SET_HOME_OFFSETS);
     case ID_MaxSpeed:       return GET_TEXT_F(MSG_MAX_SPEED);
     case ID_MaxAcceleration: return F("Max Acceleration");
     #if ENABLED(CLASSIC_JERK)
       case ID_MaxJerk:      return F("Max Jerk");
     #endif
-    case ID_Steps:          return GET_TEXT_F(MSG_STEPS_PER_MM);
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+      case ID_Steps:        return GET_TEXT_F(MSG_STEPS_PER_MM);
+    #endif
     case ID_Visual:         return F("Visual Settings");
     case ID_Advanced:       return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
     #if HAS_BED_PROBE
       case ID_ProbeMenu:    return F("Bed Probe");
     #endif
     #if HAS_TRINAMIC_CONFIG
       case ID_TMCMenu:      return GET_TEXT_F(MSG_TMC_DRIVERS);
     #endif
     case ID_ColorSettings:  return F("UI Color Settings");
     case ID_Info:           return GET_TEXT_F(MSG_BUTTON_INFO);
@@ -4243,21 +4256,23 @@ uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
       case ID_Preheat1 ... CAT(ID_Preheat, PREHEAT_COUNT):
                             return PREHEAT_SUBMENU_TOTAL;
     #endif
     case ID_Motion:         return MOTION_TOTAL;
     case ID_HomeOffsets:    return HOMEOFFSETS_TOTAL;
     case ID_MaxSpeed:       return SPEED_TOTAL;
     case ID_MaxAcceleration: return ACCEL_TOTAL;
     #if ENABLED(CLASSIC_JERK)
       case ID_MaxJerk:      return JERK_TOTAL;
     #endif
-    case ID_Steps:          return STEPS_TOTAL;
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+      case ID_Steps:        return STEPS_TOTAL;
+    #endif
     case ID_Visual:         return VISUAL_TOTAL;
     case ID_Advanced:       return ADVANCED_TOTAL;
     #if HAS_BED_PROBE
       case ID_ProbeMenu:    return PROBE_TOTAL;
     #endif
     #if HAS_TRINAMIC_CONFIG
       case ID_TMCMenu:      return TMC_TOTAL;
     #endif
     case ID_Info:           return INFO_TOTAL;
     case ID_InfoMain:       return INFO_TOTAL;

commit cb291e8d00a6c1ee0a778625e0170b6b7430a004
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 22:41:00 2024 -0600

    🩹 Fix some temp constraints

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 296f46f68a..8d0482f410 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -107,21 +107,21 @@
     #define MIN_Z_OFFSET -9.99
   #else
     #define MIN_Z_OFFSET -1
   #endif
 #endif
 
 #if HAS_HOTEND
   #define MAX_FLOW_RATE   299
   #define MIN_FLOW_RATE   10
 
-  #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+  #define MAX_E_TEMP    thermalManager.hotend_max_target(0)
   #define MIN_E_TEMP    0
 #endif
 
 #if HAS_HEATED_BED
   #define MAX_BED_TEMP  BED_MAX_TARGET
   #define MIN_BED_TEMP  0
 #endif
 
 #define FEEDRATE_UNIT 1
 #define ACCELERATION_UNIT 1

commit 6d407767e7692d66bc93a0012d71268770e4835c
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 3 16:43:18 2024 +0100

    🔧 CONFIGURE_FILAMENT_CHANGE - Optional M603 (#26613)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index da6fda08d5..296f46f68a 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2903,38 +2903,38 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           case ADVANCED_LA:
             if (draw) {
               drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K));
               drawFloat(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
-        #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
           case ADVANCED_LOAD:
             if (draw) {
               drawMenuItem(row, ICON_WriteEEPROM, F("Load Length"));
               drawFloat(fc_settings[0].load_length, row, false, 1);
             }
             else
               modifyValue(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
           case ADVANCED_UNLOAD:
             if (draw) {
               drawMenuItem(row, ICON_ReadEEPROM, F("Unload Length"));
               drawFloat(fc_settings[0].unload_length, row, false, 1);
             }
             else
               modifyValue(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
-        #endif // ADVANCED_PAUSE_FEATURE
+        #endif // CONFIGURE_FILAMENT_CHANGE
 
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           case ADVANCED_COLD_EXTRUDE:
             if (draw) {
               drawMenuItem(row, ICON_Cool, F("Min Extrusion T"));
               drawFloat(thermalManager.extrude_min_temp, row, false, 1);
             }
             else {
               modifyValue(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
               thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    🧑‍💻 AS_CHAR => C (#26569)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 847c4bfd08..da6fda08d5 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -287,28 +287,28 @@ private:
           return true;
         }
 
         bedlevel.set_all_mesh_points_to_value(0);
 
         matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
         GRID_LOOP(i, j) {
           float mx = bedlevel.get_mesh_x(i), my = bedlevel.get_mesh_y(j), mz = bedlevel.z_values[i][j];
 
           if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOLN(F("before rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), F("]   ---> "));
+            DEBUG_ECHOLN(F("before rotation = ["), p_float_t(mx, 7), C(','), p_float_t(my, 7), C(','), p_float_t(mz, 7), F("]   ---> "));
             DEBUG_DELAY(20);
           }
 
           rotation.apply_rotation_xyz(mx, my, mz);
 
           if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOLN(F("after rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), AS_CHAR(']'));
+            DEBUG_ECHOLN(F("after rotation = ["), p_float_t(mx, 7), C(','), p_float_t(my, 7), C(','), p_float_t(mz, 7), C(']'));
             DEBUG_DELAY(20);
           }
 
           bedlevel.z_values[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
 

commit 0f0955492994f4a7f4649c22e0f3aa5cc71541d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 24 14:53:09 2023 -0600

    🧑‍💻 DWIN icon updates, etc.

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 1cb2a2efed..847c4bfd08 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1151,21 +1151,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             if (draw)
               drawMenuItem(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
             else
               drawMenu(ID_MenuCustom);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
-              drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
+              drawMenuItem(row, ICON_ResetEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 drawMenu(ID_ChangeFilament);
               #else
                 if (thermalManager.targetTooColdToExtrude(0))
@@ -1759,21 +1759,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 }
                 popupHandler(Popup_FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 redrawMenu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
-              drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
+              drawMenuItem(row, ICON_ResetEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
               if (thermalManager.targetTooColdToExtrude(0))
                 popupHandler(Popup_ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 popupHandler(Popup_FilChange);
                 gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.degTargetHotend(0)));
@@ -3442,21 +3442,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             case LEVELING_SETTINGS_TILT:
               if (draw) {
                 drawMenuItem(row, ICON_Tilt, F("Tilting Grid Size"));
                 drawFloat(mesh_conf.tilt_grid, row, false, 1);
               }
               else
                 modifyValue(mesh_conf.tilt_grid, 1, 8, 1);
               break;
             case LEVELING_SETTINGS_PLANE:
               if (draw)
-                drawMenuItem(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
+                drawMenuItem(row, ICON_ResetEEPROM, F("Convert Mesh to Plane"));
               else {
                 if (mesh_conf.createPlaneFromMesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 audioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
                 drawMenuItem(row, ICON_Mesh, F("Mesh Zero"));
@@ -3587,21 +3587,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               mesh_conf.goto_mesh_value ^= true;
               current_position.z = 0;
               mesh_conf.manual_mesh_move(true);
               drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
             case LEVELING_M_UNDEF:
               if (draw)
-                drawMenuItem(row, ICON_ResumeEEPROM, F("Clear Point Value"));
+                drawMenuItem(row, ICON_ResetEEPROM, F("Clear Point Value"));
               else {
                 mesh_conf.manualValueUpdate(true);
                 redrawMenu(false);
               }
               break;
           #endif
         }
         break;
     #endif // HAS_MESH
 
@@ -3917,21 +3917,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawFloat(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
-              drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
+              drawMenuItem(row, ICON_ResetEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else
               popupHandler(Popup_ConfFilChange);
             break;
         #endif
 
         #if ENABLED(FWRETRACT)
           case TUNE_FWRETRACT:
             if (draw)
               drawMenuItem(row, ICON_SetHome, GET_TEXT_F(MSG_FWRETRACT), nullptr, true);
             else

commit 75da3555ee0910f3d572f4b8176afecdc941524b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 14 10:03:11 2023 -0600

    🔧 Update CLASSIC_JERK conditionals

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index be8605e3bb..1cb2a2efed 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2326,21 +2326,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define _PREHEAT_SUBMENU_CASE(N) case ID_Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
     case ID_Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
-      #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
+      #define MOTION_JERK (MOTION_ACCEL + ENABLED(CLASSIC_JERK))
       #define MOTION_STEPS (MOTION_JERK + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
       #define MOTION_LA (MOTION_FLOW + ENABLED(LIN_ADVANCE))
       #define MOTION_TOTAL MOTION_LA
 
       switch (item) {
         case MOTION_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
@@ -2357,21 +2357,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawMenuItem(row, ICON_MaxSpeed, GET_TEXT_F(MSG_MAX_SPEED), nullptr, true);
           else
             drawMenu(ID_MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
             drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ACCELERATION), nullptr, true);
           else
             drawMenu(ID_MaxAcceleration);
           break;
-        #if HAS_CLASSIC_JERK
+        #if ENABLED(CLASSIC_JERK)
           case MOTION_JERK:
             if (draw)
               drawMenuItem(row, ICON_MaxJerk, GET_TEXT_F(MSG_JERK), nullptr, true);
             else
               drawMenu(ID_MaxJerk);
             break;
         #endif
         case MOTION_STEPS:
           if (draw)
             drawMenuItem(row, ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), nullptr, true);
@@ -2546,21 +2546,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             if (draw) {
               drawMenuItem(row, ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E));
               drawFloat(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, ACCELERATION_UNIT);
             }
             else
               modifyValue(planner.settings.max_acceleration_mm_per_s2[E_AXIS], min_acceleration_edit_values.e, max_acceleration_edit_values.e, ACCELERATION_UNIT);
             break;
         #endif
       }
       break;
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       case ID_MaxJerk:
 
         #define JERK_BACK 0
         #define JERK_X (JERK_BACK + ENABLED(HAS_X_AXIS))
         #define JERK_Y (JERK_X + ENABLED(HAS_Y_AXIS))
         #define JERK_Z (JERK_Y + ENABLED(HAS_Z_AXIS))
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
@@ -4163,21 +4163,21 @@ FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
       case ID_MPC:          return F("MPC Menu");
     #endif
     #if HAS_PREHEAT
       #define _PREHEAT_TITLE_CASE(N) case ID_Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
     case ID_Motion:         return GET_TEXT_F(MSG_MOTION);
     case ID_HomeOffsets:    return GET_TEXT_F(MSG_SET_HOME_OFFSETS);
     case ID_MaxSpeed:       return GET_TEXT_F(MSG_MAX_SPEED);
     case ID_MaxAcceleration: return F("Max Acceleration");
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       case ID_MaxJerk:      return F("Max Jerk");
     #endif
     case ID_Steps:          return GET_TEXT_F(MSG_STEPS_PER_MM);
     case ID_Visual:         return F("Visual Settings");
     case ID_Advanced:       return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
     #if HAS_BED_PROBE
       case ID_ProbeMenu:    return F("Bed Probe");
     #endif
     #if HAS_TRINAMIC_CONFIG
       case ID_TMCMenu:      return GET_TEXT_F(MSG_TMC_DRIVERS);
@@ -4240,21 +4240,21 @@ uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
       case ID_MPC:          return MPCMENU_TOTAL;
     #endif
     #if HAS_PREHEAT
       case ID_Preheat1 ... CAT(ID_Preheat, PREHEAT_COUNT):
                             return PREHEAT_SUBMENU_TOTAL;
     #endif
     case ID_Motion:         return MOTION_TOTAL;
     case ID_HomeOffsets:    return HOMEOFFSETS_TOTAL;
     case ID_MaxSpeed:       return SPEED_TOTAL;
     case ID_MaxAcceleration: return ACCEL_TOTAL;
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       case ID_MaxJerk:      return JERK_TOTAL;
     #endif
     case ID_Steps:          return STEPS_TOTAL;
     case ID_Visual:         return VISUAL_TOTAL;
     case ID_Advanced:       return ADVANCED_TOTAL;
     #if HAS_BED_PROBE
       case ID_ProbeMenu:    return PROBE_TOTAL;
     #endif
     #if HAS_TRINAMIC_CONFIG
       case ID_TMCMenu:      return TMC_TOTAL;

commit 3d8e3c3c9a2e955b7075783b8a95c3526b2936a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 30 16:25:11 2023 -0600

    🐛 Touch fixes (#26455)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 6e7898a389..be8605e3bb 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -382,34 +382,34 @@ private:
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? rmax : v_max)) << 5) |  // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
-          xy_uint_t offset { 0, cell_height_px / 2 - 6 };
+          const int8_t offset_y = cell_height_px / 2 - 6;
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
-            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset.y, F("X"));
+            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
               msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
               msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
-            offset.x = cell_width_px / 2 - 3 * msg.length() - 2;
+            const int8_t offset_x = cell_width_px / 2 - 3 * msg.length() - 2;
             if (GRID_MAX_POINTS_X >= 10)
-              dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px - 2 + offset.x, start_y_px + offset.y /*+ square / 2 - 6*/, F("."));
-            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + 1 + offset.x, start_y_px + offset.y /*+ square / 2 - 6*/, msg);
+              dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, msg);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
       float v1, v2,
             v_min = abs(getMinValue()),

commit c2376d62e232b952923cdda55bdb0bbc3c59063c
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Nov 22 03:40:50 2023 -0500

    🩹 Fix JyersUI/ProUI narrowing (#26453)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index cf78bdd7c6..6e7898a389 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -382,21 +382,21 @@ private:
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? rmax : v_max)) << 5) |  // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
-          xy_int_t offset { 0, cell_height_px / 2 - 6 };
+          xy_uint_t offset { 0, cell_height_px / 2 - 6 };
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
             dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset.y, F("X"));
           }
           else {                          // has value
             MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
               msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
               msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
             offset.x = cell_width_px / 2 - 3 * msg.length() - 2;

commit cc8f7c83dabdff51a0980d8fa066833aeaa3d97d
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Tue Nov 21 04:57:31 2023 -0500

    🚸 Fix, clean up ProUI (#26434)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 0222f1e1d0..cf78bdd7c6 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -382,21 +382,21 @@ private:
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? rmax : v_max)) << 5) |  // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
-          xy_int8_t offset { 0, cell_height_px / 2 - 6 };
+          xy_int_t offset { 0, cell_height_px / 2 - 6 };
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
             dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset.y, F("X"));
           }
           else {                          // has value
             MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
               msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
               msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
             offset.x = cell_width_px / 2 - 3 * msg.length() - 2;

commit 376673df284333ed499dd6a1e8ab52c317d2af73
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Nov 20 00:53:35 2023 -0600

    🚸 Minor touch calibration improvement (#26445)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index d945db8e58..0222f1e1d0 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -382,34 +382,34 @@ private:
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? rmax : v_max)) << 5) |  // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
-          int8_t offset_x, offset_y = cell_height_px / 2 - 6;
+          xy_int8_t offset { 0, cell_height_px / 2 - 6 };
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
-            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset.y, F("X"));
           }
           else {                          // has value
             MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
               msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
               msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
-            offset_x = cell_width_px / 2 - 3 * msg.length() - 2;
+            offset.x = cell_width_px / 2 - 3 * msg.length() - 2;
             if (GRID_MAX_POINTS_X >= 10)
-              dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, msg);
+              dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px - 2 + offset.x, start_y_px + offset.y /*+ square / 2 - 6*/, F("."));
+            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + 1 + offset.x, start_y_px + offset.y /*+ square / 2 - 6*/, msg);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
       float v1, v2,
             v_min = abs(getMinValue()),

commit 6d3122d4e8525dea64cf83a98354a95f2a1d9a29
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Oct 19 21:22:04 2023 -0400

    🚸 Misc. JyersUI tweaks (#26228)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 0b3c979d9e..d945db8e58 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -84,49 +84,49 @@
 
 #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 
 #define DWIN_FONT_MENU font8x16
 #define DWIN_FONT_STAT font10x20
 #define DWIN_FONT_HEAD font10x20
 
 #define MENU_CHAR_LIMIT  24
 #define STATUS_Y 352
 
-#define MAX_PRINT_SPEED   500
+#define MAX_PRINT_SPEED   999
 #define MIN_PRINT_SPEED   10
 
 #if HAS_FAN
   #define MAX_FAN_SPEED     255
   #define MIN_FAN_SPEED     0
 #endif
 
 #define MAX_XY_OFFSET 100
 
 #if HAS_ZOFFSET_ITEM
   #define MAX_Z_OFFSET 9.99
   #if HAS_BED_PROBE
     #define MIN_Z_OFFSET -9.99
   #else
     #define MIN_Z_OFFSET -1
   #endif
 #endif
 
 #if HAS_HOTEND
-  #define MAX_FLOW_RATE   200
+  #define MAX_FLOW_RATE   299
   #define MIN_FLOW_RATE   10
 
   #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
   #define MIN_E_TEMP    0
 #endif
 
 #if HAS_HEATED_BED
-  #define MAX_BED_TEMP  BED_MAXTEMP
+  #define MAX_BED_TEMP  BED_MAX_TARGET
   #define MIN_BED_TEMP  0
 #endif
 
 #define FEEDRATE_UNIT 1
 #define ACCELERATION_UNIT 1
 #define JERK_UNIT 10
 #define STEPS_UNIT 10
 
 //
 // Custom menu items with JyersLCD
@@ -393,21 +393,21 @@ private:
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
             dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
               msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
               msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
             offset_x = cell_width_px / 2 - 3 * msg.length() - 2;
-            if (!(GRID_MAX_POINTS_X < 10))
+            if (GRID_MAX_POINTS_X >= 10)
               dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
             dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, msg);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
@@ -420,21 +420,21 @@ private:
         v1 = -v_min;
         v2 =  v_max;
       }
       else {
         float rmax = _MAX(v_min, v_max), rmin = _MIN(v_min, v_max);
         if (rmax > 3e+10f) rmax = 0.0000001;
         if (rmin > 3e+10f) rmin = 0.0000001;
         v1 = -rmax;
         v2 =  rmin;
       }
-      jyersDWIN.updateStatus(TS(F("Red "), p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), F(" Green")));
+      jyersDWIN.updateStatus(TS(GET_TEXT_F(MSG_COLORS_RED), ' ', p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), ' ', GET_TEXT_F(MSG_COLORS_GREEN)));
       drawing_mesh = false;
     }
 
   } mesh_conf;
 
 #endif // HAS_MESH
 
 //
 // General Display Functions
 //
@@ -573,132 +573,132 @@ void JyersDWIN::redrawScreen() {
   updateStatusBar(true);
 }
 
 //
 // Primary Menus and Screen Elements
 //
 void JyersDWIN::mainMenuIcons() {
   if (selection == 0) {
     dwinIconShow(ICON, ICON_Print_1, 17, 130);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 17, 130, 126, 229);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 52, 200, F("Print"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 52, 200, GET_TEXT_F(MSG_BUTTON_PRINT));
   }
   else {
     dwinIconShow(ICON, ICON_Print_0, 17, 130);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 52, 200, F("Print"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 52, 200, GET_TEXT_F(MSG_BUTTON_PRINT));
   }
   if (selection == 1) {
     dwinIconShow(ICON, ICON_Prepare_1, 145, 130);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 145, 130, 254, 229);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 170, 200, F("Prepare"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 170, 200, GET_TEXT_F(MSG_PREPARE));
   }
   else {
     dwinIconShow(ICON, ICON_Prepare_0, 145, 130);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 170, 200, F("Prepare"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 170, 200, GET_TEXT_F(MSG_PREPARE));
   }
   if (selection == 2) {
     dwinIconShow(ICON, ICON_Control_1, 17, 246);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 17, 246, 126, 345);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 43, 317, F("Control"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 43, 317, GET_TEXT_F(MSG_CONTROL));
   }
   else {
     dwinIconShow(ICON, ICON_Control_0, 17, 246);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 43, 317, F("Control"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 43, 317, GET_TEXT_F(MSG_CONTROL));
   }
   #if HAS_ABL_OR_UBL
     if (selection == 3) {
       dwinIconShow(ICON, ICON_Leveling_1, 145, 246);
       dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 145, 246, 254, 345);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 179, 317, F("Level"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 179, 317, GET_TEXT_F(MSG_BUTTON_LEVEL));
     }
     else {
       dwinIconShow(ICON, ICON_Leveling_0, 145, 246);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 179, 317, F("Level"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 179, 317, GET_TEXT_F(MSG_BUTTON_LEVEL));
     }
   #else
     if (selection == 3) {
       dwinIconShow(ICON, ICON_Info_1, 145, 246);
       dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 145, 246, 254, 345);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 181, 317, F("Info"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 181, 317, GET_TEXT_F(MSG_BUTTON_INFO));
     }
     else {
       dwinIconShow(ICON, ICON_Info_0, 145, 246);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 181, 317, F("Info"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 181, 317, GET_TEXT_F(MSG_BUTTON_INFO));
     }
   #endif
 }
 
 void JyersDWIN::drawMainMenu(const uint8_t select/*=0*/) {
   process = Proc_Main;
   active_menu = ID_MainMenu;
   selection = select;
   clearScreen();
   drawTitle(getMenuTitle(ID_MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
   dwinIconShow(ICON, ICON_LOGO, 71, 72);
   mainMenuIcons();
 }
 
 void JyersDWIN::printScreenIcons() {
   if (selection == 0) {
     dwinIconShow(ICON, ICON_Setup_1, 8, 252);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 8, 252, 87, 351);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 30, 322, F("Tune"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 30, 322, GET_TEXT_F(MSG_TUNE));
   }
   else {
     dwinIconShow(ICON, ICON_Setup_0, 8, 252);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 30, 322, F("Tune"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 30, 322, GET_TEXT_F(MSG_TUNE));
   }
   if (selection == 2) {
     dwinIconShow(ICON, ICON_Stop_1, 184, 252);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 184, 252, 263, 351);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 205, 322, F("Stop"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 205, 322, GET_TEXT_F(MSG_BUTTON_STOP));
   }
   else {
     dwinIconShow(ICON, ICON_Stop_0, 184, 252);
-    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 205, 322, F("Stop"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 205, 322, GET_TEXT_F(MSG_BUTTON_STOP));
   }
   if (paused) {
     if (selection == 1) {
       dwinIconShow(ICON, ICON_Continue_1, 96, 252);
       dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 96, 252, 175, 351);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Print"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, GET_TEXT_F(MSG_BUTTON_PRINT));
     }
     else {
       dwinIconShow(ICON, ICON_Continue_0, 96, 252);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Print"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, GET_TEXT_F(MSG_BUTTON_PRINT));
     }
   }
   else {
     if (selection == 1) {
       dwinIconShow(ICON, ICON_Pause_1, 96, 252);
       dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 96, 252, 175, 351);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Pause"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, GET_TEXT_F(MSG_BUTTON_PAUSE));
     }
     else {
       dwinIconShow(ICON, ICON_Pause_0, 96, 252);
-      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Pause"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, GET_TEXT_F(MSG_BUTTON_PAUSE));
     }
   }
 }
 
 void JyersDWIN::drawPrintScreen() {
   process = Proc_Print;
   selection = 0;
   clearScreen();
   dwinDrawRectangle(1, COLOR_BG_BLACK, 8, 352, DWIN_WIDTH - 8, 376);
-  drawTitle("Printing...");
+  drawTitle(GET_TEXT_F(MSG_PRINTING));
   printScreenIcons();
   dwinIconShow(ICON, ICON_PrintTime, 14, 171);
   dwinIconShow(ICON, ICON_RemainTime, 147, 169);
   dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, 41, 163, F("Elapsed"));
-  dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, 176, 163, F("Remaining"));
+  dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, 176, 163, GET_TEXT_F(MSG_REMAINING_TIME));
   updateStatusBar(true);
   drawPrintProgressBar();
   drawPrintProgressElapsed();
   TERN_(SET_REMAINING_TIME, drawPrintProgressRemain());
   drawPrintFilename(true);
 }
 
 void JyersDWIN::drawPrintFilename(const bool reset/*=false*/) {
   typedef TextScroller<30> Scroller;
   static Scroller scroller;
@@ -754,53 +754,53 @@ void JyersDWIN::drawPrintConfirm() {
   process = Proc_Confirm;
   popup = Popup_Complete;
   dwinDrawRectangle(1, COLOR_BG_BLACK, 8, 252, 263, 351);
   dwinIconShow(ICON, ICON_Confirm_E, 87, 283);
   dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 86, 282, 187, 321);
   dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 85, 281, 188, 322);
 }
 
 void JyersDWIN::drawSDItem(const uint8_t item, const uint8_t row) {
   if (item == 0)
-    drawMenuItem(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
+    drawMenuItem(0, ICON_Back, card.flag.workDirIsRoot ? GET_TEXT_F(MSG_BACK) : F(".."));
   else {
     card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
     for (uint8_t i = 0; i < len; ++i) name[i] = filename[i];
     if (pos > max)
       for (uint8_t i = len - 3; i < len; ++i) name[i] = '.';
     name[len] = '\0';
     drawMenuItem(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
 void JyersDWIN::drawSDList(const bool removed/*=false*/) {
   clearScreen();
-  drawTitle("Select File");
+  drawTitle(GET_TEXT_F(MSG_MEDIA_MENU));
   selection = 0;
   scrollpos = 0;
   process = Proc_File;
   if (card.isMounted() && !removed) {
     for (uint8_t i = 0; i < _MIN(card.get_num_items() + 1, TROWS); ++i)
       drawSDItem(i, i);
   }
   else {
-    drawMenuItem(0, ICON_Back, F("Back"));
+    drawMenuItem(0, ICON_Back, GET_TEXT_F(MSG_BACK));
     dwinDrawRectangle(1, COLOR_BG_RED, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    dwinDrawString(false, font16x32, COLOR_YELLOW, COLOR_BG_RED, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
+    dwinDrawString(false, font16x32, COLOR_YELLOW, COLOR_BG_RED, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), GET_TEXT_F(MSG_NO_MEDIA));
   }
   dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
 void JyersDWIN::drawStatusArea(const bool icons/*=false*/) {
 
   if (icons) dwinDrawRectangle(1, COLOR_BG_BLACK, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
@@ -935,27 +935,27 @@ void JyersDWIN::drawPopup(FSTR_P const line1, FSTR_P const line2, FSTR_P const l
   dwinDrawRectangle(1, COLOR_BG_WINDOW, 14, 60, 258, 350);
   const uint8_t ypos = (mode == Proc_Popup || mode == Proc_Confirm) ? 150 : 230;
   if (icon > 0) dwinIconShow(ICON, icon, 101, 105);
   dwinDrawString(true, DWIN_FONT_MENU, COLOR_POPUP_TEXT, COLOR_BG_WINDOW, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
   dwinDrawString(true, DWIN_FONT_MENU, COLOR_POPUP_TEXT, COLOR_BG_WINDOW, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
   dwinDrawString(true, DWIN_FONT_MENU, COLOR_POPUP_TEXT, COLOR_BG_WINDOW, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
   if (mode == Proc_Popup) {
     selection = 0;
     dwinDrawRectangle(1, COLOR_CONFIRM, 26, 280, 125, 317);
     dwinDrawRectangle(1, COLOR_CANCEL, 146, 280, 245, 317);
-    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 39, 290, F("Confirm"));
-    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 165, 290, F("Cancel"));
+    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 39, 290, GET_TEXT_F(MSG_BUTTON_CONFIRM));
+    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 165, 290, GET_TEXT_F(MSG_BUTTON_CANCEL));
     popupSelect();
   }
   else if (mode == Proc_Confirm) {
     dwinDrawRectangle(1, COLOR_CONFIRM, 87, 280, 186, 317);
-    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 96, 290, F("Continue"));
+    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 96, 290, GET_TEXT_F(MSG_BUTTON_CONTINUE));
   }
 }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
   jyersDWIN.drawPopup(F("Printer Kill Reason:"), error, F("Restart Required"), Proc_Wait, ICON_BLTouch);
 }
 
 void JyersDWIN::popupSelect() {
   const uint16_t c1 = selection ? COLOR_BG_WINDOW : getColor(eeprom_settings.highlight_box, COLOR_WHITE),
                  c2 = selection ? getColor(eeprom_settings.highlight_box, COLOR_WHITE) : COLOR_BG_WINDOW;
@@ -1008,48 +1008,48 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
     #define PREHEAT_BACK 0
     #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
     #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
     #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
     #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
 
     auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
       switch (item) {
         case PREHEAT_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_TempMenu, sel);
           break;
         #if HAS_HOTEND
           case PREHEAT_SUBMENU_HOTEND:
             if (draw) {
-              drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
+              drawMenuItem(row, ICON_SetEndTemp, GET_TEXT_F(MSG_NOZZLE));
               drawFloat(ui.material_preset[index].hotend_temp, row, false, 1);
             }
             else
               modifyValue(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
         #if HAS_HEATED_BED
           case PREHEAT_SUBMENU_BED:
             if (draw) {
-              drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
+              drawMenuItem(row, ICON_SetBedTemp, GET_TEXT_F(MSG_BED));
               drawFloat(ui.material_preset[index].bed_temp, row, false, 1);
             }
             else
               modifyValue(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case PREHEAT_SUBMENU_FAN:
             if (draw) {
-              drawMenuItem(row, ICON_FanSpeed, F("Fan"));
+              drawMenuItem(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
               drawFloat(ui.material_preset[index].fan_speed, row, false, 1);
             }
             else
               modifyValue(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
       }
     };
 
   #endif
@@ -1060,44 +1060,45 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
       #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ANY(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define PREPARE_CUSTOM_MENU (PREPARE_CHANGEFIL + ENABLED(HAS_CUSTOM_MENU))
-      #define PREPARE_TOTAL PREPARE_CUSTOM_MENU
+      #define PREPARE_FWRETRACT (PREPARE_CUSTOM_MENU + ENABLED(FWRETRACT))
+      #define PREPARE_TOTAL PREPARE_FWRETRACT
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMainMenu(1);
           break;
         case PREPARE_MOVE:
           if (draw)
-            drawMenuItem(row, ICON_Axis, F("Move"), nullptr, true);
+            drawMenuItem(row, ICON_Axis, GET_TEXT_F(MSG_MOVE_AXIS), nullptr, true);
           else
             drawMenu(ID_Move);
           break;
         case PREPARE_DISABLE:
           if (draw)
-            drawMenuItem(row, ICON_CloseMotor, F("Disable Stepper"));
+            drawMenuItem(row, ICON_CloseMotor, GET_TEXT_F(MSG_DISABLE_STEPPERS));
           else
             queue.inject(F("M84"));
           break;
         case PREPARE_HOME:
           if (draw)
-            drawMenuItem(row, ICON_SetHome, F("Homing"), nullptr, true);
+            drawMenuItem(row, ICON_SetHome, GET_TEXT_F(MSG_HOMING), nullptr, true);
           else
             drawMenu(ID_HomeMenu);
           break;
         case PREPARE_MANUALLEVEL:
           if (draw)
             drawMenuItem(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
           else {
             if (axes_should_home()) {
               popupHandler(Popup_Home);
               gcode.home_all_axes(true);
@@ -1129,21 +1130,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             if (draw)
               drawMenuItem(row, ICON_Temperature, F("Preheat"), nullptr, true);
             else
               drawMenu(ID_Preheat);
             break;
         #endif
 
         #if HAS_HOTEND || HAS_HEATED_BED
           case PREPARE_COOLDOWN:
             if (draw)
-              drawMenuItem(row, ICON_Cool, F("Cooldown"));
+              drawMenuItem(row, ICON_Cool, GET_TEXT_F(MSG_COOLDOWN));
             else
               thermalManager.cooldown();
             break;
         #endif
 
         #if HAS_CUSTOM_MENU
           case PREPARE_CUSTOM_MENU:
             #ifndef CUSTOM_MENU_CONFIG_TITLE
               #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
             #endif
@@ -1174,82 +1175,91 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                     popupHandler(Popup_Heating);
                     thermalManager.wait_for_hotend(0);
                   }
                   popupHandler(Popup_FilChange);
                   gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.degTargetHotend(0)));
                 }
               #endif
             }
             break;
         #endif
+
+        #if ENABLED(FWRETRACT)
+          case PREPARE_FWRETRACT:
+            if (draw)
+              drawMenuItem(row, ICON_SetHome, GET_TEXT_F(MSG_FWRETRACT), nullptr, true);
+            else
+              drawMenu(ID_FWMenu);
+            break;
+        #endif
       }
       break;
 
     case ID_HomeMenu:
 
       #define HOME_BACK  0
       #define HOME_ALL   (HOME_BACK + 1)
       #define HOME_X     (HOME_ALL + 1)
       #define HOME_Y     (HOME_X + 1)
       #define HOME_Z     (HOME_Y + 1)
       #define HOME_SET   (HOME_Z + 1)
       #define HOME_TOTAL HOME_SET
 
       switch (item) {
         case HOME_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Prepare, PREPARE_HOME);
           break;
         case HOME_ALL:
           if (draw)
-            drawMenuItem(row, ICON_Homing, F("Home All"));
+            drawMenuItem(row, ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME));
           else {
             popupHandler(Popup_Home);
             gcode.home_all_axes(true);
             redrawMenu();
           }
           break;
         case HOME_X:
           if (draw)
-            drawMenuItem(row, ICON_MoveX, F("Home X"));
+            drawMenuItem(row, ICON_MoveX, GET_TEXT_F(MSG_AUTO_HOME_X));
           else {
             popupHandler(Popup_Home);
-            gcode.process_subcommands_now(F("G28 X"));
+            gcode.process_subcommands_now(F("G28X"));
             planner.synchronize();
             redrawMenu();
           }
           break;
         case HOME_Y:
           if (draw)
-            drawMenuItem(row, ICON_MoveY, F("Home Y"));
+            drawMenuItem(row, ICON_MoveY, GET_TEXT_F(MSG_AUTO_HOME_X));
           else {
             popupHandler(Popup_Home);
-            gcode.process_subcommands_now(F("G28 Y"));
+            gcode.process_subcommands_now(F("G28Y"));
             planner.synchronize();
             redrawMenu();
           }
           break;
         case HOME_Z:
           if (draw)
-            drawMenuItem(row, ICON_MoveZ, F("Home Z"));
+            drawMenuItem(row, ICON_MoveZ, GET_TEXT_F(MSG_AUTO_HOME_X));
           else {
             popupHandler(Popup_Home);
-            gcode.process_subcommands_now(F("G28 Z"));
+            gcode.process_subcommands_now(F("G28Z"));
             planner.synchronize();
             redrawMenu();
           }
           break;
         case HOME_SET:
           if (draw)
-            drawMenuItem(row, ICON_SetHome, F("Set Home Position"));
+            drawMenuItem(row, ICON_SetHome, F("Set Home Here"));
           else {
             gcode.process_subcommands_now(F("G92X0Y0Z0"));
             audioFeedback();
           }
           break;
       }
       break;
 
     case ID_Move:
 
@@ -1258,58 +1268,58 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define MOVE_Y (MOVE_X + 1)
       #define MOVE_Z (MOVE_Y + 1)
       #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
       #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
       #define MOVE_LIVE (MOVE_P + 1)
       #define MOVE_TOTAL MOVE_LIVE
 
       switch (item) {
         case MOVE_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else {
             #if HAS_BED_PROBE
               probe_deployed = false;
               probe.set_deployed(probe_deployed);
             #endif
             drawMenu(ID_Prepare, PREPARE_MOVE);
           }
           break;
         case MOVE_X:
           if (draw) {
-            drawMenuItem(row, ICON_MoveX, F("Move X"));
+            drawMenuItem(row, ICON_MoveX, GET_TEXT_F(MSG_MOVE_X));
             drawFloat(current_position.x, row, false);
           }
           else
             modifyValue(current_position.x, X_MIN_POS, X_MAX_POS, 10);
           break;
         case MOVE_Y:
           if (draw) {
-            drawMenuItem(row, ICON_MoveY, F("Move Y"));
+            drawMenuItem(row, ICON_MoveY, GET_TEXT_F(MSG_MOVE_Y));
             drawFloat(current_position.y, row);
           }
           else
             modifyValue(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
           break;
         case MOVE_Z:
           if (draw) {
-            drawMenuItem(row, ICON_MoveZ, F("Move Z"));
+            drawMenuItem(row, ICON_MoveZ, GET_TEXT_F(MSG_MOVE_Z));
             drawFloat(current_position.z, row);
           }
           else
             modifyValue(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
           break;
 
         #if HAS_HOTEND
           case MOVE_E:
             if (draw) {
-              drawMenuItem(row, ICON_Extruder, F("Extruder"));
+              drawMenuItem(row, ICON_Extruder, GET_TEXT_F(MSG_MOVE_E));
               current_position.e = 0;
               sync_plan_position();
               drawFloat(current_position.e, row);
             }
             else {
               if (thermalManager.targetTooColdToExtrude(0)) {
                 popupHandler(Popup_ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
@@ -1334,21 +1344,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               probe_deployed ^= true;
               probe.set_deployed(probe_deployed);
               drawCheckbox(row, probe_deployed);
             }
             break;
         #endif
 
         case MOVE_LIVE:
           if (draw) {
-            drawMenuItem(row, ICON_Axis, F("Live Movement"));
+            drawMenuItem(row, ICON_Axis, GET_TEXT_F(MSG_LIVE_MOVE));
             drawCheckbox(row, livemove);
           }
           else {
             livemove ^= true;
             drawCheckbox(row, livemove);
           }
           break;
       }
       break;
     case ID_ManualLevel: {
@@ -1369,21 +1379,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #if HAS_BED_PROBE
         const float probe_x_min = _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x,
                     probe_x_max = _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x,
                     probe_y_min = _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y,
                     probe_y_max = _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y;
       #endif
 
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
             drawMenu(ID_Prepare, PREPARE_MANUALLEVEL);
           }
           break;
 
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
               drawMenuItem(row, ICON_Zoffset, F("Use Probe"));
@@ -1500,21 +1510,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t(corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
-            drawMenuItem(row, ICON_AxisC, F("Center"));
+            drawMenuItem(row, ICON_AxisC, GET_TEXT_F(MSG_TRAM_C));
           else {
             popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_MAX_POS) / 2.0f - probe.offset.x, 3), 'Y', p_float_t((Y_MAX_POS) / 2.0f - probe.offset.y, 3))
                 );
                 planner.synchronize();
                 popupHandler(Popup_ManualProbing);
               #endif
@@ -1548,30 +1558,30 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
         #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
         #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
         #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
         #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
         #define ZOFFSET_TOTAL ZOFFSET_SAVE
 
         switch (item) {
           case ZOFFSET_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else {
               liveadjust = false;
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
               drawMenu(ID_Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
-              drawMenuItem(row, ICON_Homing, F("Home Z Axis"));
+              drawMenuItem(row, ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME_Z));
             else {
               popupHandler(Popup_Home);
               gcode.process_subcommands_now(F("G28Z"));
               popupHandler(Popup_MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 gcode.process_subcommands_now(
                   TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3))
                 );
               #else
@@ -1613,50 +1623,50 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           case ZOFFSET_OFFSET:
             if (draw) {
               drawMenuItem(row, ICON_SetZOffset, F("Z Offset"));
               drawFloat(zoffsetvalue, row, false, 100);
             }
             else
               modifyValue(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case ZOFFSET_UP:
             if (draw)
-              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("+0.01mm Up"));
             else {
               if (zoffsetvalue < MAX_Z_OFFSET) {
                 if (liveadjust) {
                   gcode.process_subcommands_now(F("M290 Z0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue += 0.01;
                 drawFloat(zoffsetvalue, row - 1, false, 100);
               }
             }
             break;
           case ZOFFSET_DOWN:
             if (draw)
-              drawMenuItem(row, ICON_AxisD, F("Microstep Down"));
+              drawMenuItem(row, ICON_AxisD, F("-0.01mm Down"));
             else {
               if (zoffsetvalue > MIN_Z_OFFSET) {
                 if (liveadjust) {
                   gcode.process_subcommands_now(F("M290 Z-0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue -= 0.01;
                 drawFloat(zoffsetvalue, row - 2, false, 100);
               }
             }
             break;
           #if ENABLED(EEPROM_SETTINGS)
             case ZOFFSET_SAVE:
               if (draw)
-                drawMenuItem(row, ICON_WriteEEPROM, F("Save"));
+                drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_BUTTON_SAVE));
               else
                 audioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
 
     #if HAS_PREHEAT
       case ID_Preheat: {
@@ -1670,25 +1680,24 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
 
         auto do_preheat = [](const uint8_t m) {
           thermalManager.cooldown();
           if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
           if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
         };
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Prepare, PREPARE_PREHEAT);
             break;
-
           case PREHEAT_MODE:
             if (draw) {
               drawMenuItem(row, ICON_Homing, F("Preheat Mode"));
               drawOption(preheatmode, preheat_modes, row);
             }
             else
               modifyOption(preheatmode, preheat_modes, 2);
             break;
 
           #define _PREHEAT_CASE(N) \
@@ -1707,21 +1716,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
 
         #define CHANGEFIL_BACK 0
         #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
         #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
         #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
 
         switch (item) {
           case CHANGEFIL_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
               drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
             else {
               if (thermalManager.targetTooColdToExtrude(0))
                 popupHandler(Popup_ETemp);
               else {
@@ -1769,35 +1778,34 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 popupHandler(Popup_FilChange);
                 gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.degTargetHotend(0)));
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
     #if HAS_CUSTOM_MENU
-
       case ID_MenuCustom:
 
         #define CUSTOM_MENU_BACK 0
         #define CUSTOM_MENU_1 1
         #define CUSTOM_MENU_2 2
         #define CUSTOM_MENU_3 3
         #define CUSTOM_MENU_4 4
         #define CUSTOM_MENU_5 5
         #define CUSTOM_MENU_TOTAL CUSTOM_MENU_COUNT
 
         switch (item) {
           case CUSTOM_MENU_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Prepare, PREPARE_CUSTOM_MENU);
             break;
 
           #if CUSTOM_MENU_COUNT >= 1
             case CUSTOM_MENU_1:
               if (draw)
                 drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
               else {
                 popupHandler(Popup_Custom);
@@ -1885,92 +1893,91 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                   audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif // Custom Menu
         }
         break;
-
     #endif // HAS_CUSTOM_MENU
 
     case ID_Control:
 
       #define CONTROL_BACK 0
       #define CONTROL_TEMP (CONTROL_BACK + 1)
       #define CONTROL_MOTION (CONTROL_TEMP + 1)
       #define CONTROL_VISUAL (CONTROL_MOTION + 1)
       #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
       #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
-      #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
-      #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_LOAD (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_RESET (CONTROL_LOAD + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_INFO (CONTROL_RESET + 1)
       #define CONTROL_TOTAL CONTROL_INFO
 
       switch (item) {
         case CONTROL_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMainMenu(2);
           break;
         case CONTROL_TEMP:
           if (draw)
-            drawMenuItem(row, ICON_Temperature, F("Temperature"), nullptr, true);
+            drawMenuItem(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), nullptr, true);
           else
             drawMenu(ID_TempMenu);
           break;
         case CONTROL_MOTION:
           if (draw)
-            drawMenuItem(row, ICON_Motion, F("Motion"), nullptr, true);
+            drawMenuItem(row, ICON_Motion, GET_TEXT_F(MSG_MOTION), nullptr, true);
           else
             drawMenu(ID_Motion);
           break;
         case CONTROL_VISUAL:
           if (draw)
             drawMenuItem(row, ICON_PrintSize, F("Visual"), nullptr, true);
           else
             drawMenu(ID_Visual);
           break;
         case CONTROL_ADVANCED:
           if (draw)
-            drawMenuItem(row, ICON_Version, F("Advanced"), nullptr, true);
+            drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_ADVANCED_SETTINGS), nullptr, true);
           else
             drawMenu(ID_Advanced);
           break;
         #if ENABLED(EEPROM_SETTINGS)
           case CONTROL_SAVE:
             if (draw)
-              drawMenuItem(row, ICON_WriteEEPROM, F("Store Settings"));
+              drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM));
             else
               audioFeedback(settings.save());
             break;
-          case CONTROL_RESTORE:
+          case CONTROL_LOAD:
             if (draw)
-              drawMenuItem(row, ICON_ReadEEPROM, F("Restore Settings"));
+              drawMenuItem(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM));
             else
               audioFeedback(settings.load());
             break;
           case CONTROL_RESET:
             if (draw)
-              drawMenuItem(row, ICON_Temperature, F("Reset to Defaults"));
+              drawMenuItem(row, ICON_Temperature, GET_TEXT_F(MSG_RESTORE_DEFAULTS));
             else {
               settings.reset();
               audioFeedback();
             }
             break;
         #endif
         case CONTROL_INFO:
           if (draw)
-            drawMenuItem(row, ICON_Info, F("Info"));
+            drawMenuItem(row, ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN));
           else
             drawMenu(ID_Info);
           break;
       }
       break;
 
     case ID_TempMenu:
 
       #define TEMP_BACK 0
       #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
@@ -1981,48 +1988,48 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define TEMP_PREHEAT1 (TEMP_MPC + (PREHEAT_COUNT >= 1))
       #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
       #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
       #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
       #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
       #define TEMP_TOTAL TEMP_PREHEAT5
 
       switch (item) {
         case TEMP_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Control, CONTROL_TEMP);
           break;
         #if HAS_HOTEND
           case TEMP_HOTEND:
             if (draw) {
-              drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
+              drawMenuItem(row, ICON_SetEndTemp, GET_TEXT_F(MSG_NOZZLE));
               drawFloat(thermalManager.degTargetHotend(0), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
         #if HAS_HEATED_BED
           case TEMP_BED:
             if (draw) {
-              drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
+              drawMenuItem(row, ICON_SetBedTemp, GET_TEXT_F(MSG_BED));
               drawFloat(thermalManager.degTargetBed(), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case TEMP_FAN:
             if (draw) {
-              drawMenuItem(row, ICON_FanSpeed, F("Fan"));
+              drawMenuItem(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
               drawFloat(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               modifyValue(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
         #if ANY(PIDTEMP, PIDTEMPBED)
           case TEMP_PID:
             if (draw)
               drawMenuItem(row, ICON_Step, F("PID"), nullptr, true);
@@ -2056,36 +2063,36 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define PID_HOTEND (PID_BACK + ENABLED(PIDTEMP))
         #define PID_BED (PID_HOTEND + ENABLED(PIDTEMPBED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
         switch (item) {
           case PID_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_TempMenu, TEMP_PID);
             break;
           #if ENABLED(PIDTEMP)
             case PID_HOTEND:
               if (draw)
-                drawMenuItem(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
+                drawMenuItem(row, ICON_HotendTemp, GET_TEXT_F(MSG_NOZZLE), nullptr, true);
               else
                 drawMenu(ID_HotendPID);
               break;
           #endif
           #if ENABLED(PIDTEMPBED)
             case PID_BED:
               if (draw)
-                drawMenuItem(row, ICON_BedTemp, F("Bed"), nullptr, true);
+                drawMenuItem(row, ICON_BedTemp, GET_TEXT_F(MSG_BED), nullptr, true);
               else
                 drawMenu(ID_BedPID);
               break;
           #endif
           case PID_CYCLES:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Cycles"));
               drawFloat(PID_cycles, row, false, 1);
             }
             else
@@ -2104,61 +2111,61 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
         #define HOTENDPID_KI (HOTENDPID_KP + 1)
         #define HOTENDPID_KD (HOTENDPID_KI + 1)
         #define HOTENDPID_TOTAL HOTENDPID_KD
 
         static uint16_t PID_e_temp = 180;
 
         switch (item) {
           case HOTENDPID_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
-              drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
+              drawMenuItem(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
             else {
               popupHandler(Popup_PIDWait);
               gcode.process_subcommands_now(TS(F("M303E0C"), PID_cycles, 'S', PID_e_temp, 'U'));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
-              drawMenuItem(row, ICON_Temperature, F("Temperature"));
+              drawMenuItem(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE));
               drawFloat(PID_e_temp, row, false, 1);
             }
             else
               modifyValue(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
           case HOTENDPID_KP:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("Kp Value"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_PID_P));
               drawFloat(thermalManager.temp_hotend[0].pid.p(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KI:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("Ki Value"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_PID_I));
               drawFloat(thermalManager.temp_hotend[0].pid.i(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KD:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("Kd Value"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_PID_D));
               drawFloat(thermalManager.temp_hotend[0].pid.d(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // PIDTEMP
 
     #if ENABLED(PIDTEMPBED)
@@ -2170,61 +2177,61 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define BEDPID_KP (BEDPID_TEMP + 1)
         #define BEDPID_KI (BEDPID_KP + 1)
         #define BEDPID_KD (BEDPID_KI + 1)
         #define BEDPID_TOTAL BEDPID_KD
 
         static uint16_t PID_bed_temp = 60;
 
         switch (item) {
           case BEDPID_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
-              drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
+              drawMenuItem(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
             else {
               popupHandler(Popup_PIDWait);
               gcode.process_subcommands_now(TS(F("M303E-1C"), PID_cycles, 'S', PID_bed_temp, 'U'));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
-              drawMenuItem(row, ICON_Temperature, F("Temperature"));
+              drawMenuItem(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE));
               drawFloat(PID_bed_temp, row, false, 1);
             }
             else
               modifyValue(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
           case BEDPID_KP:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("Kp Value"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_PID_P));
               drawFloat(thermalManager.temp_bed.pid.p(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
           case BEDPID_KI:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("Ki Value"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_PID_I));
               drawFloat(thermalManager.temp_bed.pid.i(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
           case BEDPID_KD:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("Kd Value"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_PID_D));
               drawFloat(thermalManager.temp_bed.pid.d(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
         }
         break;
     #endif // PIDTEMPBED
 
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
@@ -2235,79 +2242,79 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define MPCMENU_HEATER_POWER (MPCMENU_AUTOTUNE + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_BLOCK_HEAT_CAPACITY (MPCMENU_HEATER_POWER + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_SENSOR_RESPONSIVENESS (MPCMENU_BLOCK_HEAT_CAPACITY + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_AMBIENT_XFER_COEFF (MPCMENU_SENSOR_RESPONSIVENESS + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_AMBIENT_XFER_COEFF_FAN (MPCMENU_AMBIENT_XFER_COEFF + ALL(MPC_EDIT_MENU, MPC_INCLUDE_FAN))
         #define MPCMENU_TOTAL MPCMENU_AMBIENT_XFER_COEFF_FAN
 
         switch (item) {
           case MPCMENU_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_TempMenu, TEMP_MPC);
             break;
 
           #if ENABLED(MPC_AUTOTUNE_MENU)
             case MPCMENU_AUTOTUNE:
               if (draw)
-                drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
+                drawMenuItem(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
               else {
                 popupHandler(Popup_MPCWait);
                 thermalManager.MPC_autotune(active_extruder, Temperature::MPCTuningType::AUTO);
                 redrawMenu();
               }
               break;
           #endif
 
           #if ENABLED(MPC_EDIT_MENU)
             case MPCMENU_HEATER_POWER:
               if (draw) {
-                drawMenuItem(row, ICON_Version, F("Heater Power"));
+                drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_MPC_POWER));
                 drawFloat(thermalManager.temp_hotend[0].mpc.heater_power, row, false, 1);
               }
               else
                 modifyValue(thermalManager.temp_hotend[0].mpc.heater_power, 1, 200, 1);
               break;
 
             case MPCMENU_BLOCK_HEAT_CAPACITY:
               if (draw) {
-                drawMenuItem(row, ICON_Version, F("Block Heat Cap."));
+                drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_MPC_BLOCK_HEAT_CAPACITY));
                 drawFloat(thermalManager.temp_hotend[0].mpc.block_heat_capacity, row, false, 100);
               }
               else
                 modifyValue(thermalManager.temp_hotend[0].mpc.block_heat_capacity, 0, 40, 100);
               break;
 
             case MPCMENU_SENSOR_RESPONSIVENESS:
               if (draw) {
-                drawMenuItem(row, ICON_Version, F("Sensor Resp."));
+                drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_SENSOR_RESPONSIVENESS));
                 drawFloat(thermalManager.temp_hotend[0].mpc.sensor_responsiveness, row, false, 10000);
               }
               else
                 modifyValue(thermalManager.temp_hotend[0].mpc.sensor_responsiveness, 0, 1, 10000);
               break;
 
             case MPCMENU_AMBIENT_XFER_COEFF:
               if (draw) {
-                drawMenuItem(row, ICON_Version, F("Amb. xfer coeff"));
+                drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_MPC_AMBIENT_XFER_COEFF));
                 drawFloat(thermalManager.temp_hotend[0].mpc.ambient_xfer_coeff_fan0, row, false, 10000);
               }
               else
                 modifyValue(thermalManager.temp_hotend[0].mpc.ambient_xfer_coeff_fan0, 0, 1, 10000);
               break;
 
             #if ENABLED(MPC_INCLUDE_FAN)
               case MPCMENU_AMBIENT_XFER_COEFF_FAN: {
                 static float fan255_adjustment;
                 if (draw) {
-                  drawMenuItem(row, ICON_Version, F("Amb. xfer adj."));
+                  drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_MPC_AMBIENT_XFER_COEFF_FAN));
                   fan255_adjustment = thermalManager.temp_hotend[0].fanCoefficient();
                   drawFloat(fan255_adjustment, row, false, 10000);
                 }
                 else
                   modifyValue(fan255_adjustment, 0, 1, 10000, []{ thermalManager.temp_hotend[0].applyFanAdjustment(fan255_adjustment); });
               } break;
             #endif
 
           #endif // MPC_EDIT_MENU
         }
@@ -2322,330 +2329,347 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
 
     case ID_Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
       #define MOTION_STEPS (MOTION_JERK + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
-      #define MOTION_TOTAL MOTION_FLOW
+      #define MOTION_LA (MOTION_FLOW + ENABLED(LIN_ADVANCE))
+      #define MOTION_TOTAL MOTION_LA
 
       switch (item) {
         case MOTION_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Control, CONTROL_MOTION);
           break;
         case MOTION_HOMEOFFSETS:
           if (draw)
-            drawMenuItem(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
+            drawMenuItem(row, ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS), nullptr, true);
           else
             drawMenu(ID_HomeOffsets);
           break;
         case MOTION_SPEED:
           if (draw)
-            drawMenuItem(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
+            drawMenuItem(row, ICON_MaxSpeed, GET_TEXT_F(MSG_MAX_SPEED), nullptr, true);
           else
             drawMenu(ID_MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
-            drawMenuItem(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
+            drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ACCELERATION), nullptr, true);
           else
             drawMenu(ID_MaxAcceleration);
           break;
         #if HAS_CLASSIC_JERK
           case MOTION_JERK:
             if (draw)
-              drawMenuItem(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
+              drawMenuItem(row, ICON_MaxJerk, GET_TEXT_F(MSG_JERK), nullptr, true);
             else
               drawMenu(ID_MaxJerk);
             break;
         #endif
         case MOTION_STEPS:
           if (draw)
-            drawMenuItem(row, ICON_Step, F("Steps/mm"), nullptr, true);
+            drawMenuItem(row, ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), nullptr, true);
           else
             drawMenu(ID_Steps);
           break;
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
-              drawMenuItem(row, ICON_Speed, F("Flow Rate"));
+              drawMenuItem(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
               drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
               modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
         #endif
+        #if ENABLED(LIN_ADVANCE)
+          case MOTION_LA:
+            if (draw) {
+              drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K));
+              drawFloat(planner.extruder_advance_K[0], row, false, 100);
+            }
+            else
+              modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
+            break;
+        #endif
       }
       break;
 
     case ID_HomeOffsets:
 
       #define HOMEOFFSETS_BACK 0
       #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
       #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
       #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
 
       switch (item) {
         case HOMEOFFSETS_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Motion, MOTION_HOMEOFFSETS);
           break;
         case HOMEOFFSETS_XOFFSET:
           if (draw) {
-            drawMenuItem(row, ICON_StepX, F("X Offset"));
+            drawMenuItem(row, ICON_StepX, GET_TEXT_F(MSG_HOME_OFFSET_X));
             drawFloat(home_offset.x, row, false, 100);
           }
           else
             modifyValue(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
         case HOMEOFFSETS_YOFFSET:
           if (draw) {
-            drawMenuItem(row, ICON_StepY, F("Y Offset"));
+            drawMenuItem(row, ICON_StepY, GET_TEXT_F(MSG_HOME_OFFSET_Y));
             drawFloat(home_offset.y, row, false, 100);
           }
           else
             modifyValue(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
       }
       break;
     case ID_MaxSpeed:
 
       #define SPEED_BACK 0
       #define SPEED_X (SPEED_BACK + 1)
       #define SPEED_Y (SPEED_X + 1)
       #define SPEED_Z (SPEED_Y + 1)
       #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
       #define SPEED_TOTAL SPEED_E
 
       switch (item) {
         case SPEED_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Motion, MOTION_SPEED);
           break;
         #if HAS_X_AXIS
           case SPEED_X:
             if (draw) {
-              drawMenuItem(row, ICON_MaxSpeedX, F("X Axis"));
+              drawMenuItem(row, ICON_MaxSpeedX, GET_TEXT_F(MSG_VMAX_A));
               drawFloat(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
               modifyValue(planner.settings.max_feedrate_mm_s[X_AXIS], min_feedrate_edit_values.x, max_feedrate_edit_values.x, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_Y_AXIS
           case SPEED_Y:
             if (draw) {
-              drawMenuItem(row, ICON_MaxSpeedY, F("Y Axis"));
+              drawMenuItem(row, ICON_MaxSpeedY, GET_TEXT_F(MSG_VMAX_B));
               drawFloat(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
               modifyValue(planner.settings.max_feedrate_mm_s[Y_AXIS], min_feedrate_edit_values.y, max_feedrate_edit_values.y, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_Z_AXIS
           case SPEED_Z:
             if (draw) {
-              drawMenuItem(row, ICON_MaxSpeedZ, F("Z Axis"));
+              drawMenuItem(row, ICON_MaxSpeedZ, GET_TEXT_F(MSG_VMAX_C));
               drawFloat(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
               modifyValue(planner.settings.max_feedrate_mm_s[Z_AXIS], min_feedrate_edit_values.z, max_feedrate_edit_values.z, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_HOTEND
           case SPEED_E:
             if (draw) {
-              drawMenuItem(row, ICON_MaxSpeedE, F("Extruder"));
+              drawMenuItem(row, ICON_MaxSpeedE, GET_TEXT_F(MSG_VMAX_E));
               drawFloat(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
               modifyValue(planner.settings.max_feedrate_mm_s[E_AXIS], min_feedrate_edit_values.e, max_feedrate_edit_values.e, FEEDRATE_UNIT);
             break;
         #endif
       }
       break;
 
     case ID_MaxAcceleration:
 
       #define ACCEL_BACK 0
-      #define ACCEL_X (ACCEL_BACK + 1)
-      #define ACCEL_Y (ACCEL_X + 1)
-      #define ACCEL_Z (ACCEL_Y + 1)
+      #define ACCEL_X (ACCEL_BACK + ENABLED(HAS_X_AXIS))
+      #define ACCEL_Y (ACCEL_X + ENABLED(HAS_Y_AXIS))
+      #define ACCEL_Z (ACCEL_Y + ENABLED(HAS_Z_AXIS))
       #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
       #define ACCEL_TOTAL ACCEL_E
 
       switch (item) {
         case ACCEL_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Motion, MOTION_ACCEL);
           break;
-        case ACCEL_X:
-          if (draw) {
-            drawMenuItem(row, ICON_MaxAccX, F("X Axis"));
-            drawFloat(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, ACCELERATION_UNIT);
-          }
-          else
-            modifyValue(planner.settings.max_acceleration_mm_per_s2[X_AXIS], min_acceleration_edit_values.x, max_acceleration_edit_values.x, ACCELERATION_UNIT);
-          break;
-        case ACCEL_Y:
-          if (draw) {
-            drawMenuItem(row, ICON_MaxAccY, F("Y Axis"));
-            drawFloat(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, ACCELERATION_UNIT);
-          }
-          else
-            modifyValue(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], min_acceleration_edit_values.y, max_acceleration_edit_values.y, ACCELERATION_UNIT);
-          break;
-        case ACCEL_Z:
-          if (draw) {
-            drawMenuItem(row, ICON_MaxAccZ, F("Z Axis"));
-            drawFloat(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, ACCELERATION_UNIT);
-          }
-          else
-            modifyValue(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], min_acceleration_edit_values.z, max_acceleration_edit_values.z, ACCELERATION_UNIT);
-          break;
+        #if HAS_X_AXIS
+          case ACCEL_X:
+            if (draw) {
+              drawMenuItem(row, ICON_MaxAccX, GET_TEXT_F(MSG_AMAX_A));
+              drawFloat(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, ACCELERATION_UNIT);
+            }
+            else
+              modifyValue(planner.settings.max_acceleration_mm_per_s2[X_AXIS], min_acceleration_edit_values.x, max_acceleration_edit_values.x, ACCELERATION_UNIT);
+            break;
+        #endif
+        #if HAS_Y_AXIS
+          case ACCEL_Y:
+            if (draw) {
+              drawMenuItem(row, ICON_MaxAccY, GET_TEXT_F(MSG_AMAX_B));
+              drawFloat(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, ACCELERATION_UNIT);
+            }
+            else
+              modifyValue(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], min_acceleration_edit_values.y, max_acceleration_edit_values.y, ACCELERATION_UNIT);
+            break;
+        #endif
+        #if HAS_Z_AXIS
+          case ACCEL_Z:
+            if (draw) {
+              drawMenuItem(row, ICON_MaxAccZ, GET_TEXT_F(MSG_AMAX_C));
+              drawFloat(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, ACCELERATION_UNIT);
+            }
+            else
+              modifyValue(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], min_acceleration_edit_values.z, max_acceleration_edit_values.z, ACCELERATION_UNIT);
+            break;
+        #endif
         #if HAS_HOTEND
           case ACCEL_E:
             if (draw) {
-              drawMenuItem(row, ICON_MaxAccE, F("Extruder"));
+              drawMenuItem(row, ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E));
               drawFloat(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, ACCELERATION_UNIT);
             }
             else
               modifyValue(planner.settings.max_acceleration_mm_per_s2[E_AXIS], min_acceleration_edit_values.e, max_acceleration_edit_values.e, ACCELERATION_UNIT);
             break;
         #endif
       }
       break;
     #if HAS_CLASSIC_JERK
       case ID_MaxJerk:
 
         #define JERK_BACK 0
-        #define JERK_X (JERK_BACK + 1)
-        #define JERK_Y (JERK_X + 1)
-        #define JERK_Z (JERK_Y + 1)
+        #define JERK_X (JERK_BACK + ENABLED(HAS_X_AXIS))
+        #define JERK_Y (JERK_X + ENABLED(HAS_Y_AXIS))
+        #define JERK_Z (JERK_Y + ENABLED(HAS_Z_AXIS))
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
           case JERK_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Motion, MOTION_JERK);
             break;
           #if HAS_X_AXIS
             case JERK_X:
               if (draw) {
-                drawMenuItem(row, ICON_MaxSpeedJerkX, F("X Axis"));
+                drawMenuItem(row, ICON_MaxSpeedJerkX, GET_TEXT_F(MSG_VA_JERK));
                 drawFloat(planner.max_jerk.x, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.x, min_jerk_edit_values.x, max_jerk_edit_values.x, JERK_UNIT);
               break;
           #endif
           #if HAS_Y_AXIS
             case JERK_Y:
               if (draw) {
-                drawMenuItem(row, ICON_MaxSpeedJerkY, F("Y Axis"));
+                drawMenuItem(row, ICON_MaxSpeedJerkY, GET_TEXT_F(MSG_VB_JERK));
                 drawFloat(planner.max_jerk.y, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.y, min_jerk_edit_values.y, max_jerk_edit_values.y, JERK_UNIT);
               break;
           #endif
           #if HAS_Z_AXIS
             case JERK_Z:
               if (draw) {
-                drawMenuItem(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
+                drawMenuItem(row, ICON_MaxSpeedJerkZ, GET_TEXT_F(MSG_VC_JERK));
                 drawFloat(planner.max_jerk.z, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.z, min_jerk_edit_values.z, max_jerk_edit_values.z, JERK_UNIT);
               break;
           #endif
           #if HAS_HOTEND
             case JERK_E:
               if (draw) {
-                drawMenuItem(row, ICON_MaxSpeedJerkE, F("Extruder"));
+                drawMenuItem(row, ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK));
                 drawFloat(planner.max_jerk.e, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.e, min_jerk_edit_values.e, max_jerk_edit_values.e, JERK_UNIT);
               break;
           #endif
         }
         break;
     #endif
     case ID_Steps:
 
       #define STEPS_BACK 0
-      #define STEPS_X (STEPS_BACK + 1)
-      #define STEPS_Y (STEPS_X + 1)
-      #define STEPS_Z (STEPS_Y + 1)
+      #define STEPS_X (STEPS_BACK + ENABLED(HAS_X_AXIS))
+      #define STEPS_Y (STEPS_X + ENABLED(HAS_Y_AXIS))
+      #define STEPS_Z (STEPS_Y + ENABLED(HAS_Z_AXIS))
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Motion, MOTION_STEPS);
           break;
         #if HAS_X_AXIS
           case STEPS_X:
             if (draw) {
-              drawMenuItem(row, ICON_StepX, F("X Axis"));
+              drawMenuItem(row, ICON_StepX, GET_TEXT_F(MSG_A_STEPS));
               drawFloat(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
             }
             else
               modifyValue(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
             break;
         #endif
         #if HAS_Y_AXIS
           case STEPS_Y:
             if (draw) {
-              drawMenuItem(row, ICON_StepY, F("Y Axis"));
+              drawMenuItem(row, ICON_StepY, GET_TEXT_F(MSG_B_STEPS));
               drawFloat(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, STEPS_UNIT);
             }
             else
               modifyValue(planner.settings.axis_steps_per_mm[Y_AXIS], min_steps_edit_values.y, max_steps_edit_values.y, STEPS_UNIT);
             break;
         #endif
         #if HAS_Z_AXIS
           case STEPS_Z:
             if (draw) {
-              drawMenuItem(row, ICON_StepZ, F("Z Axis"));
+              drawMenuItem(row, ICON_StepZ, GET_TEXT_F(MSG_C_STEPS));
               drawFloat(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, STEPS_UNIT);
             }
             else
               modifyValue(planner.settings.axis_steps_per_mm[Z_AXIS], min_steps_edit_values.z, max_steps_edit_values.z, STEPS_UNIT);
             break;
         #endif
         #if HAS_HOTEND
           case STEPS_E:
             if (draw) {
-              drawMenuItem(row, ICON_StepE, F("Extruder"));
+              drawMenuItem(row, ICON_StepE, GET_TEXT_F(MSG_E_STEPS));
               drawFloat(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
             }
             else
               modifyValue(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
             break;
         #endif
       }
       break;
 
     case ID_Visual:
@@ -2653,33 +2677,33 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
       #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
       #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
       #define VISUAL_TOTAL VISUAL_COLOR_THEMES
 
       switch (item) {
         case VISUAL_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Control, CONTROL_VISUAL);
           break;
         case VISUAL_BACKLIGHT:
           if (draw)
-            drawMenuItem(row, ICON_Brightness, F("Display Off"));
+            drawMenuItem(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF));
           else
             ui.set_brightness(0);
           break;
         case VISUAL_BRIGHTNESS:
           if (draw) {
-            drawMenuItem(row, ICON_Brightness, F("LCD Brightness"));
+            drawMenuItem(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS));
             drawFloat(ui.brightness, row, false, 1);
           }
           else
             modifyValue(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
         case VISUAL_TIME_FORMAT:
           if (draw) {
             drawMenuItem(row, ICON_PrintTime, F("Progress as __h__m"));
             drawCheckbox(row, eeprom_settings.time_format_textual);
           }
@@ -2709,21 +2733,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
       #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
 
       switch (item) {
         case COLORSETTINGS_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Visual, VISUAL_COLOR_THEMES);
           break;
         case COLORSETTINGS_CURSOR:
           if (draw) {
             drawMenuItem(row, ICON_MaxSpeed, F("Cursor"));
             drawOption(eeprom_settings.cursor_color, color_names, row, false, true);
           }
           else
             modifyOption(eeprom_settings.cursor_color, color_names, Custom_Colors);
@@ -2823,29 +2847,29 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
       #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
 
       switch (item) {
         case ADVANCED_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawMenu(ID_Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
-              drawMenuItem(row, ICON_Version, F("LCD Beeper"));
+              drawMenuItem(row, ICON_Version, GET_TEXT_F(MSG_SOUND));
               drawCheckbox(row, ui.sound_on);
             }
             else {
               ui.sound_on ^= true;
               drawCheckbox(row, ui.sound_on);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
@@ -2871,21 +2895,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawMenuItem(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
             drawFloat(corner_pos, row, false, 10);
           }
           else
             modifyValue(corner_pos, 1, 100, 10);
           break;
 
         #if ENABLED(LIN_ADVANCE)
           case ADVANCED_LA:
             if (draw) {
-              drawMenuItem(row, ICON_MaxAccelerated, F("Lin Advance K"));
+              drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K));
               drawFloat(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case ADVANCED_LOAD:
             if (draw) {
@@ -2914,45 +2938,45 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               modifyValue(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
               thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case ADVANCED_FILSENSORENABLED:
             if (draw) {
-              drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
+              drawMenuItem(row, ICON_Extruder, GET_TEXT_F(MSG_RUNOUT_SENSOR));
               drawCheckbox(row, runout.enabled);
             }
             else {
               runout.enabled ^= true;
               drawCheckbox(row, runout.enabled);
             }
             break;
 
           #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
             case ADVANCED_FILSENSORDISTANCE:
               if (draw) {
-                drawMenuItem(row, ICON_MaxAccE, F("Runout Distance"));
+                drawMenuItem(row, ICON_MaxAccE, GET_TEXT_F(MSG_RUNOUT_DISTANCE_MM));
                 drawFloat(runout.runout_distance(), row, false, 10);
               }
               else
                 modifyValue(runout.runout_distance(), 0, 999, 10);
               break;
           #endif
         #endif // FILAMENT_RUNOUT_SENSOR
 
         #if ENABLED(POWER_LOSS_RECOVERY)
           case ADVANCED_POWER_LOSS:
             if (draw) {
-              drawMenuItem(row, ICON_Motion, F("Power-loss recovery"));
+              drawMenuItem(row, ICON_Motion, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
               drawCheckbox(row, recovery.enabled);
             }
             else {
               recovery.enable(!recovery.enabled);
               drawCheckbox(row, recovery.enabled);
             }
             break;
         #endif
       }
       break;
@@ -2965,21 +2989,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
         #define PROBE_TEST (PROBE_YOFFSET + 1)
         #define PROBE_TEST_COUNT (PROBE_TEST + 1)
         #define PROBE_TOTAL PROBE_TEST_COUNT
 
         static uint8_t testcount = 4;
 
         switch (item) {
           case PROBE_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Advanced, ADVANCED_PROBE);
             break;
 
             case PROBE_XOFFSET:
               if (draw) {
                 drawMenuItem(row, ICON_StepX, F("Probe X Offset"));
                 drawFloat(probe.offset.x, row, false, 10);
               }
               else
@@ -3021,74 +3045,74 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define TMC_STEPPER_CURRENT_X (TMC_BACK + AXIS_IS_TMC(X))
         #define TMC_STEPPER_CURRENT_Y (TMC_STEPPER_CURRENT_X + AXIS_IS_TMC(Y))
         #define TMC_STEPPER_CURRENT_Z (TMC_STEPPER_CURRENT_Y + AXIS_IS_TMC(Z))
         #define TMC_STEPPER_CURRENT_E (TMC_STEPPER_CURRENT_Z + AXIS_IS_TMC(E0))
         #define TMC_TOTAL TMC_STEPPER_CURRENT_E
 
         switch (item) {
 
           case TMC_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Advanced, ADVANCED_TMC);
             break;
 
           #if AXIS_IS_TMC(X)
             case TMC_STEPPER_CURRENT_X:
 
               static float stepper_current_x;
 
               if (draw) {
-                drawMenuItem(row, ICON_StepX, F("Stepper X current"));
+                drawMenuItem(row, ICON_StepX, GET_TEXT_F(MSG_TMC_ACURRENT));
                 stepper_current_x = stepperX.getMilliamps();
                 drawFloat(stepper_current_x, row, false, 1);
               }
               else {
                 modifyValue(stepper_current_x, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperX.rms_current(stepper_current_x); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(Y)
             case TMC_STEPPER_CURRENT_Y:
               static float stepper_current_y;
               if (draw) {
-                drawMenuItem(row, ICON_StepY, F("Stepper Y current"));
+                drawMenuItem(row, ICON_StepY, GET_TEXT_F(MSG_TMC_BCURRENT));
                 stepper_current_y = stepperY.getMilliamps();
                 drawFloat(stepper_current_y, row, false, 1);
               }
               else {
                 modifyValue(stepper_current_y, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperY.rms_current(stepper_current_y); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(Z)
             case TMC_STEPPER_CURRENT_Z:
               static float stepper_current_z;
               if (draw) {
-                drawMenuItem(row, ICON_StepZ, F("Stepper Z current"));
+                drawMenuItem(row, ICON_StepZ, GET_TEXT_F(MSG_TMC_CCURRENT));
                 stepper_current_z = stepperZ.getMilliamps();
                 drawFloat(stepper_current_z, row, false, 1);
               }
               else {
                 modifyValue(stepper_current_z, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperZ.rms_current(stepper_current_z); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(E0)
             case TMC_STEPPER_CURRENT_E:
               static float stepper_current_e;
               if (draw) {
-                drawMenuItem(row, ICON_StepE, F("Stepper E current"));
+                drawMenuItem(row, ICON_StepE, GET_TEXT_F(MSG_TMC_ECURRENT));
                 stepper_current_e = stepperE0.getMilliamps();
                 drawFloat(stepper_current_e, row, false, 1);
               }
               else
                 modifyValue(stepper_current_e, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperE0.rms_current(stepper_current_e); });
               break;
           #endif
         };
         break;
     #endif // HAS_TRINAMIC_CONFIG
@@ -3100,21 +3124,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
       #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
       #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
       #define INFO_SIZE (INFO_PRINTTIME + 1)
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
       #define INFO_TOTAL INFO_BACK
 
       switch (item) {
         case INFO_BACK:
           if (draw) {
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
 
             #if ENABLED(PRINTCOUNTER)
 
               printStatistics ps = print_job_timer.getStats();
               drawMenuItem(INFO_PRINTCOUNT, ICON_HotendTemp,
                 TS(ps.totalPrints, F(" prints, "), ps.finishedPrints, F(" finished")),
                 TS(p_float_t(ps.filamentUsed / 1000, 2), F(" m filament used")),
                 false, true
               );
 
@@ -3152,57 +3176,53 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define LEVELING_VIEW (LEVELING_MANUAL + 1)
         #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
         #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_TOTAL LEVELING_SAVE
 
         switch (item) {
           case LEVELING_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMainMenu(3);
             break;
           case LEVELING_ACTIVE:
             if (draw) {
-              drawMenuItem(row, ICON_StockConfiguration, F("Leveling Active"));
+              drawMenuItem(row, ICON_StockConfiguration, GET_TEXT_F(MSG_BED_LEVELING));
               drawCheckbox(row, planner.leveling_active);
             }
             else {
               if (!planner.leveling_active) {
                 set_bed_leveling_enabled(!planner.leveling_active);
                 if (!planner.leveling_active) {
                   confirmHandler(Popup_LevelError);
                   break;
                 }
               }
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
               drawCheckbox(row, planner.leveling_active);
             }
             break;
           #if ALL(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
-                drawMenuItem(row, ICON_Tilt, F("Autotilt Current Mesh"));
+                drawMenuItem(row, ICON_Tilt, GET_TEXT_F(MSG_UBL_TILT_MESH));
               else {
-                if (bedlevel.storage_slot < 0) {
-                  popupHandler(Popup_MeshSlot);
-                  break;
-                }
+                if (bedlevel.storage_slot < 0) { popupHandler(Popup_MeshSlot); break; }
                 popupHandler(Popup_Home);
                 gcode.home_all_axes(true);
                 popupHandler(Popup_Level);
-                if (mesh_conf.tilt_grid > 1) {
+                if (mesh_conf.tilt_grid > 1)
                   gcode.process_subcommands_now(TS(F("G29J"), mesh_conf.tilt_grid));
-                }
                 else
                   gcode.process_subcommands_now(F("G29J"));
                 planner.synchronize();
                 redrawMenu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
               drawMenuItem(row, ICON_Mesh, F("Create New Mesh"));
@@ -3300,70 +3320,70 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenu(ID_LevelView);
             }
             break;
           case LEVELING_SETTINGS:
             if (draw)
               drawMenuItem(row, ICON_Step, F("Leveling Settings"), nullptr, true);
             else
               drawMenu(ID_LevelSettings);
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
-          case LEVELING_SLOT:
-            if (draw) {
-              drawMenuItem(row, ICON_PrintSize, F("Mesh Slot"));
-              drawFloat(bedlevel.storage_slot, row, false, 1);
-            }
-            else
-              modifyValue(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
-            break;
-          case LEVELING_LOAD:
-            if (draw)
-              drawMenuItem(row, ICON_ReadEEPROM, F("Load Mesh"));
-            else {
-              if (bedlevel.storage_slot < 0) {
-                popupHandler(Popup_MeshSlot);
-                break;
+            case LEVELING_SLOT:
+              if (draw) {
+                drawMenuItem(row, ICON_PrintSize, GET_TEXT_F(MSG_UBL_STORAGE_SLOT));
+                drawFloat(bedlevel.storage_slot, row, false, 1);
               }
-              gcode.process_subcommands_now(F("G29 L"));
-              planner.synchronize();
-              audioFeedback(true);
-            }
-            break;
-          case LEVELING_SAVE:
-            if (draw)
-              drawMenuItem(row, ICON_WriteEEPROM, F("Save Mesh"));
-            else {
-              if (bedlevel.storage_slot < 0) {
-                popupHandler(Popup_MeshSlot);
-                break;
+              else
+                modifyValue(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
+              break;
+            case LEVELING_LOAD:
+              if (draw)
+                drawMenuItem(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_UBL_LOAD_MESH));
+              else {
+                if (bedlevel.storage_slot < 0) {
+                  popupHandler(Popup_MeshSlot);
+                  break;
+                }
+                gcode.process_subcommands_now(F("G29 L"));
+                planner.synchronize();
+                audioFeedback(true);
               }
-              gcode.process_subcommands_now(F("G29 S"));
-              planner.synchronize();
-              audioFeedback(true);
-            }
-            break;
-          #endif
+              break;
+            case LEVELING_SAVE:
+              if (draw)
+                drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_UBL_SAVE_MESH));
+              else {
+                if (bedlevel.storage_slot < 0) {
+                  popupHandler(Popup_MeshSlot);
+                  break;
+                }
+                gcode.process_subcommands_now(F("G29 S"));
+                planner.synchronize();
+                audioFeedback(true);
+              }
+              break;
+          #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
       case ID_LevelView:
 
         #define LEVELING_VIEW_BACK 0
         #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
         #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
         #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
         #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
               drawMenuItem(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
               drawMenu(ID_MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
@@ -3395,27 +3415,27 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
         #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
 
         switch (item) {
           case LEVELING_SETTINGS_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               drawMenu(ID_Leveling, LEVELING_SETTINGS);
             break;
           case LEVELING_SETTINGS_FADE:
               if (draw) {
-                drawMenuItem(row, ICON_Fade, F("Fade Mesh within"));
+                drawMenuItem(row, ICON_Fade, GET_TEXT_F(MSG_Z_FADE_HEIGHT));
                 drawFloat(planner.z_fade_height, row, false, 1);
               }
               else {
                 modifyValue(planner.z_fade_height, 0, Z_MAX_POS, 1);
                 planner.z_fade_height = -1;
                 set_z_fade_height(planner.z_fade_height);
               }
               break;
 
           #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -3432,41 +3452,41 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawMenuItem(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
               else {
                 if (mesh_conf.createPlaneFromMesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 audioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
-                drawMenuItem(row, ICON_Mesh, F("Zero Current Mesh"));
+                drawMenuItem(row, ICON_Mesh, F("Mesh Zero"));
               else
                 ZERO(bedlevel.z_values);
               break;
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
-                drawMenuItem(row, ICON_Mesh, F("Clear Current Mesh"));
+                drawMenuItem(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_RESET));
               else
                 bedlevel.invalidate();
               break;
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
       case ID_MeshViewer:
         #define MESHVIEW_BACK 0
         #define MESHVIEW_TOTAL MESHVIEW_BACK
 
         if (item == MESHVIEW_BACK) {
           if (draw) {
-            drawMenuItem(0, ICON_Back, F("Back"));
+            drawMenuItem(0, ICON_Back, GET_TEXT_F(MSG_BACK));
             mesh_conf.drawBedMesh();
             mesh_conf.setMeshViewerStatus();
           }
           else if (!mesh_conf.drawing_mesh) {
             drawMenu(ID_LevelView, LEVELING_VIEW_MESH);
             updateStatus("");
           }
         }
         break;
 
@@ -3479,84 +3499,84 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
         #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
         #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else {
               set_bed_leveling_enabled(level_state);
               TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
               drawMenu(ID_Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
-              drawMenuItem(row, ICON_MoveX, F("Mesh Point X"));
+              drawMenuItem(row, ICON_MoveX, GET_TEXT_F(MSG_MESH_X));
               drawFloat(mesh_conf.mesh_x, row, 0, 1);
             }
             else
               modifyValue(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
             break;
           case LEVELING_M_Y:
             if (draw) {
-              drawMenuItem(row, ICON_MoveY, F("Mesh Point Y"));
+              drawMenuItem(row, ICON_MoveY, GET_TEXT_F(MSG_MESH_Y));
               drawFloat(mesh_conf.mesh_y, row, 0, 1);
             }
             else
               modifyValue(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
             break;
           case LEVELING_M_NEXT:
             if (draw)
-              drawMenuItem(row, ICON_More, F("Next Point"));
+              drawMenuItem(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_mesh_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
-              drawMenuItem(row, ICON_SetZOffset, F("Point Z Offset"));
+              drawMenuItem(row, ICON_SetZOffset, GET_TEXT_F(MSG_MESH_EDIT_Z));
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
               modifyValue(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case LEVELING_M_UP:
             if (draw)
-              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("+0.01mm Up"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case LEVELING_M_DOWN:
             if (draw)
-              drawMenuItem(row, ICON_AxisD, F("Microstep Down"));
+              drawMenuItem(row, ICON_AxisD, F("-0.01mm Down"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
@@ -3565,59 +3585,59 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             else {
               mesh_conf.goto_mesh_value ^= true;
               current_position.z = 0;
               mesh_conf.manual_mesh_move(true);
               drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
-          case LEVELING_M_UNDEF:
-            if (draw)
-              drawMenuItem(row, ICON_ResumeEEPROM, F("Clear Point Value"));
-            else {
-              mesh_conf.manualValueUpdate(true);
-              redrawMenu(false);
-            }
-            break;
+            case LEVELING_M_UNDEF:
+              if (draw)
+                drawMenuItem(row, ICON_ResumeEEPROM, F("Clear Point Value"));
+              else {
+                mesh_conf.manualValueUpdate(true);
+                redrawMenu(false);
+              }
+              break;
           #endif
         }
         break;
     #endif // HAS_MESH
 
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case ID_UBLMesh:
 
         #define UBL_M_BACK 0
         #define UBL_M_NEXT (UBL_M_BACK + 1)
         #define UBL_M_PREV (UBL_M_NEXT + 1)
         #define UBL_M_OFFSET (UBL_M_PREV + 1)
         #define UBL_M_UP (UBL_M_OFFSET + 1)
         #define UBL_M_DOWN (UBL_M_UP + 1)
         #define UBL_M_TOTAL UBL_M_DOWN
 
         switch (item) {
           case UBL_M_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else {
               set_bed_leveling_enabled(level_state);
               drawMenu(ID_Leveling, LEVELING_GET_MESH);
             }
             break;
           case UBL_M_NEXT:
             if (draw) {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
-                drawMenuItem(row, ICON_More, F("Next Point"));
+                drawMenuItem(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
               else
-                drawMenuItem(row, ICON_More, F("Save Mesh"));
+                drawMenuItem(row, ICON_More, GET_TEXT_F(MSG_UBL_SAVE_MESH));
             }
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_mesh_move();
@@ -3640,44 +3660,44 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x--;
                 else
                   mesh_conf.mesh_x++;
                 mesh_conf.manual_mesh_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
-              drawMenuItem(row, ICON_SetZOffset, F("Point Z Offset"));
+              drawMenuItem(row, ICON_SetZOffset, GET_TEXT_F(MSG_MESH_EDIT_Z));
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
               modifyValue(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case UBL_M_UP:
             if (draw)
-              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("+0.01mm Up"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case UBL_M_DOWN:
             if (draw)
-              drawMenuItem(row, ICON_Axis, F("Microstep Down"));
+              drawMenuItem(row, ICON_Axis, F("-0.01mm Down"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
@@ -3691,34 +3711,34 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define MMESH_NEXT (MMESH_BACK + 1)
         #define MMESH_OFFSET (MMESH_NEXT + 1)
         #define MMESH_UP (MMESH_OFFSET + 1)
         #define MMESH_DOWN (MMESH_UP + 1)
         #define MMESH_OLD (MMESH_DOWN + 1)
         #define MMESH_TOTAL MMESH_OLD
 
         switch (item) {
           case MMESH_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Cancel"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_CANCEL));
             else {
               gcode.process_subcommands_now(F("G29 A"));
               planner.synchronize();
               set_bed_leveling_enabled(level_state);
               drawMenu(ID_Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_NEXT:
             if (draw) {
               if (gridpoint < GRID_MAX_POINTS)
-                drawMenuItem(row, ICON_More, F("Next Point"));
+                drawMenuItem(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
               else
-                drawMenuItem(row, ICON_More, F("Save Mesh"));
+                drawMenuItem(row, ICON_More, GET_TEXT_F(MSG_UBL_SAVE_MESH));
             }
             else if (gridpoint < GRID_MAX_POINTS) {
               popupHandler(Popup_MoveWait);
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               gridpoint++;
               redrawMenu();
             }
             else {
               gcode.process_subcommands_now(F("G29"));
@@ -3731,32 +3751,32 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             if (draw) {
               drawMenuItem(row, ICON_SetZOffset, F("Z Position"));
               current_position.z = MANUAL_PROBE_START_Z;
               drawFloat(current_position.z, row, false, 100);
             }
             else
               modifyValue(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case MMESH_UP:
             if (draw)
-              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("+0.01mm Up"));
             else if (current_position.z < MAX_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               drawFloat(current_position.z, row - 1, false, 100);
             }
             break;
           case MMESH_DOWN:
             if (draw)
-              drawMenuItem(row, ICON_AxisD, F("Microstep Down"));
+              drawMenuItem(row, ICON_AxisD, F("-0.01mm Down"));
             else if (current_position.z > MIN_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               drawFloat(current_position.z, row - 2, false, 100);
             }
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
@@ -3789,143 +3809,165 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
 
       #define TUNE_BACK 0
       #define TUNE_SPEED (TUNE_BACK + 1)
       #define TUNE_FLOW (TUNE_SPEED + ENABLED(HAS_HOTEND))
       #define TUNE_HOTEND (TUNE_FLOW + ENABLED(HAS_HOTEND))
       #define TUNE_BED (TUNE_HOTEND + ENABLED(HAS_HEATED_BED))
       #define TUNE_FAN (TUNE_BED + ENABLED(HAS_FAN))
       #define TUNE_ZOFFSET (TUNE_FAN + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_ZUP (TUNE_ZOFFSET + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
-      #define TUNE_CHANGEFIL (TUNE_ZDOWN + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
-      #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
+      #define TUNE_LA (TUNE_ZDOWN + ENABLED(LIN_ADVANCE))
+      #define TUNE_CHANGEFIL (TUNE_LA + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
+      #define TUNE_FWRETRACT (TUNE_CHANGEFIL + ENABLED(FWRETRACT))
+      #define TUNE_FILSENSORENABLED (TUNE_FWRETRACT + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
       #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
       #define TUNE_TOTAL TUNE_BACKLIGHT
 
       switch (item) {
         case TUNE_BACK:
           if (draw)
-            drawMenuItem(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             drawPrintScreen();
           break;
         case TUNE_SPEED:
           if (draw) {
-            drawMenuItem(row, ICON_Speed, F("Print Speed"));
+            drawMenuItem(row, ICON_Speed, GET_TEXT_F(MSG_SPEED));
             drawFloat(feedrate_percentage, row, false, 1);
           }
           else
             modifyValue(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
           break;
 
         #if HAS_HOTEND
           case TUNE_FLOW:
             if (draw) {
-              drawMenuItem(row, ICON_Speed, F("Flow Rate"));
+              drawMenuItem(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
               drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
               modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
           case TUNE_HOTEND:
             if (draw) {
-              drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
+              drawMenuItem(row, ICON_SetEndTemp, GET_TEXT_F(MSG_NOZZLE));
               drawFloat(thermalManager.degTargetHotend(0), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
 
         #if HAS_HEATED_BED
           case TUNE_BED:
             if (draw) {
-              drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
+              drawMenuItem(row, ICON_SetBedTemp, GET_TEXT_F(MSG_BED));
               drawFloat(thermalManager.degTargetBed(), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
 
         #if HAS_FAN
           case TUNE_FAN:
             if (draw) {
-              drawMenuItem(row, ICON_FanSpeed, F("Fan"));
+              drawMenuItem(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
               drawFloat(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               modifyValue(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
 
         #if HAS_ZOFFSET_ITEM
           case TUNE_ZOFFSET:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Z-Offset"));
               drawFloat(zoffsetvalue, row, false, 100);
             }
             else
               modifyValue(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case TUNE_ZUP:
             if (draw)
-              drawMenuItem(row, ICON_Axis, F("Z-Offset Up"));
+              drawMenuItem(row, ICON_Axis, F("Z-Offset +0.01mm Up"));
             else if (zoffsetvalue < MAX_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z0.01"));
               zoffsetvalue += 0.01;
               drawFloat(zoffsetvalue, row - 1, false, 100);
             }
             break;
           case TUNE_ZDOWN:
             if (draw)
-              drawMenuItem(row, ICON_AxisD, F("Z-Offset Down"));
+              drawMenuItem(row, ICON_AxisD, F("Z-Offset -0.01mm Down"));
             else if (zoffsetvalue > MIN_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               zoffsetvalue -= 0.01;
               drawFloat(zoffsetvalue, row - 2, false, 100);
             }
             break;
         #endif
 
+        #if ENABLED(LIN_ADVANCE)
+          case TUNE_LA:
+            if (draw) {
+              drawMenuItem(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K));
+              drawFloat(planner.extruder_advance_K[0], row, false, 100);
+            }
+            else
+              modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
+            break;
+        #endif
+
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else
               popupHandler(Popup_ConfFilChange);
             break;
         #endif
 
+        #if ENABLED(FWRETRACT)
+          case TUNE_FWRETRACT:
+            if (draw)
+              drawMenuItem(row, ICON_SetHome, GET_TEXT_F(MSG_FWRETRACT), nullptr, true);
+            else
+              drawMenu(ID_FWMenu);
+            break;
+        #endif
+
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
-              drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
+              drawMenuItem(row, ICON_Extruder, GET_TEXT_F(MSG_RUNOUT_SENSOR));
               drawCheckbox(row, runout.enabled);
             }
             else {
               runout.enabled ^= true;
               drawCheckbox(row, runout.enabled);
             }
             break;
         #endif
 
         case TUNE_BACKLIGHT_OFF:
           if (draw)
-            drawMenuItem(row, ICON_Brightness, F("Display Off"));
+            drawMenuItem(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF));
           else
             ui.set_brightness(0);
           break;
         case TUNE_BACKLIGHT:
           if (draw) {
-            drawMenuItem(row, ICON_Brightness, F("LCD Brightness"));
+            drawMenuItem(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS));
             drawFloat(ui.brightness, row, false, 1);
           }
           else
             modifyValue(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
       }
       break;
 
     #if HAS_PREHEAT && HAS_HOTEND
 
@@ -3937,30 +3979,30 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
         #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
         #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
         #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
         #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
         #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
 
         switch (item) {
           case PREHEATHOTEND_BACK:
             if (draw)
-              drawMenuItem(row, ICON_Back, F("Cancel"));
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_CANCEL));
             else {
               thermalManager.setTargetHotend(0, 0);
               TERN_(HAS_FAN, thermalManager.set_fan_speed(0, 0));
               redrawMenu(false, true, true);
             }
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
-              drawMenuItem(row, ICON_SetEndTemp, F("Continue"));
+              drawMenuItem(row, ICON_SetEndTemp, GET_TEXT_F(MSG_BUTTON_CONTINUE));
             else {
               popupHandler(Popup_Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
                 case ID_Prepare:
                   popupHandler(Popup_FilChange);
                   gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.degTargetHotend(0)));
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   case ID_ChangeFilament:
@@ -3984,41 +4026,105 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                     }
                     break;
                 #endif
                 default:
                   redrawMenu(true, true, true);
                   break;
               }
             }
             break;
 
-
           #define _PREHEAT_HOTEND_CASE(N) \
             case PREHEATHOTEND_##N: \
               if (draw) drawMenuItem(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
               else ui.preheat_hotend_and_fan((N) - 1); \
               break;
 
           REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
 
           case PREHEATHOTEND_CUSTOM:
             if (draw) {
               drawMenuItem(row, ICON_Temperature, F("Custom"));
               drawFloat(thermalManager.degTargetHotend(0), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
+
+    #if ENABLED(FWRETRACT)
+      case ID_FWMenu:
+        #define FWRETRACT_BACK 0
+        #define FWRETRACT_RETLEN (FWRETRACT_BACK + 1)
+        #define FWRETRACT_RETSPD (FWRETRACT_RETLEN + 1)
+        #define FWRETRACT_RETZHOP (FWRETRACT_RETSPD + 1)
+        #define FWRETRACT_RECSPD (FWRETRACT_RETZHOP + 1)
+        #define FWRETRACT_RECLEN (FWRETRACT_RECSPD + 1)
+        #define FWRETRACT_TOTAL (FWRETRACT_RECLEN + 1)
+
+        switch (item) {
+          case FWRETRACT_BACK:
+            if (draw)
+              drawMenuItem(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK));
+            else {
+              if (last_menu == ID_Prepare)
+                drawMenu(ID_Prepare, PREPARE_FWRETRACT);
+              else if (last_menu == ID_Tune)
+                drawMenu(ID_Tune, TUNE_FWRETRACT);
+            }
+            break;
+          case FWRETRACT_RETLEN:
+            if (draw) {
+              drawMenuItem(row, ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT));
+              drawFloat(fwretract.settings.retract_length, row, false, 10);
+            }
+            else
+              modifyValue(fwretract.settings.retract_length, 0, 10, 10);
+            break;
+          case FWRETRACT_RETSPD:
+            if (draw) {
+              drawMenuItem(row, ICON_FWRetLength, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED));
+              drawFloat(fwretract.settings.retract_feedrate_mm_s, row, false, 1);
+            }
+            else
+              modifyValue(fwretract.settings.retract_feedrate_mm_s, 1, 90, 1);
+            break;
+          case FWRETRACT_RETZHOP:
+            if (draw) {
+              drawMenuItem(row, ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP));
+              drawFloat(fwretract.settings.retract_zraise, row, false, 100);
+            }
+            else
+              modifyValue(fwretract.settings.retract_zraise, 0, 2, 100);
+            break;
+          case FWRETRACT_RECSPD:
+            if (draw) {
+              drawMenuItem(row, ICON_FWRetLength, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED));
+              drawFloat(fwretract.settings.retract_recover_feedrate_mm_s, row, false, 1);
+            }
+            else
+              modifyValue(fwretract.settings.retract_recover_feedrate_mm_s, 1, 90, 1);
+            break;
+          case FWRETRACT_RECLEN:
+            if (draw) {
+              drawMenuItem(row, ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT_RECOVER));
+              drawFloat(fwretract.settings.retract_recover_extra, row, false, 10);
+            }
+            else
+              modifyValue(fwretract.settings.retract_recover_extra, -5, 5, 10);
+            break;
+        }
+        break;
+    #endif
   }
 }
 
 FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
   switch (menu) {
     case ID_MainMenu:       return GET_TEXT_F(MSG_MAIN_MENU);
     case ID_Prepare:        return GET_TEXT_F(MSG_PREPARE);
     case ID_HomeMenu:       return F("Homing Menu");
     case ID_Move:           return GET_TEXT_F(MSG_MOVE_AXIS);
     case ID_ManualLevel:    return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
@@ -4032,59 +4138,62 @@ FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
       case ID_ChangeFilament: return GET_TEXT_F(MSG_FILAMENTCHANGE);
     #endif
     #if HAS_CUSTOM_MENU
       case ID_MenuCustom:
         #ifdef CUSTOM_MENU_CONFIG_TITLE
           return F(CUSTOM_MENU_CONFIG_TITLE);
         #else
           return GET_TEXT_F(MSG_CUSTOM_COMMANDS);
         #endif
     #endif
+    #if ENABLED(FWRETRACT)
+      case ID_FWMenu:       return GET_TEXT_F(MSG_FWRETRACT);
+    #endif
     case ID_Control:        return GET_TEXT_F(MSG_CONTROL);
     case ID_TempMenu:       return GET_TEXT_F(MSG_TEMPERATURE);
     #if ANY(PIDTEMP, PIDTEMPBED)
       case ID_PID:          return F("PID Menu");
     #endif
     #if ENABLED(PIDTEMP)
       case ID_HotendPID:    return F("Hotend PID Settings");
     #endif
     #if ENABLED(PIDTEMPBED)
       case ID_BedPID:       return F("Bed PID Settings");
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
       case ID_MPC:          return F("MPC Menu");
     #endif
     #if HAS_PREHEAT
       #define _PREHEAT_TITLE_CASE(N) case ID_Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
-    case ID_Motion:         return F("Motion Settings");
-    case ID_HomeOffsets:    return F("Home Offsets");
-    case ID_MaxSpeed:       return F("Max Speed");
+    case ID_Motion:         return GET_TEXT_F(MSG_MOTION);
+    case ID_HomeOffsets:    return GET_TEXT_F(MSG_SET_HOME_OFFSETS);
+    case ID_MaxSpeed:       return GET_TEXT_F(MSG_MAX_SPEED);
     case ID_MaxAcceleration: return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
       case ID_MaxJerk:      return F("Max Jerk");
     #endif
     case ID_Steps:          return GET_TEXT_F(MSG_STEPS_PER_MM);
     case ID_Visual:         return F("Visual Settings");
     case ID_Advanced:       return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
     #if HAS_BED_PROBE
       case ID_ProbeMenu:    return F("Bed Probe");
     #endif
     #if HAS_TRINAMIC_CONFIG
       case ID_TMCMenu:      return GET_TEXT_F(MSG_TMC_DRIVERS);
     #endif
     case ID_ColorSettings:  return F("UI Color Settings");
-    case ID_Info:           return F("Info");
-    case ID_InfoMain:       return F("Info");
+    case ID_Info:           return GET_TEXT_F(MSG_BUTTON_INFO);
+    case ID_InfoMain:       return GET_TEXT_F(MSG_BUTTON_INFO);
     #if HAS_MESH
-      case ID_Leveling:     return F("Leveling");
+      case ID_Leveling:     return GET_TEXT_F(MSG_BED_LEVELING);
       case ID_LevelView:    return GET_TEXT_F(MSG_MESH_VIEW);
       case ID_LevelSettings: return F("Leveling Settings");
       case ID_MeshViewer:   return GET_TEXT_F(MSG_MESH_VIEW);
       case ID_LevelManual:  return F("Manual Tuning");
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case ID_UBLMesh:      return F("UBL Bed Leveling");
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ID_ManualMesh:   return GET_TEXT_F(MSG_MANUAL_LEVELING);
@@ -4106,20 +4215,23 @@ uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
     #endif
     #if HAS_PREHEAT
       case ID_Preheat:      return PREHEAT_TOTAL;
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ID_ChangeFilament: return CHANGEFIL_TOTAL;
     #endif
     #if HAS_CUSTOM_MENU
       case ID_MenuCustom:   return CUSTOM_MENU_TOTAL;
     #endif
+    #if ENABLED(FWRETRACT)
+      case ID_FWMenu:       return FWRETRACT_TOTAL;
+    #endif
     case ID_Control:        return CONTROL_TOTAL;
     case ID_TempMenu:       return TEMP_TOTAL;
     #if ANY(PIDTEMP, PIDTEMPBED)
       case ID_PID:          return PID_TOTAL;
     #endif
     #if ENABLED(PIDTEMP)
       case ID_HotendPID:    return HOTENDPID_TOTAL;
     #endif
     #if ENABLED(PIDTEMPBED)
       case ID_BedPID:       return BEDPID_TOTAL;
@@ -4139,21 +4251,20 @@ uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
       case ID_MaxJerk:      return JERK_TOTAL;
     #endif
     case ID_Steps:          return STEPS_TOTAL;
     case ID_Visual:         return VISUAL_TOTAL;
     case ID_Advanced:       return ADVANCED_TOTAL;
     #if HAS_BED_PROBE
       case ID_ProbeMenu:    return PROBE_TOTAL;
     #endif
     #if HAS_TRINAMIC_CONFIG
       case ID_TMCMenu:      return TMC_TOTAL;
-      case ID_TMCMenu:      return TMC_TOTAL;
     #endif
     case ID_Info:           return INFO_TOTAL;
     case ID_InfoMain:       return INFO_TOTAL;
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case ID_UBLMesh:      return UBL_M_TOTAL;
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ID_ManualMesh:   return MMESH_TOTAL;
     #endif
     #if HAS_MESH
@@ -4173,42 +4284,51 @@ uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
   }
   return 0;
 }
 
 //
 // Popup Config
 //
 
 void JyersDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/) {
   popup = last_popup = popupid;
+  FSTR_P const PWID = F("Please wait until done.");
   switch (popupid) {
-    case Popup_Pause:         drawPopup(F("Pause Print"), F(""), F(""), Proc_Popup); break;
-    case Popup_Stop:          drawPopup(F("Stop Print"), F(""), F(""), Proc_Popup); break;
+    case Popup_Pause:         drawPopup(GET_TEXT_F(MSG_PAUSE_PRINT), F(""), F(""), Proc_Popup); break;
+    case Popup_Stop:          drawPopup(GET_TEXT_F(MSG_STOP_PRINT), F(""), F(""), Proc_Popup); break;
     case Popup_Resume:        drawPopup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Proc_Popup); break;
     case Popup_ConfFilChange: drawPopup(F("Confirm Filament Change"), F(""), F(""), Proc_Popup); break;
     case Popup_PurgeMore:     drawPopup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Proc_Popup); break;
-    case Popup_SaveLevel:     drawPopup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Proc_Popup); break;
-    case Popup_MeshSlot:      drawPopup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Proc_Popup); break;
-    case Popup_ETemp:         drawPopup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Proc_Popup); break;
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      case Popup_SaveLevel:   drawPopup(GET_TEXT_F(MSG_LEVEL_BED_DONE), F("Save to EEPROM?"), F(""), Proc_Popup); break;
+      case Popup_MeshSlot:    drawPopup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Proc_Popup); break;
+    #endif
+    case Popup_ETemp:         drawPopup(GET_TEXT_F(MSG_HOTEND_TOO_COLD), F("Open Preheat Menu?"), F(""), Proc_Popup); break;
     case Popup_ManualProbing: drawPopup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Proc_Popup); break;
-    case Popup_Level:         drawPopup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Proc_Wait, ICON_AutoLeveling); break;
-    case Popup_Home:          drawPopup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
-    case Popup_MoveWait:      drawPopup(F("Moving to Point"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
-    case Popup_Heating:       drawPopup(F("Heating"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
-    case Popup_FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Level:         drawPopup(GET_TEXT_F(MSG_BED_LEVELING), PWID, F(""), Proc_Wait, ICON_AutoLeveling); break;
+    case Popup_Home:          drawPopup(option ? F("Parking") : GET_TEXT_F(MSG_HOMING), PWID, F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_MoveWait:      drawPopup(GET_TEXT_F(MSG_UBL_MOVING_TO_NEXT), PWID, F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Heating:       drawPopup(GET_TEXT_F(MSG_HEATING), PWID, F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), PWID, F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Proc_Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
-    case Popup_Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Proc_Wait, ICON_BLTouch); break;
-    case Popup_PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Proc_Wait, ICON_BLTouch); break;
-    case Popup_MPCWait:       drawPopup(F("MPC Autotune"), F("in process"), F("Please wait until done."), Proc_Wait, ICON_BLTouch); break;
-    case Popup_Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
-    case Popup_Custom:        drawPopup(F("Running Custom G-Code"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+      case Popup_Runout:      drawPopup(F("Filament Runout"), F(""), F(""), Proc_Wait, ICON_BLTouch); break;
+    #endif
+    #if ANY(PIDTEMP, PIDTEMPBED)
+      case Popup_PIDWait:     drawPopup(GET_TEXT_F(MSG_PID_AUTOTUNE), F("in progress"), PWID, Proc_Wait, ICON_BLTouch); break;
+    #endif
+    #if ENABLED(MPC_AUTOTUNE_MENU)
+      case Popup_MPCWait:     drawPopup(GET_TEXT_F(MSG_MPC_AUTOTUNE), F("in progress"), PWID, Proc_Wait, ICON_BLTouch); break;
+    #endif
+    case Popup_Resuming:      drawPopup(F("Resuming Print"), PWID, F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Custom:        drawPopup(F("Running Custom G-Code"), PWID, F(""), Proc_Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
 void JyersDWIN::confirmHandler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
     case Popup_FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Proc_Confirm); break;
     case Popup_HeaterTime:  drawPopup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Proc_Confirm); break;
     case Popup_UserInput:   drawPopup(F("Waiting for Input"), F("Press to Continue"), F(""), Proc_Confirm); break;
@@ -4432,23 +4552,22 @@ void JyersDWIN::fileControl() {
         card.cdup();
         drawSDList();
       }
     }
     else {
       card.selectFileByIndexSorted(selection - 1);
       if (card.flag.filenameIsDir) {
         card.cd(card.filename);
         drawSDList();
       }
-      else {
+      else
         card.openAndPrintFile(card.filename);
-      }
     }
   }
   dwinUpdateLCD();
 }
 
 void JyersDWIN::printScreenControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
     selection++; // Select Down

commit 4744997c164931f8c1f8753ba4112e466b7c83a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 12:14:57 2023 -0500

    📝 GCode => G-Code

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 343252df4c..0b3c979d9e 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4194,21 +4194,21 @@ void JyersDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/)
     case Popup_Home:          drawPopup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_MoveWait:      drawPopup(F("Moving to Point"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_Heating:       drawPopup(F("Heating"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Proc_Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
     case Popup_Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Proc_Wait, ICON_BLTouch); break;
     case Popup_PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Proc_Wait, ICON_BLTouch); break;
     case Popup_MPCWait:       drawPopup(F("MPC Autotune"), F("in process"), F("Please wait until done."), Proc_Wait, ICON_BLTouch); break;
     case Popup_Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
-    case Popup_Custom:        drawPopup(F("Running Custom GCode"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Custom:        drawPopup(F("Running Custom G-Code"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
 void JyersDWIN::confirmHandler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
     case Popup_FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Proc_Confirm); break;
     case Popup_HeaterTime:  drawPopup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Proc_Confirm); break;
     case Popup_UserInput:   drawPopup(F("Waiting for Input"), F("Press to Continue"), F(""), Proc_Confirm); break;

commit 03cf2b577be63a8f630c2ad9547d0e2ab3b73e00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 6 19:15:28 2023 -0500

    misc. formatting, grid condition

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index e6768e1ef4..343252df4c 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4473,21 +4473,21 @@ void JyersDWIN::printScreenControl() {
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
               #if HAS_HEATED_BED
                 gcode.process_subcommands_now(TS(F("M140 S"), pausebed));
               #endif
               #if HAS_EXTRUDERS
                 gcode.process_subcommands_now(TS(F("M109 S"), pausetemp));
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
-              TERN_(HAS_MEDIA, queue.inject(F("M24")));
+              TERN_(HAS_MEDIA, queue.inject(FPSTR(M24_STR)));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           drawPrintScreen();
         }
         else
           popupHandler(Popup_Pause);
         break;

commit 8fa6a4da2eebc1dbe120dcac87b159e389e17dc3
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Fri Aug 25 19:33:49 2023 -0400

    🚸 Fixes for ProUI, JyersUI, backlight, etc. (#26086)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 5156848a43..e6768e1ef4 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -334,65 +334,59 @@ private:
         gcode.process_subcommands_now(TS(F("G42 F4000 I"), mesh_x, 'J', mesh_y));
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
         jyersDWIN.redrawMenu();
       }
     }
 
     float getMaxValue() {
-      float max = __FLT_MIN__;
-      GRID_LOOP(x, y) {
-        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
-          max = bedlevel.z_values[x][y];
-      }
+      float max = -(__FLT_MAX__);
+      GRID_LOOP(x, y) { const float z = bedlevel.z_values[x][y]; if (!isnan(z)) NOLESS(max, z); }
       return max;
     }
 
     float getMinValue() {
       float min = __FLT_MAX__;
-      GRID_LOOP(x, y) {
-        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
-          min = bedlevel.z_values[x][y];
-      }
+      GRID_LOOP(x, y) { const float z = bedlevel.z_values[x][y]; if (!isnan(z)) NOMORE(min, z); }
       return min;
     }
 
     void drawBedMesh(const int16_t selected=-1, const uint8_t gridline_width=1, const uint16_t padding_x=8, const uint16_t padding_y_top=40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
                      cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
                      cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
-      const float v_max = abs(getMaxValue()), v_min = abs(getMinValue()), range = _MAX(v_min, v_max);
+      const float v_max = abs(getMaxValue()), v_min = abs(getMinValue()), rmax = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
       dwinDrawRectangle(1, COLOR_BG_BLACK, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / (GRID_MAX_POINTS_X);
         const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
         dwinDrawRectangle(1, COLOR_WHITE, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
-        dwinDrawRectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
-          isnan(bedlevel.z_values[x][y]) ? COLOR_GREY : (                                                           // gray if undefined
+        dwinDrawRectangle(1,                                          // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
+          isnan(bedlevel.z_values[x][y]) ? COLOR_GREY : (             // gray if undefined
             (bedlevel.z_values[x][y] < 0 ?
-              (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
-              (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
+              (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? rmax : v_min)) << 11 :  // red if mesh point value is negative
+              (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? rmax : v_max)) << 5) |  // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
@@ -414,30 +408,31 @@ private:
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
       float v1, v2,
             v_min = abs(getMinValue()),
             v_max = abs(getMaxValue());
       if (viewer_asymmetric_range) {
-        if (v_min > 3e+10F) v_min = 0.0000001;
-        if (v_max > 3e+10F) v_max = 0.0000001;
+        if (v_min > 3e+10f) v_min = 0.0000001;
+        if (v_max > 3e+10f) v_max = 0.0000001;
         v1 = -v_min;
         v2 =  v_max;
       }
       else {
-        float range = _MAX(v_min, v_max);
-        if (range > 3e+10F) range = 0.0000001;
-        v1 = -range;
-        v2 =  range;
+        float rmax = _MAX(v_min, v_max), rmin = _MIN(v_min, v_max);
+        if (rmax > 3e+10f) rmax = 0.0000001;
+        if (rmin > 3e+10f) rmin = 0.0000001;
+        v1 = -rmax;
+        v2 =  rmin;
       }
       jyersDWIN.updateStatus(TS(F("Red "), p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), F(" Green")));
       drawing_mesh = false;
     }
 
   } mesh_conf;
 
 #endif // HAS_MESH
 
 //

commit a0e3dea8b879aba8e0d2d7e4dc6a6447b3fe76ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 20:25:39 2023 -0500

    🚸 ColorUI Touch Calibrate in CW order

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index fea1f081f6..5156848a43 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1413,21 +1413,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 }
                 corner_avg /= 4;
                 redrawMenu();
               }
             }
             break;
         #endif
 
         case MLEVEL_BL:
           if (draw)
-            drawMenuItem(row, ICON_AxisBL, F("Bottom Left"));
+            drawMenuItem(row, ICON_AxisBL, GET_TEXT_F(MSG_BOTTOM_LEFT));
           else {
             popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_min, 3), 'Y', p_float_t(probe_y_min, 3))
                 );
                 planner.synchronize();
                 popupHandler(Popup_ManualProbing);
               #endif
@@ -1436,21 +1436,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(corner_pos, 3), 'Y', p_float_t(corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
-            drawMenuItem(row, ICON_AxisTL, F("Top Left"));
+            drawMenuItem(row, ICON_AxisTL, GET_TEXT_F(MSG_TOP_LEFT));
           else {
             popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_min, 3), 'Y', p_float_t(probe_y_max, 3))
                 );
                 planner.synchronize();
                 popupHandler(Popup_ManualProbing);
               #endif
@@ -1459,21 +1459,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
-            drawMenuItem(row, ICON_AxisTR, F("Top Right"));
+            drawMenuItem(row, ICON_AxisTR, GET_TEXT_F(MSG_TOP_RIGHT));
           else {
             popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_max, 3), 'Y', p_float_t(probe_y_max, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
                 );
                 planner.synchronize();
                 popupHandler(Popup_ManualProbing);
               #endif
@@ -1482,21 +1482,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
-            drawMenuItem(row, ICON_AxisBR, F("Bottom Right"));
+            drawMenuItem(row, ICON_AxisBR, GET_TEXT_F(MSG_BOTTOM_RIGHT));
           else {
             popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_max, 3), 'Y', p_float_t(probe_y_min, 3))
                 );
                 planner.synchronize();
                 popupHandler(Popup_ManualProbing);
               #endif

commit fc2272c4b473a45f2033d4dd82aef4b259b99759
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Sat Jul 15 21:10:42 2023 -0400

    🩹 Fix, clean up ProUI, JyersUI (#26078)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 7139f3cdf9..fea1f081f6 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -247,21 +247,21 @@ public:
       return text;
     }
   }
 
 private:
   uint16_t scrollpos;
 };
 
 #if HAS_MESH
 
-  struct Mesh_Settings {
+  struct {
     bool viewer_asymmetric_range = false;
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       uint8_t tilt_grid = 1;
 
@@ -429,22 +429,21 @@ private:
       else {
         float range = _MAX(v_min, v_max);
         if (range > 3e+10F) range = 0.0000001;
         v1 = -range;
         v2 =  range;
       }
       jyersDWIN.updateStatus(TS(F("Red "), p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), F(" Green")));
       drawing_mesh = false;
     }
 
-  };
-  Mesh_Settings mesh_conf;
+  } mesh_conf;
 
 #endif // HAS_MESH
 
 //
 // General Display Functions
 //
 
 struct JyersDWIN::EEPROM_Settings JyersDWIN::eeprom_settings{0};
 constexpr const char * const JyersDWIN::color_names[11];
 constexpr const char * const JyersDWIN::preheat_modes[3];
@@ -810,28 +809,28 @@ void JyersDWIN::drawStatusArea(const bool icons/*=false*/) {
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
       dwinIconShow(ICON, ICON_HotendTemp, 10, 383);
       dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     }
-    if (thermalManager.temp_hotend[0].celsius != hotend) {
-      hotend = thermalManager.temp_hotend[0].celsius;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
+    if (thermalManager.degHotend(0) != hotend) {
+      hotend = thermalManager.degHotend(0);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 28, 384, hotend);
       dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 3 * STAT_CHR_W + 5, 386);
     }
-    if (thermalManager.temp_hotend[0].target != hotendtarget) {
-      hotendtarget = thermalManager.temp_hotend[0].target;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
+    if (thermalManager.wholeDegHotend(0) != hotendtarget) {
+      hotendtarget = thermalManager.degTargetHotend(0);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 384, hotendtarget);
       dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 4 * STAT_CHR_W + 39, 386);
     }
     if (icons) {
       flow = -1;
       dwinIconShow(ICON, ICON_StepE, 112, 417);
       dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
     }
     if (planner.flow_percentage[0] != flow) {
       flow = planner.flow_percentage[0];
       dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
@@ -840,28 +839,28 @@ void JyersDWIN::drawStatusArea(const bool icons/*=false*/) {
 
   #if HAS_HEATED_BED
     static float bed = -1;
     static int16_t bedtarget = -1;
     if (icons) {
       bed = -1;
       bedtarget = -1;
       dwinIconShow(ICON, ICON_BedTemp, 10, 416);
       dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     }
-    if (thermalManager.temp_bed.celsius != bed) {
-      bed = thermalManager.temp_bed.celsius;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 28, 417, thermalManager.temp_bed.celsius);
+    if (thermalManager.degBed() != bed) {
+      bed = thermalManager.degBed();
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 28, 417, bed);
       dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 3 * STAT_CHR_W + 5, 419);
     }
-    if (thermalManager.temp_bed.target != bedtarget) {
-      bedtarget = thermalManager.temp_bed.target;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
+    if (thermalManager.degTargetBed() != bedtarget) {
+      bedtarget = thermalManager.degTargetBed();
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 417, bedtarget);
       dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 4 * STAT_CHR_W + 39, 419);
     }
   #endif
 
   #if HAS_FAN
     static uint8_t fan = -1;
     if (icons) {
       fan = -1;
       dwinIconShow(ICON, ICON_FanSpeed, 187, 383);
     }
@@ -1166,29 +1165,29 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 drawMenu(ID_ChangeFilament);
               #else
-                if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                if (thermalManager.targetTooColdToExtrude(0))
                   popupHandler(Popup_ETemp);
                 else {
                   if (thermalManager.temp_hotend[0].is_below_target(2)) {
                     popupHandler(Popup_Heating);
                     thermalManager.wait_for_hotend(0);
                   }
                   popupHandler(Popup_FilChange);
-                  gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
+                  gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.degTargetHotend(0)));
                 }
               #endif
             }
             break;
         #endif
       }
       break;
 
     case ID_HomeMenu:
 
@@ -1307,21 +1306,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
 
         #if HAS_HOTEND
           case MOVE_E:
             if (draw) {
               drawMenuItem(row, ICON_Extruder, F("Extruder"));
               current_position.e = 0;
               sync_plan_position();
               drawFloat(current_position.e, row);
             }
             else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+              if (thermalManager.targetTooColdToExtrude(0)) {
                 popupHandler(Popup_ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                   redrawMenu();
                 }
                 current_position.e = 0;
                 sync_plan_position();
@@ -1331,34 +1330,34 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           break;
         #endif // HAS_HOTEND
 
         #if HAS_BED_PROBE
           case MOVE_P:
             if (draw) {
               drawMenuItem(row, ICON_StockConfiguration, F("Probe"));
               drawCheckbox(row, probe_deployed);
             }
             else {
-              probe_deployed = !probe_deployed;
+              probe_deployed ^= true;
               probe.set_deployed(probe_deployed);
               drawCheckbox(row, probe_deployed);
             }
             break;
         #endif
 
         case MOVE_LIVE:
           if (draw) {
             drawMenuItem(row, ICON_Axis, F("Live Movement"));
             drawCheckbox(row, livemove);
           }
           else {
-            livemove = !livemove;
+            livemove ^= true;
             drawCheckbox(row, livemove);
           }
           break;
       }
       break;
     case ID_ManualLevel: {
 
       #define MLEVEL_BACK 0
       #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
       #define MLEVEL_BL (MLEVEL_PROBE + 1)
@@ -1605,21 +1604,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                   gcode.process_subcommands_now(
                     TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3))
                   );
                 #else
                   gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
                 #endif
                 gcode.process_subcommands_now(F("G0F300Z0"));
                 planner.synchronize();
                 redrawMenu();
               }
-              liveadjust = !liveadjust;
+              liveadjust ^= true;
               drawCheckbox(row, liveadjust);
             }
             break;
           case ZOFFSET_OFFSET:
             if (draw) {
               drawMenuItem(row, ICON_SetZOffset, F("Z Offset"));
               drawFloat(zoffsetvalue, row, false, 100);
             }
             else
               modifyValue(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
@@ -1721,66 +1720,66 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           case CHANGEFIL_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
               drawMenu(ID_Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
               drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
             else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+              if (thermalManager.targetTooColdToExtrude(0))
                 popupHandler(Popup_ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 popupHandler(Popup_FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 redrawMenu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
               drawMenuItem(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
             else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+              if (thermalManager.targetTooColdToExtrude(0)) {
                 popupHandler(Popup_ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 popupHandler(Popup_FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 redrawMenu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+              if (thermalManager.targetTooColdToExtrude(0))
                 popupHandler(Popup_ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 popupHandler(Popup_FilChange);
-                gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.temp_hotend[0].target));
+                gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.degTargetHotend(0)));
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
     #if HAS_CUSTOM_MENU
 
       case ID_MenuCustom:
@@ -1995,31 +1994,31 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         case TEMP_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
             drawMenu(ID_Control, CONTROL_TEMP);
           break;
         #if HAS_HOTEND
           case TEMP_HOTEND:
             if (draw) {
               drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
-              drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
+              drawFloat(thermalManager.degTargetHotend(0), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
         #if HAS_HEATED_BED
           case TEMP_BED:
             if (draw) {
               drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
-              drawFloat(thermalManager.temp_bed.target, row, false, 1);
+              drawFloat(thermalManager.degTargetBed(), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case TEMP_FAN:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Fan"));
               drawFloat(thermalManager.fan_speed[0], row, false, 1);
@@ -2683,21 +2682,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           }
           else
             modifyValue(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
         case VISUAL_TIME_FORMAT:
           if (draw) {
             drawMenuItem(row, ICON_PrintTime, F("Progress as __h__m"));
             drawCheckbox(row, eeprom_settings.time_format_textual);
           }
           else {
-            eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
+            eeprom_settings.time_format_textual ^= true;
             drawCheckbox(row, eeprom_settings.time_format_textual);
           }
           break;
         case VISUAL_COLOR_THEMES:
           if (draw)
             drawMenuItem(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
           else
             drawMenu(ID_ColorSettings);
         break;
       }
@@ -2841,21 +2840,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawMenu(ID_Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
               drawMenuItem(row, ICON_Version, F("LCD Beeper"));
               drawCheckbox(row, ui.sound_on);
             }
             else {
-              ui.sound_on = !ui.sound_on;
+              ui.sound_on ^= true;
               drawCheckbox(row, ui.sound_on);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
               drawMenuItem(row, ICON_StepX, F("Probe"), nullptr, true);
             else
@@ -2924,21 +2923,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case ADVANCED_FILSENSORENABLED:
             if (draw) {
               drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
               drawCheckbox(row, runout.enabled);
             }
             else {
-              runout.enabled = !runout.enabled;
+              runout.enabled ^= true;
               drawCheckbox(row, runout.enabled);
             }
             break;
 
           #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
             case ADVANCED_FILSENSORDISTANCE:
               if (draw) {
                 drawMenuItem(row, ICON_MaxAccE, F("Runout Distance"));
                 drawFloat(runout.runout_distance(), row, false, 10);
               }
@@ -3371,31 +3370,31 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenuItem(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
               drawMenu(ID_MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
               drawMenuItem(row, ICON_Contact, F("Viewer Show Values"));
               drawCheckbox(row, mesh_conf.viewer_print_value);
             }
             else {
-              mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
+              mesh_conf.viewer_print_value ^= true;
               drawCheckbox(row, mesh_conf.viewer_print_value);
             }
             break;
           case LEVELING_VIEW_ASYMMETRIC:
             if (draw) {
               drawMenuItem(row, ICON_Axis, F("Viewer Asymmetric"));
               drawCheckbox(row, mesh_conf.viewer_asymmetric_range);
             }
             else {
-              mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
+              mesh_conf.viewer_asymmetric_range ^= true;
               drawCheckbox(row, mesh_conf.viewer_asymmetric_range);
             }
             break;
         }
         break;
 
       case ID_LevelSettings:
 
         #define LEVELING_SETTINGS_BACK 0
         #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
@@ -3564,21 +3563,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               sync_plan_position();
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
               drawMenuItem(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
               drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             else {
-              mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
+              mesh_conf.goto_mesh_value ^= true;
               current_position.z = 0;
               mesh_conf.manual_mesh_move(true);
               drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_M_UNDEF:
             if (draw)
               drawMenuItem(row, ICON_ResumeEEPROM, F("Clear Point Value"));
             else {
@@ -3829,32 +3828,32 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             if (draw) {
               drawMenuItem(row, ICON_Speed, F("Flow Rate"));
               drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
               modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
           case TUNE_HOTEND:
             if (draw) {
               drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
-              drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
+              drawFloat(thermalManager.degTargetHotend(0), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
 
         #if HAS_HEATED_BED
           case TUNE_BED:
             if (draw) {
               drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
-              drawFloat(thermalManager.temp_bed.target, row, false, 1);
+              drawFloat(thermalManager.degTargetBed(), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
 
         #if HAS_FAN
           case TUNE_FAN:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Fan"));
@@ -3903,21 +3902,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
               drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
               drawCheckbox(row, runout.enabled);
             }
             else {
-              runout.enabled = !runout.enabled;
+              runout.enabled ^= true;
               drawCheckbox(row, runout.enabled);
             }
             break;
         #endif
 
         case TUNE_BACKLIGHT_OFF:
           if (draw)
             drawMenuItem(row, ICON_Brightness, F("Display Off"));
           else
             ui.set_brightness(0);
@@ -3959,40 +3958,40 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
               drawMenuItem(row, ICON_SetEndTemp, F("Continue"));
             else {
               popupHandler(Popup_Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
                 case ID_Prepare:
                   popupHandler(Popup_FilChange);
-                  gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
+                  gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.degTargetHotend(0)));
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   case ID_ChangeFilament:
                     switch (last_selection) {
                       case CHANGEFIL_LOAD:
                         popupHandler(Popup_FilLoad);
                         gcode.process_subcommands_now(F("M701"));
                         planner.synchronize();
                         redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_UNLOAD:
                         popupHandler(Popup_FilLoad, true);
                         gcode.process_subcommands_now(F("M702"));
                         planner.synchronize();
                         redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_CHANGE:
                         popupHandler(Popup_FilChange);
-                        gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
+                        gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.degTargetHotend(0)));
                         break;
                     }
                     break;
                 #endif
                 default:
                   redrawMenu(true, true, true);
                   break;
               }
             }
             break;
@@ -4002,21 +4001,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             case PREHEATHOTEND_##N: \
               if (draw) drawMenuItem(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
               else ui.preheat_hotend_and_fan((N) - 1); \
               break;
 
           REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
 
           case PREHEATHOTEND_CUSTOM:
             if (draw) {
               drawMenuItem(row, ICON_Temperature, F("Custom"));
-              drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
+              drawFloat(thermalManager.degTargetHotend(0), row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
@@ -4525,22 +4524,22 @@ void JyersDWIN::popupControl() {
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               popupHandler(Popup_Home, true);
               #if HAS_MEDIA
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
               queue.inject(F("M125"));
               planner.synchronize();
             #else
               queue.inject(F("M25"));
-              TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
-              TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
+              TERN_(HAS_HOTEND, pausetemp = thermalManager.degTargetHotend(0));
+              TERN_(HAS_HEATED_BED, pausebed = thermalManager.degTargetBed());
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
               thermalManager.cooldown();
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.pause());
           }
         }
         drawPrintScreen();
         break;
@@ -4587,29 +4586,29 @@ void JyersDWIN::popupControl() {
           else {
             redrawMenu(true, true, false);
             updateStatus("");
           }
           break;
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         case Popup_ConfFilChange:
           if (selection == 0) {
-            if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+            if (thermalManager.targetTooColdToExtrude(0))
               popupHandler(Popup_ETemp);
             else {
               if (thermalManager.temp_hotend[0].is_below_target(2)) {
                 popupHandler(Popup_Heating);
                 thermalManager.wait_for_hotend(0);
               }
               popupHandler(Popup_FilChange);
-              gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.temp_hotend[0].target));
+              gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.degTargetHotend(0)));
             }
           }
           else
             redrawMenu(true, true, false);
           break;
         case Popup_PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
             popupHandler(Popup_FilChange);
           }
@@ -4779,26 +4778,26 @@ void JyersDWIN::stopPrint() {
   thermalManager.cooldown();
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress(100 * (PROGRESS_SCALE)));
   TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
   drawPrintConfirm();
 }
 
 void JyersDWIN::update() {
   stateUpdate();
   screenUpdate();
   switch (process) {
-    case Proc_Main:    mainMenuControl();    break;
+    case Proc_Main:    mainMenuControl();     break;
     case Proc_Menu:    menuControl();         break;
     case Proc_Value:   valueControl();        break;
     case Proc_Option:  optionControl();       break;
     case Proc_File:    fileControl();         break;
-    case Proc_Print:   printScreenControl(); break;
+    case Proc_Print:   printScreenControl();  break;
     case Proc_Popup:   popupControl();        break;
     case Proc_Confirm: confirmControl();      break;
   }
 }
 
 void MarlinUI::update() { jyersDWIN.update(); }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
@@ -4893,72 +4892,72 @@ void JyersDWIN::screenUpdate() {
     #else
       if (-home_offset.z != lastzoffset)
         zoffsetvalue = lastzoffset = -home_offset.z;
     #endif
   #endif // HAS_ZOFFSET_ITEM
 
   if (process == Proc_Menu || process == Proc_Value) {
     switch (active_menu) {
       case ID_TempMenu:
         #if HAS_HOTEND
-          if (thermalManager.temp_hotend[0].target != hotendtarget) {
-            hotendtarget = thermalManager.temp_hotend[0].target;
+          if (thermalManager.degTargetHotend(0) != hotendtarget) {
+            hotendtarget = thermalManager.degTargetHotend(0);
             if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
               if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
-                drawFloat(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
+                drawFloat(hotendtarget, TEMP_HOTEND - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_HEATED_BED
-          if (thermalManager.temp_bed.target != bedtarget) {
-            bedtarget = thermalManager.temp_bed.target;
+          if (thermalManager.degTargetBed() != bedtarget) {
+            bedtarget = thermalManager.degTargetBed();
             if (scrollpos <= TEMP_BED && TEMP_BED <= scrollpos + MROWS) {
               if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
-                drawFloat(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
+                drawFloat(bedtarget, TEMP_BED - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_FAN
           if (thermalManager.fan_speed[0] != fanspeed) {
             fanspeed = thermalManager.fan_speed[0];
             if (scrollpos <= TEMP_FAN && TEMP_FAN <= scrollpos + MROWS) {
               if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
-                drawFloat(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
+                drawFloat(fanspeed, TEMP_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
       case ID_Tune:
         #if HAS_HOTEND
-          if (thermalManager.temp_hotend[0].target != hotendtarget) {
-            hotendtarget = thermalManager.temp_hotend[0].target;
+          if (thermalManager.degTargetHotend(0) != hotendtarget) {
+            hotendtarget = thermalManager.degTargetHotend(0);
             if (scrollpos <= TUNE_HOTEND && TUNE_HOTEND <= scrollpos + MROWS) {
               if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
-                drawFloat(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
+                drawFloat(hotendtarget, TUNE_HOTEND - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_HEATED_BED
-          if (thermalManager.temp_bed.target != bedtarget) {
-            bedtarget = thermalManager.temp_bed.target;
+          if (thermalManager.degTargetBed() != bedtarget) {
+            bedtarget = thermalManager.degTargetBed();
             if (scrollpos <= TUNE_BED && TUNE_BED <= scrollpos + MROWS) {
               if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
-                drawFloat(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
+                drawFloat(bedtarget, TUNE_BED - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_FAN
           if (thermalManager.fan_speed[0] != fanspeed) {
             fanspeed = thermalManager.fan_speed[0];
             if (scrollpos <= TUNE_FAN && TUNE_FAN <= scrollpos + MROWS) {
               if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
-                drawFloat(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
+                drawFloat(fanspeed, TUNE_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
     }
   }
 }
 
 void JyersDWIN::audioFeedback(const bool success/*=true*/) {
   if (ui.sound_on)

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    🎨 Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 22ff4b8a00..7139f3cdf9 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -162,24 +162,24 @@ enum SelectItem : uint8_t {
   PAGE_CONTROL,
   PAGE_INFO_LEVELING,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
   PRINT_PAUSE_RESUME,
   PRINT_STOP,
   PRINT_COUNT
 };
 
-uint8_t active_menu = MainMenu, last_menu = MainMenu;
+uint8_t active_menu = ID_MainMenu, last_menu = ID_MainMenu;
 uint8_t selection = 0, last_selection = 0;
 uint8_t scrollpos = 0;
-uint8_t process = Main, last_process = Main;
+uint8_t process = Proc_Main, last_process = Proc_Main;
 PopupID popup, last_popup;
 
 void (*funcpointer)() = nullptr;
 void *valuepointer = nullptr;
 float tempvalue;
 float valuemin;
 float valuemax;
 uint8_t valueunit;
 uint8_t valuetype;
 
@@ -258,28 +258,28 @@ private:
     bool viewer_asymmetric_range = false;
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       uint8_t tilt_grid = 1;
 
-      void manual_value_update(bool undefined=false) {
+      void manualValueUpdate(bool undefined=false) {
         gcode.process_subcommands_now(
           TS(F("M421I"), mesh_x, 'J', mesh_y, 'Z', p_float_t(current_position.z, 3), undefined ? "N" : "")
         );
         planner.synchronize();
       }
 
-      bool create_plane_from_mesh() {
+      bool createPlaneFromMesh() {
         struct linear_fit_data lsf_results;
         incremental_LSF_reset(&lsf_results);
         GRID_LOOP(x, y) {
           if (!isnan(bedlevel.z_values[x][y])) {
             xy_pos_t rpos = { bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) };
             incremental_LSF(&lsf_results, rpos, bedlevel.z_values[x][y]);
           }
         }
 
         if (finish_incremental_LSF(&lsf_results)) {
@@ -305,128 +305,128 @@ private:
             DEBUG_DELAY(20);
           }
 
           bedlevel.z_values[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
 
-      void manual_value_update() {
+      void manualValueUpdate() {
         gcode.process_subcommands_now(
           TS(F("G29I"), mesh_x, 'J', mesh_y, 'Z', p_float_t(current_position.z, 3))
         );
         planner.synchronize();
       }
 
     #endif
 
     void manual_mesh_move(const bool zmove=false) {
       if (zmove) {
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
-        jyersDWIN.popupHandler(MoveWait);
+        jyersDWIN.popupHandler(Popup_MoveWait);
         gcode.process_subcommands_now(TS(F("G0F300Z"), p_float_t(current_position.z, 3)));
         gcode.process_subcommands_now(TS(F("G42 F4000 I"), mesh_x, 'J', mesh_y));
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
         jyersDWIN.redrawMenu();
       }
     }
 
-    float get_max_value() {
+    float getMaxValue() {
       float max = __FLT_MIN__;
       GRID_LOOP(x, y) {
         if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
           max = bedlevel.z_values[x][y];
       }
       return max;
     }
 
-    float get_min_value() {
+    float getMinValue() {
       float min = __FLT_MAX__;
       GRID_LOOP(x, y) {
         if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
           min = bedlevel.z_values[x][y];
       }
       return min;
     }
 
     void drawBedMesh(const int16_t selected=-1, const uint8_t gridline_width=1, const uint16_t padding_x=8, const uint16_t padding_y_top=40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
                      cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
                      cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
-      const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
+      const float v_max = abs(getMaxValue()), v_min = abs(getMinValue()), range = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
-      dwinDrawRectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
+      dwinDrawRectangle(1, COLOR_BG_BLACK, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / (GRID_MAX_POINTS_X);
         const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
-        dwinDrawRectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
+        dwinDrawRectangle(1, COLOR_WHITE, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
         dwinDrawRectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
-          isnan(bedlevel.z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
+          isnan(bedlevel.z_values[x][y]) ? COLOR_GREY : (                                                           // gray if undefined
             (bedlevel.z_values[x][y] < 0 ?
               (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
-            dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
               msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
               msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
             offset_x = cell_width_px / 2 - 3 * msg.length() - 2;
             if (!(GRID_MAX_POINTS_X < 10))
-              dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, msg);
+              dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            dwinDrawString(false, font6x12, COLOR_WHITE, COLOR_BG_BLUE, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, msg);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
       float v1, v2,
-            v_min = abs(get_min_value()),
-            v_max = abs(get_max_value());
+            v_min = abs(getMinValue()),
+            v_max = abs(getMaxValue());
       if (viewer_asymmetric_range) {
         if (v_min > 3e+10F) v_min = 0.0000001;
         if (v_max > 3e+10F) v_max = 0.0000001;
         v1 = -v_min;
         v2 =  v_max;
       }
       else {
         float range = _MAX(v_min, v_max);
         if (range > 3e+10F) range = 0.0000001;
         v1 = -range;
@@ -448,328 +448,328 @@ private:
 struct JyersDWIN::EEPROM_Settings JyersDWIN::eeprom_settings{0};
 constexpr const char * const JyersDWIN::color_names[11];
 constexpr const char * const JyersDWIN::preheat_modes[3];
 
 // Clear a part of the screen
 //  4=Entire screen
 //  3=Title bar and Menu area (default)
 //  2=Menu area
 //  1=Title bar
 void JyersDWIN::clearScreen(const uint8_t e/*=3*/) {
-  if (e == 1 || e == 3 || e == 4) dwinDrawRectangle(1, getColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
-  if (e == 2 || e == 3) dwinDrawRectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
-  if (e == 4) dwinDrawRectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
+  if (e == 1 || e == 3 || e == 4) dwinDrawRectangle(1, getColor(eeprom_settings.menu_top_bg, COLOR_BG_BLUE, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
+  if (e == 2 || e == 3) dwinDrawRectangle(1, COLOR_BG_BLACK, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
+  if (e == 4) dwinDrawRectangle(1, COLOR_BG_BLACK, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
 }
 
 void JyersDWIN::drawFloat(const_float_t value, const uint8_t row, const bool selected/*=false*/, const uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
-  const uint16_t bColor = selected ? Select_Color : Color_Bg_Black;
+  const uint16_t bColor = selected ? COLOR_SELECT : COLOR_BG_BLACK;
   const uint16_t xpos = 240 - (digits * 8);
-  dwinDrawRectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
+  dwinDrawRectangle(1, COLOR_BG_BLACK, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
-    dwinDrawString(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
+    dwinDrawString(true, DWIN_FONT_MENU, COLOR_WHITE, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
-    dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
-    dwinDrawString(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
+    dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, COLOR_WHITE, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
+    dwinDrawString(true, DWIN_FONT_MENU, COLOR_WHITE, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
 void JyersDWIN::drawOption(const uint8_t value, const char * const * options, const uint8_t row, const bool selected/*=false*/, const bool color/*=false*/) {
-  const uint16_t bColor = selected ? Select_Color : Color_Bg_Black,
-                 tColor = color ? getColor(value, Color_White, false) : Color_White;
+  const uint16_t bColor = selected ? COLOR_SELECT : COLOR_BG_BLACK,
+                 tColor = color ? getColor(value, COLOR_WHITE, false) : COLOR_WHITE;
   dwinDrawRectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
   dwinDrawString(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
 uint16_t JyersDWIN::getColor(const uint8_t color, const uint16_t original, const bool light/*=false*/) {
   switch (color) {
-    case White:   return light ? Color_Light_White   : Color_White;
-    case Green:   return light ? Color_Light_Green   : Color_Green;
-    case Cyan:    return light ? Color_Light_Cyan    : Color_Cyan;
-    case Blue:    return light ? Color_Light_Blue    : Color_Blue;
-    case Magenta: return light ? Color_Light_Magenta : Color_Magenta;
-    case Red:     return light ? Color_Light_Red     : Color_Red;
-    case Orange:  return light ? Color_Light_Orange  : Color_Orange;
-    case Yellow:  return light ? Color_Light_Yellow  : Color_Yellow;
-    case Brown:   return light ? Color_Light_Brown   : Color_Brown;
-    case Black:   return Color_Black;
+    case White:   return light ? COLOR_LIGHT_WHITE   : COLOR_WHITE;
+    case Green:   return light ? COLOR_LIGHT_GREEN   : COLOR_GREEN;
+    case Cyan:    return light ? COLOR_LIGHT_CYAN    : COLOR_CYAN;
+    case Blue:    return light ? COLOR_LIGHT_BLUE    : COLOR_BLUE;
+    case Magenta: return light ? COLOR_LIGHT_MAGENTA : COLOR_MAGENTA;
+    case Red:     return light ? COLOR_LIGHT_RED     : COLOR_RED;
+    case Orange:  return light ? COLOR_LIGHT_ORANGE  : COLOR_ORANGE;
+    case Yellow:  return light ? COLOR_LIGHT_YELLOW  : COLOR_YELLOW;
+    case Brown:   return light ? COLOR_LIGHT_BROWN   : COLOR_BROWN;
+    case Black:   return COLOR_BLACK;
     case Default: return original;
   }
-  return Color_White;
+  return COLOR_WHITE;
 }
 
 void JyersDWIN::drawTitle(const char * const ctitle) {
-  dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
+  dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, COLOR_WHITE, false), COLOR_BG_BLUE, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
 }
 void JyersDWIN::drawTitle(FSTR_P const ftitle) {
-  dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
+  dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, COLOR_WHITE, false), COLOR_BG_BLUE, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
 }
 
 void _decorateMenuItem(uint8_t row, uint8_t icon, bool more) {
   if (icon) dwinIconShow(ICON, icon, 26, MBASE(row) - 3);       // Draw Menu Icon
   if (more) dwinIconShow(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
-  dwinDrawLine(jyersDWIN.getColor(jyersDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+  dwinDrawLine(jyersDWIN.getColor(jyersDWIN.eeprom_settings.menu_split_line, COLOR_LINE, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
 void JyersDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, const char * const label1, const char * const label2, const bool more/*=false*/, const bool centered/*=false*/) {
   const uint8_t label_offset_y = label2 ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
-  if (label1) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
-  if (label2) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
+  if (label1) dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
+  if (label2) dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
   _decorateMenuItem(row, icon, more);
 }
 
 void JyersDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, const bool more/*=false*/, const bool centered/*=false*/) {
   const uint8_t label_offset_y = flabel2 ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
-  if (flabel1) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
-  if (flabel2) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
+  if (flabel1) dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
+  if (flabel2) dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
   _decorateMenuItem(row, icon, more);
 }
 
 void JyersDWIN::drawCheckbox(const uint8_t row, const bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS)   // Draw appropriate checkbox icon
     dwinIconShow(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
-    dwinDrawRectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
-    dwinDrawRectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    dwinDrawRectangle(0, COLOR_WHITE, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     if (value) {
-      dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
-      dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
-      dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
-      dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
-      dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
-      dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
+      dwinDrawLine(COLOR_CHECKBOX, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
+      dwinDrawLine(COLOR_CHECKBOX, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
+      dwinDrawLine(COLOR_CHECKBOX, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
+      dwinDrawLine(COLOR_CHECKBOX, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
+      dwinDrawLine(COLOR_CHECKBOX, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
+      dwinDrawLine(COLOR_CHECKBOX, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
     }
   #endif
 }
 
 void JyersDWIN::drawMenu(const uint8_t menu, const uint8_t select/*=0*/, const uint8_t scroll/*=0*/) {
   if (active_menu != menu) {
     last_menu = active_menu;
-    if (process == Menu) last_selection = selection;
+    if (process == Proc_Menu) last_selection = selection;
   }
   selection = _MIN(select, getMenuSize(menu));
   scrollpos = scroll;
   if (selection - scrollpos > MROWS) scrollpos = selection - MROWS; // i.e., NOLESS(scrollpos, selection - MROWS);
-  process = Menu;
+  process = Proc_Menu;
   active_menu = menu;
   clearScreen();
   drawTitle(getMenuTitle(menu));
   for (uint8_t i = 0; i < TROWS; ++i) menuItemHandler(menu, i + scrollpos);
-  dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
 
 void JyersDWIN::redrawMenu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
   switch (lastproc ? last_process : process) {
-    case Menu:
+    case Proc_Menu:
       drawMenu(lastmenu ? last_menu : active_menu, lastsel ? last_selection : selection, lastmenu ? 0 : scrollpos);
       break;
-    case Main:  drawMainMenu(lastsel ? last_selection : selection); break;
-    case Print: drawPrintScreen(); break;
-    case File:  drawSDList(); break;
+    case Proc_Main:  drawMainMenu(lastsel ? last_selection : selection); break;
+    case Proc_Print: drawPrintScreen(); break;
+    case Proc_File:  drawSDList(); break;
     default: break;
   }
 }
 
 void JyersDWIN::redrawScreen() {
   redrawMenu(false);
   drawStatusArea(true);
   updateStatusBar(true);
 }
 
 //
 // Primary Menus and Screen Elements
 //
 void JyersDWIN::mainMenuIcons() {
   if (selection == 0) {
     dwinIconShow(ICON, ICON_Print_1, 17, 130);
-    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 17, 130, 126, 229);
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 52, 200, F("Print"));
   }
   else {
     dwinIconShow(ICON, ICON_Print_0, 17, 130);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 52, 200, F("Print"));
   }
   if (selection == 1) {
     dwinIconShow(ICON, ICON_Prepare_1, 145, 130);
-    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 145, 130, 254, 229);
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 170, 200, F("Prepare"));
   }
   else {
     dwinIconShow(ICON, ICON_Prepare_0, 145, 130);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 170, 200, F("Prepare"));
   }
   if (selection == 2) {
     dwinIconShow(ICON, ICON_Control_1, 17, 246);
-    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 17, 246, 126, 345);
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 43, 317, F("Control"));
   }
   else {
     dwinIconShow(ICON, ICON_Control_0, 17, 246);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 43, 317, F("Control"));
   }
   #if HAS_ABL_OR_UBL
     if (selection == 3) {
       dwinIconShow(ICON, ICON_Leveling_1, 145, 246);
-      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 145, 246, 254, 345);
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 179, 317, F("Level"));
     }
     else {
       dwinIconShow(ICON, ICON_Leveling_0, 145, 246);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 179, 317, F("Level"));
     }
   #else
     if (selection == 3) {
       dwinIconShow(ICON, ICON_Info_1, 145, 246);
-      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 145, 246, 254, 345);
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 181, 317, F("Info"));
     }
     else {
       dwinIconShow(ICON, ICON_Info_0, 145, 246);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 181, 317, F("Info"));
     }
   #endif
 }
 
 void JyersDWIN::drawMainMenu(const uint8_t select/*=0*/) {
-  process = Main;
-  active_menu = MainMenu;
+  process = Proc_Main;
+  active_menu = ID_MainMenu;
   selection = select;
   clearScreen();
-  drawTitle(getMenuTitle(MainMenu));
+  drawTitle(getMenuTitle(ID_MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
   dwinIconShow(ICON, ICON_LOGO, 71, 72);
   mainMenuIcons();
 }
 
 void JyersDWIN::printScreenIcons() {
   if (selection == 0) {
     dwinIconShow(ICON, ICON_Setup_1, 8, 252);
-    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 8, 252, 87, 351);
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 30, 322, F("Tune"));
   }
   else {
     dwinIconShow(ICON, ICON_Setup_0, 8, 252);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 30, 322, F("Tune"));
   }
   if (selection == 2) {
     dwinIconShow(ICON, ICON_Stop_1, 184, 252);
-    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 184, 252, 263, 351);
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 205, 322, F("Stop"));
   }
   else {
     dwinIconShow(ICON, ICON_Stop_0, 184, 252);
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 205, 322, F("Stop"));
   }
   if (paused) {
     if (selection == 1) {
       dwinIconShow(ICON, ICON_Continue_1, 96, 252);
-      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 96, 252, 175, 351);
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Print"));
     }
     else {
       dwinIconShow(ICON, ICON_Continue_0, 96, 252);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Print"));
     }
   }
   else {
     if (selection == 1) {
       dwinIconShow(ICON, ICON_Pause_1, 96, 252);
-      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 96, 252, 175, 351);
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Pause"));
     }
     else {
       dwinIconShow(ICON, ICON_Pause_0, 96, 252);
-      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLUE, 114, 322, F("Pause"));
     }
   }
 }
 
 void JyersDWIN::drawPrintScreen() {
-  process = Print;
+  process = Proc_Print;
   selection = 0;
   clearScreen();
-  dwinDrawRectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+  dwinDrawRectangle(1, COLOR_BG_BLACK, 8, 352, DWIN_WIDTH - 8, 376);
   drawTitle("Printing...");
   printScreenIcons();
   dwinIconShow(ICON, ICON_PrintTime, 14, 171);
   dwinIconShow(ICON, ICON_RemainTime, 147, 169);
-  dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
-  dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
+  dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, 41, 163, F("Elapsed"));
+  dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, 176, 163, F("Remaining"));
   updateStatusBar(true);
   drawPrintProgressBar();
   drawPrintProgressElapsed();
   TERN_(SET_REMAINING_TIME, drawPrintProgressRemain());
   drawPrintFilename(true);
 }
 
 void JyersDWIN::drawPrintFilename(const bool reset/*=false*/) {
   typedef TextScroller<30> Scroller;
   static Scroller scroller;
   if (reset) scroller.reset();
-  if (process == Print) {
+  if (process == Proc_Print) {
     Scroller::Buffer buf;
     size_t outlen = 0;
     const char* outstr = scroller.scroll(outlen, buf, filename);
-    dwinDrawRectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 8, 50, DWIN_WIDTH - 8, 80);
     const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
-    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
+    dwinDrawString(false, DWIN_FONT_MENU, COLOR_WHITE, COLOR_BG_BLACK, npos, 60, outstr);
   }
 }
 
 void JyersDWIN::drawPrintProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
   dwinIconShow(ICON, ICON_Bar, 15, 93);
-  dwinDrawRectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
-  dwinDrawIntValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
-  dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
+  dwinDrawRectangle(1, COLOR_BARFILL, 16 + printpercent * 240 / 100, 93, 256, 113);
+  dwinDrawIntValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, COLOR_PERCENT), COLOR_BG_BLACK, 3, 109, 133, printpercent);
+  dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, COLOR_PERCENT), COLOR_BG_BLACK, 133, 133, F("%"));
 }
 
 #if ENABLED(SET_REMAINING_TIME)
 
   void JyersDWIN::drawPrintProgressRemain() {
     uint16_t remainingtime = ui.get_remaining_time();
-    dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
-    dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
+    dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 2, 176, 187, remainingtime / 3600);
+    dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 2, 200, 187, (remainingtime % 3600) / 60);
     if (eeprom_settings.time_format_textual) {
-      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
-      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 192, 187, F("h"));
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 216, 187, F("m"));
     }
     else
-      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 192, 187, F(":"));
   }
 
 #endif
 
 void JyersDWIN::drawPrintProgressElapsed() {
   duration_t elapsed = print_job_timer.duration();
-  dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
-  dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
+  dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 2, 42, 187, elapsed.value / 3600);
+  dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 2, 66, 187, (elapsed.value % 3600) / 60);
   if (eeprom_settings.time_format_textual) {
-    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
-    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
+    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 58, 187, F("h"));
+    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 82, 187, F("m"));
   }
   else
-    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
+    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, COLOR_WHITE), COLOR_BG_BLACK, 58, 187, F(":"));
 }
 
 void JyersDWIN::drawPrintConfirm() {
   drawPrintScreen();
-  process = Confirm;
-  popup = Complete;
-  dwinDrawRectangle(1, Color_Bg_Black, 8, 252, 263, 351);
+  process = Proc_Confirm;
+  popup = Popup_Complete;
+  dwinDrawRectangle(1, COLOR_BG_BLACK, 8, 252, 263, 351);
   dwinIconShow(ICON, ICON_Confirm_E, 87, 283);
-  dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
-  dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
+  dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 86, 282, 187, 321);
+  dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, COLOR_WHITE), 85, 281, 188, 322);
 }
 
 void JyersDWIN::drawSDItem(const uint8_t item, const uint8_t row) {
   if (item == 0)
     drawMenuItem(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
   else {
     card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
@@ -784,194 +784,194 @@ void JyersDWIN::drawSDItem(const uint8_t item, const uint8_t row) {
     name[len] = '\0';
     drawMenuItem(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
 void JyersDWIN::drawSDList(const bool removed/*=false*/) {
   clearScreen();
   drawTitle("Select File");
   selection = 0;
   scrollpos = 0;
-  process = File;
+  process = Proc_File;
   if (card.isMounted() && !removed) {
     for (uint8_t i = 0; i < _MIN(card.get_num_items() + 1, TROWS); ++i)
       drawSDItem(i, i);
   }
   else {
     drawMenuItem(0, ICON_Back, F("Back"));
-    dwinDrawRectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    dwinDrawString(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
+    dwinDrawRectangle(1, COLOR_BG_RED, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    dwinDrawString(false, font16x32, COLOR_YELLOW, COLOR_BG_RED, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
-  dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
+  dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
 void JyersDWIN::drawStatusArea(const bool icons/*=false*/) {
 
-  if (icons) dwinDrawRectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
+  if (icons) dwinDrawRectangle(1, COLOR_BG_BLACK, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
       dwinIconShow(ICON, ICON_HotendTemp, 10, 383);
-      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     }
     if (thermalManager.temp_hotend[0].celsius != hotend) {
       hotend = thermalManager.temp_hotend[0].celsius;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
-      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 3 * STAT_CHR_W + 5, 386);
     }
     if (thermalManager.temp_hotend[0].target != hotendtarget) {
       hotendtarget = thermalManager.temp_hotend[0].target;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
-      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 4 * STAT_CHR_W + 39, 386);
     }
     if (icons) {
       flow = -1;
       dwinIconShow(ICON, ICON_StepE, 112, 417);
-      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
     }
     if (planner.flow_percentage[0] != flow) {
       flow = planner.flow_percentage[0];
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     }
   #endif
 
   #if HAS_HEATED_BED
     static float bed = -1;
     static int16_t bedtarget = -1;
     if (icons) {
       bed = -1;
       bedtarget = -1;
       dwinIconShow(ICON, ICON_BedTemp, 10, 416);
-      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     }
     if (thermalManager.temp_bed.celsius != bed) {
       bed = thermalManager.temp_bed.celsius;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
-      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 28, 417, thermalManager.temp_bed.celsius);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 3 * STAT_CHR_W + 5, 419);
     }
     if (thermalManager.temp_bed.target != bedtarget) {
       bedtarget = thermalManager.temp_bed.target;
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
-      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, COLOR_WHITE), 25 + 4 * STAT_CHR_W + 39, 419);
     }
   #endif
 
   #if HAS_FAN
     static uint8_t fan = -1;
     if (icons) {
       fan = -1;
       dwinIconShow(ICON, ICON_FanSpeed, 187, 383);
     }
     if (thermalManager.fan_speed[0] != fan) {
       fan = thermalManager.fan_speed[0];
-      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
     }
   #endif
 
   #if HAS_ZOFFSET_ITEM
     static float offset = -1;
 
     if (icons) {
       offset = -1;
       dwinIconShow(ICON, ICON_Zoffset, 187, 416);
     }
     if (zoffsetvalue != offset) {
       offset = zoffsetvalue;
-      dwinDrawFloatValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
-      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
     }
   #endif
 
   static int16_t feedrate = -1;
   if (icons) {
     feedrate = -1;
     dwinIconShow(ICON, ICON_Speed, 113, 383);
-    dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+    dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
   }
   if (feedrate_percentage != feedrate) {
     feedrate = feedrate_percentage;
-    dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+    dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   }
 
   static float x = -1, y = -1, z = -1;
   static bool update_x = false, update_y = false, update_z = false;
   update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
   update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
   update_z = (current_position.z != z || axis_should_home(Z_AXIS) || update_z);
   if (icons) {
     x = y = z = -1;
-    dwinDrawLine(getColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
+    dwinDrawLine(getColor(eeprom_settings.coordinates_split_line, COLOR_LINE, true), 16, 450, 256, 450);
     dwinIconShow(ICON, ICON_MaxSpeedX,  10, 456);
     dwinIconShow(ICON, ICON_MaxSpeedY,  95, 456);
     dwinIconShow(ICON, ICON_MaxSpeedZ, 180, 456);
   }
   if (update_x) {
     x = current_position.x;
     if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
-      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, COLOR_WHITE), COLOR_BG_BLACK, 35, 459, F("  -?-  "));
     else
-      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x);
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 1, 35, 459, current_position.x);
   }
   if (update_y) {
     y = current_position.y;
     if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
-      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, COLOR_WHITE), COLOR_BG_BLACK, 120, 459, F("  -?-  "));
     else
-      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 1, 120, 459, current_position.y);
   }
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
-      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, COLOR_WHITE), COLOR_BG_BLACK, 205, 459, F("  -?-  "));
     else
-      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, current_position.z >= 0 ? current_position.z : 0);
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, COLOR_WHITE), COLOR_BG_BLACK, 3, 2, 205, 459, current_position.z >= 0 ? current_position.z : 0);
   }
   dwinUpdateLCD();
 }
 
 void JyersDWIN::drawPopup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
-  if (process != Confirm && process != Popup && process != Wait) last_process = process;
-  if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
+  if (process != Proc_Confirm && process != Proc_Popup && process != Proc_Wait) last_process = process;
+  if ((process == Proc_Menu || process == Proc_Wait) && mode == Proc_Popup) last_selection = selection;
   process = mode;
   clearScreen();
-  dwinDrawRectangle(0, Color_White, 13, 59, 259, 351);
-  dwinDrawRectangle(1, Color_Bg_Window, 14, 60, 258, 350);
-  const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
+  dwinDrawRectangle(0, COLOR_WHITE, 13, 59, 259, 351);
+  dwinDrawRectangle(1, COLOR_BG_WINDOW, 14, 60, 258, 350);
+  const uint8_t ypos = (mode == Proc_Popup || mode == Proc_Confirm) ? 150 : 230;
   if (icon > 0) dwinIconShow(ICON, icon, 101, 105);
-  dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
-  dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
-  dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
-  if (mode == Popup) {
+  dwinDrawString(true, DWIN_FONT_MENU, COLOR_POPUP_TEXT, COLOR_BG_WINDOW, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
+  dwinDrawString(true, DWIN_FONT_MENU, COLOR_POPUP_TEXT, COLOR_BG_WINDOW, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
+  dwinDrawString(true, DWIN_FONT_MENU, COLOR_POPUP_TEXT, COLOR_BG_WINDOW, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
+  if (mode == Proc_Popup) {
     selection = 0;
-    dwinDrawRectangle(1, Confirm_Color, 26, 280, 125, 317);
-    dwinDrawRectangle(1, Cancel_Color, 146, 280, 245, 317);
-    dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
-    dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
+    dwinDrawRectangle(1, COLOR_CONFIRM, 26, 280, 125, 317);
+    dwinDrawRectangle(1, COLOR_CANCEL, 146, 280, 245, 317);
+    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 39, 290, F("Confirm"));
+    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 165, 290, F("Cancel"));
     popupSelect();
   }
-  else if (mode == Confirm) {
-    dwinDrawRectangle(1, Confirm_Color, 87, 280, 186, 317);
-    dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
+  else if (mode == Proc_Confirm) {
+    dwinDrawRectangle(1, COLOR_CONFIRM, 87, 280, 186, 317);
+    dwinDrawString(false, DWIN_FONT_STAT, COLOR_WHITE, COLOR_BG_WINDOW, 96, 290, F("Continue"));
   }
 }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
-  jyersDWIN.drawPopup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
+  jyersDWIN.drawPopup(F("Printer Kill Reason:"), error, F("Restart Required"), Proc_Wait, ICON_BLTouch);
 }
 
 void JyersDWIN::popupSelect() {
-  const uint16_t c1 = selection ? Color_Bg_Window : getColor(eeprom_settings.highlight_box, Color_White),
-                 c2 = selection ? getColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window;
+  const uint16_t c1 = selection ? COLOR_BG_WINDOW : getColor(eeprom_settings.highlight_box, COLOR_WHITE),
+                 c2 = selection ? getColor(eeprom_settings.highlight_box, COLOR_WHITE) : COLOR_BG_WINDOW;
   dwinDrawRectangle(0, c1, 25, 279, 126, 318);
   dwinDrawRectangle(0, c1, 24, 278, 127, 319);
   dwinDrawRectangle(0, c2, 145, 279, 246, 318);
   dwinDrawRectangle(0, c2, 144, 278, 247, 319);
 }
 
 void JyersDWIN::updateStatusBar(const bool refresh/*=false*/) {
   typedef TextScroller<30> Scroller;
   static bool new_msg;
   static Scroller scroller;
@@ -979,29 +979,29 @@ void JyersDWIN::updateStatusBar(const bool refresh/*=false*/) {
   if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
     strcpy(lastmsg, statusmsg);
     scroller.reset();
     new_msg = true;
   }
   Scroller::Buffer buf;
   size_t len = 0;
   const char* dispmsg = scroller.scroll(len, buf, statusmsg, &new_msg);
   if (new_msg) {
     new_msg = false;
-    if (process == Print) {
-      dwinDrawRectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+    if (process == Proc_Print) {
+      dwinDrawRectangle(1, COLOR_GREY, 8, 214, DWIN_WIDTH - 8, 238);
       const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
-      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, COLOR_WHITE), COLOR_BG_BLACK, npos, 219, dispmsg);
     }
     else {
-      dwinDrawRectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+      dwinDrawRectangle(1, COLOR_BG_BLACK, 8, 352, DWIN_WIDTH - 8, 376);
       const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
-      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, COLOR_WHITE), COLOR_BG_BLACK, npos, 357, dispmsg);
     }
   }
 }
 
 //
 // Menu Item Config
 //
 
 void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool draw/*=true*/) {
   const uint8_t row = item - scrollpos;
@@ -1016,21 +1016,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
     #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
     #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
     #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
 
     auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
       switch (item) {
         case PREHEAT_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(TempMenu, sel);
+            drawMenu(ID_TempMenu, sel);
           break;
         #if HAS_HOTEND
           case PREHEAT_SUBMENU_HOTEND:
             if (draw) {
               drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
               drawFloat(ui.material_preset[index].hotend_temp, row, false, 1);
             }
             else
               modifyValue(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
@@ -1054,21 +1054,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else
               modifyValue(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
       }
     };
 
   #endif
 
   switch (menu) {
-    case Prepare:
+    case ID_Prepare:
 
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
       #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ANY(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
@@ -1079,212 +1079,212 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         case PREPARE_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
             drawMainMenu(1);
           break;
         case PREPARE_MOVE:
           if (draw)
             drawMenuItem(row, ICON_Axis, F("Move"), nullptr, true);
           else
-            drawMenu(Move);
+            drawMenu(ID_Move);
           break;
         case PREPARE_DISABLE:
           if (draw)
             drawMenuItem(row, ICON_CloseMotor, F("Disable Stepper"));
           else
             queue.inject(F("M84"));
           break;
         case PREPARE_HOME:
           if (draw)
             drawMenuItem(row, ICON_SetHome, F("Homing"), nullptr, true);
           else
-            drawMenu(HomeMenu);
+            drawMenu(ID_HomeMenu);
           break;
         case PREPARE_MANUALLEVEL:
           if (draw)
             drawMenuItem(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
           else {
             if (axes_should_home()) {
-              popupHandler(Home);
+              popupHandler(Popup_Home);
               gcode.home_all_axes(true);
             }
             #if HAS_LEVELING
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
             #endif
-            drawMenu(ManualLevel);
+            drawMenu(ID_ManualLevel);
           }
           break;
 
         #if HAS_ZOFFSET_ITEM
           case PREPARE_ZOFFSET:
             if (draw)
               drawMenuItem(row, ICON_Zoffset, F("Z-Offset"), nullptr, true);
             else {
               #if HAS_LEVELING
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
               #endif
-              drawMenu(ZOffset);
+              drawMenu(ID_ZOffset);
             }
             break;
         #endif
 
         #if HAS_PREHEAT
           case PREPARE_PREHEAT:
             if (draw)
               drawMenuItem(row, ICON_Temperature, F("Preheat"), nullptr, true);
             else
-              drawMenu(Preheat);
+              drawMenu(ID_Preheat);
             break;
         #endif
 
         #if HAS_HOTEND || HAS_HEATED_BED
           case PREPARE_COOLDOWN:
             if (draw)
               drawMenuItem(row, ICON_Cool, F("Cooldown"));
             else
               thermalManager.cooldown();
             break;
         #endif
 
         #if HAS_CUSTOM_MENU
           case PREPARE_CUSTOM_MENU:
             #ifndef CUSTOM_MENU_CONFIG_TITLE
               #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
             #endif
             if (draw)
               drawMenuItem(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
             else
-              drawMenu(MenuCustom);
+              drawMenu(ID_MenuCustom);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                drawMenu(ChangeFilament);
+                drawMenu(ID_ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                  popupHandler(ETemp);
+                  popupHandler(Popup_ETemp);
                 else {
                   if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                    popupHandler(Heating);
+                    popupHandler(Popup_Heating);
                     thermalManager.wait_for_hotend(0);
                   }
-                  popupHandler(FilChange);
+                  popupHandler(Popup_FilChange);
                   gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
                 }
               #endif
             }
             break;
         #endif
       }
       break;
 
-    case HomeMenu:
+    case ID_HomeMenu:
 
       #define HOME_BACK  0
       #define HOME_ALL   (HOME_BACK + 1)
       #define HOME_X     (HOME_ALL + 1)
       #define HOME_Y     (HOME_X + 1)
       #define HOME_Z     (HOME_Y + 1)
       #define HOME_SET   (HOME_Z + 1)
       #define HOME_TOTAL HOME_SET
 
       switch (item) {
         case HOME_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Prepare, PREPARE_HOME);
+            drawMenu(ID_Prepare, PREPARE_HOME);
           break;
         case HOME_ALL:
           if (draw)
             drawMenuItem(row, ICON_Homing, F("Home All"));
           else {
-            popupHandler(Home);
+            popupHandler(Popup_Home);
             gcode.home_all_axes(true);
             redrawMenu();
           }
           break;
         case HOME_X:
           if (draw)
             drawMenuItem(row, ICON_MoveX, F("Home X"));
           else {
-            popupHandler(Home);
+            popupHandler(Popup_Home);
             gcode.process_subcommands_now(F("G28 X"));
             planner.synchronize();
             redrawMenu();
           }
           break;
         case HOME_Y:
           if (draw)
             drawMenuItem(row, ICON_MoveY, F("Home Y"));
           else {
-            popupHandler(Home);
+            popupHandler(Popup_Home);
             gcode.process_subcommands_now(F("G28 Y"));
             planner.synchronize();
             redrawMenu();
           }
           break;
         case HOME_Z:
           if (draw)
             drawMenuItem(row, ICON_MoveZ, F("Home Z"));
           else {
-            popupHandler(Home);
+            popupHandler(Popup_Home);
             gcode.process_subcommands_now(F("G28 Z"));
             planner.synchronize();
             redrawMenu();
           }
           break;
         case HOME_SET:
           if (draw)
             drawMenuItem(row, ICON_SetHome, F("Set Home Position"));
           else {
             gcode.process_subcommands_now(F("G92X0Y0Z0"));
             audioFeedback();
           }
           break;
       }
       break;
 
-    case Move:
+    case ID_Move:
 
       #define MOVE_BACK 0
       #define MOVE_X (MOVE_BACK + 1)
       #define MOVE_Y (MOVE_X + 1)
       #define MOVE_Z (MOVE_Y + 1)
       #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
       #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
       #define MOVE_LIVE (MOVE_P + 1)
       #define MOVE_TOTAL MOVE_LIVE
 
       switch (item) {
         case MOVE_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else {
             #if HAS_BED_PROBE
               probe_deployed = false;
               probe.set_deployed(probe_deployed);
             #endif
-            drawMenu(Prepare, PREPARE_MOVE);
+            drawMenu(ID_Prepare, PREPARE_MOVE);
           }
           break;
         case MOVE_X:
           if (draw) {
             drawMenuItem(row, ICON_MoveX, F("Move X"));
             drawFloat(current_position.x, row, false);
           }
           else
             modifyValue(current_position.x, X_MIN_POS, X_MAX_POS, 10);
           break;
@@ -1308,25 +1308,25 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #if HAS_HOTEND
           case MOVE_E:
             if (draw) {
               drawMenuItem(row, ICON_Extruder, F("Extruder"));
               current_position.e = 0;
               sync_plan_position();
               drawFloat(current_position.e, row);
             }
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
-                popupHandler(ETemp);
+                popupHandler(Popup_ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  popupHandler(Heating);
+                  popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                   redrawMenu();
                 }
                 current_position.e = 0;
                 sync_plan_position();
                 modifyValue(current_position.e, -500, 500, 10);
               }
             }
           break;
         #endif // HAS_HOTEND
@@ -1350,21 +1350,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawMenuItem(row, ICON_Axis, F("Live Movement"));
             drawCheckbox(row, livemove);
           }
           else {
             livemove = !livemove;
             drawCheckbox(row, livemove);
           }
           break;
       }
       break;
-    case ManualLevel: {
+    case ID_ManualLevel: {
 
       #define MLEVEL_BACK 0
       #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
       #define MLEVEL_BL (MLEVEL_PROBE + 1)
       #define MLEVEL_TL (MLEVEL_BL + 1)
       #define MLEVEL_TR (MLEVEL_TL + 1)
       #define MLEVEL_BR (MLEVEL_TR + 1)
       #define MLEVEL_C (MLEVEL_BR + 1)
       #define MLEVEL_ZPOS (MLEVEL_C + 1)
       #define MLEVEL_TOTAL MLEVEL_ZPOS
@@ -1378,35 +1378,35 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                     probe_y_min = _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y,
                     probe_y_max = _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y;
       #endif
 
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
-            drawMenu(Prepare, PREPARE_MANUALLEVEL);
+            drawMenu(ID_Prepare, PREPARE_MANUALLEVEL);
           }
           break;
 
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
               drawMenuItem(row, ICON_Zoffset, F("Use Probe"));
               drawCheckbox(row, use_probe);
             }
             else {
               use_probe ^= true;
               drawCheckbox(row, use_probe);
               if (use_probe) {
-                popupHandler(Level);
+                popupHandler(Popup_Level);
                 const struct { xy_pos_t p; ProbePtRaise r; } points[] = {
                   { { probe_x_min, probe_y_min }, PROBE_PT_RAISE },
                   { { probe_x_min, probe_y_max }, PROBE_PT_RAISE },
                   { { probe_x_max, probe_y_max }, PROBE_PT_RAISE },
                   { { probe_x_max, probe_y_min }, PROBE_PT_STOW }
                 };
                 corner_avg = 0;
                 for (uint8_t i = 0; i < COUNT(points); i++) {
                   const float mz = probe.probe_at_point(points[i].p, points[i].r, 0, false);
                   if (isnan(mz)) { corner_avg = 0; break; }
@@ -1416,120 +1416,120 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 redrawMenu();
               }
             }
             break;
         #endif
 
         case MLEVEL_BL:
           if (draw)
             drawMenuItem(row, ICON_AxisBL, F("Bottom Left"));
           else {
-            popupHandler(MoveWait);
+            popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_min, 3), 'Y', p_float_t(probe_y_min, 3))
                 );
                 planner.synchronize();
-                popupHandler(ManualProbing);
+                popupHandler(Popup_ManualProbing);
               #endif
             }
             else {
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(corner_pos, 3), 'Y', p_float_t(corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
             drawMenuItem(row, ICON_AxisTL, F("Top Left"));
           else {
-            popupHandler(MoveWait);
+            popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_min, 3), 'Y', p_float_t(probe_y_max, 3))
                 );
                 planner.synchronize();
-                popupHandler(ManualProbing);
+                popupHandler(Popup_ManualProbing);
               #endif
             }
             else {
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
             drawMenuItem(row, ICON_AxisTR, F("Top Right"));
           else {
-            popupHandler(MoveWait);
+            popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_max, 3), 'Y', p_float_t(probe_y_max, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
                 );
                 planner.synchronize();
-                popupHandler(ManualProbing);
+                popupHandler(Popup_ManualProbing);
               #endif
             }
             else {
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
             drawMenuItem(row, ICON_AxisBR, F("Bottom Right"));
           else {
-            popupHandler(MoveWait);
+            popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_max, 3), 'Y', p_float_t(probe_y_min, 3))
                 );
                 planner.synchronize();
-                popupHandler(ManualProbing);
+                popupHandler(Popup_ManualProbing);
               #endif
             }
             else {
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t(corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
             drawMenuItem(row, ICON_AxisC, F("Center"));
           else {
-            popupHandler(MoveWait);
+            popupHandler(Popup_MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 gcode.process_subcommands_now(
                   TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_MAX_POS) / 2.0f - probe.offset.x, 3), 'Y', p_float_t((Y_MAX_POS) / 2.0f - probe.offset.y, 3))
                 );
                 planner.synchronize();
-                popupHandler(ManualProbing);
+                popupHandler(Popup_ManualProbing);
               #endif
             }
             else {
               gcode.process_subcommands_now(
                 TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
               );
               planner.synchronize();
               redrawMenu();
             }
           }
@@ -1540,48 +1540,48 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawFloat(mlev_z_pos, row, false, 100);
           }
           else
             modifyValue(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
           break;
       }
 
     } break;
 
     #if HAS_ZOFFSET_ITEM
-      case ZOffset:
+      case ID_ZOffset:
 
         #define ZOFFSET_BACK 0
         #define ZOFFSET_HOME (ZOFFSET_BACK + 1)
         #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
         #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
         #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
         #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
         #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
         #define ZOFFSET_TOTAL ZOFFSET_SAVE
 
         switch (item) {
           case ZOFFSET_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else {
               liveadjust = false;
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
-              drawMenu(Prepare, PREPARE_ZOFFSET);
+              drawMenu(ID_Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
               drawMenuItem(row, ICON_Homing, F("Home Z Axis"));
             else {
-              popupHandler(Home);
+              popupHandler(Popup_Home);
               gcode.process_subcommands_now(F("G28Z"));
-              popupHandler(MoveWait);
+              popupHandler(Popup_MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 gcode.process_subcommands_now(
                   TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3))
                 );
               #else
                 gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
               #endif
               gcode.process_subcommands_now(F("G0F300Z0"));
               planner.synchronize();
@@ -1589,24 +1589,24 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             }
             break;
           case ZOFFSET_MODE:
             if (draw) {
               drawMenuItem(row, ICON_Zoffset, F("Live Adjustment"));
               drawCheckbox(row, liveadjust);
             }
             else {
               if (!liveadjust) {
                 if (axes_should_home()) {
-                  popupHandler(Home);
+                  popupHandler(Popup_Home);
                   gcode.home_all_axes(true);
                 }
-                popupHandler(MoveWait);
+                popupHandler(Popup_MoveWait);
                 #if ENABLED(Z_SAFE_HOMING)
                   planner.synchronize();
                   gcode.process_subcommands_now(
                     TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3))
                   );
                 #else
                   gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
                 #endif
                 gcode.process_subcommands_now(F("G0F300Z0"));
                 planner.synchronize();
@@ -1658,41 +1658,41 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawMenuItem(row, ICON_WriteEEPROM, F("Save"));
               else
                 audioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
 
     #if HAS_PREHEAT
-      case Preheat: {
+      case ID_Preheat: {
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
         #define PREHEAT_1 (PREHEAT_MODE + 1)
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
         auto do_preheat = [](const uint8_t m) {
           thermalManager.cooldown();
           if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
           if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
         };
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Prepare, PREPARE_PREHEAT);
+              drawMenu(ID_Prepare, PREPARE_PREHEAT);
             break;
 
           case PREHEAT_MODE:
             if (draw) {
               drawMenuItem(row, ICON_Homing, F("Preheat Mode"));
               drawOption(preheatmode, preheat_modes, row);
             }
             else
               modifyOption(preheatmode, preheat_modes, 2);
             break;
@@ -1702,213 +1702,213 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               if (draw) drawMenuItem(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
               else do_preheat(N - 1); \
             } break;
 
           REPEAT_1(PREHEAT_COUNT, _PREHEAT_CASE)
         }
       } break;
     #endif // HAS_PREHEAT
 
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:
+      case ID_ChangeFilament:
 
         #define CHANGEFIL_BACK 0
         #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
         #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
         #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
 
         switch (item) {
           case CHANGEFIL_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Prepare, PREPARE_CHANGEFIL);
+              drawMenu(ID_Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
               drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                popupHandler(ETemp);
+                popupHandler(Popup_ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  popupHandler(Heating);
+                  popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
-                popupHandler(FilLoad);
+                popupHandler(Popup_FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 redrawMenu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
               drawMenuItem(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
-                popupHandler(ETemp);
+                popupHandler(Popup_ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  popupHandler(Heating);
+                  popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
-                popupHandler(FilLoad, true);
+                popupHandler(Popup_FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 redrawMenu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                popupHandler(ETemp);
+                popupHandler(Popup_ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  popupHandler(Heating);
+                  popupHandler(Popup_Heating);
                   thermalManager.wait_for_hotend(0);
                 }
-                popupHandler(FilChange);
+                popupHandler(Popup_FilChange);
                 gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.temp_hotend[0].target));
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
     #if HAS_CUSTOM_MENU
 
-      case MenuCustom:
+      case ID_MenuCustom:
 
         #define CUSTOM_MENU_BACK 0
         #define CUSTOM_MENU_1 1
         #define CUSTOM_MENU_2 2
         #define CUSTOM_MENU_3 3
         #define CUSTOM_MENU_4 4
         #define CUSTOM_MENU_5 5
         #define CUSTOM_MENU_TOTAL CUSTOM_MENU_COUNT
 
         switch (item) {
           case CUSTOM_MENU_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Prepare, PREPARE_CUSTOM_MENU);
+              drawMenu(ID_Prepare, PREPARE_CUSTOM_MENU);
             break;
 
           #if CUSTOM_MENU_COUNT >= 1
             case CUSTOM_MENU_1:
               if (draw)
                 drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
               else {
-                popupHandler(Custom);
+                popupHandler(Popup_Custom);
                 //queue.inject(F(CONFIG_MENU_ITEM_1_GCODE)); // Old code
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_1_GCODE));
                 planner.synchronize();
                 redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
                   audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 2
             case CUSTOM_MENU_2:
               if (draw)
                 drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_2_DESC));
               else {
-                popupHandler(Custom);
+                popupHandler(Popup_Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_2_GCODE));
                 planner.synchronize();
                 redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
                   audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 3
             case CUSTOM_MENU_3:
               if (draw)
                 drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_3_DESC));
               else {
-                popupHandler(Custom);
+                popupHandler(Popup_Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_3_GCODE));
                 planner.synchronize();
                 redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
                   audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 4
             case CUSTOM_MENU_4:
               if (draw)
                 drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_4_DESC));
               else {
-                popupHandler(Custom);
+                popupHandler(Popup_Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_4_GCODE));
                 planner.synchronize();
                 redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
                   audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 5
             case CUSTOM_MENU_5:
               if (draw)
                 drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_5_DESC));
               else {
-                popupHandler(Custom);
+                popupHandler(Popup_Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_5_GCODE));
                 planner.synchronize();
                 redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
                   audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif // Custom Menu
         }
         break;
 
     #endif // HAS_CUSTOM_MENU
 
-    case Control:
+    case ID_Control:
 
       #define CONTROL_BACK 0
       #define CONTROL_TEMP (CONTROL_BACK + 1)
       #define CONTROL_MOTION (CONTROL_TEMP + 1)
       #define CONTROL_VISUAL (CONTROL_MOTION + 1)
       #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
       #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_INFO (CONTROL_RESET + 1)
@@ -1918,39 +1918,39 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         case CONTROL_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
             drawMainMenu(2);
           break;
         case CONTROL_TEMP:
           if (draw)
             drawMenuItem(row, ICON_Temperature, F("Temperature"), nullptr, true);
           else
-            drawMenu(TempMenu);
+            drawMenu(ID_TempMenu);
           break;
         case CONTROL_MOTION:
           if (draw)
             drawMenuItem(row, ICON_Motion, F("Motion"), nullptr, true);
           else
-            drawMenu(Motion);
+            drawMenu(ID_Motion);
           break;
         case CONTROL_VISUAL:
           if (draw)
             drawMenuItem(row, ICON_PrintSize, F("Visual"), nullptr, true);
           else
-            drawMenu(Visual);
+            drawMenu(ID_Visual);
           break;
         case CONTROL_ADVANCED:
           if (draw)
             drawMenuItem(row, ICON_Version, F("Advanced"), nullptr, true);
           else
-            drawMenu(Advanced);
+            drawMenu(ID_Advanced);
           break;
         #if ENABLED(EEPROM_SETTINGS)
           case CONTROL_SAVE:
             if (draw)
               drawMenuItem(row, ICON_WriteEEPROM, F("Store Settings"));
             else
               audioFeedback(settings.save());
             break;
           case CONTROL_RESTORE:
             if (draw)
@@ -1964,46 +1964,46 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               settings.reset();
               audioFeedback();
             }
             break;
         #endif
         case CONTROL_INFO:
           if (draw)
             drawMenuItem(row, ICON_Info, F("Info"));
           else
-            drawMenu(Info);
+            drawMenu(ID_Info);
           break;
       }
       break;
 
-    case TempMenu:
+    case ID_TempMenu:
 
       #define TEMP_BACK 0
       #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
       #define TEMP_BED (TEMP_HOTEND + ENABLED(HAS_HEATED_BED))
       #define TEMP_FAN (TEMP_BED + ENABLED(HAS_FAN))
       #define TEMP_PID (TEMP_FAN + ANY(PIDTEMP, PIDTEMPBED))
       #define TEMP_MPC (TEMP_PID + ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU))
       #define TEMP_PREHEAT1 (TEMP_MPC + (PREHEAT_COUNT >= 1))
       #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
       #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
       #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
       #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
       #define TEMP_TOTAL TEMP_PREHEAT5
 
       switch (item) {
         case TEMP_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Control, CONTROL_TEMP);
+            drawMenu(ID_Control, CONTROL_TEMP);
           break;
         #if HAS_HOTEND
           case TEMP_HOTEND:
             if (draw) {
               drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
               drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
@@ -2026,113 +2026,113 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             }
             else
               modifyValue(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
         #if ANY(PIDTEMP, PIDTEMPBED)
           case TEMP_PID:
             if (draw)
               drawMenuItem(row, ICON_Step, F("PID"), nullptr, true);
             else
-              drawMenu(PID);
+              drawMenu(ID_PID);
             break;
         #endif
         #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
           case TEMP_MPC:
             if (draw)
               drawMenuItem(row, ICON_Step, F("MPC"), nullptr, true);
             else
-              drawMenu(MPC);
+              drawMenu(ID_MPC);
             break;
         #endif
 
         #define _TEMP_PREHEAT_CASE(N) \
           case TEMP_PREHEAT##N: { \
             if (draw) drawMenuItem(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
-            else drawMenu(Preheat##N); \
+            else drawMenu(ID_Preheat##N); \
           } break;
 
         REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
       }
       break;
 
     #if ANY(PIDTEMP, PIDTEMPBED)
-      case PID:
+      case ID_PID:
 
         #define PID_BACK 0
         #define PID_HOTEND (PID_BACK + ENABLED(PIDTEMP))
         #define PID_BED (PID_HOTEND + ENABLED(PIDTEMPBED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
         switch (item) {
           case PID_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(TempMenu, TEMP_PID);
+              drawMenu(ID_TempMenu, TEMP_PID);
             break;
           #if ENABLED(PIDTEMP)
             case PID_HOTEND:
               if (draw)
                 drawMenuItem(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
               else
-                drawMenu(HotendPID);
+                drawMenu(ID_HotendPID);
               break;
           #endif
           #if ENABLED(PIDTEMPBED)
             case PID_BED:
               if (draw)
                 drawMenuItem(row, ICON_BedTemp, F("Bed"), nullptr, true);
               else
-                drawMenu(BedPID);
+                drawMenu(ID_BedPID);
               break;
           #endif
           case PID_CYCLES:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Cycles"));
               drawFloat(PID_cycles, row, false, 1);
             }
             else
               modifyValue(PID_cycles, 3, 50, 1);
             break;
         }
         break;
     #endif // PIDTEMP || PIDTEMPBED
 
     #if ENABLED(PIDTEMP)
-      case HotendPID:
+      case ID_HotendPID:
 
         #define HOTENDPID_BACK 0
         #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
         #define HOTENDPID_TEMP (HOTENDPID_TUNE + 1)
         #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
         #define HOTENDPID_KI (HOTENDPID_KP + 1)
         #define HOTENDPID_KD (HOTENDPID_KI + 1)
         #define HOTENDPID_TOTAL HOTENDPID_KD
 
         static uint16_t PID_e_temp = 180;
 
         switch (item) {
           case HOTENDPID_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(PID, PID_HOTEND);
+              drawMenu(ID_PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
               drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
             else {
-              popupHandler(PIDWait);
+              popupHandler(Popup_PIDWait);
               gcode.process_subcommands_now(TS(F("M303E0C"), PID_cycles, 'S', PID_e_temp, 'U'));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
               drawMenuItem(row, ICON_Temperature, F("Temperature"));
               drawFloat(PID_e_temp, row, false, 1);
             }
@@ -2161,44 +2161,44 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawFloat(thermalManager.temp_hotend[0].pid.d(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // PIDTEMP
 
     #if ENABLED(PIDTEMPBED)
-      case BedPID:
+      case ID_BedPID:
 
         #define BEDPID_BACK 0
         #define BEDPID_TUNE (BEDPID_BACK + 1)
         #define BEDPID_TEMP (BEDPID_TUNE + 1)
         #define BEDPID_KP (BEDPID_TEMP + 1)
         #define BEDPID_KI (BEDPID_KP + 1)
         #define BEDPID_KD (BEDPID_KI + 1)
         #define BEDPID_TOTAL BEDPID_KD
 
         static uint16_t PID_bed_temp = 60;
 
         switch (item) {
           case BEDPID_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(PID, PID_BED);
+              drawMenu(ID_PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
               drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
             else {
-              popupHandler(PIDWait);
+              popupHandler(Popup_PIDWait);
               gcode.process_subcommands_now(TS(F("M303E-1C"), PID_cycles, 'S', PID_bed_temp, 'U'));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
               drawMenuItem(row, ICON_Temperature, F("Temperature"));
               drawFloat(PID_bed_temp, row, false, 1);
             }
@@ -2227,45 +2227,45 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawFloat(thermalManager.temp_bed.pid.d(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
         }
         break;
     #endif // PIDTEMPBED
 
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
-      case MPC:
+      case ID_MPC:
 
         #define MPCMENU_BACK 0
         #define MPCMENU_AUTOTUNE (MPCMENU_BACK + ENABLED(MPC_AUTOTUNE_MENU))
         #define MPCMENU_HEATER_POWER (MPCMENU_AUTOTUNE + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_BLOCK_HEAT_CAPACITY (MPCMENU_HEATER_POWER + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_SENSOR_RESPONSIVENESS (MPCMENU_BLOCK_HEAT_CAPACITY + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_AMBIENT_XFER_COEFF (MPCMENU_SENSOR_RESPONSIVENESS + ENABLED(MPC_EDIT_MENU))
         #define MPCMENU_AMBIENT_XFER_COEFF_FAN (MPCMENU_AMBIENT_XFER_COEFF + ALL(MPC_EDIT_MENU, MPC_INCLUDE_FAN))
         #define MPCMENU_TOTAL MPCMENU_AMBIENT_XFER_COEFF_FAN
 
         switch (item) {
           case MPCMENU_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(TempMenu, TEMP_MPC);
+              drawMenu(ID_TempMenu, TEMP_MPC);
             break;
 
           #if ENABLED(MPC_AUTOTUNE_MENU)
             case MPCMENU_AUTOTUNE:
               if (draw)
                 drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
               else {
-                popupHandler(MPCWait);
+                popupHandler(Popup_MPCWait);
                 thermalManager.MPC_autotune(active_extruder, Temperature::MPCTuningType::AUTO);
                 redrawMenu();
               }
               break;
           #endif
 
           #if ENABLED(MPC_EDIT_MENU)
             case MPCMENU_HEATER_POWER:
               if (draw) {
                 drawMenuItem(row, ICON_Version, F("Heater Power"));
@@ -2315,134 +2315,134 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               } break;
             #endif
 
           #endif // MPC_EDIT_MENU
         }
         break;
 
     #endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
 
     #if HAS_PREHEAT
-      #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
+      #define _PREHEAT_SUBMENU_CASE(N) case ID_Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
-    case Motion:
+    case ID_Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
       #define MOTION_STEPS (MOTION_JERK + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
       #define MOTION_TOTAL MOTION_FLOW
 
       switch (item) {
         case MOTION_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Control, CONTROL_MOTION);
+            drawMenu(ID_Control, CONTROL_MOTION);
           break;
         case MOTION_HOMEOFFSETS:
           if (draw)
             drawMenuItem(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
           else
-            drawMenu(HomeOffsets);
+            drawMenu(ID_HomeOffsets);
           break;
         case MOTION_SPEED:
           if (draw)
             drawMenuItem(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
           else
-            drawMenu(MaxSpeed);
+            drawMenu(ID_MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
             drawMenuItem(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
           else
-            drawMenu(MaxAcceleration);
+            drawMenu(ID_MaxAcceleration);
           break;
         #if HAS_CLASSIC_JERK
           case MOTION_JERK:
             if (draw)
               drawMenuItem(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
             else
-              drawMenu(MaxJerk);
+              drawMenu(ID_MaxJerk);
             break;
         #endif
         case MOTION_STEPS:
           if (draw)
             drawMenuItem(row, ICON_Step, F("Steps/mm"), nullptr, true);
           else
-            drawMenu(Steps);
+            drawMenu(ID_Steps);
           break;
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
               drawMenuItem(row, ICON_Speed, F("Flow Rate"));
               drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
               modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
         #endif
       }
       break;
 
-    case HomeOffsets:
+    case ID_HomeOffsets:
 
       #define HOMEOFFSETS_BACK 0
       #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
       #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
       #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
 
       switch (item) {
         case HOMEOFFSETS_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Motion, MOTION_HOMEOFFSETS);
+            drawMenu(ID_Motion, MOTION_HOMEOFFSETS);
           break;
         case HOMEOFFSETS_XOFFSET:
           if (draw) {
             drawMenuItem(row, ICON_StepX, F("X Offset"));
             drawFloat(home_offset.x, row, false, 100);
           }
           else
             modifyValue(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
         case HOMEOFFSETS_YOFFSET:
           if (draw) {
             drawMenuItem(row, ICON_StepY, F("Y Offset"));
             drawFloat(home_offset.y, row, false, 100);
           }
           else
             modifyValue(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
       }
       break;
-    case MaxSpeed:
+    case ID_MaxSpeed:
 
       #define SPEED_BACK 0
       #define SPEED_X (SPEED_BACK + 1)
       #define SPEED_Y (SPEED_X + 1)
       #define SPEED_Z (SPEED_Y + 1)
       #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
       #define SPEED_TOTAL SPEED_E
 
       switch (item) {
         case SPEED_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Motion, MOTION_SPEED);
+            drawMenu(ID_Motion, MOTION_SPEED);
           break;
         #if HAS_X_AXIS
           case SPEED_X:
             if (draw) {
               drawMenuItem(row, ICON_MaxSpeedX, F("X Axis"));
               drawFloat(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
               modifyValue(planner.settings.max_feedrate_mm_s[X_AXIS], min_feedrate_edit_values.x, max_feedrate_edit_values.x, FEEDRATE_UNIT);
             break;
@@ -2476,35 +2476,35 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenuItem(row, ICON_MaxSpeedE, F("Extruder"));
               drawFloat(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
               modifyValue(planner.settings.max_feedrate_mm_s[E_AXIS], min_feedrate_edit_values.e, max_feedrate_edit_values.e, FEEDRATE_UNIT);
             break;
         #endif
       }
       break;
 
-    case MaxAcceleration:
+    case ID_MaxAcceleration:
 
       #define ACCEL_BACK 0
       #define ACCEL_X (ACCEL_BACK + 1)
       #define ACCEL_Y (ACCEL_X + 1)
       #define ACCEL_Z (ACCEL_Y + 1)
       #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
       #define ACCEL_TOTAL ACCEL_E
 
       switch (item) {
         case ACCEL_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Motion, MOTION_ACCEL);
+            drawMenu(ID_Motion, MOTION_ACCEL);
           break;
         case ACCEL_X:
           if (draw) {
             drawMenuItem(row, ICON_MaxAccX, F("X Axis"));
             drawFloat(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
             modifyValue(planner.settings.max_acceleration_mm_per_s2[X_AXIS], min_acceleration_edit_values.x, max_acceleration_edit_values.x, ACCELERATION_UNIT);
           break;
         case ACCEL_Y:
@@ -2529,35 +2529,35 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenuItem(row, ICON_MaxAccE, F("Extruder"));
               drawFloat(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, ACCELERATION_UNIT);
             }
             else
               modifyValue(planner.settings.max_acceleration_mm_per_s2[E_AXIS], min_acceleration_edit_values.e, max_acceleration_edit_values.e, ACCELERATION_UNIT);
             break;
         #endif
       }
       break;
     #if HAS_CLASSIC_JERK
-      case MaxJerk:
+      case ID_MaxJerk:
 
         #define JERK_BACK 0
         #define JERK_X (JERK_BACK + 1)
         #define JERK_Y (JERK_X + 1)
         #define JERK_Z (JERK_Y + 1)
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
           case JERK_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Motion, MOTION_JERK);
+              drawMenu(ID_Motion, MOTION_JERK);
             break;
           #if HAS_X_AXIS
             case JERK_X:
               if (draw) {
                 drawMenuItem(row, ICON_MaxSpeedJerkX, F("X Axis"));
                 drawFloat(planner.max_jerk.x, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.x, min_jerk_edit_values.x, max_jerk_edit_values.x, JERK_UNIT);
               break;
@@ -2588,35 +2588,35 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawMenuItem(row, ICON_MaxSpeedJerkE, F("Extruder"));
                 drawFloat(planner.max_jerk.e, row, false, JERK_UNIT);
               }
               else
                 modifyValue(planner.max_jerk.e, min_jerk_edit_values.e, max_jerk_edit_values.e, JERK_UNIT);
               break;
           #endif
         }
         break;
     #endif
-    case Steps:
+    case ID_Steps:
 
       #define STEPS_BACK 0
       #define STEPS_X (STEPS_BACK + 1)
       #define STEPS_Y (STEPS_X + 1)
       #define STEPS_Z (STEPS_Y + 1)
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Motion, MOTION_STEPS);
+            drawMenu(ID_Motion, MOTION_STEPS);
           break;
         #if HAS_X_AXIS
           case STEPS_X:
             if (draw) {
               drawMenuItem(row, ICON_StepX, F("X Axis"));
               drawFloat(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
             }
             else
               modifyValue(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
             break;
@@ -2647,35 +2647,35 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenuItem(row, ICON_StepE, F("Extruder"));
               drawFloat(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
             }
             else
               modifyValue(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
             break;
         #endif
       }
       break;
 
-    case Visual:
+    case ID_Visual:
 
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
       #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
       #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
       #define VISUAL_TOTAL VISUAL_COLOR_THEMES
 
       switch (item) {
         case VISUAL_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Control, CONTROL_VISUAL);
+            drawMenu(ID_Control, CONTROL_VISUAL);
           break;
         case VISUAL_BACKLIGHT:
           if (draw)
             drawMenuItem(row, ICON_Brightness, F("Display Off"));
           else
             ui.set_brightness(0);
           break;
         case VISUAL_BRIGHTNESS:
           if (draw) {
             drawMenuItem(row, ICON_Brightness, F("LCD Brightness"));
@@ -2691,47 +2691,47 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           }
           else {
             eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
             drawCheckbox(row, eeprom_settings.time_format_textual);
           }
           break;
         case VISUAL_COLOR_THEMES:
           if (draw)
             drawMenuItem(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
           else
-            drawMenu(ColorSettings);
+            drawMenu(ID_ColorSettings);
         break;
       }
       break;
 
-    case ColorSettings:
+    case ID_ColorSettings:
 
       #define COLORSETTINGS_BACK 0
       #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
       #define COLORSETTINGS_SPLIT_LINE (COLORSETTINGS_CURSOR + 1)
       #define COLORSETTINGS_MENU_TOP_TXT (COLORSETTINGS_SPLIT_LINE + 1)
       #define COLORSETTINGS_MENU_TOP_BG (COLORSETTINGS_MENU_TOP_TXT + 1)
       #define COLORSETTINGS_HIGHLIGHT_BORDER (COLORSETTINGS_MENU_TOP_BG + 1)
       #define COLORSETTINGS_PROGRESS_PERCENT (COLORSETTINGS_HIGHLIGHT_BORDER + 1)
       #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
       #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
 
       switch (item) {
         case COLORSETTINGS_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Visual, VISUAL_COLOR_THEMES);
+            drawMenu(ID_Visual, VISUAL_COLOR_THEMES);
           break;
         case COLORSETTINGS_CURSOR:
           if (draw) {
             drawMenuItem(row, ICON_MaxSpeed, F("Cursor"));
             drawOption(eeprom_settings.cursor_color, color_names, row, false, true);
           }
           else
             modifyOption(eeprom_settings.cursor_color, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_SPLIT_LINE:
@@ -2810,72 +2810,72 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           if (draw) {
             drawMenuItem(row, ICON_MaxSpeed, F("Coordinates Line"));
             drawOption(eeprom_settings.coordinates_split_line, color_names, row, false, true);
           }
           else
             modifyOption(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
           break;
       } // switch (item)
       break;
 
-    case Advanced:
+    case ID_Advanced:
 
       #define ADVANCED_BACK 0
       #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
       #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
       #define ADVANCED_TMC (ADVANCED_PROBE + ENABLED(HAS_TRINAMIC_CONFIG))
       #define ADVANCED_CORNER (ADVANCED_TMC + 1)
       #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
       #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
       #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
 
       switch (item) {
         case ADVANCED_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
           else
-            drawMenu(Control, CONTROL_ADVANCED);
+            drawMenu(ID_Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
               drawMenuItem(row, ICON_Version, F("LCD Beeper"));
               drawCheckbox(row, ui.sound_on);
             }
             else {
               ui.sound_on = !ui.sound_on;
               drawCheckbox(row, ui.sound_on);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
               drawMenuItem(row, ICON_StepX, F("Probe"), nullptr, true);
             else
-              drawMenu(ProbeMenu);
+              drawMenu(ID_ProbeMenu);
             break;
         #endif
 
         #if HAS_TRINAMIC_CONFIG
           case ADVANCED_TMC:
             if (draw)
               drawMenuItem(row, ICON_Motion, F("TMC Drivers"), nullptr, true);
             else
-              drawMenu(TMCMenu);
+              drawMenu(ID_TMCMenu);
             break;
         #endif
 
         case ADVANCED_CORNER:
           if (draw) {
             drawMenuItem(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
             drawFloat(corner_pos, row, false, 10);
           }
           else
             modifyValue(corner_pos, 1, 100, 10);
@@ -2957,37 +2957,37 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               recovery.enable(!recovery.enabled);
               drawCheckbox(row, recovery.enabled);
             }
             break;
         #endif
       }
       break;
 
     #if HAS_BED_PROBE
-      case ProbeMenu:
+      case ID_ProbeMenu:
 
         #define PROBE_BACK 0
         #define PROBE_XOFFSET (PROBE_BACK + 1)
         #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
         #define PROBE_TEST (PROBE_YOFFSET + 1)
         #define PROBE_TEST_COUNT (PROBE_TEST + 1)
         #define PROBE_TOTAL PROBE_TEST_COUNT
 
         static uint8_t testcount = 4;
 
         switch (item) {
           case PROBE_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Advanced, ADVANCED_PROBE);
+              drawMenu(ID_Advanced, ADVANCED_PROBE);
             break;
 
             case PROBE_XOFFSET:
               if (draw) {
                 drawMenuItem(row, ICON_StepX, F("Probe X Offset"));
                 drawFloat(probe.offset.x, row, false, 10);
               }
               else
                 modifyValue(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
@@ -3014,36 +3014,36 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawFloat(testcount, row, false, 1);
               }
               else
                 modifyValue(testcount, 4, 50, 1);
               break;
         }
         break;
     #endif  // HAS_PROBE_MENU
 
     #if HAS_TRINAMIC_CONFIG
-      case TMCMenu:
+      case ID_TMCMenu:
 
         #define TMC_BACK 0
         #define TMC_STEPPER_CURRENT_X (TMC_BACK + AXIS_IS_TMC(X))
         #define TMC_STEPPER_CURRENT_Y (TMC_STEPPER_CURRENT_X + AXIS_IS_TMC(Y))
         #define TMC_STEPPER_CURRENT_Z (TMC_STEPPER_CURRENT_Y + AXIS_IS_TMC(Z))
         #define TMC_STEPPER_CURRENT_E (TMC_STEPPER_CURRENT_Z + AXIS_IS_TMC(E0))
         #define TMC_TOTAL TMC_STEPPER_CURRENT_E
 
         switch (item) {
 
           case TMC_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Advanced, ADVANCED_TMC);
+              drawMenu(ID_Advanced, ADVANCED_TMC);
             break;
 
           #if AXIS_IS_TMC(X)
             case TMC_STEPPER_CURRENT_X:
 
               static float stepper_current_x;
 
               if (draw) {
                 drawMenuItem(row, ICON_StepX, F("Stepper X current"));
                 stepper_current_x = stepperX.getMilliamps();
@@ -3092,22 +3092,22 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawFloat(stepper_current_e, row, false, 1);
               }
               else
                 modifyValue(stepper_current_e, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperE0.rms_current(stepper_current_e); });
               break;
           #endif
         };
         break;
     #endif // HAS_TRINAMIC_CONFIG
 
-    case InfoMain:
-    case Info:
+    case ID_InfoMain:
+    case ID_Info:
 
       #define INFO_BACK 0
       #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
       #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
       #define INFO_SIZE (INFO_PRINTTIME + 1)
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
       #define INFO_TOTAL INFO_BACK
 
       switch (item) {
@@ -3131,31 +3131,31 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 false, true
               );
 
             #endif
 
             drawMenuItem(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
             drawMenuItem(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
             drawMenuItem(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
           }
           else {
-            if (menu == Info)
-              drawMenu(Control, CONTROL_INFO);
+            if (menu == ID_Info)
+              drawMenu(ID_Control, CONTROL_INFO);
             else
               drawMainMenu(3);
           }
           break;
       }
       break;
 
     #if HAS_MESH
-      case Leveling:
+      case ID_Leveling:
 
         #define LEVELING_BACK 0
         #define LEVELING_ACTIVE (LEVELING_BACK + 1)
         #define LEVELING_GET_TILT (LEVELING_ACTIVE + ALL(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL))
         #define LEVELING_GET_MESH (LEVELING_GET_TILT + 1)
         #define LEVELING_MANUAL (LEVELING_GET_MESH + 1)
         #define LEVELING_VIEW (LEVELING_MANUAL + 1)
         #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
         #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
@@ -3171,213 +3171,213 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             break;
           case LEVELING_ACTIVE:
             if (draw) {
               drawMenuItem(row, ICON_StockConfiguration, F("Leveling Active"));
               drawCheckbox(row, planner.leveling_active);
             }
             else {
               if (!planner.leveling_active) {
                 set_bed_leveling_enabled(!planner.leveling_active);
                 if (!planner.leveling_active) {
-                  confirmHandler(LevelError);
+                  confirmHandler(Popup_LevelError);
                   break;
                 }
               }
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
               drawCheckbox(row, planner.leveling_active);
             }
             break;
           #if ALL(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
                 drawMenuItem(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
                 if (bedlevel.storage_slot < 0) {
-                  popupHandler(MeshSlot);
+                  popupHandler(Popup_MeshSlot);
                   break;
                 }
-                popupHandler(Home);
+                popupHandler(Popup_Home);
                 gcode.home_all_axes(true);
-                popupHandler(Level);
+                popupHandler(Popup_Level);
                 if (mesh_conf.tilt_grid > 1) {
                   gcode.process_subcommands_now(TS(F("G29J"), mesh_conf.tilt_grid));
                 }
                 else
                   gcode.process_subcommands_now(F("G29J"));
                 planner.synchronize();
                 redrawMenu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
               drawMenuItem(row, ICON_Mesh, F("Create New Mesh"));
             else {
-              popupHandler(Home);
+              popupHandler(Popup_Home);
               gcode.home_all_axes(true);
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 #if ENABLED(PREHEAT_BEFORE_LEVELING)
-                  popupHandler(Heating);
+                  popupHandler(Popup_Heating);
                   probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
                 #endif
                 #if HAS_BED_PROBE
-                  popupHandler(Level);
+                  popupHandler(Popup_Level);
                   gcode.process_subcommands_now(F("G29P0\nG29P1"));
                   gcode.process_subcommands_now(F("G29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nM420S1"));
                   planner.synchronize();
                   updateStatus("Probed all reachable points");
-                  popupHandler(SaveLevel);
+                  popupHandler(Popup_SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
-                  popupHandler(MoveWait);
+                  popupHandler(Popup_MoveWait);
                   mesh_conf.manual_mesh_move();
-                  drawMenu(UBLMesh);
+                  drawMenu(ID_UBLMesh);
                 #endif
               #elif HAS_BED_PROBE
-                popupHandler(Level);
+                popupHandler(Popup_Level);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
-                popupHandler(SaveLevel);
+                popupHandler(Popup_SaveLevel);
               #else
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
                 gridpoint = 1;
-                popupHandler(MoveWait);
+                popupHandler(Popup_MoveWait);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
-                drawMenu(ManualMesh);
+                drawMenu(ID_ManualMesh);
               #endif
             }
             break;
           case LEVELING_MANUAL:
             if (draw)
               drawMenuItem(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
                 if (!leveling_is_valid()) {
-                  confirmHandler(InvalidMesh);
+                  confirmHandler(Popup_InvalidMesh);
                   break;
                 }
               #endif
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (bedlevel.storage_slot < 0) {
-                  popupHandler(MeshSlot);
+                  popupHandler(Popup_MeshSlot);
                   break;
                 }
               #endif
               if (axes_should_home()) {
-                popupHandler(Home);
+                popupHandler(Popup_Home);
                 gcode.home_all_axes(true);
               }
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
               mesh_conf.goto_mesh_value = false;
               #if ENABLED(PREHEAT_BEFORE_LEVELING)
-                popupHandler(Heating);
+                popupHandler(Popup_Heating);
                 #if HAS_HOTEND
                   if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
                     thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
                 #endif
                 #if HAS_HEATED_BED
                   if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
                     thermalManager.setTargetBed(LEVELING_BED_TEMP);
                 #endif
                 TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
                 TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
               #endif
-              popupHandler(MoveWait);
+              popupHandler(Popup_MoveWait);
               mesh_conf.manual_mesh_move();
-              drawMenu(LevelManual);
+              drawMenu(ID_LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
               drawMenuItem(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (bedlevel.storage_slot < 0) {
-                  popupHandler(MeshSlot);
+                  popupHandler(Popup_MeshSlot);
                   break;
                 }
               #endif
-              drawMenu(LevelView);
+              drawMenu(ID_LevelView);
             }
             break;
           case LEVELING_SETTINGS:
             if (draw)
               drawMenuItem(row, ICON_Step, F("Leveling Settings"), nullptr, true);
             else
-              drawMenu(LevelSettings);
+              drawMenu(ID_LevelSettings);
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_SLOT:
             if (draw) {
               drawMenuItem(row, ICON_PrintSize, F("Mesh Slot"));
               drawFloat(bedlevel.storage_slot, row, false, 1);
             }
             else
               modifyValue(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
             break;
           case LEVELING_LOAD:
             if (draw)
               drawMenuItem(row, ICON_ReadEEPROM, F("Load Mesh"));
             else {
               if (bedlevel.storage_slot < 0) {
-                popupHandler(MeshSlot);
+                popupHandler(Popup_MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 L"));
               planner.synchronize();
               audioFeedback(true);
             }
             break;
           case LEVELING_SAVE:
             if (draw)
               drawMenuItem(row, ICON_WriteEEPROM, F("Save Mesh"));
             else {
               if (bedlevel.storage_slot < 0) {
-                popupHandler(MeshSlot);
+                popupHandler(Popup_MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               audioFeedback(true);
             }
             break;
           #endif
         }
         break;
 
-      case LevelView:
+      case ID_LevelView:
 
         #define LEVELING_VIEW_BACK 0
         #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
         #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
         #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
         #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Leveling, LEVELING_VIEW);
+              drawMenu(ID_Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
               drawMenuItem(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
-              drawMenu(MeshViewer);
+              drawMenu(ID_MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
               drawMenuItem(row, ICON_Contact, F("Viewer Show Values"));
               drawCheckbox(row, mesh_conf.viewer_print_value);
             }
             else {
               mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
               drawCheckbox(row, mesh_conf.viewer_print_value);
             }
@@ -3388,36 +3388,36 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawCheckbox(row, mesh_conf.viewer_asymmetric_range);
             }
             else {
               mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
               drawCheckbox(row, mesh_conf.viewer_asymmetric_range);
             }
             break;
         }
         break;
 
-      case LevelSettings:
+      case ID_LevelSettings:
 
         #define LEVELING_SETTINGS_BACK 0
         #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
         #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
 
         switch (item) {
           case LEVELING_SETTINGS_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
-              drawMenu(Leveling, LEVELING_SETTINGS);
+              drawMenu(ID_Leveling, LEVELING_SETTINGS);
             break;
           case LEVELING_SETTINGS_FADE:
               if (draw) {
                 drawMenuItem(row, ICON_Fade, F("Fade Mesh within"));
                 drawFloat(planner.z_fade_height, row, false, 1);
               }
               else {
                 modifyValue(planner.z_fade_height, 0, Z_MAX_POS, 1);
                 planner.z_fade_height = -1;
                 set_z_fade_height(planner.z_fade_height);
@@ -3430,21 +3430,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawMenuItem(row, ICON_Tilt, F("Tilting Grid Size"));
                 drawFloat(mesh_conf.tilt_grid, row, false, 1);
               }
               else
                 modifyValue(mesh_conf.tilt_grid, 1, 8, 1);
               break;
             case LEVELING_SETTINGS_PLANE:
               if (draw)
                 drawMenuItem(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
               else {
-                if (mesh_conf.create_plane_from_mesh()) break;
+                if (mesh_conf.createPlaneFromMesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 audioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
                 drawMenuItem(row, ICON_Mesh, F("Zero Current Mesh"));
               else
                 ZERO(bedlevel.z_values);
@@ -3452,58 +3452,58 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
                 drawMenuItem(row, ICON_Mesh, F("Clear Current Mesh"));
               else
                 bedlevel.invalidate();
               break;
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
-      case MeshViewer:
+      case ID_MeshViewer:
         #define MESHVIEW_BACK 0
         #define MESHVIEW_TOTAL MESHVIEW_BACK
 
         if (item == MESHVIEW_BACK) {
           if (draw) {
             drawMenuItem(0, ICON_Back, F("Back"));
             mesh_conf.drawBedMesh();
             mesh_conf.setMeshViewerStatus();
           }
           else if (!mesh_conf.drawing_mesh) {
-            drawMenu(LevelView, LEVELING_VIEW_MESH);
+            drawMenu(ID_LevelView, LEVELING_VIEW_MESH);
             updateStatus("");
           }
         }
         break;
 
-      case LevelManual:
+      case ID_LevelManual:
 
         #define LEVELING_M_BACK 0
         #define LEVELING_M_X (LEVELING_M_BACK + 1)
         #define LEVELING_M_Y (LEVELING_M_X + 1)
         #define LEVELING_M_NEXT (LEVELING_M_Y + 1)
         #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
         #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
         #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
               TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
-              drawMenu(Leveling, LEVELING_MANUAL);
+              drawMenu(ID_Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
               drawMenuItem(row, ICON_MoveX, F("Mesh Point X"));
               drawFloat(mesh_conf.mesh_x, row, 0, 1);
             }
             else
               modifyValue(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
             break;
@@ -3575,47 +3575,47 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               current_position.z = 0;
               mesh_conf.manual_mesh_move(true);
               drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_M_UNDEF:
             if (draw)
               drawMenuItem(row, ICON_ResumeEEPROM, F("Clear Point Value"));
             else {
-              mesh_conf.manual_value_update(true);
+              mesh_conf.manualValueUpdate(true);
               redrawMenu(false);
             }
             break;
           #endif
         }
         break;
     #endif // HAS_MESH
 
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:
+      case ID_UBLMesh:
 
         #define UBL_M_BACK 0
         #define UBL_M_NEXT (UBL_M_BACK + 1)
         #define UBL_M_PREV (UBL_M_NEXT + 1)
         #define UBL_M_OFFSET (UBL_M_PREV + 1)
         #define UBL_M_UP (UBL_M_OFFSET + 1)
         #define UBL_M_DOWN (UBL_M_UP + 1)
         #define UBL_M_TOTAL UBL_M_DOWN
 
         switch (item) {
           case UBL_M_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
-              drawMenu(Leveling, LEVELING_GET_MESH);
+              drawMenu(ID_Leveling, LEVELING_GET_MESH);
             }
             break;
           case UBL_M_NEXT:
             if (draw) {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
                 drawMenuItem(row, ICON_More, F("Next Point"));
               else
                 drawMenuItem(row, ICON_More, F("Save Mesh"));
             }
             else {
@@ -3625,21 +3625,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_mesh_move();
               }
               else {
                 gcode.process_subcommands_now(F("G29 S"));
                 planner.synchronize();
                 audioFeedback(true);
-                drawMenu(Leveling, LEVELING_GET_MESH);
+                drawMenu(ID_Leveling, LEVELING_GET_MESH);
               }
             }
             break;
           case UBL_M_PREV:
             if (draw)
               drawMenuItem(row, ICON_More, F("Previous Point"));
             else {
               if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
                   mesh_conf.mesh_y--;
@@ -3684,60 +3684,60 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               current_position.z -= 0.01f;
               sync_plan_position();
               drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
         break;
     #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
 
     #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:
+      case ID_ManualMesh:
 
         #define MMESH_BACK 0
         #define MMESH_NEXT (MMESH_BACK + 1)
         #define MMESH_OFFSET (MMESH_NEXT + 1)
         #define MMESH_UP (MMESH_OFFSET + 1)
         #define MMESH_DOWN (MMESH_UP + 1)
         #define MMESH_OLD (MMESH_DOWN + 1)
         #define MMESH_TOTAL MMESH_OLD
 
         switch (item) {
           case MMESH_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Cancel"));
             else {
               gcode.process_subcommands_now(F("G29 A"));
               planner.synchronize();
               set_bed_leveling_enabled(level_state);
-              drawMenu(Leveling, LEVELING_GET_MESH);
+              drawMenu(ID_Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_NEXT:
             if (draw) {
               if (gridpoint < GRID_MAX_POINTS)
                 drawMenuItem(row, ICON_More, F("Next Point"));
               else
                 drawMenuItem(row, ICON_More, F("Save Mesh"));
             }
             else if (gridpoint < GRID_MAX_POINTS) {
-              popupHandler(MoveWait);
+              popupHandler(Popup_MoveWait);
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               gridpoint++;
               redrawMenu();
             }
             else {
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               audioFeedback(settings.save());
-              drawMenu(Leveling, LEVELING_GET_MESH);
+              drawMenu(ID_Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_OFFSET:
             if (draw) {
               drawMenuItem(row, ICON_SetZOffset, F("Z Position"));
               current_position.z = MANUAL_PROBE_START_Z;
               drawFloat(current_position.z, row, false, 100);
             }
             else
               modifyValue(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
@@ -3784,21 +3784,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               planner.synchronize();
               planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
               planner.synchronize();
               drawFloat(current_position.z, row - 3, false, 100);
             }
             break;
         }
         break;
     #endif // PROBE_MANUALLY
 
-    case Tune:
+    case ID_Tune:
 
       #define TUNE_BACK 0
       #define TUNE_SPEED (TUNE_BACK + 1)
       #define TUNE_FLOW (TUNE_SPEED + ENABLED(HAS_HOTEND))
       #define TUNE_HOTEND (TUNE_FLOW + ENABLED(HAS_HOTEND))
       #define TUNE_BED (TUNE_HOTEND + ENABLED(HAS_HEATED_BED))
       #define TUNE_FAN (TUNE_BED + ENABLED(HAS_FAN))
       #define TUNE_ZOFFSET (TUNE_FAN + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_ZUP (TUNE_ZOFFSET + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
@@ -3892,21 +3892,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawFloat(zoffsetvalue, row - 2, false, 100);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else
-              popupHandler(ConfFilChange);
+              popupHandler(Popup_ConfFilChange);
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
               drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
               drawCheckbox(row, runout.enabled);
             }
             else {
@@ -3928,21 +3928,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             drawFloat(ui.brightness, row, false, 1);
           }
           else
             modifyValue(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
       }
       break;
 
     #if HAS_PREHEAT && HAS_HOTEND
 
-      case PreheatHotend:
+      case ID_PreheatHotend:
 
         #define PREHEATHOTEND_BACK 0
         #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
         #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
         #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
         #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
         #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
         #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
         #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
         #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
@@ -3954,44 +3954,44 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               thermalManager.setTargetHotend(0, 0);
               TERN_(HAS_FAN, thermalManager.set_fan_speed(0, 0));
               redrawMenu(false, true, true);
             }
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
               drawMenuItem(row, ICON_SetEndTemp, F("Continue"));
             else {
-              popupHandler(Heating);
+              popupHandler(Popup_Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
-                case Prepare:
-                  popupHandler(FilChange);
+                case ID_Prepare:
+                  popupHandler(Popup_FilChange);
                   gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                  case ChangeFilament:
+                  case ID_ChangeFilament:
                     switch (last_selection) {
                       case CHANGEFIL_LOAD:
-                        popupHandler(FilLoad);
+                        popupHandler(Popup_FilLoad);
                         gcode.process_subcommands_now(F("M701"));
                         planner.synchronize();
                         redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_UNLOAD:
-                        popupHandler(FilLoad, true);
+                        popupHandler(Popup_FilLoad, true);
                         gcode.process_subcommands_now(F("M702"));
                         planner.synchronize();
                         redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_CHANGE:
-                        popupHandler(FilChange);
+                        popupHandler(Popup_FilChange);
                         gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
                         break;
                     }
                     break;
                 #endif
                 default:
                   redrawMenu(true, true, true);
                   break;
               }
             }
@@ -4016,216 +4016,217 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             break;
         }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
 
 FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
   switch (menu) {
-    case MainMenu:          return GET_TEXT_F(MSG_MAIN_MENU);
-    case Prepare:           return GET_TEXT_F(MSG_PREPARE);
-    case HomeMenu:          return F("Homing Menu");
-    case Move:              return GET_TEXT_F(MSG_MOVE_AXIS);
-    case ManualLevel:       return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
+    case ID_MainMenu:       return GET_TEXT_F(MSG_MAIN_MENU);
+    case ID_Prepare:        return GET_TEXT_F(MSG_PREPARE);
+    case ID_HomeMenu:       return F("Homing Menu");
+    case ID_Move:           return GET_TEXT_F(MSG_MOVE_AXIS);
+    case ID_ManualLevel:    return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
     #if HAS_ZOFFSET_ITEM
-      case ZOffset:         return GET_TEXT_F(MSG_ZPROBE_ZOFFSET);
+      case ID_ZOffset:      return GET_TEXT_F(MSG_ZPROBE_ZOFFSET);
     #endif
     #if HAS_PREHEAT
-      case Preheat:         return F("Preheat");
+      case ID_Preheat:      return F("Preheat");
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return GET_TEXT_F(MSG_FILAMENTCHANGE);
+      case ID_ChangeFilament: return GET_TEXT_F(MSG_FILAMENTCHANGE);
     #endif
     #if HAS_CUSTOM_MENU
-      case MenuCustom:
+      case ID_MenuCustom:
         #ifdef CUSTOM_MENU_CONFIG_TITLE
           return F(CUSTOM_MENU_CONFIG_TITLE);
         #else
           return GET_TEXT_F(MSG_CUSTOM_COMMANDS);
         #endif
     #endif
-    case Control:           return GET_TEXT_F(MSG_CONTROL);
-    case TempMenu:          return GET_TEXT_F(MSG_TEMPERATURE);
+    case ID_Control:        return GET_TEXT_F(MSG_CONTROL);
+    case ID_TempMenu:       return GET_TEXT_F(MSG_TEMPERATURE);
     #if ANY(PIDTEMP, PIDTEMPBED)
-      case PID:             return F("PID Menu");
+      case ID_PID:          return F("PID Menu");
     #endif
     #if ENABLED(PIDTEMP)
-      case HotendPID:       return F("Hotend PID Settings");
+      case ID_HotendPID:    return F("Hotend PID Settings");
     #endif
     #if ENABLED(PIDTEMPBED)
-      case BedPID:          return F("Bed PID Settings");
+      case ID_BedPID:       return F("Bed PID Settings");
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
-      case MPC:             return F("MPC Menu");
+      case ID_MPC:          return F("MPC Menu");
     #endif
     #if HAS_PREHEAT
-      #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
+      #define _PREHEAT_TITLE_CASE(N) case ID_Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
-    case Motion:            return F("Motion Settings");
-    case HomeOffsets:       return F("Home Offsets");
-    case MaxSpeed:          return F("Max Speed");
-    case MaxAcceleration:   return F("Max Acceleration");
+    case ID_Motion:         return F("Motion Settings");
+    case ID_HomeOffsets:    return F("Home Offsets");
+    case ID_MaxSpeed:       return F("Max Speed");
+    case ID_MaxAcceleration: return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
-      case MaxJerk:         return F("Max Jerk");
+      case ID_MaxJerk:      return F("Max Jerk");
     #endif
-    case Steps:             return GET_TEXT_F(MSG_STEPS_PER_MM);
-    case Visual:            return F("Visual Settings");
-    case Advanced:          return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
+    case ID_Steps:          return GET_TEXT_F(MSG_STEPS_PER_MM);
+    case ID_Visual:         return F("Visual Settings");
+    case ID_Advanced:       return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
     #if HAS_BED_PROBE
-      case ProbeMenu:       return F("Bed Probe");
+      case ID_ProbeMenu:    return F("Bed Probe");
     #endif
     #if HAS_TRINAMIC_CONFIG
-      case TMCMenu:         return GET_TEXT_F(MSG_TMC_DRIVERS);
+      case ID_TMCMenu:      return GET_TEXT_F(MSG_TMC_DRIVERS);
     #endif
-    case ColorSettings:     return F("UI Color Settings");
-    case Info:              return F("Info");
-    case InfoMain:          return F("Info");
+    case ID_ColorSettings:  return F("UI Color Settings");
+    case ID_Info:           return F("Info");
+    case ID_InfoMain:       return F("Info");
     #if HAS_MESH
-      case Leveling:        return F("Leveling");
-      case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
-      case LevelSettings:   return F("Leveling Settings");
-      case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
-      case LevelManual:     return F("Manual Tuning");
+      case ID_Leveling:     return F("Leveling");
+      case ID_LevelView:    return GET_TEXT_F(MSG_MESH_VIEW);
+      case ID_LevelSettings: return F("Leveling Settings");
+      case ID_MeshViewer:   return GET_TEXT_F(MSG_MESH_VIEW);
+      case ID_LevelManual:  return F("Manual Tuning");
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:         return F("UBL Bed Leveling");
+      case ID_UBLMesh:      return F("UBL Bed Leveling");
     #endif
     #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return GET_TEXT_F(MSG_MANUAL_LEVELING);
+      case ID_ManualMesh:   return GET_TEXT_F(MSG_MANUAL_LEVELING);
     #endif
-    case Tune:              return GET_TEXT_F(MSG_TUNE);
-    case PreheatHotend:     return GET_TEXT_F(MSG_PREHEAT_HOTEND);
+    case ID_Tune:           return GET_TEXT_F(MSG_TUNE);
+    case ID_PreheatHotend:  return GET_TEXT_F(MSG_PREHEAT_HOTEND);
   }
   return F("");
 }
 
 uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
   switch (menu) {
-    case Prepare:           return PREPARE_TOTAL;
-    case HomeMenu:          return HOME_TOTAL;
-    case Move:              return MOVE_TOTAL;
-    case ManualLevel:       return MLEVEL_TOTAL;
+    case ID_Prepare:        return PREPARE_TOTAL;
+    case ID_HomeMenu:       return HOME_TOTAL;
+    case ID_Move:           return MOVE_TOTAL;
+    case ID_ManualLevel:    return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
-      case ZOffset:         return ZOFFSET_TOTAL;
+      case ID_ZOffset:      return ZOFFSET_TOTAL;
     #endif
     #if HAS_PREHEAT
-      case Preheat:         return PREHEAT_TOTAL;
+      case ID_Preheat:      return PREHEAT_TOTAL;
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return CHANGEFIL_TOTAL;
+      case ID_ChangeFilament: return CHANGEFIL_TOTAL;
     #endif
     #if HAS_CUSTOM_MENU
-      case MenuCustom:      return CUSTOM_MENU_TOTAL;
+      case ID_MenuCustom:   return CUSTOM_MENU_TOTAL;
     #endif
-    case Control:           return CONTROL_TOTAL;
-    case TempMenu:          return TEMP_TOTAL;
+    case ID_Control:        return CONTROL_TOTAL;
+    case ID_TempMenu:       return TEMP_TOTAL;
     #if ANY(PIDTEMP, PIDTEMPBED)
-      case PID:             return PID_TOTAL;
+      case ID_PID:          return PID_TOTAL;
     #endif
     #if ENABLED(PIDTEMP)
-      case HotendPID:       return HOTENDPID_TOTAL;
+      case ID_HotendPID:    return HOTENDPID_TOTAL;
     #endif
     #if ENABLED(PIDTEMPBED)
-      case BedPID:          return BEDPID_TOTAL;
+      case ID_BedPID:       return BEDPID_TOTAL;
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
-      case MPC:             return MPCMENU_TOTAL;
+      case ID_MPC:          return MPCMENU_TOTAL;
     #endif
     #if HAS_PREHEAT
-      case Preheat1 ... CAT(Preheat, PREHEAT_COUNT):
+      case ID_Preheat1 ... CAT(ID_Preheat, PREHEAT_COUNT):
                             return PREHEAT_SUBMENU_TOTAL;
     #endif
-    case Motion:            return MOTION_TOTAL;
-    case HomeOffsets:       return HOMEOFFSETS_TOTAL;
-    case MaxSpeed:          return SPEED_TOTAL;
-    case MaxAcceleration:   return ACCEL_TOTAL;
+    case ID_Motion:         return MOTION_TOTAL;
+    case ID_HomeOffsets:    return HOMEOFFSETS_TOTAL;
+    case ID_MaxSpeed:       return SPEED_TOTAL;
+    case ID_MaxAcceleration: return ACCEL_TOTAL;
     #if HAS_CLASSIC_JERK
-      case MaxJerk:         return JERK_TOTAL;
+      case ID_MaxJerk:      return JERK_TOTAL;
     #endif
-    case Steps:             return STEPS_TOTAL;
-    case Visual:            return VISUAL_TOTAL;
-    case Advanced:          return ADVANCED_TOTAL;
+    case ID_Steps:          return STEPS_TOTAL;
+    case ID_Visual:         return VISUAL_TOTAL;
+    case ID_Advanced:       return ADVANCED_TOTAL;
     #if HAS_BED_PROBE
-      case ProbeMenu:       return PROBE_TOTAL;
+      case ID_ProbeMenu:    return PROBE_TOTAL;
     #endif
     #if HAS_TRINAMIC_CONFIG
-      case TMCMenu:         return TMC_TOTAL;
+      case ID_TMCMenu:      return TMC_TOTAL;
+      case ID_TMCMenu:      return TMC_TOTAL;
     #endif
-    case Info:              return INFO_TOTAL;
-    case InfoMain:          return INFO_TOTAL;
+    case ID_Info:           return INFO_TOTAL;
+    case ID_InfoMain:       return INFO_TOTAL;
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:         return UBL_M_TOTAL;
+      case ID_UBLMesh:      return UBL_M_TOTAL;
     #endif
     #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return MMESH_TOTAL;
+      case ID_ManualMesh:   return MMESH_TOTAL;
     #endif
     #if HAS_MESH
-      case Leveling:        return LEVELING_TOTAL;
-      case LevelView:       return LEVELING_VIEW_TOTAL;
-      case LevelSettings:   return LEVELING_SETTINGS_TOTAL;
-      case MeshViewer:      return MESHVIEW_TOTAL;
-      case LevelManual:     return LEVELING_M_TOTAL;
+      case ID_Leveling:     return LEVELING_TOTAL;
+      case ID_LevelView:    return LEVELING_VIEW_TOTAL;
+      case ID_LevelSettings: return LEVELING_SETTINGS_TOTAL;
+      case ID_MeshViewer:   return MESHVIEW_TOTAL;
+      case ID_LevelManual:  return LEVELING_M_TOTAL;
     #endif
-    case Tune:              return TUNE_TOTAL;
+    case ID_Tune:           return TUNE_TOTAL;
 
     #if HAS_PREHEAT && HAS_HOTEND
-      case PreheatHotend:   return PREHEATHOTEND_TOTAL;
+      case ID_PreheatHotend: return PREHEATHOTEND_TOTAL;
     #endif
 
-    case ColorSettings:     return COLORSETTINGS_TOTAL;
+    case ID_ColorSettings:  return COLORSETTINGS_TOTAL;
   }
   return 0;
 }
 
 //
 // Popup Config
 //
 
 void JyersDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
-    case Pause:         drawPopup(F("Pause Print"), F(""), F(""), Popup); break;
-    case Stop:          drawPopup(F("Stop Print"), F(""), F(""), Popup); break;
-    case Resume:        drawPopup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
-    case ConfFilChange: drawPopup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
-    case PurgeMore:     drawPopup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
-    case SaveLevel:     drawPopup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
-    case MeshSlot:      drawPopup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
-    case ETemp:         drawPopup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
-    case ManualProbing: drawPopup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
-    case Level:         drawPopup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
-    case Home:          drawPopup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case MoveWait:      drawPopup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case Heating:       drawPopup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
-    case TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
-    case Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
-    case PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
-    case MPCWait:       drawPopup(F("MPC Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
-    case Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case Custom:        drawPopup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Popup_Pause:         drawPopup(F("Pause Print"), F(""), F(""), Proc_Popup); break;
+    case Popup_Stop:          drawPopup(F("Stop Print"), F(""), F(""), Proc_Popup); break;
+    case Popup_Resume:        drawPopup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Proc_Popup); break;
+    case Popup_ConfFilChange: drawPopup(F("Confirm Filament Change"), F(""), F(""), Proc_Popup); break;
+    case Popup_PurgeMore:     drawPopup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Proc_Popup); break;
+    case Popup_SaveLevel:     drawPopup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Proc_Popup); break;
+    case Popup_MeshSlot:      drawPopup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Proc_Popup); break;
+    case Popup_ETemp:         drawPopup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Proc_Popup); break;
+    case Popup_ManualProbing: drawPopup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Proc_Popup); break;
+    case Popup_Level:         drawPopup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Proc_Wait, ICON_AutoLeveling); break;
+    case Popup_Home:          drawPopup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_MoveWait:      drawPopup(F("Moving to Point"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Heating:       drawPopup(F("Heating"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Proc_Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
+    case Popup_Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Proc_Wait, ICON_BLTouch); break;
+    case Popup_MPCWait:       drawPopup(F("MPC Autotune"), F("in process"), F("Please wait until done."), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
+    case Popup_Custom:        drawPopup(F("Running Custom GCode"), F("Please wait until done."), F(""), Proc_Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
 void JyersDWIN::confirmHandler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
-    case FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
-    case HeaterTime:  drawPopup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
-    case UserInput:   drawPopup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
-    case LevelError:  drawPopup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
-    case InvalidMesh: drawPopup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
+    case Popup_FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Proc_Confirm); break;
+    case Popup_HeaterTime:  drawPopup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Proc_Confirm); break;
+    case Popup_UserInput:   drawPopup(F("Waiting for Input"), F("Press to Continue"), F(""), Proc_Confirm); break;
+    case Popup_LevelError:  drawPopup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Proc_Confirm); break;
+    case Popup_InvalidMesh: drawPopup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Proc_Confirm); break;
     default: break;
   }
 }
 
 //
 // Navigation and Control
 //
 
 void JyersDWIN::mainMenuControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
@@ -4234,125 +4235,125 @@ void JyersDWIN::mainMenuControl() {
     selection++; // Select Down
     mainMenuIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     mainMenuIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     switch (selection) {
       case PAGE_PRINT: card.mount(); drawSDList(); break;
-      case PAGE_PREPARE: drawMenu(Prepare); break;
-      case PAGE_CONTROL: drawMenu(Control); break;
-      case PAGE_INFO_LEVELING: drawMenu(TERN(HAS_MESH, Leveling, InfoMain)); break;
+      case PAGE_PREPARE: drawMenu(ID_Prepare); break;
+      case PAGE_CONTROL: drawMenu(ID_Control); break;
+      case PAGE_INFO_LEVELING: drawMenu(TERN(HAS_MESH, ID_Leveling, ID_InfoMain)); break;
     }
   dwinUpdateLCD();
 }
 
 void JyersDWIN::menuControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < getMenuSize(active_menu)) {
-    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection++; // Select Down
     if (selection > scrollpos + MROWS) {
       scrollpos++;
-      dwinFrameAreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      dwinFrameAreaMove(1, 2, MLINE, COLOR_BG_BLACK, 0, 31, DWIN_WIDTH, 349);
       menuItemHandler(active_menu, selection);
     }
-    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
-      dwinFrameAreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      dwinFrameAreaMove(1, 3, MLINE, COLOR_BG_BLACK, 0, 31, DWIN_WIDTH, 349);
       menuItemHandler(active_menu, selection);
     }
-    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     menuItemHandler(active_menu, selection, false);
   dwinUpdateLCD();
 }
 
 void JyersDWIN::valueControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    process = Menu;
+    process = Proc_Menu;
     encoderRate.enabled = false;
     drawFloat(tempvalue / valueunit, selection - scrollpos, false, valueunit);
     dwinUpdateLCD();
-    if (active_menu == ZOffset && liveadjust) {
+    if (active_menu == ID_ZOffset && liveadjust) {
       planner.synchronize();
       current_position.z += (tempvalue / valueunit - zoffsetvalue);
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
       current_position.z = 0;
       sync_plan_position();
     }
-    else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
+    else if (active_menu == ID_Tune && selection == TUNE_ZOFFSET) {
       gcode.process_subcommands_now(TS(F("M290Z"), p_float_t((tempvalue / valueunit - zoffsetvalue), 3)));
     }
     if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Ki))
       tempvalue = scalePID_i(tempvalue);
     if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Kd))
       tempvalue = scalePID_d(tempvalue);
     switch (valuetype) {
       case 0: *(float*)valuepointer = tempvalue / valueunit; break;
       case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
       case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
       case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
       case 4: *(uint32_t*)valuepointer = tempvalue / valueunit; break;
       case 5: *(int8_t*)valuepointer = tempvalue / valueunit; break;
     }
     switch (active_menu) {
-      case Move:
+      case ID_Move:
         planner.synchronize();
         planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
         break;
       #if HAS_MESH
-        case ManualMesh:
+        case ID_ManualMesh:
           planner.synchronize();
           planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
           planner.synchronize();
           break;
-        case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
-        case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
+        case ID_UBLMesh: mesh_conf.manual_mesh_move(true); break;
+        case ID_LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
       #endif
     }
     if (funcpointer) funcpointer();
     return;
   }
   LIMIT(tempvalue, valuemin * valueunit, valuemax * valueunit);
   drawFloat(tempvalue / valueunit, selection - scrollpos, true, valueunit);
   dwinUpdateLCD();
-  if (active_menu == Move && livemove) {
+  if (active_menu == ID_Move && livemove) {
     *(float*)valuepointer = tempvalue / valueunit;
     planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
   }
 }
 
 void JyersDWIN::optionControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    process = Menu;
+    process = Proc_Menu;
     encoderRate.enabled = false;
     if (valuepointer == &color_names) {
       switch (selection) {
         case COLORSETTINGS_CURSOR: eeprom_settings.cursor_color = tempvalue; break;
         case COLORSETTINGS_SPLIT_LINE: eeprom_settings.menu_split_line = tempvalue; break;
         case COLORSETTINGS_MENU_TOP_BG: eeprom_settings.menu_top_bg = tempvalue; break;
         case COLORSETTINGS_MENU_TOP_TXT: eeprom_settings.menu_top_txt = tempvalue; break;
         case COLORSETTINGS_HIGHLIGHT_BORDER: eeprom_settings.highlight_box = tempvalue; break;
         case COLORSETTINGS_PROGRESS_PERCENT: eeprom_settings.progress_percent = tempvalue; break;
         case COLORSETTINGS_PROGRESS_TIME: eeprom_settings.progress_time = tempvalue; break;
@@ -4385,59 +4386,59 @@ void JyersDWIN::fileControl() {
       char * const filename = card.longest_filename();
       size_t len = strlen(filename), pos = len;
       if (!card.flag.filenameIsDir)
         while (pos && filename[pos] != '.') pos--;
       if (pos > MENU_CHAR_LIMIT) {
         static millis_t time = 0;
         if (PENDING(millis(), time)) return;
         time = millis() + 200;
         Scroller::Buffer buf;
         const char* const name = scroller.scroll(pos, buf, filename);
-        dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+        dwinDrawRectangle(1, COLOR_BG_BLACK, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
         drawMenuItem(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
         dwinUpdateLCD();
       }
     }
     return;
   }
   if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_items()) {
-    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     if (selection > 0) {
-      dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+      dwinDrawRectangle(1, COLOR_BG_BLACK, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
       drawSDItem(selection, selection - scrollpos);
     }
     scroller.reset();
     selection++; // Select Down
     if (selection > scrollpos + MROWS) {
       scrollpos++;
-      dwinFrameAreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      dwinFrameAreaMove(1, 2, MLINE, COLOR_BG_BLACK, 0, 31, DWIN_WIDTH, 349);
       drawSDItem(selection, selection - scrollpos);
     }
-    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
     drawSDItem(selection, selection - scrollpos);
     scroller.reset();
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
-      dwinFrameAreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      dwinFrameAreaMove(1, 3, MLINE, COLOR_BG_BLACK, 0, 31, DWIN_WIDTH, 349);
       drawSDItem(selection, selection - scrollpos);
     }
-    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, COLOR_RECTANGLE), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     if (selection == 0) {
       if (card.flag.workDirIsRoot) {
-        process = Main;
+        process = Proc_Main;
         drawMainMenu();
       }
       else {
         card.cdup();
         drawSDList();
       }
     }
     else {
       card.selectFileByIndexSorted(selection - 1);
       if (card.flag.filenameIsDir) {
@@ -4459,21 +4460,21 @@ void JyersDWIN::printScreenControl() {
     selection++; // Select Down
     printScreenIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     printScreenIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (selection) {
       case PRINT_SETUP:
-        drawMenu(Tune);
+        drawMenu(ID_Tune);
         updateStatusBar(true);
         break;
       case PRINT_PAUSE_RESUME:
         if (paused) {
           if (sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
@@ -4487,187 +4488,187 @@ void JyersDWIN::printScreenControl() {
               planner.synchronize();
               TERN_(HAS_MEDIA, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           drawPrintScreen();
         }
         else
-          popupHandler(Pause);
+          popupHandler(Popup_Pause);
         break;
-      case PRINT_STOP: popupHandler(Stop); break;
+      case PRINT_STOP: popupHandler(Popup_Stop); break;
     }
   }
   dwinUpdateLCD();
 }
 
 void JyersDWIN::popupControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
     selection++;
     popupSelect();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--;
     popupSelect();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
-      case Pause:
+      case Popup_Pause:
         if (selection == 0) {
           if (sdprint) {
             #if ENABLED(POWER_LOSS_RECOVERY)
               if (recovery.enabled) recovery.save(true);
             #endif
             #if ENABLED(PARK_HEAD_ON_PAUSE)
-              popupHandler(Home, true);
+              popupHandler(Popup_Home, true);
               #if HAS_MEDIA
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
               queue.inject(F("M125"));
               planner.synchronize();
             #else
               queue.inject(F("M25"));
               TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
               TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
               thermalManager.cooldown();
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.pause());
           }
         }
         drawPrintScreen();
         break;
-      case Stop:
+      case Popup_Stop:
         if (selection == 0) {
           if (sdprint) {
             ui.abort_print();
             thermalManager.cooldown();
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
           }
         }
         else
           drawPrintScreen();
         break;
-      case Resume:
+      case Popup_Resume:
         if (selection == 0)
           queue.inject(F("M1000"));
         else {
           queue.inject(F("M1000 C"));
           drawMainMenu();
         }
         break;
 
       #if HAS_HOTEND
-        case ETemp:
+        case Popup_ETemp:
           if (selection == 0) {
             thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
             TERN_(HAS_FAN, thermalManager.set_fan_speed(0, MAX_FAN_SPEED));
-            drawMenu(PreheatHotend);
+            drawMenu(ID_PreheatHotend);
           }
           else
             redrawMenu(true, true, false);
           break;
       #endif
 
       #if HAS_BED_PROBE
-        case ManualProbing:
+        case Popup_ManualProbing:
           if (selection == 0) {
             const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - corner_avg;
             updateStatus(TS(F("Corner is "), p_float_t(abs(dif), 3), "mm ", dif > 0 ? F("high") : F("low")));
           }
           else {
             redrawMenu(true, true, false);
             updateStatus("");
           }
           break;
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        case ConfFilChange:
+        case Popup_ConfFilChange:
           if (selection == 0) {
             if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-              popupHandler(ETemp);
+              popupHandler(Popup_ETemp);
             else {
               if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                popupHandler(Heating);
+                popupHandler(Popup_Heating);
                 thermalManager.wait_for_hotend(0);
               }
-              popupHandler(FilChange);
+              popupHandler(Popup_FilChange);
               gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.temp_hotend[0].target));
             }
           }
           else
             redrawMenu(true, true, false);
           break;
-        case PurgeMore:
+        case Popup_PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
-            popupHandler(FilChange);
+            popupHandler(Popup_FilChange);
           }
           else {
             pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
-            if (printing) popupHandler(Resuming);
-            else redrawMenu(true, true, active_menu == PreheatHotend);
+            if (printing) popupHandler(Popup_Resuming);
+            else redrawMenu(true, true, active_menu == ID_PreheatHotend);
           }
           break;
       #endif // ADVANCED_PAUSE_FEATURE
 
       #if HAS_MESH
-        case SaveLevel:
+        case Popup_SaveLevel:
           if (selection == 0) {
             #if ENABLED(AUTO_BED_LEVELING_UBL)
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               audioFeedback(true);
             #else
               audioFeedback(settings.save());
             #endif
           }
-          drawMenu(Leveling, LEVELING_GET_MESH);
+          drawMenu(ID_Leveling, LEVELING_GET_MESH);
           break;
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        case MeshSlot:
+        case Popup_MeshSlot:
           if (selection == 0) bedlevel.storage_slot = 0;
           redrawMenu(true, true);
           break;
       #endif
       default: break;
     }
   }
   dwinUpdateLCD();
 }
 
 void JyersDWIN::confirmControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
-      case Complete:
+      case Popup_Complete:
         drawMainMenu();
         break;
-      case FilInsert:
-        popupHandler(FilChange);
+      case Popup_FilInsert:
+        popupHandler(Popup_FilChange);
         wait_for_user = false;
         break;
-      case HeaterTime:
-        popupHandler(Heating);
+      case Popup_HeaterTime:
+        popupHandler(Popup_Heating);
         wait_for_user = false;
         break;
       default:
         redrawMenu(true, true, false);
         wait_for_user = false;
         break;
     }
   }
   dwinUpdateLCD();
 }
@@ -4680,21 +4681,21 @@ void JyersDWIN::setupValue(const_float_t value, const_float_t min, const_float_t
   if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Ki))
     tempvalue = unscalePID_i(value) * unit;
   else if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Kd))
     tempvalue = unscalePID_d(value) * unit;
   else
     tempvalue = value * unit;
   valuemin = min;
   valuemax = max;
   valueunit = unit;
   valuetype = type;
-  process = Value;
+  process = Proc_Value;
   encoderRate.enabled = true;
   drawFloat(tempvalue / unit, selection - scrollpos, true, valueunit);
 }
 
 void JyersDWIN::modifyValue(float &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 0);
 }
 void JyersDWIN::modifyValue(uint8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
@@ -4721,21 +4722,21 @@ void JyersDWIN::modifyValue(int8_t &value, const_float_t min, const_float_t max,
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 5);
 }
 
 void JyersDWIN::modifyOption(const uint8_t value, const char * const * options, const uint8_t max) {
   tempvalue = value;
   valuepointer = const_cast<const char * *>(options);
   valuemin = 0;
   valuemax = max;
-  process = Option;
+  process = Proc_Option;
   encoderRate.enabled = true;
   drawOption(value, options, selection - scrollpos, true);
 }
 
 //
 // Main Functions
 //
 
 void JyersDWIN::updateStatus(const char * const text) {
   if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
@@ -4778,97 +4779,97 @@ void JyersDWIN::stopPrint() {
   thermalManager.cooldown();
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress(100 * (PROGRESS_SCALE)));
   TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
   drawPrintConfirm();
 }
 
 void JyersDWIN::update() {
   stateUpdate();
   screenUpdate();
   switch (process) {
-    case Main:    mainMenuControl();    break;
-    case Menu:    menuControl();         break;
-    case Value:   valueControl();        break;
-    case Option:  optionControl();       break;
-    case File:    fileControl();         break;
-    case Print:   printScreenControl(); break;
-    case Popup:   popupControl();        break;
-    case Confirm: confirmControl();      break;
+    case Proc_Main:    mainMenuControl();    break;
+    case Proc_Menu:    menuControl();         break;
+    case Proc_Value:   valueControl();        break;
+    case Proc_Option:  optionControl();       break;
+    case Proc_File:    fileControl();         break;
+    case Proc_Print:   printScreenControl(); break;
+    case Proc_Popup:   popupControl();        break;
+    case Proc_Confirm: confirmControl();      break;
   }
 }
 
 void MarlinUI::update() { jyersDWIN.update(); }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void JyersDWIN::stateUpdate() {
   if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
     if (!printing) startPrint(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
     else stopPrint();
   }
   if (print_job_timer.isPaused() != paused) {
     paused = print_job_timer.isPaused();
-    if (process == Print) printScreenIcons();
-    if (process == Wait && !paused) redrawMenu(true, true);
+    if (process == Proc_Print) printScreenIcons();
+    if (process == Proc_Wait && !paused) redrawMenu(true, true);
   }
-  if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
-    confirmHandler(UserInput);
+  if (wait_for_user && !(process == Proc_Confirm) && !print_job_timer.isPaused())
+    confirmHandler(Popup_UserInput);
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    if (process == Popup && popup == PurgeMore) {
+    if (process == Proc_Popup && popup == Popup_PurgeMore) {
       if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
-        popupHandler(FilChange);
+        popupHandler(Popup_FilChange);
       else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
-        if (printing) popupHandler(Resuming);
-        else redrawMenu(true, true, active_menu == PreheatHotend);
+        if (printing) popupHandler(Popup_Resuming);
+        else redrawMenu(true, true, active_menu == ID_PreheatHotend);
       }
     }
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     static bool ranout = false;
     if (runout.filament_ran_out != ranout) {
       ranout = runout.filament_ran_out;
-      if (ranout) popupHandler(Runout);
+      if (ranout) popupHandler(Popup_Runout);
     }
   #endif
 }
 
 void JyersDWIN::screenUpdate() {
   const millis_t ms = millis();
   static millis_t scrltime = 0;
   if (ELAPSED(ms, scrltime)) {
     scrltime = ms + 200;
     updateStatusBar();
-    if (process == Print) drawPrintFilename();
+    if (process == Proc_Print) drawPrintFilename();
   }
 
   static millis_t statustime = 0;
   if (ELAPSED(ms, statustime)) {
     statustime = ms + 500;
     drawStatusArea();
   }
 
   static millis_t printtime = 0;
   if (ELAPSED(ms, printtime)) {
     printtime = ms + 1000;
-    if (process == Print) {
+    if (process == Proc_Print) {
       drawPrintProgressBar();
       drawPrintProgressElapsed();
       TERN_(SET_REMAINING_TIME, drawPrintProgressRemain());
     }
   }
 
   static bool mounted = card.isMounted();
   if (mounted != card.isMounted()) {
     mounted = card.isMounted();
-    if (process == File)
+    if (process == Proc_File)
       drawSDList();
   }
 
   #if HAS_HOTEND
     static int16_t hotendtarget = -1;
   #endif
   #if HAS_HEATED_BED
     static int16_t bedtarget = -1;
   #endif
   #if HAS_FAN
@@ -4888,75 +4889,75 @@ void JyersDWIN::screenUpdate() {
 
     #if HAS_BED_PROBE
       if (probe.offset.z != lastzoffset)
         zoffsetvalue = lastzoffset = probe.offset.z;
     #else
       if (-home_offset.z != lastzoffset)
         zoffsetvalue = lastzoffset = -home_offset.z;
     #endif
   #endif // HAS_ZOFFSET_ITEM
 
-  if (process == Menu || process == Value) {
+  if (process == Proc_Menu || process == Proc_Value) {
     switch (active_menu) {
-      case TempMenu:
+      case ID_TempMenu:
         #if HAS_HOTEND
           if (thermalManager.temp_hotend[0].target != hotendtarget) {
             hotendtarget = thermalManager.temp_hotend[0].target;
             if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+              if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_HEATED_BED
           if (thermalManager.temp_bed.target != bedtarget) {
             bedtarget = thermalManager.temp_bed.target;
             if (scrollpos <= TEMP_BED && TEMP_BED <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+              if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_FAN
           if (thermalManager.fan_speed[0] != fanspeed) {
             fanspeed = thermalManager.fan_speed[0];
             if (scrollpos <= TEMP_FAN && TEMP_FAN <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+              if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
-      case Tune:
+      case ID_Tune:
         #if HAS_HOTEND
           if (thermalManager.temp_hotend[0].target != hotendtarget) {
             hotendtarget = thermalManager.temp_hotend[0].target;
             if (scrollpos <= TUNE_HOTEND && TUNE_HOTEND <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+              if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_HEATED_BED
           if (thermalManager.temp_bed.target != bedtarget) {
             bedtarget = thermalManager.temp_bed.target;
             if (scrollpos <= TUNE_BED && TUNE_BED <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+              if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_FAN
           if (thermalManager.fan_speed[0] != fanspeed) {
             fanspeed = thermalManager.fan_speed[0];
             if (scrollpos <= TUNE_FAN && TUNE_FAN <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+              if (process != Proc_Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
     }
   }
 }
 
 void JyersDWIN::audioFeedback(const bool success/*=true*/) {
@@ -5010,34 +5011,34 @@ void JyersDWIN::resetSettings() {
 
 void MarlinUI::init_lcd() {
   delay(800);
   SERIAL_ECHOPGM("\nDWIN handshake ");
   if (dwinHandshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
   dwinFrameSetDir(1); // Orientation 90°
   dwinUpdateLCD();     // Show bootscreen (first image)
   encoderConfiguration();
   for (uint16_t t = 0; t <= 100; t += 2) {
     dwinIconShow(ICON, ICON_Bar, 15, 260);
-    dwinDrawRectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
+    dwinDrawRectangle(1, COLOR_BG_BLACK, 15 + t * 242 / 100, 260, 257, 280);
     dwinUpdateLCD();
     delay(20);
   }
 
   dwinJPGShowAndCache(3);
   dwinJPGCacheTo1(Language_English);
   jyersDWIN.redrawScreen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     switch (message) {
-      case PAUSE_MESSAGE_INSERT:  jyersDWIN.confirmHandler(FilInsert);  break;
+      case PAUSE_MESSAGE_INSERT:  jyersDWIN.confirmHandler(Popup_FilInsert);  break;
       case PAUSE_MESSAGE_PURGE:
-      case PAUSE_MESSAGE_OPTION:  jyersDWIN.popupHandler(PurgeMore);    break;
-      case PAUSE_MESSAGE_HEAT:    jyersDWIN.confirmHandler(HeaterTime); break;
+      case PAUSE_MESSAGE_OPTION:  jyersDWIN.popupHandler(Popup_PurgeMore);  break;
+      case PAUSE_MESSAGE_HEAT:    jyersDWIN.confirmHandler(Popup_HeaterTime); break;
       case PAUSE_MESSAGE_WAITING: jyersDWIN.drawPrintScreen();          break;
       default: break;
     }
   }
 #endif
 
 #endif // DWIN_CREALITY_LCD_JYERSUI

commit cb12114a7eeaefc227aa7aa94a8e382bfd3aa95a
Author: Krzysztof Błażewicz <blazewicz.krzysztof@gmail.com>
Date:   Thu Jun 29 09:18:32 2023 +0200

    🩹 Fix JyersUI typos (#26029)
    
    Followup to #24390

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 33495d82ba..22ff4b8a00 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1571,21 +1571,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           case ZOFFSET_HOME:
             if (draw)
               drawMenuItem(row, ICON_Homing, F("Home Z Axis"));
             else {
               popupHandler(Home);
               gcode.process_subcommands_now(F("G28Z"));
               popupHandler(MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 gcode.process_subcommands_now(
-                  TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3));
+                  TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3))
                 );
               #else
                 gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
               #endif
               gcode.process_subcommands_now(F("G0F300Z0"));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case ZOFFSET_MODE:
@@ -1596,21 +1596,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
             else {
               if (!liveadjust) {
                 if (axes_should_home()) {
                   popupHandler(Home);
                   gcode.home_all_axes(true);
                 }
                 popupHandler(MoveWait);
                 #if ENABLED(Z_SAFE_HOMING)
                   planner.synchronize();
                   gcode.process_subcommands_now(
-                    TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3));
+                    TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3))
                   );
                 #else
                   gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
                 #endif
                 gcode.process_subcommands_now(F("G0F300Z0"));
                 planner.synchronize();
                 redrawMenu();
               }
               liveadjust = !liveadjust;
               drawCheckbox(row, liveadjust);
@@ -2997,21 +2997,21 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
                 drawFloat(probe.offset.y, row, false, 10);
               }
               else
                 modifyValue(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_TEST:
               if (draw)
                 drawMenuItem(row, ICON_StepY, F("M48 Probe Test"));
               else {
                 gcode.process_subcommands_now(
-                  TS(F("G28O\nM48X" , p_float_t((X_BED_SIZE + X_MIN_POS) / 2.0f, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 3), 'P', testcount))
+                  TS(F("G28O\nM48X") , p_float_t((X_BED_SIZE + X_MIN_POS) / 2.0f, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 3), 'P', testcount)
                 );
               }
               break;
             case PROBE_TEST_COUNT:
               if (draw) {
                 drawMenuItem(row, ICON_StepY, F("Probe Test Count"));
                 drawFloat(testcount, row, false, 1);
               }
               else
                 modifyValue(testcount, 4, 50, 1);

commit be18edd604d10aba6fb7a3210e90bf711cc436dc
Author: Krzysztof Błażewicz <blazewicz.krzysztof@gmail.com>
Date:   Wed Jun 28 05:51:47 2023 +0200

    🚸 JyersUI MPC menu (#26017)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index c43afab100..33495d82ba 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1975,22 +1975,23 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           break;
       }
       break;
 
     case TempMenu:
 
       #define TEMP_BACK 0
       #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
       #define TEMP_BED (TEMP_HOTEND + ENABLED(HAS_HEATED_BED))
       #define TEMP_FAN (TEMP_BED + ENABLED(HAS_FAN))
-      #define TEMP_PID (TEMP_FAN + ANY(HAS_HOTEND, HAS_HEATED_BED))
-      #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
+      #define TEMP_PID (TEMP_FAN + ANY(PIDTEMP, PIDTEMPBED))
+      #define TEMP_MPC (TEMP_PID + ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU))
+      #define TEMP_PREHEAT1 (TEMP_MPC + (PREHEAT_COUNT >= 1))
       #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
       #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
       #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
       #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
       #define TEMP_TOTAL TEMP_PREHEAT5
 
       switch (item) {
         case TEMP_BACK:
           if (draw)
             drawMenuItem(row, ICON_Back, F("Back"));
@@ -2020,86 +2021,94 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
         #if HAS_FAN
           case TEMP_FAN:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Fan"));
               drawFloat(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               modifyValue(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
-        #if HAS_HOTEND || HAS_HEATED_BED
+        #if ANY(PIDTEMP, PIDTEMPBED)
           case TEMP_PID:
             if (draw)
               drawMenuItem(row, ICON_Step, F("PID"), nullptr, true);
             else
               drawMenu(PID);
             break;
         #endif
+        #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+          case TEMP_MPC:
+            if (draw)
+              drawMenuItem(row, ICON_Step, F("MPC"), nullptr, true);
+            else
+              drawMenu(MPC);
+            break;
+        #endif
 
         #define _TEMP_PREHEAT_CASE(N) \
           case TEMP_PREHEAT##N: { \
             if (draw) drawMenuItem(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
             else drawMenu(Preheat##N); \
           } break;
 
         REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
       }
       break;
 
     #if ANY(PIDTEMP, PIDTEMPBED)
       case PID:
 
         #define PID_BACK 0
-        #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
-        #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PID_HOTEND (PID_BACK + ENABLED(PIDTEMP))
+        #define PID_BED (PID_HOTEND + ENABLED(PIDTEMPBED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
         switch (item) {
           case PID_BACK:
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
               drawMenu(TempMenu, TEMP_PID);
             break;
-          #if HAS_HOTEND
+          #if ENABLED(PIDTEMP)
             case PID_HOTEND:
               if (draw)
                 drawMenuItem(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
               else
                 drawMenu(HotendPID);
               break;
           #endif
-          #if HAS_HEATED_BED
+          #if ENABLED(PIDTEMPBED)
             case PID_BED:
               if (draw)
                 drawMenuItem(row, ICON_BedTemp, F("Bed"), nullptr, true);
               else
                 drawMenu(BedPID);
               break;
           #endif
           case PID_CYCLES:
             if (draw) {
               drawMenuItem(row, ICON_FanSpeed, F("Cycles"));
               drawFloat(PID_cycles, row, false, 1);
             }
             else
               modifyValue(PID_cycles, 3, 50, 1);
             break;
         }
         break;
-    #endif // HAS_HOTEND || HAS_HEATED_BED
+    #endif // PIDTEMP || PIDTEMPBED
 
-    #if HAS_HOTEND
+    #if ENABLED(PIDTEMP)
       case HotendPID:
 
         #define HOTENDPID_BACK 0
         #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
         #define HOTENDPID_TEMP (HOTENDPID_TUNE + 1)
         #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
         #define HOTENDPID_KI (HOTENDPID_KP + 1)
         #define HOTENDPID_KD (HOTENDPID_KI + 1)
         #define HOTENDPID_TOTAL HOTENDPID_KD
 
@@ -2149,23 +2158,23 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
           case HOTENDPID_KD:
             if (draw) {
               drawMenuItem(row, ICON_Version, F("Kd Value"));
               drawFloat(thermalManager.temp_hotend[0].pid.d(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
-    #endif // HAS_HOTEND
+    #endif // PIDTEMP
 
-    #if HAS_HEATED_BED
+    #if ENABLED(PIDTEMPBED)
       case BedPID:
 
         #define BEDPID_BACK 0
         #define BEDPID_TUNE (BEDPID_BACK + 1)
         #define BEDPID_TEMP (BEDPID_TUNE + 1)
         #define BEDPID_KP (BEDPID_TEMP + 1)
         #define BEDPID_KI (BEDPID_KP + 1)
         #define BEDPID_KD (BEDPID_KI + 1)
         #define BEDPID_TOTAL BEDPID_KD
 
@@ -2217,20 +2226,108 @@ void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool dra
               drawMenuItem(row, ICON_Version, F("Kd Value"));
               drawFloat(thermalManager.temp_bed.pid.d(), row, false, 100);
             }
             else
               modifyValue(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
         }
         break;
     #endif // PIDTEMPBED
 
+    #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+      case MPC:
+
+        #define MPCMENU_BACK 0
+        #define MPCMENU_AUTOTUNE (MPCMENU_BACK + ENABLED(MPC_AUTOTUNE_MENU))
+        #define MPCMENU_HEATER_POWER (MPCMENU_AUTOTUNE + ENABLED(MPC_EDIT_MENU))
+        #define MPCMENU_BLOCK_HEAT_CAPACITY (MPCMENU_HEATER_POWER + ENABLED(MPC_EDIT_MENU))
+        #define MPCMENU_SENSOR_RESPONSIVENESS (MPCMENU_BLOCK_HEAT_CAPACITY + ENABLED(MPC_EDIT_MENU))
+        #define MPCMENU_AMBIENT_XFER_COEFF (MPCMENU_SENSOR_RESPONSIVENESS + ENABLED(MPC_EDIT_MENU))
+        #define MPCMENU_AMBIENT_XFER_COEFF_FAN (MPCMENU_AMBIENT_XFER_COEFF + ALL(MPC_EDIT_MENU, MPC_INCLUDE_FAN))
+        #define MPCMENU_TOTAL MPCMENU_AMBIENT_XFER_COEFF_FAN
+
+        switch (item) {
+          case MPCMENU_BACK:
+            if (draw)
+              drawMenuItem(row, ICON_Back, F("Back"));
+            else
+              drawMenu(TempMenu, TEMP_MPC);
+            break;
+
+          #if ENABLED(MPC_AUTOTUNE_MENU)
+            case MPCMENU_AUTOTUNE:
+              if (draw)
+                drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
+              else {
+                popupHandler(MPCWait);
+                thermalManager.MPC_autotune(active_extruder, Temperature::MPCTuningType::AUTO);
+                redrawMenu();
+              }
+              break;
+          #endif
+
+          #if ENABLED(MPC_EDIT_MENU)
+            case MPCMENU_HEATER_POWER:
+              if (draw) {
+                drawMenuItem(row, ICON_Version, F("Heater Power"));
+                drawFloat(thermalManager.temp_hotend[0].mpc.heater_power, row, false, 1);
+              }
+              else
+                modifyValue(thermalManager.temp_hotend[0].mpc.heater_power, 1, 200, 1);
+              break;
+
+            case MPCMENU_BLOCK_HEAT_CAPACITY:
+              if (draw) {
+                drawMenuItem(row, ICON_Version, F("Block Heat Cap."));
+                drawFloat(thermalManager.temp_hotend[0].mpc.block_heat_capacity, row, false, 100);
+              }
+              else
+                modifyValue(thermalManager.temp_hotend[0].mpc.block_heat_capacity, 0, 40, 100);
+              break;
+
+            case MPCMENU_SENSOR_RESPONSIVENESS:
+              if (draw) {
+                drawMenuItem(row, ICON_Version, F("Sensor Resp."));
+                drawFloat(thermalManager.temp_hotend[0].mpc.sensor_responsiveness, row, false, 10000);
+              }
+              else
+                modifyValue(thermalManager.temp_hotend[0].mpc.sensor_responsiveness, 0, 1, 10000);
+              break;
+
+            case MPCMENU_AMBIENT_XFER_COEFF:
+              if (draw) {
+                drawMenuItem(row, ICON_Version, F("Amb. xfer coeff"));
+                drawFloat(thermalManager.temp_hotend[0].mpc.ambient_xfer_coeff_fan0, row, false, 10000);
+              }
+              else
+                modifyValue(thermalManager.temp_hotend[0].mpc.ambient_xfer_coeff_fan0, 0, 1, 10000);
+              break;
+
+            #if ENABLED(MPC_INCLUDE_FAN)
+              case MPCMENU_AMBIENT_XFER_COEFF_FAN: {
+                static float fan255_adjustment;
+                if (draw) {
+                  drawMenuItem(row, ICON_Version, F("Amb. xfer adj."));
+                  fan255_adjustment = thermalManager.temp_hotend[0].fanCoefficient();
+                  drawFloat(fan255_adjustment, row, false, 10000);
+                }
+                else
+                  modifyValue(fan255_adjustment, 0, 1, 10000, []{ thermalManager.temp_hotend[0].applyFanAdjustment(fan255_adjustment); });
+              } break;
+            #endif
+
+          #endif // MPC_EDIT_MENU
+        }
+        break;
+
+    #endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
+
     #if HAS_PREHEAT
       #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
     case Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
@@ -3943,29 +4040,32 @@ FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
     #if HAS_CUSTOM_MENU
       case MenuCustom:
         #ifdef CUSTOM_MENU_CONFIG_TITLE
           return F(CUSTOM_MENU_CONFIG_TITLE);
         #else
           return GET_TEXT_F(MSG_CUSTOM_COMMANDS);
         #endif
     #endif
     case Control:           return GET_TEXT_F(MSG_CONTROL);
     case TempMenu:          return GET_TEXT_F(MSG_TEMPERATURE);
-    #if HAS_HOTEND || HAS_HEATED_BED
+    #if ANY(PIDTEMP, PIDTEMPBED)
       case PID:             return F("PID Menu");
     #endif
-    #if HAS_HOTEND
+    #if ENABLED(PIDTEMP)
       case HotendPID:       return F("Hotend PID Settings");
     #endif
-    #if HAS_HEATED_BED
+    #if ENABLED(PIDTEMPBED)
       case BedPID:          return F("Bed PID Settings");
     #endif
+    #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+      case MPC:             return F("MPC Menu");
+    #endif
     #if HAS_PREHEAT
       #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
     case Motion:            return F("Motion Settings");
     case HomeOffsets:       return F("Home Offsets");
     case MaxSpeed:          return F("Max Speed");
     case MaxAcceleration:   return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return F("Max Jerk");
@@ -4014,29 +4114,32 @@ uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
       case Preheat:         return PREHEAT_TOTAL;
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:  return CHANGEFIL_TOTAL;
     #endif
     #if HAS_CUSTOM_MENU
       case MenuCustom:      return CUSTOM_MENU_TOTAL;
     #endif
     case Control:           return CONTROL_TOTAL;
     case TempMenu:          return TEMP_TOTAL;
-    #if HAS_HOTEND || HAS_HEATED_BED
+    #if ANY(PIDTEMP, PIDTEMPBED)
       case PID:             return PID_TOTAL;
     #endif
-    #if HAS_HOTEND
+    #if ENABLED(PIDTEMP)
       case HotendPID:       return HOTENDPID_TOTAL;
     #endif
-    #if HAS_HEATED_BED
+    #if ENABLED(PIDTEMPBED)
       case BedPID:          return BEDPID_TOTAL;
     #endif
+    #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+      case MPC:             return MPCMENU_TOTAL;
+    #endif
     #if HAS_PREHEAT
       case Preheat1 ... CAT(Preheat, PREHEAT_COUNT):
                             return PREHEAT_SUBMENU_TOTAL;
     #endif
     case Motion:            return MOTION_TOTAL;
     case HomeOffsets:       return HOMEOFFSETS_TOTAL;
     case MaxSpeed:          return SPEED_TOTAL;
     case MaxAcceleration:   return ACCEL_TOTAL;
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return JERK_TOTAL;
@@ -4094,20 +4197,21 @@ void JyersDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/)
     case ManualProbing: drawPopup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
     case Level:         drawPopup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
     case Home:          drawPopup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case MoveWait:      drawPopup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case Heating:       drawPopup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
     case TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
     case Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
     case PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
+    case MPCWait:       drawPopup(F("MPC Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
     case Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case Custom:        drawPopup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
 void JyersDWIN::confirmHandler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
     case FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
@@ -4187,23 +4291,23 @@ void JyersDWIN::valueControl() {
     if (active_menu == ZOffset && liveadjust) {
       planner.synchronize();
       current_position.z += (tempvalue / valueunit - zoffsetvalue);
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
       current_position.z = 0;
       sync_plan_position();
     }
     else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
       gcode.process_subcommands_now(TS(F("M290Z"), p_float_t((tempvalue / valueunit - zoffsetvalue), 3)));
     }
-    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
+    if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Ki))
       tempvalue = scalePID_i(tempvalue);
-    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
+    if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Kd))
       tempvalue = scalePID_d(tempvalue);
     switch (valuetype) {
       case 0: *(float*)valuepointer = tempvalue / valueunit; break;
       case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
       case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
       case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
       case 4: *(uint32_t*)valuepointer = tempvalue / valueunit; break;
       case 5: *(int8_t*)valuepointer = tempvalue / valueunit; break;
     }
     switch (active_menu) {

commit bbfaf7474c50f81d606c2dde91035bc40835e830
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 21:44:42 2023 -0500

    🎨 CrealityDWIN => JyersDWIN (#26026)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 95a387c6cb..c43afab100 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -121,23 +121,23 @@
 #if HAS_HEATED_BED
   #define MAX_BED_TEMP  BED_MAXTEMP
   #define MIN_BED_TEMP  0
 #endif
 
 #define FEEDRATE_UNIT 1
 #define ACCELERATION_UNIT 1
 #define JERK_UNIT 10
 #define STEPS_UNIT 10
 
-/**
- * Custom menu items with jyersLCD
- */
+//
+// Custom menu items with JyersLCD
+//
 #if ENABLED(CUSTOM_MENU_CONFIG)
   #ifdef CONFIG_MENU_ITEM_5_DESC
     #define CUSTOM_MENU_COUNT 5
   #elif defined(CONFIG_MENU_ITEM_4_DESC)
     #define CUSTOM_MENU_COUNT 4
   #elif defined(CONFIG_MENU_ITEM_3_DESC)
     #define CUSTOM_MENU_COUNT 3
   #elif defined(CONFIG_MENU_ITEM_2_DESC)
     #define CUSTOM_MENU_COUNT 2
   #elif defined(CONFIG_MENU_ITEM_1_DESC)
@@ -194,21 +194,21 @@ int16_t pausetemp, pausebed, pausefan;
 bool livemove = false;
 bool liveadjust = false;
 uint8_t preheatmode = 0;
 float zoffsetvalue = 0;
 grid_count_t gridpoint;
 float corner_avg;
 float corner_pos;
 
 bool probe_deployed = false;
 
-CrealityDWIN crealityDWIN;
+JyersDWIN jyersDWIN;
 
 template <unsigned N, unsigned S = N>
 class TextScroller {
 public:
   static const unsigned SIZE = N;
   static const unsigned SPACE = S;
   typedef char Buffer[SIZE + 1];
 
   inline TextScroller()
     : scrollpos(0)
@@ -322,28 +322,28 @@ private:
     #endif
 
     void manual_mesh_move(const bool zmove=false) {
       if (zmove) {
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
-        crealityDWIN.popupHandler(MoveWait);
+        jyersDWIN.popupHandler(MoveWait);
         gcode.process_subcommands_now(TS(F("G0F300Z"), p_float_t(current_position.z, 3)));
         gcode.process_subcommands_now(TS(F("G42 F4000 I"), mesh_x, 'J', mesh_y));
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
-        crealityDWIN.redrawMenu();
+        jyersDWIN.redrawMenu();
       }
     }
 
     float get_max_value() {
       float max = __FLT_MIN__;
       GRID_LOOP(x, y) {
         if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
           max = bedlevel.z_values[x][y];
       }
       return max;
@@ -425,191 +425,171 @@ private:
         if (v_max > 3e+10F) v_max = 0.0000001;
         v1 = -v_min;
         v2 =  v_max;
       }
       else {
         float range = _MAX(v_min, v_max);
         if (range > 3e+10F) range = 0.0000001;
         v1 = -range;
         v2 =  range;
       }
-      crealityDWIN.updateStatus(TS(F("Red "), p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), F(" Green")));
+      jyersDWIN.updateStatus(TS(F("Red "), p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), F(" Green")));
       drawing_mesh = false;
     }
 
   };
   Mesh_Settings mesh_conf;
 
 #endif // HAS_MESH
 
-/* General Display Functions */
+//
+// General Display Functions
+//
 
-struct CrealityDWIN::EEPROM_Settings CrealityDWIN::eeprom_settings{0};
-constexpr const char * const CrealityDWIN::color_names[11];
-constexpr const char * const CrealityDWIN::preheat_modes[3];
+struct JyersDWIN::EEPROM_Settings JyersDWIN::eeprom_settings{0};
+constexpr const char * const JyersDWIN::color_names[11];
+constexpr const char * const JyersDWIN::preheat_modes[3];
 
 // Clear a part of the screen
 //  4=Entire screen
 //  3=Title bar and Menu area (default)
 //  2=Menu area
 //  1=Title bar
-void CrealityDWIN::clearScreen(const uint8_t e/*=3*/) {
+void JyersDWIN::clearScreen(const uint8_t e/*=3*/) {
   if (e == 1 || e == 3 || e == 4) dwinDrawRectangle(1, getColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
   if (e == 2 || e == 3) dwinDrawRectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
   if (e == 4) dwinDrawRectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
 }
 
-void CrealityDWIN::drawFloat(const_float_t value, const uint8_t row, const bool selected/*=false*/, const uint8_t minunit/*=10*/) {
+void JyersDWIN::drawFloat(const_float_t value, const uint8_t row, const bool selected/*=false*/, const uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
   const uint16_t bColor = selected ? Select_Color : Color_Bg_Black;
   const uint16_t xpos = 240 - (digits * 8);
   dwinDrawRectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
     dwinDrawString(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
     dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
     dwinDrawString(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
-void CrealityDWIN::drawOption(const uint8_t value, const char * const * options, const uint8_t row, const bool selected/*=false*/, const bool color/*=false*/) {
+void JyersDWIN::drawOption(const uint8_t value, const char * const * options, const uint8_t row, const bool selected/*=false*/, const bool color/*=false*/) {
   const uint16_t bColor = selected ? Select_Color : Color_Bg_Black,
                  tColor = color ? getColor(value, Color_White, false) : Color_White;
   dwinDrawRectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
   dwinDrawString(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
-uint16_t CrealityDWIN::getColor(const uint8_t color, const uint16_t original, const bool light/*=false*/) {
+uint16_t JyersDWIN::getColor(const uint8_t color, const uint16_t original, const bool light/*=false*/) {
   switch (color) {
-    case Default:
-      return original;
-      break;
-    case White:
-      return light ? Color_Light_White : Color_White;
-      break;
-    case Green:
-      return light ? Color_Light_Green : Color_Green;
-      break;
-    case Cyan:
-      return light ? Color_Light_Cyan : Color_Cyan;
-      break;
-    case Blue:
-      return light ? Color_Light_Blue : Color_Blue;
-      break;
-    case Magenta:
-      return light ? Color_Light_Magenta : Color_Magenta;
-      break;
-    case Red:
-      return light ? Color_Light_Red : Color_Red;
-      break;
-    case Orange:
-      return light ? Color_Light_Orange : Color_Orange;
-      break;
-    case Yellow:
-      return light ? Color_Light_Yellow : Color_Yellow;
-      break;
-    case Brown:
-      return light ? Color_Light_Brown : Color_Brown;
-      break;
-    case Black:
-      return Color_Black;
-      break;
+    case White:   return light ? Color_Light_White   : Color_White;
+    case Green:   return light ? Color_Light_Green   : Color_Green;
+    case Cyan:    return light ? Color_Light_Cyan    : Color_Cyan;
+    case Blue:    return light ? Color_Light_Blue    : Color_Blue;
+    case Magenta: return light ? Color_Light_Magenta : Color_Magenta;
+    case Red:     return light ? Color_Light_Red     : Color_Red;
+    case Orange:  return light ? Color_Light_Orange  : Color_Orange;
+    case Yellow:  return light ? Color_Light_Yellow  : Color_Yellow;
+    case Brown:   return light ? Color_Light_Brown   : Color_Brown;
+    case Black:   return Color_Black;
+    case Default: return original;
   }
   return Color_White;
 }
 
-void CrealityDWIN::drawTitle(const char * const ctitle) {
+void JyersDWIN::drawTitle(const char * const ctitle) {
   dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
 }
-void CrealityDWIN::drawTitle(FSTR_P const ftitle) {
+void JyersDWIN::drawTitle(FSTR_P const ftitle) {
   dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
 }
 
 void _decorateMenuItem(uint8_t row, uint8_t icon, bool more) {
-  if (icon) dwinIconShow(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
+  if (icon) dwinIconShow(ICON, icon, 26, MBASE(row) - 3);       // Draw Menu Icon
   if (more) dwinIconShow(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
-  dwinDrawLine(crealityDWIN.getColor(crealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+  dwinDrawLine(jyersDWIN.getColor(jyersDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
-void CrealityDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, const char * const label1, const char * const label2, const bool more/*=false*/, const bool centered/*=false*/) {
-  const uint8_t label_offset_y = (label1 || label2) ? MENU_CHR_H * 3 / 5 : 0,
+void JyersDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, const char * const label1, const char * const label2, const bool more/*=false*/, const bool centered/*=false*/) {
+  const uint8_t label_offset_y = label2 ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
   if (label1) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
   if (label2) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
   _decorateMenuItem(row, icon, more);
 }
 
-void CrealityDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, const bool more/*=false*/, const bool centered/*=false*/) {
-  const uint8_t label_offset_y = (flabel1 || flabel2) ? MENU_CHR_H * 3 / 5 : 0,
+void JyersDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, const bool more/*=false*/, const bool centered/*=false*/) {
+  const uint8_t label_offset_y = flabel2 ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
   if (flabel1) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
   if (flabel2) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
   _decorateMenuItem(row, icon, more);
 }
 
-void CrealityDWIN::drawCheckbox(const uint8_t row, const bool value) {
-  #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
+void JyersDWIN::drawCheckbox(const uint8_t row, const bool value) {
+  #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS)   // Draw appropriate checkbox icon
     dwinIconShow(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
     dwinDrawRectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     dwinDrawRectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     if (value) {
       dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
       dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
       dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
       dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
       dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
       dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
     }
   #endif
 }
 
-void CrealityDWIN::drawMenu(const uint8_t menu, const uint8_t select/*=0*/, const uint8_t scroll/*=0*/) {
+void JyersDWIN::drawMenu(const uint8_t menu, const uint8_t select/*=0*/, const uint8_t scroll/*=0*/) {
   if (active_menu != menu) {
     last_menu = active_menu;
     if (process == Menu) last_selection = selection;
   }
   selection = _MIN(select, getMenuSize(menu));
   scrollpos = scroll;
-  if (selection - scrollpos > MROWS)
-    scrollpos = selection - MROWS;
+  if (selection - scrollpos > MROWS) scrollpos = selection - MROWS; // i.e., NOLESS(scrollpos, selection - MROWS);
   process = Menu;
   active_menu = menu;
   clearScreen();
   drawTitle(getMenuTitle(menu));
   for (uint8_t i = 0; i < TROWS; ++i) menuItemHandler(menu, i + scrollpos);
   dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
 
-void CrealityDWIN::redrawMenu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
+void JyersDWIN::redrawMenu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
   switch (lastproc ? last_process : process) {
     case Menu:
       drawMenu(lastmenu ? last_menu : active_menu, lastsel ? last_selection : selection, lastmenu ? 0 : scrollpos);
       break;
     case Main:  drawMainMenu(lastsel ? last_selection : selection); break;
     case Print: drawPrintScreen(); break;
     case File:  drawSDList(); break;
     default: break;
   }
 }
 
-void CrealityDWIN::redrawScreen() {
+void JyersDWIN::redrawScreen() {
   redrawMenu(false);
   drawStatusArea(true);
   updateStatusBar(true);
 }
 
-/* Primary Menus and Screen Elements */
-
-void CrealityDWIN::mainMenuIcons() {
+//
+// Primary Menus and Screen Elements
+//
+void JyersDWIN::mainMenuIcons() {
   if (selection == 0) {
     dwinIconShow(ICON, ICON_Print_1, 17, 130);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
     dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
   }
   else {
     dwinIconShow(ICON, ICON_Print_0, 17, 130);
     dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
   }
   if (selection == 1) {
@@ -646,32 +626,32 @@ void CrealityDWIN::mainMenuIcons() {
       dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
       dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
     else {
       dwinIconShow(ICON, ICON_Info_0, 145, 246);
       dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
   #endif
 }
 
-void CrealityDWIN::drawMainMenu(const uint8_t select/*=0*/) {
+void JyersDWIN::drawMainMenu(const uint8_t select/*=0*/) {
   process = Main;
   active_menu = MainMenu;
   selection = select;
   clearScreen();
   drawTitle(getMenuTitle(MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
   dwinIconShow(ICON, ICON_LOGO, 71, 72);
   mainMenuIcons();
 }
 
-void CrealityDWIN::printScreenIcons() {
+void JyersDWIN::printScreenIcons() {
   if (selection == 0) {
     dwinIconShow(ICON, ICON_Setup_1, 8, 252);
     dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
     dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
   }
   else {
     dwinIconShow(ICON, ICON_Setup_0, 8, 252);
     dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
   }
   if (selection == 2) {
@@ -700,138 +680,138 @@ void CrealityDWIN::printScreenIcons() {
       dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
       dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
     }
     else {
       dwinIconShow(ICON, ICON_Pause_0, 96, 252);
       dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
     }
   }
 }
 
-void CrealityDWIN::drawPrintScreen() {
+void JyersDWIN::drawPrintScreen() {
   process = Print;
   selection = 0;
   clearScreen();
   dwinDrawRectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
   drawTitle("Printing...");
   printScreenIcons();
   dwinIconShow(ICON, ICON_PrintTime, 14, 171);
   dwinIconShow(ICON, ICON_RemainTime, 147, 169);
   dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
   dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
   updateStatusBar(true);
   drawPrintProgressBar();
   drawPrintProgressElapsed();
   TERN_(SET_REMAINING_TIME, drawPrintProgressRemain());
   drawPrintFilename(true);
 }
 
-void CrealityDWIN::drawPrintFilename(const bool reset/*=false*/) {
+void JyersDWIN::drawPrintFilename(const bool reset/*=false*/) {
   typedef TextScroller<30> Scroller;
   static Scroller scroller;
   if (reset) scroller.reset();
   if (process == Print) {
     Scroller::Buffer buf;
     size_t outlen = 0;
     const char* outstr = scroller.scroll(outlen, buf, filename);
     dwinDrawRectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
     const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
     dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
   }
 }
 
-void CrealityDWIN::drawPrintProgressBar() {
+void JyersDWIN::drawPrintProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
   dwinIconShow(ICON, ICON_Bar, 15, 93);
   dwinDrawRectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
   dwinDrawIntValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
   dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
 }
 
 #if ENABLED(SET_REMAINING_TIME)
 
-  void CrealityDWIN::drawPrintProgressRemain() {
+  void JyersDWIN::drawPrintProgressRemain() {
     uint16_t remainingtime = ui.get_remaining_time();
     dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
     dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
     if (eeprom_settings.time_format_textual) {
       dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
       dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
     }
     else
       dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
   }
 
 #endif
 
-void CrealityDWIN::drawPrintProgressElapsed() {
+void JyersDWIN::drawPrintProgressElapsed() {
   duration_t elapsed = print_job_timer.duration();
   dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
   dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
   if (eeprom_settings.time_format_textual) {
     dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
     dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
   }
   else
     dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
 }
 
-void CrealityDWIN::drawPrintConfirm() {
+void JyersDWIN::drawPrintConfirm() {
   drawPrintScreen();
   process = Confirm;
   popup = Complete;
   dwinDrawRectangle(1, Color_Bg_Black, 8, 252, 263, 351);
   dwinIconShow(ICON, ICON_Confirm_E, 87, 283);
   dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
   dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
 }
 
-void CrealityDWIN::drawSDItem(const uint8_t item, const uint8_t row) {
+void JyersDWIN::drawSDItem(const uint8_t item, const uint8_t row) {
   if (item == 0)
     drawMenuItem(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
   else {
     card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
     for (uint8_t i = 0; i < len; ++i) name[i] = filename[i];
     if (pos > max)
       for (uint8_t i = len - 3; i < len; ++i) name[i] = '.';
     name[len] = '\0';
     drawMenuItem(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
-void CrealityDWIN::drawSDList(const bool removed/*=false*/) {
+void JyersDWIN::drawSDList(const bool removed/*=false*/) {
   clearScreen();
   drawTitle("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
     for (uint8_t i = 0; i < _MIN(card.get_num_items() + 1, TROWS); ++i)
       drawSDItem(i, i);
   }
   else {
     drawMenuItem(0, ICON_Back, F("Back"));
     dwinDrawRectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     dwinDrawString(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
   dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
-void CrealityDWIN::drawStatusArea(const bool icons/*=false*/) {
+void JyersDWIN::drawStatusArea(const bool icons/*=false*/) {
 
   if (icons) dwinDrawRectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
       dwinIconShow(ICON, ICON_HotendTemp, 10, 383);
@@ -945,21 +925,21 @@ void CrealityDWIN::drawStatusArea(const bool icons/*=false*/) {
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
       dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
     else
       dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, current_position.z >= 0 ? current_position.z : 0);
   }
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::drawPopup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
+void JyersDWIN::drawPopup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
   if (process != Confirm && process != Popup && process != Wait) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
   clearScreen();
   dwinDrawRectangle(0, Color_White, 13, 59, 259, 351);
   dwinDrawRectangle(1, Color_Bg_Window, 14, 60, 258, 350);
   const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
   if (icon > 0) dwinIconShow(ICON, icon, 101, 105);
   dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
   dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
@@ -972,33 +952,33 @@ void CrealityDWIN::drawPopup(FSTR_P const line1, FSTR_P const line2, FSTR_P cons
     dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
     popupSelect();
   }
   else if (mode == Confirm) {
     dwinDrawRectangle(1, Confirm_Color, 87, 280, 186, 317);
     dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
   }
 }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
-  crealityDWIN.drawPopup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
+  jyersDWIN.drawPopup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
 }
 
-void CrealityDWIN::popupSelect() {
+void JyersDWIN::popupSelect() {
   const uint16_t c1 = selection ? Color_Bg_Window : getColor(eeprom_settings.highlight_box, Color_White),
                  c2 = selection ? getColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window;
   dwinDrawRectangle(0, c1, 25, 279, 126, 318);
   dwinDrawRectangle(0, c1, 24, 278, 127, 319);
   dwinDrawRectangle(0, c2, 145, 279, 246, 318);
   dwinDrawRectangle(0, c2, 144, 278, 247, 319);
 }
 
-void CrealityDWIN::updateStatusBar(const bool refresh/*=false*/) {
+void JyersDWIN::updateStatusBar(const bool refresh/*=false*/) {
   typedef TextScroller<30> Scroller;
   static bool new_msg;
   static Scroller scroller;
   static char lastmsg[64];
   if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
     strcpy(lastmsg, statusmsg);
     scroller.reset();
     new_msg = true;
   }
   Scroller::Buffer buf;
@@ -1012,23 +992,25 @@ void CrealityDWIN::updateStatusBar(const bool refresh/*=false*/) {
       dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
     }
     else {
       dwinDrawRectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
       const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
       dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
     }
   }
 }
 
-/* Menu Item Config */
+//
+// Menu Item Config
+//
 
-void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool draw/*=true*/) {
+void JyersDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool draw/*=true*/) {
   const uint8_t row = item - scrollpos;
   #if HAS_LEVELING
     static bool level_state;
   #endif
 
   #if HAS_PREHEAT
 
     #define PREHEAT_BACK 0
     #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
     #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
@@ -2057,21 +2039,21 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
         #define _TEMP_PREHEAT_CASE(N) \
           case TEMP_PREHEAT##N: { \
             if (draw) drawMenuItem(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
             else drawMenu(Preheat##N); \
           } break;
 
         REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
       }
       break;
 
-    #if HAS_HOTEND || HAS_HEATED_BED
+    #if ANY(PIDTEMP, PIDTEMPBED)
       case PID:
 
         #define PID_BACK 0
         #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
         #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
@@ -2212,43 +2194,42 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
               drawFloat(PID_bed_temp, row, false, 1);
             }
             else
               modifyValue(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
           case BEDPID_KP:
             if (draw) {
               drawMenuItem(row, ICON_Version, F("Kp Value"));
               drawFloat(thermalManager.temp_bed.pid.p(), row, false, 100);
             }
-            else {
-              modifyValue(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
-            }
+            else
+              modifyValue(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
           case BEDPID_KI:
             if (draw) {
               drawMenuItem(row, ICON_Version, F("Ki Value"));
               drawFloat(thermalManager.temp_bed.pid.i(), row, false, 100);
             }
             else
-              modifyValue(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
           case BEDPID_KD:
             if (draw) {
               drawMenuItem(row, ICON_Version, F("Kd Value"));
               drawFloat(thermalManager.temp_bed.pid.d(), row, false, 100);
             }
             else
-              modifyValue(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, []{ thermalManager.temp_bed.pid.reset(); });
             break;
         }
         break;
-    #endif // HAS_HEATED_BED
+    #endif // PIDTEMPBED
 
     #if HAS_PREHEAT
       #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
     case Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
@@ -3936,21 +3917,21 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
             else
               modifyValue(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
 
-FSTR_P CrealityDWIN::getMenuTitle(const uint8_t menu) {
+FSTR_P JyersDWIN::getMenuTitle(const uint8_t menu) {
   switch (menu) {
     case MainMenu:          return GET_TEXT_F(MSG_MAIN_MENU);
     case Prepare:           return GET_TEXT_F(MSG_PREPARE);
     case HomeMenu:          return F("Homing Menu");
     case Move:              return GET_TEXT_F(MSG_MOVE_AXIS);
     case ManualLevel:       return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return GET_TEXT_F(MSG_ZPROBE_ZOFFSET);
     #endif
     #if HAS_PREHEAT
@@ -4013,21 +3994,21 @@ FSTR_P CrealityDWIN::getMenuTitle(const uint8_t menu) {
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:      return GET_TEXT_F(MSG_MANUAL_LEVELING);
     #endif
     case Tune:              return GET_TEXT_F(MSG_TUNE);
     case PreheatHotend:     return GET_TEXT_F(MSG_PREHEAT_HOTEND);
   }
   return F("");
 }
 
-uint8_t CrealityDWIN::getMenuSize(const uint8_t menu) {
+uint8_t JyersDWIN::getMenuSize(const uint8_t menu) {
   switch (menu) {
     case Prepare:           return PREPARE_TOTAL;
     case HomeMenu:          return HOME_TOTAL;
     case Move:              return MOVE_TOTAL;
     case ManualLevel:       return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return ZOFFSET_TOTAL;
     #endif
     #if HAS_PREHEAT
       case Preheat:         return PREHEAT_TOTAL;
@@ -4088,23 +4069,25 @@ uint8_t CrealityDWIN::getMenuSize(const uint8_t menu) {
 
     #if HAS_PREHEAT && HAS_HOTEND
       case PreheatHotend:   return PREHEATHOTEND_TOTAL;
     #endif
 
     case ColorSettings:     return COLORSETTINGS_TOTAL;
   }
   return 0;
 }
 
-/* Popup Config */
+//
+// Popup Config
+//
 
-void CrealityDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/) {
+void JyersDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
     case Pause:         drawPopup(F("Pause Print"), F(""), F(""), Popup); break;
     case Stop:          drawPopup(F("Stop Print"), F(""), F(""), Popup); break;
     case Resume:        drawPopup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
     case ConfFilChange: drawPopup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
     case PurgeMore:     drawPopup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
     case SaveLevel:     drawPopup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
     case MeshSlot:      drawPopup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
     case ETemp:         drawPopup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
@@ -4117,62 +4100,64 @@ void CrealityDWIN::popupHandler(const PopupID popupid, const bool option/*=false
     case FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
     case TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
     case Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
     case PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
     case Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case Custom:        drawPopup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
-void CrealityDWIN::confirmHandler(PopupID popupid) {
+void JyersDWIN::confirmHandler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
     case FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
     case HeaterTime:  drawPopup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
     case UserInput:   drawPopup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
     case LevelError:  drawPopup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
     case InvalidMesh: drawPopup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
     default: break;
   }
 }
 
-/* Navigation and Control */
+//
+// Navigation and Control
+//
 
-void CrealityDWIN::mainMenuControl() {
+void JyersDWIN::mainMenuControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {
     selection++; // Select Down
     mainMenuIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     mainMenuIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     switch (selection) {
       case PAGE_PRINT: card.mount(); drawSDList(); break;
       case PAGE_PREPARE: drawMenu(Prepare); break;
       case PAGE_CONTROL: drawMenu(Control); break;
       case PAGE_INFO_LEVELING: drawMenu(TERN(HAS_MESH, Leveling, InfoMain)); break;
     }
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::menuControl() {
+void JyersDWIN::menuControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < getMenuSize(active_menu)) {
     dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection++; // Select Down
-    if (selection > scrollpos+MROWS) {
+    if (selection > scrollpos + MROWS) {
       scrollpos++;
       dwinFrameAreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
       menuItemHandler(active_menu, selection);
     }
     dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection--; // Select Up
     if (selection < scrollpos) {
@@ -4180,21 +4165,21 @@ void CrealityDWIN::menuControl() {
       dwinFrameAreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
       menuItemHandler(active_menu, selection);
     }
     dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     menuItemHandler(active_menu, selection, false);
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::valueControl() {
+void JyersDWIN::valueControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
     encoderRate.enabled = false;
     drawFloat(tempvalue / valueunit, selection - scrollpos, false, valueunit);
@@ -4241,21 +4226,21 @@ void CrealityDWIN::valueControl() {
   }
   LIMIT(tempvalue, valuemin * valueunit, valuemax * valueunit);
   drawFloat(tempvalue / valueunit, selection - scrollpos, true, valueunit);
   dwinUpdateLCD();
   if (active_menu == Move && livemove) {
     *(float*)valuepointer = tempvalue / valueunit;
     planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
   }
 }
 
-void CrealityDWIN::optionControl() {
+void JyersDWIN::optionControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
     encoderRate.enabled = false;
     if (valuepointer == &color_names) {
@@ -4279,30 +4264,29 @@ void CrealityDWIN::optionControl() {
 
     drawOption(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
     dwinUpdateLCD();
     return;
   }
   LIMIT(tempvalue, valuemin, valuemax);
   drawOption(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::fileControl() {
+void JyersDWIN::fileControl() {
   typedef TextScroller<MENU_CHAR_LIMIT> Scroller;
   static Scroller scroller;
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) {
     if (selection > 0) {
       card.selectFileByIndexSorted(selection - 1);
       char * const filename = card.longest_filename();
-      size_t len = strlen(filename);
-      size_t pos = len;
+      size_t len = strlen(filename), pos = len;
       if (!card.flag.filenameIsDir)
         while (pos && filename[pos] != '.') pos--;
       if (pos > MENU_CHAR_LIMIT) {
         static millis_t time = 0;
         if (PENDING(millis(), time)) return;
         time = millis() + 200;
         Scroller::Buffer buf;
         const char* const name = scroller.scroll(pos, buf, filename);
         dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
         drawMenuItem(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
@@ -4357,21 +4341,21 @@ void CrealityDWIN::fileControl() {
         drawSDList();
       }
       else {
         card.openAndPrintFile(card.filename);
       }
     }
   }
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::printScreenControl() {
+void JyersDWIN::printScreenControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
     selection++; // Select Down
     printScreenIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     printScreenIcons();
   }
@@ -4407,21 +4391,21 @@ void CrealityDWIN::printScreenControl() {
         }
         else
           popupHandler(Pause);
         break;
       case PRINT_STOP: popupHandler(Stop); break;
     }
   }
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::popupControl() {
+void JyersDWIN::popupControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
     selection++;
     popupSelect();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--;
     popupSelect();
   }
@@ -4552,21 +4536,21 @@ void CrealityDWIN::popupControl() {
           if (selection == 0) bedlevel.storage_slot = 0;
           redrawMenu(true, true);
           break;
       #endif
       default: break;
     }
   }
   dwinUpdateLCD();
 }
 
-void CrealityDWIN::confirmControl() {
+void JyersDWIN::confirmControl() {
   EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
       case Complete:
         drawMainMenu();
         break;
       case FilInsert:
         popupHandler(FilChange);
         wait_for_user = false;
@@ -4577,94 +4561,98 @@ void CrealityDWIN::confirmControl() {
         break;
       default:
         redrawMenu(true, true, false);
         wait_for_user = false;
         break;
     }
   }
   dwinUpdateLCD();
 }
 
-/* In-Menu Value Modification */
+//
+// In-Menu Value Modification
+//
 
-void CrealityDWIN::setupValue(const_float_t value, const_float_t min, const_float_t max, const_float_t unit, const uint8_t type) {
-  if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
+void JyersDWIN::setupValue(const_float_t value, const_float_t min, const_float_t max, const_float_t unit, const uint8_t type) {
+  if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Ki))
     tempvalue = unscalePID_i(value) * unit;
-  else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
+  else if (TERN0(PIDTEMP, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(PIDTEMPBED, valuepointer == &thermalManager.temp_bed.pid.Kd))
     tempvalue = unscalePID_d(value) * unit;
   else
     tempvalue = value * unit;
   valuemin = min;
   valuemax = max;
   valueunit = unit;
   valuetype = type;
   process = Value;
   encoderRate.enabled = true;
   drawFloat(tempvalue / unit, selection - scrollpos, true, valueunit);
 }
 
-void CrealityDWIN::modifyValue(float &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void JyersDWIN::modifyValue(float &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 0);
 }
-void CrealityDWIN::modifyValue(uint8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void JyersDWIN::modifyValue(uint8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 1);
 }
-void CrealityDWIN::modifyValue(uint16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void JyersDWIN::modifyValue(uint16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 2);
 }
-void CrealityDWIN::modifyValue(int16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void JyersDWIN::modifyValue(int16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 3);
 }
-void CrealityDWIN::modifyValue(uint32_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void JyersDWIN::modifyValue(uint32_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 4);
 }
-void CrealityDWIN::modifyValue(int8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void JyersDWIN::modifyValue(int8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   setupValue((float)value, min, max, unit, 5);
 }
 
-void CrealityDWIN::modifyOption(const uint8_t value, const char * const * options, const uint8_t max) {
+void JyersDWIN::modifyOption(const uint8_t value, const char * const * options, const uint8_t max) {
   tempvalue = value;
   valuepointer = const_cast<const char * *>(options);
   valuemin = 0;
   valuemax = max;
   process = Option;
   encoderRate.enabled = true;
   drawOption(value, options, selection - scrollpos, true);
 }
 
-/* Main Functions */
+//
+// Main Functions
+//
 
-void CrealityDWIN::updateStatus(const char * const text) {
+void JyersDWIN::updateStatus(const char * const text) {
   if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
     for (uint8_t i = 0; i < _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text)); ++i) filename[i] = text[i + 3];
     filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
     drawPrintFilename(true);
   }
   else {
     for (uint8_t i = 0; i < _MIN((size_t)64, strlen(text)); ++i) statusmsg[i] = text[i];
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
-void CrealityDWIN::startPrint(const bool sd) {
+void JyersDWIN::startPrint(const bool sd) {
   sdprint = sd;
   if (!printing) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {
       #if ENABLED(POWER_LOSS_RECOVERY)
         if (recovery.valid()) {
           MediaFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
@@ -4673,51 +4661,51 @@ void CrealityDWIN::startPrint(const bool sd) {
       strcpy(filename, card.longest_filename());
     }
     else
       strcpy_P(filename, PSTR("Host Print"));
     TERN_(SET_PROGRESS_PERCENT, ui.set_progress(0));
     TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
     drawPrintScreen();
   }
 }
 
-void CrealityDWIN::stopPrint() {
+void JyersDWIN::stopPrint() {
   printing = false;
   sdprint = false;
   thermalManager.cooldown();
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress(100 * (PROGRESS_SCALE)));
   TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
   drawPrintConfirm();
 }
 
-void CrealityDWIN::update() {
+void JyersDWIN::update() {
   stateUpdate();
   screenUpdate();
   switch (process) {
     case Main:    mainMenuControl();    break;
     case Menu:    menuControl();         break;
     case Value:   valueControl();        break;
     case Option:  optionControl();       break;
     case File:    fileControl();         break;
     case Print:   printScreenControl(); break;
     case Popup:   popupControl();        break;
     case Confirm: confirmControl();      break;
   }
 }
 
-void MarlinUI::update() { crealityDWIN.update(); }
+void MarlinUI::update() { jyersDWIN.update(); }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
-void CrealityDWIN::stateUpdate() {
+void JyersDWIN::stateUpdate() {
   if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
     if (!printing) startPrint(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
     else stopPrint();
   }
   if (print_job_timer.isPaused() != paused) {
     paused = print_job_timer.isPaused();
     if (process == Print) printScreenIcons();
     if (process == Wait && !paused) redrawMenu(true, true);
   }
   if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
@@ -4734,21 +4722,21 @@ void CrealityDWIN::stateUpdate() {
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     static bool ranout = false;
     if (runout.filament_ran_out != ranout) {
       ranout = runout.filament_ran_out;
       if (ranout) popupHandler(Runout);
     }
   #endif
 }
 
-void CrealityDWIN::screenUpdate() {
+void JyersDWIN::screenUpdate() {
   const millis_t ms = millis();
   static millis_t scrltime = 0;
   if (ELAPSED(ms, scrltime)) {
     scrltime = ms + 200;
     updateStatusBar();
     if (process == Print) drawPrintFilename();
   }
 
   static millis_t statustime = 0;
   if (ELAPSED(ms, statustime)) {
@@ -4860,49 +4848,49 @@ void CrealityDWIN::screenUpdate() {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
                 drawFloat(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
     }
   }
 }
 
-void CrealityDWIN::audioFeedback(const bool success/*=true*/) {
+void JyersDWIN::audioFeedback(const bool success/*=true*/) {
   if (ui.sound_on)
     DONE_BUZZ(success);
   else
     updateStatus(success ? "Success" : "Failed");
 }
 
-void CrealityDWIN::saveSettings(char * const buff) {
+void JyersDWIN::saveSettings(char * const buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
 
-void CrealityDWIN::loadSettings(const char * const buff) {
+void JyersDWIN::loadSettings(const char * const buff) {
   memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
   corner_pos = eeprom_settings.corner_pos / 10.0f;
   redrawScreen();
   #if ENABLED(POWER_LOSS_RECOVERY)
     static bool init = true;
     if (init) {
       init = false;
       queue.inject(F("M1000 S"));
     }
   #endif
 }
 
-void CrealityDWIN::resetSettings() {
+void JyersDWIN::resetSettings() {
   eeprom_settings.time_format_textual = false;
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
   eeprom_settings.corner_pos = 325;
   eeprom_settings.cursor_color = 0;
   eeprom_settings.menu_split_line = 0;
   eeprom_settings.menu_top_bg = 0;
   eeprom_settings.menu_top_txt = 0;
   eeprom_settings.highlight_box = 0;
   eeprom_settings.progress_percent = 0;
   eeprom_settings.progress_time = 0;
@@ -4925,27 +4913,27 @@ void MarlinUI::init_lcd() {
   encoderConfiguration();
   for (uint16_t t = 0; t <= 100; t += 2) {
     dwinIconShow(ICON, ICON_Bar, 15, 260);
     dwinDrawRectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
     dwinUpdateLCD();
     delay(20);
   }
 
   dwinJPGShowAndCache(3);
   dwinJPGCacheTo1(Language_English);
-  crealityDWIN.redrawScreen();
+  jyersDWIN.redrawScreen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     switch (message) {
-      case PAUSE_MESSAGE_INSERT:  crealityDWIN.confirmHandler(FilInsert);  break;
+      case PAUSE_MESSAGE_INSERT:  jyersDWIN.confirmHandler(FilInsert);  break;
       case PAUSE_MESSAGE_PURGE:
-      case PAUSE_MESSAGE_OPTION:  crealityDWIN.popupHandler(PurgeMore);    break;
-      case PAUSE_MESSAGE_HEAT:    crealityDWIN.confirmHandler(HeaterTime); break;
-      case PAUSE_MESSAGE_WAITING: crealityDWIN.drawPrintScreen();         break;
+      case PAUSE_MESSAGE_OPTION:  jyersDWIN.popupHandler(PurgeMore);    break;
+      case PAUSE_MESSAGE_HEAT:    jyersDWIN.confirmHandler(HeaterTime); break;
+      case PAUSE_MESSAGE_WAITING: jyersDWIN.drawPrintScreen();          break;
       default: break;
     }
   }
 #endif
 
 #endif // DWIN_CREALITY_LCD_JYERSUI

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ♻️ String helper class (#24390)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index b7b2629f99..95a387c6cb 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -176,21 +176,20 @@ uint8_t process = Main, last_process = Main;
 PopupID popup, last_popup;
 
 void (*funcpointer)() = nullptr;
 void *valuepointer = nullptr;
 float tempvalue;
 float valuemin;
 float valuemax;
 uint8_t valueunit;
 uint8_t valuetype;
 
-char cmd[MAX_CMD_SIZE+16], str_1[16], str_2[16], str_3[16];
 char statusmsg[64];
 char filename[LONG_FILENAME_LENGTH];
 bool printing = false;
 bool paused = false;
 bool sdprint = false;
 
 int16_t pausetemp, pausebed, pausefan;
 
 bool livemove = false;
 bool liveadjust = false;
@@ -260,22 +259,23 @@ private:
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       uint8_t tilt_grid = 1;
 
       void manual_value_update(bool undefined=false) {
-        sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
-        gcode.process_subcommands_now(cmd);
+        gcode.process_subcommands_now(
+          TS(F("M421I"), mesh_x, 'J', mesh_y, 'Z', p_float_t(current_position.z, 3), undefined ? "N" : "")
+        );
         planner.synchronize();
       }
 
       bool create_plane_from_mesh() {
         struct linear_fit_data lsf_results;
         incremental_LSF_reset(&lsf_results);
         GRID_LOOP(x, y) {
           if (!isnan(bedlevel.z_values[x][y])) {
             xy_pos_t rpos = { bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) };
             incremental_LSF(&lsf_results, rpos, bedlevel.z_values[x][y]);
@@ -306,40 +306,39 @@ private:
           }
 
           bedlevel.z_values[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
 
       void manual_value_update() {
-        sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
-        gcode.process_subcommands_now(cmd);
+        gcode.process_subcommands_now(
+          TS(F("G29I"), mesh_x, 'J', mesh_y, 'Z', p_float_t(current_position.z, 3))
+        );
         planner.synchronize();
       }
 
     #endif
 
     void manual_mesh_move(const bool zmove=false) {
       if (zmove) {
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
         crealityDWIN.popupHandler(MoveWait);
-        sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
-        gcode.process_subcommands_now(cmd);
-        sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
-        gcode.process_subcommands_now(cmd);
+        gcode.process_subcommands_now(TS(F("G0F300Z"), p_float_t(current_position.z, 3)));
+        gcode.process_subcommands_now(TS(F("G42 F4000 I"), mesh_x, 'J', mesh_y));
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
         crealityDWIN.redrawMenu();
       }
     }
 
     float get_max_value() {
       float max = __FLT_MIN__;
@@ -370,21 +369,20 @@ private:
       dwinDrawRectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / (GRID_MAX_POINTS_X);
         const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
         dwinDrawRectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
-      char buf[8];
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
         dwinDrawRectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
           isnan(bedlevel.z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
             (bedlevel.z_values[x][y] < 0 ?
               (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
@@ -395,51 +393,53 @@ private:
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
             dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
+            MString<12> msg;
             if (GRID_MAX_POINTS_X < 10)
-              sprintf_P(buf, PSTR("%s"), dtostrf(abs(bedlevel.z_values[x][y]), 1, 2, str_1));
+              msg.set(p_float_t(abs(bedlevel.z_values[x][y]), 2));
             else
-              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(bedlevel.z_values[x][y] - (int16_t)bedlevel.z_values[x][y]) * 100));
-            offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
+              msg.setf(F("%02i"), uint16_t(abs(bedlevel.z_values[x][y] - int16_t(bedlevel.z_values[x][y])) * 100));
+            offset_x = cell_width_px / 2 - 3 * msg.length() - 2;
             if (!(GRID_MAX_POINTS_X < 10))
               dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
+            dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, msg);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
-      float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
-      if (v_min > 3e+10F) v_min = 0.0000001;
-      if (v_max > 3e+10F) v_max = 0.0000001;
-      if (range > 3e+10F) range = 0.0000001;
-      char msg[46];
+      float v1, v2,
+            v_min = abs(get_min_value()),
+            v_max = abs(get_max_value());
       if (viewer_asymmetric_range) {
-        dtostrf(-v_min, 1, 3, str_1);
-        dtostrf( v_max, 1, 3, str_2);
+        if (v_min > 3e+10F) v_min = 0.0000001;
+        if (v_max > 3e+10F) v_max = 0.0000001;
+        v1 = -v_min;
+        v2 =  v_max;
       }
       else {
-        dtostrf(-range, 1, 3, str_1);
-        dtostrf( range, 1, 3, str_2);
+        float range = _MAX(v_min, v_max);
+        if (range > 3e+10F) range = 0.0000001;
+        v1 = -range;
+        v2 =  range;
       }
-      sprintf_P(msg, PSTR("Red %s..0..%s Green"), str_1, str_2);
-      crealityDWIN.updateStatus(msg);
+      crealityDWIN.updateStatus(TS(F("Red "), p_float_t(v1, 3) , F("..0.."), p_float_t(v2, 3), F(" Green")));
       drawing_mesh = false;
     }
 
   };
   Mesh_Settings mesh_conf;
 
 #endif // HAS_MESH
 
 /* General Display Functions */
 
@@ -1192,22 +1192,21 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
                 drawMenu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                   popupHandler(ETemp);
                 else {
                   if (thermalManager.temp_hotend[0].is_below_target(2)) {
                     popupHandler(Heating);
                     thermalManager.wait_for_hotend(0);
                   }
                   popupHandler(FilChange);
-                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                  gcode.process_subcommands_now(cmd);
+                  gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
                 }
               #endif
             }
             break;
         #endif
       }
       break;
 
     case HomeMenu:
 
@@ -1438,113 +1437,123 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
             break;
         #endif
 
         case MLEVEL_BL:
           if (draw)
             drawMenuItem(row, ICON_AxisBL, F("Bottom Left"));
           else {
             popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_min, 3), 'Y', p_float_t(probe_y_min, 3))
+                );
                 planner.synchronize();
                 popupHandler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(
+                TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(corner_pos, 3), 'Y', p_float_t(corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
+              );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
             drawMenuItem(row, ICON_AxisTL, F("Top Left"));
           else {
             popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_max, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_min, 3), 'Y', p_float_t(probe_y_max, 3))
+                );
                 planner.synchronize();
                 popupHandler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(
+                TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
+              );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
             drawMenuItem(row, ICON_AxisTR, F("Top Right"));
           else {
             popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_max, 1, 3, str_1), dtostrf(probe_y_max, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_max, 3), 'Y', p_float_t(probe_y_max, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
+                );
                 planner.synchronize();
                 popupHandler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(
+                TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
+              );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
             drawMenuItem(row, ICON_AxisBR, F("Bottom Right"));
           else {
             popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_max, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G0F4000\nG0Z10\nG0X"), p_float_t(probe_x_max, 3), 'Y', p_float_t(probe_y_min, 3))
+                );
                 planner.synchronize();
                 popupHandler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(
+                TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t(corner_pos, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
+              );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
             drawMenuItem(row, ICON_AxisC, F("Center"));
           else {
             popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_MAX_POS) / 2.0f - probe.offset.x, 3), 'Y', p_float_t((Y_MAX_POS) / 2.0f - probe.offset.y, 3))
+                );
                 planner.synchronize();
                 popupHandler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(
+                TS(F("G0F4000\nG0Z10\nG0X"), p_float_t((X_BED_SIZE + X_MIN_POS) - corner_pos, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 3), F("\nG0F300Z"), p_float_t(mlev_z_pos, 3))
+              );
               planner.synchronize();
               redrawMenu();
             }
           }
           break;
         case MLEVEL_ZPOS:
           if (draw) {
             drawMenuItem(row, ICON_SetZOffset, F("Z Position"));
             drawFloat(mlev_z_pos, row, false, 100);
           }
@@ -1575,54 +1584,56 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
               liveadjust = false;
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
               drawMenu(Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
               drawMenuItem(row, ICON_Homing, F("Home Z Axis"));
             else {
               popupHandler(Home);
-              gcode.process_subcommands_now(F("G28 Z"));
+              gcode.process_subcommands_now(F("G28Z"));
               popupHandler(MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
-                sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3));
+                );
               #else
                 gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
               #endif
-              gcode.process_subcommands_now(F("G0 F300 Z0"));
+              gcode.process_subcommands_now(F("G0F300Z0"));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case ZOFFSET_MODE:
             if (draw) {
               drawMenuItem(row, ICON_Zoffset, F("Live Adjustment"));
               drawCheckbox(row, liveadjust);
             }
             else {
               if (!liveadjust) {
                 if (axes_should_home()) {
                   popupHandler(Home);
                   gcode.home_all_axes(true);
                 }
                 popupHandler(MoveWait);
                 #if ENABLED(Z_SAFE_HOMING)
                   planner.synchronize();
-                  sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-                  gcode.process_subcommands_now(cmd);
+                  gcode.process_subcommands_now(
+                    TS(F("G0F4000X"), p_float_t(Z_SAFE_HOMING_X_POINT, 3), 'Y', p_float_t(Z_SAFE_HOMING_Y_POINT, 3));
+                  );
                 #else
                   gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
                 #endif
-                gcode.process_subcommands_now(F("G0 F300 Z0"));
+                gcode.process_subcommands_now(F("G0F300Z0"));
                 planner.synchronize();
                 redrawMenu();
               }
               liveadjust = !liveadjust;
               drawCheckbox(row, liveadjust);
             }
             break;
           case ZOFFSET_OFFSET:
             if (draw) {
               drawMenuItem(row, ICON_SetZOffset, F("Z Offset"));
@@ -1773,22 +1784,21 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
               drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 popupHandler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   popupHandler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 popupHandler(FilChange);
-                sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.temp_hotend[0].target));
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
     #if HAS_CUSTOM_MENU
 
       case MenuCustom:
@@ -2118,22 +2128,21 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
               drawMenu(PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
               drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
             else {
               popupHandler(PIDWait);
-              sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(TS(F("M303E0C"), PID_cycles, 'S', PID_e_temp, 'U'));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
               drawMenuItem(row, ICON_Temperature, F("Temperature"));
               drawFloat(PID_e_temp, row, false, 1);
             }
             else
@@ -2185,22 +2194,21 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
             if (draw)
               drawMenuItem(row, ICON_Back, F("Back"));
             else
               drawMenu(PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
               drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
             else {
               popupHandler(PIDWait);
-              sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(TS(F("M303E-1C"), PID_cycles, 'S', PID_bed_temp, 'U'));
               planner.synchronize();
               redrawMenu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
               drawMenuItem(row, ICON_Temperature, F("Temperature"));
               drawFloat(PID_bed_temp, row, false, 1);
             }
             else
@@ -2910,22 +2918,23 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
                 drawMenuItem(row, ICON_StepY, F("Probe Y Offset"));
                 drawFloat(probe.offset.y, row, false, 10);
               }
               else
                 modifyValue(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_TEST:
               if (draw)
                 drawMenuItem(row, ICON_StepY, F("M48 Probe Test"));
               else {
-                sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(
+                  TS(F("G28O\nM48X" , p_float_t((X_BED_SIZE + X_MIN_POS) / 2.0f, 3), 'Y', p_float_t((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 3), 'P', testcount))
+                );
               }
               break;
             case PROBE_TEST_COUNT:
               if (draw) {
                 drawMenuItem(row, ICON_StepY, F("Probe Test Count"));
                 drawFloat(testcount, row, false, 1);
               }
               else
                 modifyValue(testcount, 4, 50, 1);
               break;
@@ -2963,63 +2972,56 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
                 drawFloat(stepper_current_x, row, false, 1);
               }
               else {
                 modifyValue(stepper_current_x, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperX.rms_current(stepper_current_x); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(Y)
             case TMC_STEPPER_CURRENT_Y:
-
               static float stepper_current_y;
-
               if (draw) {
                 drawMenuItem(row, ICON_StepY, F("Stepper Y current"));
                 stepper_current_y = stepperY.getMilliamps();
                 drawFloat(stepper_current_y, row, false, 1);
               }
               else {
                 modifyValue(stepper_current_y, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperY.rms_current(stepper_current_y); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(Z)
             case TMC_STEPPER_CURRENT_Z:
-
               static float stepper_current_z;
-
               if (draw) {
                 drawMenuItem(row, ICON_StepZ, F("Stepper Z current"));
                 stepper_current_z = stepperZ.getMilliamps();
                 drawFloat(stepper_current_z, row, false, 1);
               }
               else {
                 modifyValue(stepper_current_z, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperZ.rms_current(stepper_current_z); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(E0)
             case TMC_STEPPER_CURRENT_E:
-
               static float stepper_current_e;
-
               if (draw) {
                 drawMenuItem(row, ICON_StepE, F("Stepper E current"));
                 stepper_current_e = stepperE0.getMilliamps();
                 drawFloat(stepper_current_e, row, false, 1);
               }
-              else {
+              else
                 modifyValue(stepper_current_e, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperE0.rms_current(stepper_current_e); });
-              }
               break;
           #endif
         };
         break;
     #endif // HAS_TRINAMIC_CONFIG
 
     case InfoMain:
     case Info:
 
       #define INFO_BACK 0
@@ -3029,32 +3031,35 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
       #define INFO_TOTAL INFO_BACK
 
       switch (item) {
         case INFO_BACK:
           if (draw) {
             drawMenuItem(row, ICON_Back, F("Back"));
 
             #if ENABLED(PRINTCOUNTER)
-              char row1[50], row2[50], buf[32];
+
               printStatistics ps = print_job_timer.getStats();
+              drawMenuItem(INFO_PRINTCOUNT, ICON_HotendTemp,
+                TS(ps.totalPrints, F(" prints, "), ps.finishedPrints, F(" finished")),
+                TS(p_float_t(ps.filamentUsed / 1000, 2), F(" m filament used")),
+                false, true
+              );
 
-              sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
-              sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
-              drawMenuItem(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
+              char buf[32];
+              drawMenuItem(INFO_PRINTTIME, ICON_PrintTime,
+                MString<50>(F("Printed: "), duration_t(print_job_timer.getStats().printTime).toString(buf)),
+                MString<50>(F("Longest: "), duration_t(print_job_timer.getStats().longestPrint).toString(buf)),
+                false, true
+              );
 
-              duration_t(print_job_timer.getStats().printTime).toString(buf);
-              sprintf_P(row1, PSTR("Printed: %s"), buf);
-              duration_t(print_job_timer.getStats().longestPrint).toString(buf);
-              sprintf_P(row2, PSTR("Longest: %s"), buf);
-              drawMenuItem(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
             #endif
 
             drawMenuItem(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
             drawMenuItem(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
             drawMenuItem(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
           }
           else {
             if (menu == Info)
               drawMenu(Control, CONTROL_INFO);
             else
@@ -3110,45 +3115,44 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
                 drawMenuItem(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
                 if (bedlevel.storage_slot < 0) {
                   popupHandler(MeshSlot);
                   break;
                 }
                 popupHandler(Home);
                 gcode.home_all_axes(true);
                 popupHandler(Level);
                 if (mesh_conf.tilt_grid > 1) {
-                  sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
-                  gcode.process_subcommands_now(cmd);
+                  gcode.process_subcommands_now(TS(F("G29J"), mesh_conf.tilt_grid));
                 }
                 else
-                  gcode.process_subcommands_now(F("G29 J"));
+                  gcode.process_subcommands_now(F("G29J"));
                 planner.synchronize();
                 redrawMenu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
               drawMenuItem(row, ICON_Mesh, F("Create New Mesh"));
             else {
               popupHandler(Home);
               gcode.home_all_axes(true);
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 #if ENABLED(PREHEAT_BEFORE_LEVELING)
                   popupHandler(Heating);
                   probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
                 #endif
                 #if HAS_BED_PROBE
                   popupHandler(Level);
-                  gcode.process_subcommands_now(F("G29 P0\nG29 P1"));
-                  gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
+                  gcode.process_subcommands_now(F("G29P0\nG29P1"));
+                  gcode.process_subcommands_now(F("G29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nG29P3\nM420S1"));
                   planner.synchronize();
                   updateStatus("Probed all reachable points");
                   popupHandler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
                   popupHandler(MoveWait);
                   mesh_conf.manual_mesh_move();
@@ -3877,42 +3881,40 @@ void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
               drawMenuItem(row, ICON_SetEndTemp, F("Continue"));
             else {
               popupHandler(Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
                 case Prepare:
                   popupHandler(FilChange);
-                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                  gcode.process_subcommands_now(cmd);
+                  gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   case ChangeFilament:
                     switch (last_selection) {
                       case CHANGEFIL_LOAD:
                         popupHandler(FilLoad);
                         gcode.process_subcommands_now(F("M701"));
                         planner.synchronize();
                         redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_UNLOAD:
                         popupHandler(FilLoad, true);
                         gcode.process_subcommands_now(F("M702"));
                         planner.synchronize();
                         redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_CHANGE:
                         popupHandler(FilChange);
-                        sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                        gcode.process_subcommands_now(cmd);
+                        gcode.process_subcommands_now(TS(F("M600 B1 R"), thermalManager.temp_hotend[0].target));
                         break;
                     }
                     break;
                 #endif
                 default:
                   redrawMenu(true, true, true);
                   break;
               }
             }
             break;
@@ -4198,22 +4200,21 @@ void CrealityDWIN::valueControl() {
     drawFloat(tempvalue / valueunit, selection - scrollpos, false, valueunit);
     dwinUpdateLCD();
     if (active_menu == ZOffset && liveadjust) {
       planner.synchronize();
       current_position.z += (tempvalue / valueunit - zoffsetvalue);
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
       current_position.z = 0;
       sync_plan_position();
     }
     else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
-      sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - zoffsetvalue), 1, 3, str_1));
-      gcode.process_subcommands_now(cmd);
+      gcode.process_subcommands_now(TS(F("M290Z"), p_float_t((tempvalue / valueunit - zoffsetvalue), 3)));
     }
     if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
       tempvalue = scalePID_i(tempvalue);
     if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
       tempvalue = scalePID_d(tempvalue);
     switch (valuetype) {
       case 0: *(float*)valuepointer = tempvalue / valueunit; break;
       case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
       case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
       case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
@@ -4381,28 +4382,25 @@ void CrealityDWIN::printScreenControl() {
         updateStatusBar(true);
         break;
       case PRINT_PAUSE_RESUME:
         if (paused) {
           if (sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
-              char cmd[20];
               #if HAS_HEATED_BED
-                sprintf_P(cmd, PSTR("M140 S%i"), pausebed);
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(TS(F("M140 S"), pausebed));
               #endif
               #if HAS_EXTRUDERS
-                sprintf_P(cmd, PSTR("M109 S%i"), pausetemp);
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(TS(F("M109 S"), pausetemp));
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
               TERN_(HAS_MEDIA, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           drawPrintScreen();
@@ -4487,45 +4485,42 @@ void CrealityDWIN::popupControl() {
             drawMenu(PreheatHotend);
           }
           else
             redrawMenu(true, true, false);
           break;
       #endif
 
       #if HAS_BED_PROBE
         case ManualProbing:
           if (selection == 0) {
-            char buf[80];
             const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - corner_avg;
-            sprintf_P(buf, dif > 0 ? PSTR("Corner is %smm high") : PSTR("Corner is %smm low"), dtostrf(abs(dif), 1, 3, str_1));
-            updateStatus(buf);
+            updateStatus(TS(F("Corner is "), p_float_t(abs(dif), 3), "mm ", dif > 0 ? F("high") : F("low")));
           }
           else {
             redrawMenu(true, true, false);
             updateStatus("");
           }
           break;
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         case ConfFilChange:
           if (selection == 0) {
             if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
               popupHandler(ETemp);
             else {
               if (thermalManager.temp_hotend[0].is_below_target(2)) {
                 popupHandler(Heating);
                 thermalManager.wait_for_hotend(0);
               }
               popupHandler(FilChange);
-              sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-              gcode.process_subcommands_now(cmd);
+              gcode.process_subcommands_now(TS(F("M600B1R"), thermalManager.temp_hotend[0].target));
             }
           }
           else
             redrawMenu(true, true, false);
           break;
         case PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
             popupHandler(FilChange);
           }

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    🎨 Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 7b83e0171f..b7b2629f99 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -51,24 +51,20 @@
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
 #endif
 
 #if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
   #define HAS_ZOFFSET_ITEM 1
 #endif
 
-#ifndef strcasecmp_P
-  #define strcasecmp_P(a, b) strcasecmp((a), (b))
-#endif
-
 #if HAS_LEVELING
   #include "../../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../../libs/least_squares_fit.h"
   #include "../../../libs/vector_3.h"
 #endif
 
 #if HAS_BED_PROBE
@@ -199,21 +195,21 @@ int16_t pausetemp, pausebed, pausefan;
 bool livemove = false;
 bool liveadjust = false;
 uint8_t preheatmode = 0;
 float zoffsetvalue = 0;
 grid_count_t gridpoint;
 float corner_avg;
 float corner_pos;
 
 bool probe_deployed = false;
 
-CrealityDWINClass CrealityDWIN;
+CrealityDWIN crealityDWIN;
 
 template <unsigned N, unsigned S = N>
 class TextScroller {
 public:
   static const unsigned SIZE = N;
   static const unsigned SPACE = S;
   typedef char Buffer[SIZE + 1];
 
   inline TextScroller()
     : scrollpos(0)
@@ -325,30 +321,30 @@ private:
     #endif
 
     void manual_mesh_move(const bool zmove=false) {
       if (zmove) {
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
-        CrealityDWIN.Popup_Handler(MoveWait);
+        crealityDWIN.popupHandler(MoveWait);
         sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
         gcode.process_subcommands_now(cmd);
         sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
         gcode.process_subcommands_now(cmd);
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
-        CrealityDWIN.Redraw_Menu();
+        crealityDWIN.redrawMenu();
       }
     }
 
     float get_max_value() {
       float max = __FLT_MIN__;
       GRID_LOOP(x, y) {
         if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
           max = bedlevel.z_values[x][y];
       }
       return max;
@@ -356,140 +352,140 @@ private:
 
     float get_min_value() {
       float min = __FLT_MAX__;
       GRID_LOOP(x, y) {
         if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
           min = bedlevel.z_values[x][y];
       }
       return min;
     }
 
-    void Draw_Bed_Mesh(const int16_t selected=-1, const uint8_t gridline_width=1, const uint16_t padding_x=8, const uint16_t padding_y_top=40 + 53 - 7) {
+    void drawBedMesh(const int16_t selected=-1, const uint8_t gridline_width=1, const uint16_t padding_x=8, const uint16_t padding_y_top=40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
                      cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
                      cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
       const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
+      dwinDrawRectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / (GRID_MAX_POINTS_X);
         const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
-        DWIN_Draw_Rectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
+        dwinDrawRectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       char buf[8];
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
-        DWIN_Draw_Rectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
+        dwinDrawRectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
           isnan(bedlevel.z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
             (bedlevel.z_values[x][y] < 0 ?
               (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
               (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
                 _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
-            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+            dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             if (GRID_MAX_POINTS_X < 10)
               sprintf_P(buf, PSTR("%s"), dtostrf(abs(bedlevel.z_values[x][y]), 1, 2, str_1));
             else
               sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(bedlevel.z_values[x][y] - (int16_t)bedlevel.z_values[x][y]) * 100));
             offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
             if (!(GRID_MAX_POINTS_X < 10))
-              DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
+              dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            dwinDrawString(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
-    void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
+    void setMeshViewerStatus() { // TODO: draw gradient with values as a legend instead
       float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
       if (v_min > 3e+10F) v_min = 0.0000001;
       if (v_max > 3e+10F) v_max = 0.0000001;
       if (range > 3e+10F) range = 0.0000001;
       char msg[46];
       if (viewer_asymmetric_range) {
         dtostrf(-v_min, 1, 3, str_1);
         dtostrf( v_max, 1, 3, str_2);
       }
       else {
         dtostrf(-range, 1, 3, str_1);
         dtostrf( range, 1, 3, str_2);
       }
       sprintf_P(msg, PSTR("Red %s..0..%s Green"), str_1, str_2);
-      CrealityDWIN.Update_Status(msg);
+      crealityDWIN.updateStatus(msg);
       drawing_mesh = false;
     }
 
   };
   Mesh_Settings mesh_conf;
 
 #endif // HAS_MESH
 
 /* General Display Functions */
 
-struct CrealityDWINClass::EEPROM_Settings CrealityDWINClass::eeprom_settings{0};
-constexpr const char * const CrealityDWINClass::color_names[11];
-constexpr const char * const CrealityDWINClass::preheat_modes[3];
+struct CrealityDWIN::EEPROM_Settings CrealityDWIN::eeprom_settings{0};
+constexpr const char * const CrealityDWIN::color_names[11];
+constexpr const char * const CrealityDWIN::preheat_modes[3];
 
 // Clear a part of the screen
 //  4=Entire screen
 //  3=Title bar and Menu area (default)
 //  2=Menu area
 //  1=Title bar
-void CrealityDWINClass::Clear_Screen(const uint8_t e/*=3*/) {
-  if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
-  if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
-  if (e == 4) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
+void CrealityDWIN::clearScreen(const uint8_t e/*=3*/) {
+  if (e == 1 || e == 3 || e == 4) dwinDrawRectangle(1, getColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
+  if (e == 2 || e == 3) dwinDrawRectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
+  if (e == 4) dwinDrawRectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
 }
 
-void CrealityDWINClass::Draw_Float(const_float_t value, const uint8_t row, const bool selected/*=false*/, const uint8_t minunit/*=10*/) {
+void CrealityDWIN::drawFloat(const_float_t value, const uint8_t row, const bool selected/*=false*/, const uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
   const uint16_t bColor = selected ? Select_Color : Color_Bg_Black;
   const uint16_t xpos = 240 - (digits * 8);
-  DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
+  dwinDrawRectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
-    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
+    dwinDrawString(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
-    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
-    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
+    dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
+    dwinDrawString(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
-void CrealityDWINClass::Draw_Option(const uint8_t value, const char * const * options, const uint8_t row, const bool selected/*=false*/, const bool color/*=false*/) {
+void CrealityDWIN::drawOption(const uint8_t value, const char * const * options, const uint8_t row, const bool selected/*=false*/, const bool color/*=false*/) {
   const uint16_t bColor = selected ? Select_Color : Color_Bg_Black,
-                 tColor = color ? GetColor(value, Color_White, false) : Color_White;
-  DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
-  DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
+                 tColor = color ? getColor(value, Color_White, false) : Color_White;
+  dwinDrawRectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
+  dwinDrawString(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
-uint16_t CrealityDWINClass::GetColor(const uint8_t color, const uint16_t original, const bool light/*=false*/) {
+uint16_t CrealityDWIN::getColor(const uint8_t color, const uint16_t original, const bool light/*=false*/) {
   switch (color) {
     case Default:
       return original;
       break;
     case White:
       return light ? Color_Light_White : Color_White;
       break;
     case Green:
       return light ? Color_Light_Green : Color_Green;
       break;
@@ -514,574 +510,574 @@ uint16_t CrealityDWINClass::GetColor(const uint8_t color, const uint16_t origina
     case Brown:
       return light ? Color_Light_Brown : Color_Brown;
       break;
     case Black:
       return Color_Black;
       break;
   }
   return Color_White;
 }
 
-void CrealityDWINClass::Draw_Title(const char * const ctitle) {
-  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
+void CrealityDWIN::drawTitle(const char * const ctitle) {
+  dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
 }
-void CrealityDWINClass::Draw_Title(FSTR_P const ftitle) {
-  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
+void CrealityDWIN::drawTitle(FSTR_P const ftitle) {
+  dwinDrawString(false, DWIN_FONT_HEAD, getColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
 }
 
-void _Decorate_Menu_Item(uint8_t row, uint8_t icon, bool more) {
-  if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
-  if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
-  DWIN_Draw_Line(CrealityDWIN.GetColor(CrealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+void _decorateMenuItem(uint8_t row, uint8_t icon, bool more) {
+  if (icon) dwinIconShow(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
+  if (more) dwinIconShow(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
+  dwinDrawLine(crealityDWIN.getColor(crealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
-void CrealityDWINClass::Draw_Menu_Item(const uint8_t row, const uint8_t icon/*=0*/, const char * const label1, const char * const label2, const bool more/*=false*/, const bool centered/*=false*/) {
+void CrealityDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, const char * const label1, const char * const label2, const bool more/*=false*/, const bool centered/*=false*/) {
   const uint8_t label_offset_y = (label1 || label2) ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
-  if (label1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
-  if (label2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
-  _Decorate_Menu_Item(row, icon, more);
+  if (label1) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
+  if (label2) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
+  _decorateMenuItem(row, icon, more);
 }
 
-void CrealityDWINClass::Draw_Menu_Item(const uint8_t row, const uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, const bool more/*=false*/, const bool centered/*=false*/) {
+void CrealityDWIN::drawMenuItem(const uint8_t row, const uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, const bool more/*=false*/, const bool centered/*=false*/) {
   const uint8_t label_offset_y = (flabel1 || flabel2) ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
-  if (flabel1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
-  if (flabel2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
-  _Decorate_Menu_Item(row, icon, more);
+  if (flabel1) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
+  if (flabel2) dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
+  _decorateMenuItem(row, icon, more);
 }
 
-void CrealityDWINClass::Draw_Checkbox(const uint8_t row, const bool value) {
+void CrealityDWIN::drawCheckbox(const uint8_t row, const bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
-    DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
+    dwinIconShow(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
-    DWIN_Draw_Rectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    dwinDrawRectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    dwinDrawRectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     if (value) {
-      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
-      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
-      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
-      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
-      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
-      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
+      dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
+      dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
+      dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
+      dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
+      dwinDrawLine(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
+      dwinDrawLine(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
     }
   #endif
 }
 
-void CrealityDWINClass::Draw_Menu(const uint8_t menu, const uint8_t select/*=0*/, const uint8_t scroll/*=0*/) {
+void CrealityDWIN::drawMenu(const uint8_t menu, const uint8_t select/*=0*/, const uint8_t scroll/*=0*/) {
   if (active_menu != menu) {
     last_menu = active_menu;
     if (process == Menu) last_selection = selection;
   }
-  selection = _MIN(select, Get_Menu_Size(menu));
+  selection = _MIN(select, getMenuSize(menu));
   scrollpos = scroll;
   if (selection - scrollpos > MROWS)
     scrollpos = selection - MROWS;
   process = Menu;
   active_menu = menu;
-  Clear_Screen();
-  Draw_Title(Get_Menu_Title(menu));
-  for (uint8_t i = 0; i < TROWS; ++i) Menu_Item_Handler(menu, i + scrollpos);
-  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  clearScreen();
+  drawTitle(getMenuTitle(menu));
+  for (uint8_t i = 0; i < TROWS; ++i) menuItemHandler(menu, i + scrollpos);
+  dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
 
-void CrealityDWINClass::Redraw_Menu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
+void CrealityDWIN::redrawMenu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
   switch (lastproc ? last_process : process) {
     case Menu:
-      Draw_Menu(lastmenu ? last_menu : active_menu, lastsel ? last_selection : selection, lastmenu ? 0 : scrollpos);
+      drawMenu(lastmenu ? last_menu : active_menu, lastsel ? last_selection : selection, lastmenu ? 0 : scrollpos);
       break;
-    case Main:  Draw_Main_Menu(lastsel ? last_selection : selection); break;
-    case Print: Draw_Print_Screen(); break;
-    case File:  Draw_SD_List(); break;
+    case Main:  drawMainMenu(lastsel ? last_selection : selection); break;
+    case Print: drawPrintScreen(); break;
+    case File:  drawSDList(); break;
     default: break;
   }
 }
 
-void CrealityDWINClass::Redraw_Screen() {
-  Redraw_Menu(false);
-  Draw_Status_Area(true);
-  Update_Status_Bar(true);
+void CrealityDWIN::redrawScreen() {
+  redrawMenu(false);
+  drawStatusArea(true);
+  updateStatusBar(true);
 }
 
 /* Primary Menus and Screen Elements */
 
-void CrealityDWINClass::Main_Menu_Icons() {
+void CrealityDWIN::mainMenuIcons() {
   if (selection == 0) {
-    DWIN_ICON_Show(ICON, ICON_Print_1, 17, 130);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    dwinIconShow(ICON, ICON_Print_1, 17, 130);
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
   }
   else {
-    DWIN_ICON_Show(ICON, ICON_Print_0, 17, 130);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    dwinIconShow(ICON, ICON_Print_0, 17, 130);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
   }
   if (selection == 1) {
-    DWIN_ICON_Show(ICON, ICON_Prepare_1, 145, 130);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    dwinIconShow(ICON, ICON_Prepare_1, 145, 130);
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
   }
   else {
-    DWIN_ICON_Show(ICON, ICON_Prepare_0, 145, 130);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    dwinIconShow(ICON, ICON_Prepare_0, 145, 130);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
   }
   if (selection == 2) {
-    DWIN_ICON_Show(ICON, ICON_Control_1, 17, 246);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    dwinIconShow(ICON, ICON_Control_1, 17, 246);
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
   }
   else {
-    DWIN_ICON_Show(ICON, ICON_Control_0, 17, 246);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    dwinIconShow(ICON, ICON_Control_0, 17, 246);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
   }
   #if HAS_ABL_OR_UBL
     if (selection == 3) {
-      DWIN_ICON_Show(ICON, ICON_Leveling_1, 145, 246);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      dwinIconShow(ICON, ICON_Leveling_1, 145, 246);
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
     }
     else {
-      DWIN_ICON_Show(ICON, ICON_Leveling_0, 145, 246);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      dwinIconShow(ICON, ICON_Leveling_0, 145, 246);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
     }
   #else
     if (selection == 3) {
-      DWIN_ICON_Show(ICON, ICON_Info_1, 145, 246);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      dwinIconShow(ICON, ICON_Info_1, 145, 246);
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
     else {
-      DWIN_ICON_Show(ICON, ICON_Info_0, 145, 246);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      dwinIconShow(ICON, ICON_Info_0, 145, 246);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
   #endif
 }
 
-void CrealityDWINClass::Draw_Main_Menu(const uint8_t select/*=0*/) {
+void CrealityDWIN::drawMainMenu(const uint8_t select/*=0*/) {
   process = Main;
   active_menu = MainMenu;
   selection = select;
-  Clear_Screen();
-  Draw_Title(Get_Menu_Title(MainMenu));
+  clearScreen();
+  drawTitle(getMenuTitle(MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
-  DWIN_ICON_Show(ICON, ICON_LOGO, 71, 72);
-  Main_Menu_Icons();
+  dwinIconShow(ICON, ICON_LOGO, 71, 72);
+  mainMenuIcons();
 }
 
-void CrealityDWINClass::Print_Screen_Icons() {
+void CrealityDWIN::printScreenIcons() {
   if (selection == 0) {
-    DWIN_ICON_Show(ICON, ICON_Setup_1, 8, 252);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    dwinIconShow(ICON, ICON_Setup_1, 8, 252);
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
   }
   else {
-    DWIN_ICON_Show(ICON, ICON_Setup_0, 8, 252);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    dwinIconShow(ICON, ICON_Setup_0, 8, 252);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
   }
   if (selection == 2) {
-    DWIN_ICON_Show(ICON, ICON_Stop_1, 184, 252);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    dwinIconShow(ICON, ICON_Stop_1, 184, 252);
+    dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
   }
   else {
-    DWIN_ICON_Show(ICON, ICON_Stop_0, 184, 252);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    dwinIconShow(ICON, ICON_Stop_0, 184, 252);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
   }
   if (paused) {
     if (selection == 1) {
-      DWIN_ICON_Show(ICON, ICON_Continue_1, 96, 252);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      dwinIconShow(ICON, ICON_Continue_1, 96, 252);
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
     }
     else {
-      DWIN_ICON_Show(ICON, ICON_Continue_0, 96, 252);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      dwinIconShow(ICON, ICON_Continue_0, 96, 252);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
     }
   }
   else {
     if (selection == 1) {
-      DWIN_ICON_Show(ICON, ICON_Pause_1, 96, 252);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      dwinIconShow(ICON, ICON_Pause_1, 96, 252);
+      dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
     }
     else {
-      DWIN_ICON_Show(ICON, ICON_Pause_0, 96, 252);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      dwinIconShow(ICON, ICON_Pause_0, 96, 252);
+      dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
     }
   }
 }
 
-void CrealityDWINClass::Draw_Print_Screen() {
+void CrealityDWIN::drawPrintScreen() {
   process = Print;
   selection = 0;
-  Clear_Screen();
-  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
-  Draw_Title("Printing...");
-  Print_Screen_Icons();
-  DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
-  DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
-  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
-  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
-  Update_Status_Bar(true);
-  Draw_Print_ProgressBar();
-  Draw_Print_ProgressElapsed();
-  TERN_(SET_REMAINING_TIME, Draw_Print_ProgressRemain());
-  Draw_Print_Filename(true);
+  clearScreen();
+  dwinDrawRectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+  drawTitle("Printing...");
+  printScreenIcons();
+  dwinIconShow(ICON, ICON_PrintTime, 14, 171);
+  dwinIconShow(ICON, ICON_RemainTime, 147, 169);
+  dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
+  dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
+  updateStatusBar(true);
+  drawPrintProgressBar();
+  drawPrintProgressElapsed();
+  TERN_(SET_REMAINING_TIME, drawPrintProgressRemain());
+  drawPrintFilename(true);
 }
 
-void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
+void CrealityDWIN::drawPrintFilename(const bool reset/*=false*/) {
   typedef TextScroller<30> Scroller;
   static Scroller scroller;
   if (reset) scroller.reset();
   if (process == Print) {
     Scroller::Buffer buf;
     size_t outlen = 0;
     const char* outstr = scroller.scroll(outlen, buf, filename);
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
+    dwinDrawRectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
     const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
+    dwinDrawString(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
   }
 }
 
-void CrealityDWINClass::Draw_Print_ProgressBar() {
+void CrealityDWIN::drawPrintProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
-  DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
-  DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
-  DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
-  DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
+  dwinIconShow(ICON, ICON_Bar, 15, 93);
+  dwinDrawRectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
+  dwinDrawIntValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
+  dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
 }
 
 #if ENABLED(SET_REMAINING_TIME)
 
-  void CrealityDWINClass::Draw_Print_ProgressRemain() {
+  void CrealityDWIN::drawPrintProgressRemain() {
     uint16_t remainingtime = ui.get_remaining_time();
-    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
-    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
+    dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
+    dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
     if (eeprom_settings.time_format_textual) {
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
     }
     else
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
   }
 
 #endif
 
-void CrealityDWINClass::Draw_Print_ProgressElapsed() {
+void CrealityDWIN::drawPrintProgressElapsed() {
   duration_t elapsed = print_job_timer.duration();
-  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
-  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
+  dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
+  dwinDrawIntValue(true, true, 1, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
   if (eeprom_settings.time_format_textual) {
-    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
-    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
+    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
+    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
   }
   else
-    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
+    dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
 }
 
-void CrealityDWINClass::Draw_Print_confirm() {
-  Draw_Print_Screen();
+void CrealityDWIN::drawPrintConfirm() {
+  drawPrintScreen();
   process = Confirm;
   popup = Complete;
-  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
-  DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
-  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
-  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
+  dwinDrawRectangle(1, Color_Bg_Black, 8, 252, 263, 351);
+  dwinIconShow(ICON, ICON_Confirm_E, 87, 283);
+  dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
+  dwinDrawRectangle(0, getColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
 }
 
-void CrealityDWINClass::Draw_SD_Item(const uint8_t item, const uint8_t row) {
+void CrealityDWIN::drawSDItem(const uint8_t item, const uint8_t row) {
   if (item == 0)
-    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
+    drawMenuItem(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
   else {
     card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
     for (uint8_t i = 0; i < len; ++i) name[i] = filename[i];
     if (pos > max)
       for (uint8_t i = len - 3; i < len; ++i) name[i] = '.';
     name[len] = '\0';
-    Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
+    drawMenuItem(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
-void CrealityDWINClass::Draw_SD_List(const bool removed/*=false*/) {
-  Clear_Screen();
-  Draw_Title("Select File");
+void CrealityDWIN::drawSDList(const bool removed/*=false*/) {
+  clearScreen();
+  drawTitle("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
     for (uint8_t i = 0; i < _MIN(card.get_num_items() + 1, TROWS); ++i)
-      Draw_SD_Item(i, i);
+      drawSDItem(i, i);
   }
   else {
-    Draw_Menu_Item(0, ICON_Back, F("Back"));
-    DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
+    drawMenuItem(0, ICON_Back, F("Back"));
+    dwinDrawRectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    dwinDrawString(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
-  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
+  dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
-void CrealityDWINClass::Draw_Status_Area(const bool icons/*=false*/) {
+void CrealityDWIN::drawStatusArea(const bool icons/*=false*/) {
 
-  if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
+  if (icons) dwinDrawRectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
-      DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
-      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+      dwinIconShow(ICON, ICON_HotendTemp, 10, 383);
+      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     }
     if (thermalManager.temp_hotend[0].celsius != hotend) {
       hotend = thermalManager.temp_hotend[0].celsius;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
     }
     if (thermalManager.temp_hotend[0].target != hotendtarget) {
       hotendtarget = thermalManager.temp_hotend[0].target;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
     }
     if (icons) {
       flow = -1;
-      DWIN_ICON_Show(ICON, ICON_StepE, 112, 417);
-      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+      dwinIconShow(ICON, ICON_StepE, 112, 417);
+      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
     }
     if (planner.flow_percentage[0] != flow) {
       flow = planner.flow_percentage[0];
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     }
   #endif
 
   #if HAS_HEATED_BED
     static float bed = -1;
     static int16_t bedtarget = -1;
     if (icons) {
       bed = -1;
       bedtarget = -1;
-      DWIN_ICON_Show(ICON, ICON_BedTemp, 10, 416);
-      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+      dwinIconShow(ICON, ICON_BedTemp, 10, 416);
+      dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     }
     if (thermalManager.temp_bed.celsius != bed) {
       bed = thermalManager.temp_bed.celsius;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
     }
     if (thermalManager.temp_bed.target != bedtarget) {
       bedtarget = thermalManager.temp_bed.target;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
+      dwinDrawDegreeSymbol(getColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
     }
   #endif
 
   #if HAS_FAN
     static uint8_t fan = -1;
     if (icons) {
       fan = -1;
-      DWIN_ICON_Show(ICON, ICON_FanSpeed, 187, 383);
+      dwinIconShow(ICON, ICON_FanSpeed, 187, 383);
     }
     if (thermalManager.fan_speed[0] != fan) {
       fan = thermalManager.fan_speed[0];
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+      dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
     }
   #endif
 
   #if HAS_ZOFFSET_ITEM
     static float offset = -1;
 
     if (icons) {
       offset = -1;
-      DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
+      dwinIconShow(ICON, ICON_Zoffset, 187, 416);
     }
     if (zoffsetvalue != offset) {
       offset = zoffsetvalue;
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
     }
   #endif
 
   static int16_t feedrate = -1;
   if (icons) {
     feedrate = -1;
-    DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
-    DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+    dwinIconShow(ICON, ICON_Speed, 113, 383);
+    dwinDrawString(false, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
   }
   if (feedrate_percentage != feedrate) {
     feedrate = feedrate_percentage;
-    DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+    dwinDrawIntValue(true, true, 0, DWIN_FONT_STAT, getColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   }
 
   static float x = -1, y = -1, z = -1;
   static bool update_x = false, update_y = false, update_z = false;
   update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
   update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
   update_z = (current_position.z != z || axis_should_home(Z_AXIS) || update_z);
   if (icons) {
     x = y = z = -1;
-    DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
-    DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
-    DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
-    DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
+    dwinDrawLine(getColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
+    dwinIconShow(ICON, ICON_MaxSpeedX,  10, 456);
+    dwinIconShow(ICON, ICON_MaxSpeedY,  95, 456);
+    dwinIconShow(ICON, ICON_MaxSpeedZ, 180, 456);
   }
   if (update_x) {
     x = current_position.x;
     if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x);
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x);
   }
   if (update_y) {
     y = current_position.y;
     if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
   }
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
+      dwinDrawString(true, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, current_position.z >= 0 ? current_position.z : 0);
+      dwinDrawFloatValue(true, true, 0, DWIN_FONT_MENU, getColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, current_position.z >= 0 ? current_position.z : 0);
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
+void CrealityDWIN::drawPopup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
   if (process != Confirm && process != Popup && process != Wait) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
-  Clear_Screen();
-  DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
-  DWIN_Draw_Rectangle(1, Color_Bg_Window, 14, 60, 258, 350);
+  clearScreen();
+  dwinDrawRectangle(0, Color_White, 13, 59, 259, 351);
+  dwinDrawRectangle(1, Color_Bg_Window, 14, 60, 258, 350);
   const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
-  if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
+  if (icon > 0) dwinIconShow(ICON, icon, 101, 105);
+  dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
+  dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
+  dwinDrawString(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
   if (mode == Popup) {
     selection = 0;
-    DWIN_Draw_Rectangle(1, Confirm_Color, 26, 280, 125, 317);
-    DWIN_Draw_Rectangle(1, Cancel_Color, 146, 280, 245, 317);
-    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
-    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
-    Popup_Select();
+    dwinDrawRectangle(1, Confirm_Color, 26, 280, 125, 317);
+    dwinDrawRectangle(1, Cancel_Color, 146, 280, 245, 317);
+    dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
+    dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
+    popupSelect();
   }
   else if (mode == Confirm) {
-    DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
-    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
+    dwinDrawRectangle(1, Confirm_Color, 87, 280, 186, 317);
+    dwinDrawString(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
   }
 }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
-  CrealityDWIN.Draw_Popup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
+  crealityDWIN.drawPopup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
 }
 
-void CrealityDWINClass::Popup_Select() {
-  const uint16_t c1 = selection ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White),
-                 c2 = selection ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window;
-  DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
-  DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
-  DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
-  DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
+void CrealityDWIN::popupSelect() {
+  const uint16_t c1 = selection ? Color_Bg_Window : getColor(eeprom_settings.highlight_box, Color_White),
+                 c2 = selection ? getColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window;
+  dwinDrawRectangle(0, c1, 25, 279, 126, 318);
+  dwinDrawRectangle(0, c1, 24, 278, 127, 319);
+  dwinDrawRectangle(0, c2, 145, 279, 246, 318);
+  dwinDrawRectangle(0, c2, 144, 278, 247, 319);
 }
 
-void CrealityDWINClass::Update_Status_Bar(const bool refresh/*=false*/) {
+void CrealityDWIN::updateStatusBar(const bool refresh/*=false*/) {
   typedef TextScroller<30> Scroller;
   static bool new_msg;
   static Scroller scroller;
   static char lastmsg[64];
   if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
     strcpy(lastmsg, statusmsg);
     scroller.reset();
     new_msg = true;
   }
   Scroller::Buffer buf;
   size_t len = 0;
   const char* dispmsg = scroller.scroll(len, buf, statusmsg, &new_msg);
   if (new_msg) {
     new_msg = false;
     if (process == Print) {
-      DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+      dwinDrawRectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
       const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
     }
     else {
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+      dwinDrawRectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
       const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
+      dwinDrawString(false, DWIN_FONT_MENU, getColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
     }
   }
 }
 
 /* Menu Item Config */
 
-void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item, bool draw/*=true*/) {
+void CrealityDWIN::menuItemHandler(const uint8_t menu, const uint8_t item, bool draw/*=true*/) {
   const uint8_t row = item - scrollpos;
   #if HAS_LEVELING
     static bool level_state;
   #endif
 
   #if HAS_PREHEAT
 
     #define PREHEAT_BACK 0
     #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
     #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
     #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
     #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
 
     auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
       switch (item) {
         case PREHEAT_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(TempMenu, sel);
+            drawMenu(TempMenu, sel);
           break;
         #if HAS_HOTEND
           case PREHEAT_SUBMENU_HOTEND:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-              Draw_Float(ui.material_preset[index].hotend_temp, row, false, 1);
+              drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
+              drawFloat(ui.material_preset[index].hotend_temp, row, false, 1);
             }
             else
-              Modify_Value(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              modifyValue(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
         #if HAS_HEATED_BED
           case PREHEAT_SUBMENU_BED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-              Draw_Float(ui.material_preset[index].bed_temp, row, false, 1);
+              drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
+              drawFloat(ui.material_preset[index].bed_temp, row, false, 1);
             }
             else
-              Modify_Value(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              modifyValue(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case PREHEAT_SUBMENU_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-              Draw_Float(ui.material_preset[index].fan_speed, row, false, 1);
+              drawMenuItem(row, ICON_FanSpeed, F("Fan"));
+              drawFloat(ui.material_preset[index].fan_speed, row, false, 1);
             }
             else
-              Modify_Value(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              modifyValue(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
       }
     };
 
   #endif
 
   switch (menu) {
     case Prepare:
 
@@ -1093,123 +1089,123 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
       #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ANY(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define PREPARE_CUSTOM_MENU (PREPARE_CHANGEFIL + ENABLED(HAS_CUSTOM_MENU))
       #define PREPARE_TOTAL PREPARE_CUSTOM_MENU
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Main_Menu(1);
+            drawMainMenu(1);
           break;
         case PREPARE_MOVE:
           if (draw)
-            Draw_Menu_Item(row, ICON_Axis, F("Move"), nullptr, true);
+            drawMenuItem(row, ICON_Axis, F("Move"), nullptr, true);
           else
-            Draw_Menu(Move);
+            drawMenu(Move);
           break;
         case PREPARE_DISABLE:
           if (draw)
-            Draw_Menu_Item(row, ICON_CloseMotor, F("Disable Stepper"));
+            drawMenuItem(row, ICON_CloseMotor, F("Disable Stepper"));
           else
             queue.inject(F("M84"));
           break;
         case PREPARE_HOME:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Homing"), nullptr, true);
+            drawMenuItem(row, ICON_SetHome, F("Homing"), nullptr, true);
           else
-            Draw_Menu(HomeMenu);
+            drawMenu(HomeMenu);
           break;
         case PREPARE_MANUALLEVEL:
           if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
+            drawMenuItem(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
           else {
             if (axes_should_home()) {
-              Popup_Handler(Home);
+              popupHandler(Home);
               gcode.home_all_axes(true);
             }
             #if HAS_LEVELING
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
             #endif
-            Draw_Menu(ManualLevel);
+            drawMenu(ManualLevel);
           }
           break;
 
         #if HAS_ZOFFSET_ITEM
           case PREPARE_ZOFFSET:
             if (draw)
-              Draw_Menu_Item(row, ICON_Zoffset, F("Z-Offset"), nullptr, true);
+              drawMenuItem(row, ICON_Zoffset, F("Z-Offset"), nullptr, true);
             else {
               #if HAS_LEVELING
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
               #endif
-              Draw_Menu(ZOffset);
+              drawMenu(ZOffset);
             }
             break;
         #endif
 
         #if HAS_PREHEAT
           case PREPARE_PREHEAT:
             if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, F("Preheat"), nullptr, true);
+              drawMenuItem(row, ICON_Temperature, F("Preheat"), nullptr, true);
             else
-              Draw_Menu(Preheat);
+              drawMenu(Preheat);
             break;
         #endif
 
         #if HAS_HOTEND || HAS_HEATED_BED
           case PREPARE_COOLDOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_Cool, F("Cooldown"));
+              drawMenuItem(row, ICON_Cool, F("Cooldown"));
             else
               thermalManager.cooldown();
             break;
         #endif
 
         #if HAS_CUSTOM_MENU
           case PREPARE_CUSTOM_MENU:
             #ifndef CUSTOM_MENU_CONFIG_TITLE
               #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
             #endif
             if (draw)
-              Draw_Menu_Item(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
+              drawMenuItem(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
             else
-              Draw_Menu(MenuCustom);
+              drawMenu(MenuCustom);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
+              drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                Draw_Menu(ChangeFilament);
+                drawMenu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                  Popup_Handler(ETemp);
+                  popupHandler(ETemp);
                 else {
                   if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                    Popup_Handler(Heating);
+                    popupHandler(Heating);
                     thermalManager.wait_for_hotend(0);
                   }
-                  Popup_Handler(FilChange);
+                  popupHandler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                   gcode.process_subcommands_now(cmd);
                 }
               #endif
             }
             break;
         #endif
       }
       break;
 
@@ -1219,170 +1215,170 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define HOME_ALL   (HOME_BACK + 1)
       #define HOME_X     (HOME_ALL + 1)
       #define HOME_Y     (HOME_X + 1)
       #define HOME_Z     (HOME_Y + 1)
       #define HOME_SET   (HOME_Z + 1)
       #define HOME_TOTAL HOME_SET
 
       switch (item) {
         case HOME_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Prepare, PREPARE_HOME);
+            drawMenu(Prepare, PREPARE_HOME);
           break;
         case HOME_ALL:
           if (draw)
-            Draw_Menu_Item(row, ICON_Homing, F("Home All"));
+            drawMenuItem(row, ICON_Homing, F("Home All"));
           else {
-            Popup_Handler(Home);
+            popupHandler(Home);
             gcode.home_all_axes(true);
-            Redraw_Menu();
+            redrawMenu();
           }
           break;
         case HOME_X:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveX, F("Home X"));
+            drawMenuItem(row, ICON_MoveX, F("Home X"));
           else {
-            Popup_Handler(Home);
+            popupHandler(Home);
             gcode.process_subcommands_now(F("G28 X"));
             planner.synchronize();
-            Redraw_Menu();
+            redrawMenu();
           }
           break;
         case HOME_Y:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveY, F("Home Y"));
+            drawMenuItem(row, ICON_MoveY, F("Home Y"));
           else {
-            Popup_Handler(Home);
+            popupHandler(Home);
             gcode.process_subcommands_now(F("G28 Y"));
             planner.synchronize();
-            Redraw_Menu();
+            redrawMenu();
           }
           break;
         case HOME_Z:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveZ, F("Home Z"));
+            drawMenuItem(row, ICON_MoveZ, F("Home Z"));
           else {
-            Popup_Handler(Home);
+            popupHandler(Home);
             gcode.process_subcommands_now(F("G28 Z"));
             planner.synchronize();
-            Redraw_Menu();
+            redrawMenu();
           }
           break;
         case HOME_SET:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Set Home Position"));
+            drawMenuItem(row, ICON_SetHome, F("Set Home Position"));
           else {
             gcode.process_subcommands_now(F("G92X0Y0Z0"));
-            AudioFeedback();
+            audioFeedback();
           }
           break;
       }
       break;
 
     case Move:
 
       #define MOVE_BACK 0
       #define MOVE_X (MOVE_BACK + 1)
       #define MOVE_Y (MOVE_X + 1)
       #define MOVE_Z (MOVE_Y + 1)
       #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
       #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
       #define MOVE_LIVE (MOVE_P + 1)
       #define MOVE_TOTAL MOVE_LIVE
 
       switch (item) {
         case MOVE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else {
             #if HAS_BED_PROBE
               probe_deployed = false;
               probe.set_deployed(probe_deployed);
             #endif
-            Draw_Menu(Prepare, PREPARE_MOVE);
+            drawMenu(Prepare, PREPARE_MOVE);
           }
           break;
         case MOVE_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveX, F("Move X"));
-            Draw_Float(current_position.x, row, false);
+            drawMenuItem(row, ICON_MoveX, F("Move X"));
+            drawFloat(current_position.x, row, false);
           }
           else
-            Modify_Value(current_position.x, X_MIN_POS, X_MAX_POS, 10);
+            modifyValue(current_position.x, X_MIN_POS, X_MAX_POS, 10);
           break;
         case MOVE_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveY, F("Move Y"));
-            Draw_Float(current_position.y, row);
+            drawMenuItem(row, ICON_MoveY, F("Move Y"));
+            drawFloat(current_position.y, row);
           }
           else
-            Modify_Value(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
+            modifyValue(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
           break;
         case MOVE_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveZ, F("Move Z"));
-            Draw_Float(current_position.z, row);
+            drawMenuItem(row, ICON_MoveZ, F("Move Z"));
+            drawFloat(current_position.z, row);
           }
           else
-            Modify_Value(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
+            modifyValue(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
           break;
 
         #if HAS_HOTEND
           case MOVE_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, F("Extruder"));
+              drawMenuItem(row, ICON_Extruder, F("Extruder"));
               current_position.e = 0;
               sync_plan_position();
-              Draw_Float(current_position.e, row);
+              drawFloat(current_position.e, row);
             }
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
-                Popup_Handler(ETemp);
+                popupHandler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  Popup_Handler(Heating);
+                  popupHandler(Heating);
                   thermalManager.wait_for_hotend(0);
-                  Redraw_Menu();
+                  redrawMenu();
                 }
                 current_position.e = 0;
                 sync_plan_position();
-                Modify_Value(current_position.e, -500, 500, 10);
+                modifyValue(current_position.e, -500, 500, 10);
               }
             }
           break;
         #endif // HAS_HOTEND
 
         #if HAS_BED_PROBE
           case MOVE_P:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, F("Probe"));
-              Draw_Checkbox(row, probe_deployed);
+              drawMenuItem(row, ICON_StockConfiguration, F("Probe"));
+              drawCheckbox(row, probe_deployed);
             }
             else {
               probe_deployed = !probe_deployed;
               probe.set_deployed(probe_deployed);
-              Draw_Checkbox(row, probe_deployed);
+              drawCheckbox(row, probe_deployed);
             }
             break;
         #endif
 
         case MOVE_LIVE:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Axis, F("Live Movement"));
-            Draw_Checkbox(row, livemove);
+            drawMenuItem(row, ICON_Axis, F("Live Movement"));
+            drawCheckbox(row, livemove);
           }
           else {
             livemove = !livemove;
-            Draw_Checkbox(row, livemove);
+            drawCheckbox(row, livemove);
           }
           break;
       }
       break;
     case ManualLevel: {
 
       #define MLEVEL_BACK 0
       #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
       #define MLEVEL_BL (MLEVEL_PROBE + 1)
       #define MLEVEL_TL (MLEVEL_BL + 1)
@@ -1398,284 +1394,284 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #if HAS_BED_PROBE
         const float probe_x_min = _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x,
                     probe_x_max = _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x,
                     probe_y_min = _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y,
                     probe_y_max = _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y;
       #endif
 
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
-            Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
+            drawMenu(Prepare, PREPARE_MANUALLEVEL);
           }
           break;
 
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
-              Draw_Checkbox(row, use_probe);
+              drawMenuItem(row, ICON_Zoffset, F("Use Probe"));
+              drawCheckbox(row, use_probe);
             }
             else {
               use_probe ^= true;
-              Draw_Checkbox(row, use_probe);
+              drawCheckbox(row, use_probe);
               if (use_probe) {
-                Popup_Handler(Level);
+                popupHandler(Level);
                 const struct { xy_pos_t p; ProbePtRaise r; } points[] = {
                   { { probe_x_min, probe_y_min }, PROBE_PT_RAISE },
                   { { probe_x_min, probe_y_max }, PROBE_PT_RAISE },
                   { { probe_x_max, probe_y_max }, PROBE_PT_RAISE },
                   { { probe_x_max, probe_y_min }, PROBE_PT_STOW }
                 };
                 corner_avg = 0;
                 for (uint8_t i = 0; i < COUNT(points); i++) {
                   const float mz = probe.probe_at_point(points[i].p, points[i].r, 0, false);
                   if (isnan(mz)) { corner_avg = 0; break; }
                   corner_avg += mz;
                 }
                 corner_avg /= 4;
-                Redraw_Menu();
+                redrawMenu();
               }
             }
             break;
         #endif
 
         case MLEVEL_BL:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisBL, F("Bottom Left"));
+            drawMenuItem(row, ICON_AxisBL, F("Bottom Left"));
           else {
-            Popup_Handler(MoveWait);
+            popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
-                Popup_Handler(ManualProbing);
+                popupHandler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisTL, F("Top Left"));
+            drawMenuItem(row, ICON_AxisTL, F("Top Left"));
           else {
-            Popup_Handler(MoveWait);
+            popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_max, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
-                Popup_Handler(ManualProbing);
+                popupHandler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisTR, F("Top Right"));
+            drawMenuItem(row, ICON_AxisTR, F("Top Right"));
           else {
-            Popup_Handler(MoveWait);
+            popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_max, 1, 3, str_1), dtostrf(probe_y_max, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
-                Popup_Handler(ManualProbing);
+                popupHandler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisBR, F("Bottom Right"));
+            drawMenuItem(row, ICON_AxisBR, F("Bottom Right"));
           else {
-            Popup_Handler(MoveWait);
+            popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_max, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
-                Popup_Handler(ManualProbing);
+                popupHandler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisC, F("Center"));
+            drawMenuItem(row, ICON_AxisC, F("Center"));
           else {
-            Popup_Handler(MoveWait);
+            popupHandler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
-                Popup_Handler(ManualProbing);
+                popupHandler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
           }
           break;
         case MLEVEL_ZPOS:
           if (draw) {
-            Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
-            Draw_Float(mlev_z_pos, row, false, 100);
+            drawMenuItem(row, ICON_SetZOffset, F("Z Position"));
+            drawFloat(mlev_z_pos, row, false, 100);
           }
           else
-            Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
+            modifyValue(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
           break;
       }
 
     } break;
 
     #if HAS_ZOFFSET_ITEM
       case ZOffset:
 
         #define ZOFFSET_BACK 0
         #define ZOFFSET_HOME (ZOFFSET_BACK + 1)
         #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
         #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
         #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
         #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
         #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
         #define ZOFFSET_TOTAL ZOFFSET_SAVE
 
         switch (item) {
           case ZOFFSET_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else {
               liveadjust = false;
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
-              Draw_Menu(Prepare, PREPARE_ZOFFSET);
+              drawMenu(Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
-              Draw_Menu_Item(row, ICON_Homing, F("Home Z Axis"));
+              drawMenuItem(row, ICON_Homing, F("Home Z Axis"));
             else {
-              Popup_Handler(Home);
+              popupHandler(Home);
               gcode.process_subcommands_now(F("G28 Z"));
-              Popup_Handler(MoveWait);
+              popupHandler(MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
               #else
                 gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
               #endif
               gcode.process_subcommands_now(F("G0 F300 Z0"));
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
             break;
           case ZOFFSET_MODE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, F("Live Adjustment"));
-              Draw_Checkbox(row, liveadjust);
+              drawMenuItem(row, ICON_Zoffset, F("Live Adjustment"));
+              drawCheckbox(row, liveadjust);
             }
             else {
               if (!liveadjust) {
                 if (axes_should_home()) {
-                  Popup_Handler(Home);
+                  popupHandler(Home);
                   gcode.home_all_axes(true);
                 }
-                Popup_Handler(MoveWait);
+                popupHandler(MoveWait);
                 #if ENABLED(Z_SAFE_HOMING)
                   planner.synchronize();
                   sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
                   gcode.process_subcommands_now(cmd);
                 #else
                   gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
                 #endif
                 gcode.process_subcommands_now(F("G0 F300 Z0"));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
               }
               liveadjust = !liveadjust;
-              Draw_Checkbox(row, liveadjust);
+              drawCheckbox(row, liveadjust);
             }
             break;
           case ZOFFSET_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Offset"));
-              Draw_Float(zoffsetvalue, row, false, 100);
+              drawMenuItem(row, ICON_SetZOffset, F("Z Offset"));
+              drawFloat(zoffsetvalue, row, false, 100);
             }
             else
-              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              modifyValue(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case ZOFFSET_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
             else {
               if (zoffsetvalue < MAX_Z_OFFSET) {
                 if (liveadjust) {
                   gcode.process_subcommands_now(F("M290 Z0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue += 0.01;
-                Draw_Float(zoffsetvalue, row - 1, false, 100);
+                drawFloat(zoffsetvalue, row - 1, false, 100);
               }
             }
             break;
           case ZOFFSET_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
+              drawMenuItem(row, ICON_AxisD, F("Microstep Down"));
             else {
               if (zoffsetvalue > MIN_Z_OFFSET) {
                 if (liveadjust) {
                   gcode.process_subcommands_now(F("M290 Z-0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue -= 0.01;
-                Draw_Float(zoffsetvalue, row - 2, false, 100);
+                drawFloat(zoffsetvalue, row - 2, false, 100);
               }
             }
             break;
           #if ENABLED(EEPROM_SETTINGS)
             case ZOFFSET_SAVE:
               if (draw)
-                Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save"));
+                drawMenuItem(row, ICON_WriteEEPROM, F("Save"));
               else
-                AudioFeedback(settings.save());
+                audioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
 
     #if HAS_PREHEAT
       case Preheat: {
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
         #define PREHEAT_1 (PREHEAT_MODE + 1)
@@ -1687,110 +1683,110 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
 
         auto do_preheat = [](const uint8_t m) {
           thermalManager.cooldown();
           if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
           if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
         };
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Prepare, PREPARE_PREHEAT);
+              drawMenu(Prepare, PREPARE_PREHEAT);
             break;
 
           case PREHEAT_MODE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
-              Draw_Option(preheatmode, preheat_modes, row);
+              drawMenuItem(row, ICON_Homing, F("Preheat Mode"));
+              drawOption(preheatmode, preheat_modes, row);
             }
             else
-              Modify_Option(preheatmode, preheat_modes, 2);
+              modifyOption(preheatmode, preheat_modes, 2);
             break;
 
           #define _PREHEAT_CASE(N) \
             case PREHEAT_##N: { \
-              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+              if (draw) drawMenuItem(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
               else do_preheat(N - 1); \
             } break;
 
           REPEAT_1(PREHEAT_COUNT, _PREHEAT_CASE)
         }
       } break;
     #endif // HAS_PREHEAT
 
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:
 
         #define CHANGEFIL_BACK 0
         #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
         #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
         #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
 
         switch (item) {
           case CHANGEFIL_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Prepare, PREPARE_CHANGEFIL);
+              drawMenu(Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
+              drawMenuItem(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                Popup_Handler(ETemp);
+                popupHandler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  Popup_Handler(Heating);
+                  popupHandler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
-                Popup_Handler(FilLoad);
+                popupHandler(FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
+              drawMenuItem(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
-                Popup_Handler(ETemp);
+                popupHandler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  Popup_Handler(Heating);
+                  popupHandler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
-                Popup_Handler(FilLoad, true);
+                popupHandler(FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
+              drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                Popup_Handler(ETemp);
+                popupHandler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                  Popup_Handler(Heating);
+                  popupHandler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
-                Popup_Handler(FilChange);
+                popupHandler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                 gcode.process_subcommands_now(cmd);
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
     #if HAS_CUSTOM_MENU
@@ -1801,113 +1797,113 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define CUSTOM_MENU_1 1
         #define CUSTOM_MENU_2 2
         #define CUSTOM_MENU_3 3
         #define CUSTOM_MENU_4 4
         #define CUSTOM_MENU_5 5
         #define CUSTOM_MENU_TOTAL CUSTOM_MENU_COUNT
 
         switch (item) {
           case CUSTOM_MENU_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Prepare, PREPARE_CUSTOM_MENU);
+              drawMenu(Prepare, PREPARE_CUSTOM_MENU);
             break;
 
           #if CUSTOM_MENU_COUNT >= 1
             case CUSTOM_MENU_1:
               if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
+                drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
               else {
-                Popup_Handler(Custom);
+                popupHandler(Custom);
                 //queue.inject(F(CONFIG_MENU_ITEM_1_GCODE)); // Old code
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_1_GCODE));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
+                  audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 2
             case CUSTOM_MENU_2:
               if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_2_DESC));
+                drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_2_DESC));
               else {
-                Popup_Handler(Custom);
+                popupHandler(Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_2_GCODE));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
+                  audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 3
             case CUSTOM_MENU_3:
               if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_3_DESC));
+                drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_3_DESC));
               else {
-                Popup_Handler(Custom);
+                popupHandler(Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_3_GCODE));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
+                  audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 4
             case CUSTOM_MENU_4:
               if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_4_DESC));
+                drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_4_DESC));
               else {
-                Popup_Handler(Custom);
+                popupHandler(Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_4_GCODE));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
+                  audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif
 
           #if CUSTOM_MENU_COUNT >= 5
             case CUSTOM_MENU_5:
               if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_5_DESC));
+                drawMenuItem(row, ICON_Info, F(CONFIG_MENU_ITEM_5_DESC));
               else {
-                Popup_Handler(Custom);
+                popupHandler(Custom);
                 gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_5_GCODE));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
                 #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
+                  audioFeedback();
                 #endif
                 #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
                   queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
                 #endif
               }
               break;
           #endif // Custom Menu
         }
         break;
 
@@ -1922,75 +1918,75 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
       #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_INFO (CONTROL_RESET + 1)
       #define CONTROL_TOTAL CONTROL_INFO
 
       switch (item) {
         case CONTROL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Main_Menu(2);
+            drawMainMenu(2);
           break;
         case CONTROL_TEMP:
           if (draw)
-            Draw_Menu_Item(row, ICON_Temperature, F("Temperature"), nullptr, true);
+            drawMenuItem(row, ICON_Temperature, F("Temperature"), nullptr, true);
           else
-            Draw_Menu(TempMenu);
+            drawMenu(TempMenu);
           break;
         case CONTROL_MOTION:
           if (draw)
-            Draw_Menu_Item(row, ICON_Motion, F("Motion"), nullptr, true);
+            drawMenuItem(row, ICON_Motion, F("Motion"), nullptr, true);
           else
-            Draw_Menu(Motion);
+            drawMenu(Motion);
           break;
         case CONTROL_VISUAL:
           if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, F("Visual"), nullptr, true);
+            drawMenuItem(row, ICON_PrintSize, F("Visual"), nullptr, true);
           else
-            Draw_Menu(Visual);
+            drawMenu(Visual);
           break;
         case CONTROL_ADVANCED:
           if (draw)
-            Draw_Menu_Item(row, ICON_Version, F("Advanced"), nullptr, true);
+            drawMenuItem(row, ICON_Version, F("Advanced"), nullptr, true);
           else
-            Draw_Menu(Advanced);
+            drawMenu(Advanced);
           break;
         #if ENABLED(EEPROM_SETTINGS)
           case CONTROL_SAVE:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Store Settings"));
+              drawMenuItem(row, ICON_WriteEEPROM, F("Store Settings"));
             else
-              AudioFeedback(settings.save());
+              audioFeedback(settings.save());
             break;
           case CONTROL_RESTORE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Restore Settings"));
+              drawMenuItem(row, ICON_ReadEEPROM, F("Restore Settings"));
             else
-              AudioFeedback(settings.load());
+              audioFeedback(settings.load());
             break;
           case CONTROL_RESET:
             if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, F("Reset to Defaults"));
+              drawMenuItem(row, ICON_Temperature, F("Reset to Defaults"));
             else {
               settings.reset();
-              AudioFeedback();
+              audioFeedback();
             }
             break;
         #endif
         case CONTROL_INFO:
           if (draw)
-            Draw_Menu_Item(row, ICON_Info, F("Info"));
+            drawMenuItem(row, ICON_Info, F("Info"));
           else
-            Draw_Menu(Info);
+            drawMenu(Info);
           break;
       }
       break;
 
     case TempMenu:
 
       #define TEMP_BACK 0
       #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
       #define TEMP_BED (TEMP_HOTEND + ENABLED(HAS_HEATED_BED))
       #define TEMP_FAN (TEMP_BED + ENABLED(HAS_FAN))
@@ -1998,114 +1994,114 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
       #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
       #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
       #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
       #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
       #define TEMP_TOTAL TEMP_PREHEAT5
 
       switch (item) {
         case TEMP_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Control, CONTROL_TEMP);
+            drawMenu(Control, CONTROL_TEMP);
           break;
         #if HAS_HOTEND
           case TEMP_HOTEND:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+              drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
+              drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
-              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
+              modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
         #if HAS_HEATED_BED
           case TEMP_BED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
+              drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
+              drawFloat(thermalManager.temp_bed.target, row, false, 1);
             }
             else
-              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              modifyValue(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case TEMP_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
+              drawMenuItem(row, ICON_FanSpeed, F("Fan"));
+              drawFloat(thermalManager.fan_speed[0], row, false, 1);
             }
             else
-              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              modifyValue(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
         #if HAS_HOTEND || HAS_HEATED_BED
           case TEMP_PID:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, F("PID"), nullptr, true);
+              drawMenuItem(row, ICON_Step, F("PID"), nullptr, true);
             else
-              Draw_Menu(PID);
+              drawMenu(PID);
             break;
         #endif
 
         #define _TEMP_PREHEAT_CASE(N) \
           case TEMP_PREHEAT##N: { \
-            if (draw) Draw_Menu_Item(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
-            else Draw_Menu(Preheat##N); \
+            if (draw) drawMenuItem(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
+            else drawMenu(Preheat##N); \
           } break;
 
         REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
       }
       break;
 
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:
 
         #define PID_BACK 0
         #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
         #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
         switch (item) {
           case PID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(TempMenu, TEMP_PID);
+              drawMenu(TempMenu, TEMP_PID);
             break;
           #if HAS_HOTEND
             case PID_HOTEND:
               if (draw)
-                Draw_Menu_Item(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
+                drawMenuItem(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
               else
-                Draw_Menu(HotendPID);
+                drawMenu(HotendPID);
               break;
           #endif
           #if HAS_HEATED_BED
             case PID_BED:
               if (draw)
-                Draw_Menu_Item(row, ICON_BedTemp, F("Bed"), nullptr, true);
+                drawMenuItem(row, ICON_BedTemp, F("Bed"), nullptr, true);
               else
-                Draw_Menu(BedPID);
+                drawMenu(BedPID);
               break;
           #endif
           case PID_CYCLES:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Cycles"));
-              Draw_Float(PID_cycles, row, false, 1);
+              drawMenuItem(row, ICON_FanSpeed, F("Cycles"));
+              drawFloat(PID_cycles, row, false, 1);
             }
             else
-              Modify_Value(PID_cycles, 3, 50, 1);
+              modifyValue(PID_cycles, 3, 50, 1);
             break;
         }
         break;
     #endif // HAS_HOTEND || HAS_HEATED_BED
 
     #if HAS_HOTEND
       case HotendPID:
 
         #define HOTENDPID_BACK 0
         #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
@@ -2113,66 +2109,66 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
         #define HOTENDPID_KI (HOTENDPID_KP + 1)
         #define HOTENDPID_KD (HOTENDPID_KI + 1)
         #define HOTENDPID_TOTAL HOTENDPID_KD
 
         static uint16_t PID_e_temp = 180;
 
         switch (item) {
           case HOTENDPID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(PID, PID_HOTEND);
+              drawMenu(PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
+              drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
             else {
-              Popup_Handler(PIDWait);
+              popupHandler(PIDWait);
               sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
-              Draw_Float(PID_e_temp, row, false, 1);
+              drawMenuItem(row, ICON_Temperature, F("Temperature"));
+              drawFloat(PID_e_temp, row, false, 1);
             }
             else
-              Modify_Value(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              modifyValue(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
           case HOTENDPID_KP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
-              Draw_Float(thermalManager.temp_hotend[0].pid.p(), row, false, 100);
+              drawMenuItem(row, ICON_Version, F("Kp Value"));
+              drawFloat(thermalManager.temp_hotend[0].pid.p(), row, false, 100);
             }
             else
-              Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KI:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
-              Draw_Float(thermalManager.temp_hotend[0].pid.i(), row, false, 100);
+              drawMenuItem(row, ICON_Version, F("Ki Value"));
+              drawFloat(thermalManager.temp_hotend[0].pid.i(), row, false, 100);
             }
             else
-              Modify_Value(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
-              Draw_Float(thermalManager.temp_hotend[0].pid.d(), row, false, 100);
+              drawMenuItem(row, ICON_Version, F("Kd Value"));
+              drawFloat(thermalManager.temp_hotend[0].pid.d(), row, false, 100);
             }
             else
-              Modify_Value(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
       case BedPID:
 
         #define BEDPID_BACK 0
         #define BEDPID_TUNE (BEDPID_BACK + 1)
@@ -2180,67 +2176,67 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define BEDPID_KP (BEDPID_TEMP + 1)
         #define BEDPID_KI (BEDPID_KP + 1)
         #define BEDPID_KD (BEDPID_KI + 1)
         #define BEDPID_TOTAL BEDPID_KD
 
         static uint16_t PID_bed_temp = 60;
 
         switch (item) {
           case BEDPID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(PID, PID_BED);
+              drawMenu(PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
+              drawMenuItem(row, ICON_HotendTemp, F("Autotune"));
             else {
-              Popup_Handler(PIDWait);
+              popupHandler(PIDWait);
               sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
-              Redraw_Menu();
+              redrawMenu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
-              Draw_Float(PID_bed_temp, row, false, 1);
+              drawMenuItem(row, ICON_Temperature, F("Temperature"));
+              drawFloat(PID_bed_temp, row, false, 1);
             }
             else
-              Modify_Value(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              modifyValue(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
           case BEDPID_KP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
-              Draw_Float(thermalManager.temp_bed.pid.p(), row, false, 100);
+              drawMenuItem(row, ICON_Version, F("Kp Value"));
+              drawFloat(thermalManager.temp_bed.pid.p(), row, false, 100);
             }
             else {
-              Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             }
             break;
           case BEDPID_KI:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
-              Draw_Float(thermalManager.temp_bed.pid.i(), row, false, 100);
+              drawMenuItem(row, ICON_Version, F("Ki Value"));
+              drawFloat(thermalManager.temp_bed.pid.i(), row, false, 100);
             }
             else
-              Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case BEDPID_KD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
-              Draw_Float(thermalManager.temp_bed.pid.d(), row, false, 100);
+              drawMenuItem(row, ICON_Version, F("Kd Value"));
+              drawFloat(thermalManager.temp_bed.pid.d(), row, false, 100);
             }
             else
-              Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+              modifyValue(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HEATED_BED
 
     #if HAS_PREHEAT
       #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
@@ -2251,379 +2247,379 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
       #define MOTION_STEPS (MOTION_JERK + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
       #define MOTION_TOTAL MOTION_FLOW
 
       switch (item) {
         case MOTION_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Control, CONTROL_MOTION);
+            drawMenu(Control, CONTROL_MOTION);
           break;
         case MOTION_HOMEOFFSETS:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
+            drawMenuItem(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
           else
-            Draw_Menu(HomeOffsets);
+            drawMenu(HomeOffsets);
           break;
         case MOTION_SPEED:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
           else
-            Draw_Menu(MaxSpeed);
+            drawMenu(MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
+            drawMenuItem(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
           else
-            Draw_Menu(MaxAcceleration);
+            drawMenu(MaxAcceleration);
           break;
         #if HAS_CLASSIC_JERK
           case MOTION_JERK:
             if (draw)
-              Draw_Menu_Item(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
+              drawMenuItem(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
             else
-              Draw_Menu(MaxJerk);
+              drawMenu(MaxJerk);
             break;
         #endif
         case MOTION_STEPS:
           if (draw)
-            Draw_Menu_Item(row, ICON_Step, F("Steps/mm"), nullptr, true);
+            drawMenuItem(row, ICON_Step, F("Steps/mm"), nullptr, true);
           else
-            Draw_Menu(Steps);
+            drawMenu(Steps);
           break;
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
-              Draw_Float(planner.flow_percentage[0], row, false, 1);
+              drawMenuItem(row, ICON_Speed, F("Flow Rate"));
+              drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
-              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
+              modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
         #endif
       }
       break;
 
     case HomeOffsets:
 
       #define HOMEOFFSETS_BACK 0
       #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
       #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
       #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
 
       switch (item) {
         case HOMEOFFSETS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Motion, MOTION_HOMEOFFSETS);
+            drawMenu(Motion, MOTION_HOMEOFFSETS);
           break;
         case HOMEOFFSETS_XOFFSET:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, F("X Offset"));
-            Draw_Float(home_offset.x, row, false, 100);
+            drawMenuItem(row, ICON_StepX, F("X Offset"));
+            drawFloat(home_offset.x, row, false, 100);
           }
           else
-            Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+            modifyValue(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
         case HOMEOFFSETS_YOFFSET:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, F("Y Offset"));
-            Draw_Float(home_offset.y, row, false, 100);
+            drawMenuItem(row, ICON_StepY, F("Y Offset"));
+            drawFloat(home_offset.y, row, false, 100);
           }
           else
-            Modify_Value(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+            modifyValue(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
       }
       break;
     case MaxSpeed:
 
       #define SPEED_BACK 0
       #define SPEED_X (SPEED_BACK + 1)
       #define SPEED_Y (SPEED_X + 1)
       #define SPEED_Z (SPEED_Y + 1)
       #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
       #define SPEED_TOTAL SPEED_E
 
       switch (item) {
         case SPEED_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Motion, MOTION_SPEED);
+            drawMenu(Motion, MOTION_SPEED);
           break;
         #if HAS_X_AXIS
           case SPEED_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, FEEDRATE_UNIT);
+              drawMenuItem(row, ICON_MaxSpeedX, F("X Axis"));
+              drawFloat(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], min_feedrate_edit_values.x, max_feedrate_edit_values.x, FEEDRATE_UNIT);
+              modifyValue(planner.settings.max_feedrate_mm_s[X_AXIS], min_feedrate_edit_values.x, max_feedrate_edit_values.x, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_Y_AXIS
           case SPEED_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedY, F("Y Axis"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, FEEDRATE_UNIT);
+              drawMenuItem(row, ICON_MaxSpeedY, F("Y Axis"));
+              drawFloat(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], min_feedrate_edit_values.y, max_feedrate_edit_values.y, FEEDRATE_UNIT);
+              modifyValue(planner.settings.max_feedrate_mm_s[Y_AXIS], min_feedrate_edit_values.y, max_feedrate_edit_values.y, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_Z_AXIS
           case SPEED_Z:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedZ, F("Z Axis"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, FEEDRATE_UNIT);
+              drawMenuItem(row, ICON_MaxSpeedZ, F("Z Axis"));
+              drawFloat(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], min_feedrate_edit_values.z, max_feedrate_edit_values.z, FEEDRATE_UNIT);
+              modifyValue(planner.settings.max_feedrate_mm_s[Z_AXIS], min_feedrate_edit_values.z, max_feedrate_edit_values.z, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_HOTEND
           case SPEED_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedE, F("Extruder"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, FEEDRATE_UNIT);
+              drawMenuItem(row, ICON_MaxSpeedE, F("Extruder"));
+              drawFloat(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], min_feedrate_edit_values.e, max_feedrate_edit_values.e, FEEDRATE_UNIT);
+              modifyValue(planner.settings.max_feedrate_mm_s[E_AXIS], min_feedrate_edit_values.e, max_feedrate_edit_values.e, FEEDRATE_UNIT);
             break;
         #endif
       }
       break;
 
     case MaxAcceleration:
 
       #define ACCEL_BACK 0
       #define ACCEL_X (ACCEL_BACK + 1)
       #define ACCEL_Y (ACCEL_X + 1)
       #define ACCEL_Z (ACCEL_Y + 1)
       #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
       #define ACCEL_TOTAL ACCEL_E
 
       switch (item) {
         case ACCEL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Motion, MOTION_ACCEL);
+            drawMenu(Motion, MOTION_ACCEL);
           break;
         case ACCEL_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccX, F("X Axis"));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, ACCELERATION_UNIT);
+            drawMenuItem(row, ICON_MaxAccX, F("X Axis"));
+            drawFloat(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], min_acceleration_edit_values.x, max_acceleration_edit_values.x, ACCELERATION_UNIT);
+            modifyValue(planner.settings.max_acceleration_mm_per_s2[X_AXIS], min_acceleration_edit_values.x, max_acceleration_edit_values.x, ACCELERATION_UNIT);
           break;
         case ACCEL_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccY, F("Y Axis"));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, ACCELERATION_UNIT);
+            drawMenuItem(row, ICON_MaxAccY, F("Y Axis"));
+            drawFloat(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], min_acceleration_edit_values.y, max_acceleration_edit_values.y, ACCELERATION_UNIT);
+            modifyValue(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], min_acceleration_edit_values.y, max_acceleration_edit_values.y, ACCELERATION_UNIT);
           break;
         case ACCEL_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccZ, F("Z Axis"));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, ACCELERATION_UNIT);
+            drawMenuItem(row, ICON_MaxAccZ, F("Z Axis"));
+            drawFloat(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], min_acceleration_edit_values.z, max_acceleration_edit_values.z, ACCELERATION_UNIT);
+            modifyValue(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], min_acceleration_edit_values.z, max_acceleration_edit_values.z, ACCELERATION_UNIT);
           break;
         #if HAS_HOTEND
           case ACCEL_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccE, F("Extruder"));
-              Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, ACCELERATION_UNIT);
+              drawMenuItem(row, ICON_MaxAccE, F("Extruder"));
+              drawFloat(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, ACCELERATION_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], min_acceleration_edit_values.e, max_acceleration_edit_values.e, ACCELERATION_UNIT);
+              modifyValue(planner.settings.max_acceleration_mm_per_s2[E_AXIS], min_acceleration_edit_values.e, max_acceleration_edit_values.e, ACCELERATION_UNIT);
             break;
         #endif
       }
       break;
     #if HAS_CLASSIC_JERK
       case MaxJerk:
 
         #define JERK_BACK 0
         #define JERK_X (JERK_BACK + 1)
         #define JERK_Y (JERK_X + 1)
         #define JERK_Z (JERK_Y + 1)
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
           case JERK_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Motion, MOTION_JERK);
+              drawMenu(Motion, MOTION_JERK);
             break;
           #if HAS_X_AXIS
             case JERK_X:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
-                Draw_Float(planner.max_jerk.x, row, false, JERK_UNIT);
+                drawMenuItem(row, ICON_MaxSpeedJerkX, F("X Axis"));
+                drawFloat(planner.max_jerk.x, row, false, JERK_UNIT);
               }
               else
-                Modify_Value(planner.max_jerk.x, min_jerk_edit_values.x, max_jerk_edit_values.x, JERK_UNIT);
+                modifyValue(planner.max_jerk.x, min_jerk_edit_values.x, max_jerk_edit_values.x, JERK_UNIT);
               break;
           #endif
           #if HAS_Y_AXIS
             case JERK_Y:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
-                Draw_Float(planner.max_jerk.y, row, false, JERK_UNIT);
+                drawMenuItem(row, ICON_MaxSpeedJerkY, F("Y Axis"));
+                drawFloat(planner.max_jerk.y, row, false, JERK_UNIT);
               }
               else
-                Modify_Value(planner.max_jerk.y, min_jerk_edit_values.y, max_jerk_edit_values.y, JERK_UNIT);
+                modifyValue(planner.max_jerk.y, min_jerk_edit_values.y, max_jerk_edit_values.y, JERK_UNIT);
               break;
           #endif
           #if HAS_Z_AXIS
             case JERK_Z:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
-                Draw_Float(planner.max_jerk.z, row, false, JERK_UNIT);
+                drawMenuItem(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
+                drawFloat(planner.max_jerk.z, row, false, JERK_UNIT);
               }
               else
-                Modify_Value(planner.max_jerk.z, min_jerk_edit_values.z, max_jerk_edit_values.z, JERK_UNIT);
+                modifyValue(planner.max_jerk.z, min_jerk_edit_values.z, max_jerk_edit_values.z, JERK_UNIT);
               break;
           #endif
           #if HAS_HOTEND
             case JERK_E:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, F("Extruder"));
-                Draw_Float(planner.max_jerk.e, row, false, JERK_UNIT);
+                drawMenuItem(row, ICON_MaxSpeedJerkE, F("Extruder"));
+                drawFloat(planner.max_jerk.e, row, false, JERK_UNIT);
               }
               else
-                Modify_Value(planner.max_jerk.e, min_jerk_edit_values.e, max_jerk_edit_values.e, JERK_UNIT);
+                modifyValue(planner.max_jerk.e, min_jerk_edit_values.e, max_jerk_edit_values.e, JERK_UNIT);
               break;
           #endif
         }
         break;
     #endif
     case Steps:
 
       #define STEPS_BACK 0
       #define STEPS_X (STEPS_BACK + 1)
       #define STEPS_Y (STEPS_X + 1)
       #define STEPS_Z (STEPS_Y + 1)
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Motion, MOTION_STEPS);
+            drawMenu(Motion, MOTION_STEPS);
           break;
         #if HAS_X_AXIS
           case STEPS_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
-              Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
+              drawMenuItem(row, ICON_StepX, F("X Axis"));
+              drawFloat(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
             }
             else
-              Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
+              modifyValue(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
             break;
         #endif
         #if HAS_Y_AXIS
           case STEPS_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StepY, F("Y Axis"));
-              Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, STEPS_UNIT);
+              drawMenuItem(row, ICON_StepY, F("Y Axis"));
+              drawFloat(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, STEPS_UNIT);
             }
             else
-              Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], min_steps_edit_values.y, max_steps_edit_values.y, STEPS_UNIT);
+              modifyValue(planner.settings.axis_steps_per_mm[Y_AXIS], min_steps_edit_values.y, max_steps_edit_values.y, STEPS_UNIT);
             break;
         #endif
         #if HAS_Z_AXIS
           case STEPS_Z:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StepZ, F("Z Axis"));
-              Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, STEPS_UNIT);
+              drawMenuItem(row, ICON_StepZ, F("Z Axis"));
+              drawFloat(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, STEPS_UNIT);
             }
             else
-              Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], min_steps_edit_values.z, max_steps_edit_values.z, STEPS_UNIT);
+              modifyValue(planner.settings.axis_steps_per_mm[Z_AXIS], min_steps_edit_values.z, max_steps_edit_values.z, STEPS_UNIT);
             break;
         #endif
         #if HAS_HOTEND
           case STEPS_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StepE, F("Extruder"));
-              Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
+              drawMenuItem(row, ICON_StepE, F("Extruder"));
+              drawFloat(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
             }
             else
-              Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
+              modifyValue(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
             break;
         #endif
       }
       break;
 
     case Visual:
 
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
       #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
       #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
       #define VISUAL_TOTAL VISUAL_COLOR_THEMES
 
       switch (item) {
         case VISUAL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Control, CONTROL_VISUAL);
+            drawMenu(Control, CONTROL_VISUAL);
           break;
         case VISUAL_BACKLIGHT:
           if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
+            drawMenuItem(row, ICON_Brightness, F("Display Off"));
           else
             ui.set_brightness(0);
           break;
         case VISUAL_BRIGHTNESS:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
-            Draw_Float(ui.brightness, row, false, 1);
+            drawMenuItem(row, ICON_Brightness, F("LCD Brightness"));
+            drawFloat(ui.brightness, row, false, 1);
           }
           else
-            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
+            modifyValue(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
         case VISUAL_TIME_FORMAT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_PrintTime, F("Progress as __h__m"));
-            Draw_Checkbox(row, eeprom_settings.time_format_textual);
+            drawMenuItem(row, ICON_PrintTime, F("Progress as __h__m"));
+            drawCheckbox(row, eeprom_settings.time_format_textual);
           }
           else {
             eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
-            Draw_Checkbox(row, eeprom_settings.time_format_textual);
+            drawCheckbox(row, eeprom_settings.time_format_textual);
           }
           break;
         case VISUAL_COLOR_THEMES:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
           else
-            Draw_Menu(ColorSettings);
+            drawMenu(ColorSettings);
         break;
       }
       break;
 
     case ColorSettings:
 
       #define COLORSETTINGS_BACK 0
       #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
       #define COLORSETTINGS_SPLIT_LINE (COLORSETTINGS_CURSOR + 1)
       #define COLORSETTINGS_MENU_TOP_TXT (COLORSETTINGS_SPLIT_LINE + 1)
@@ -2633,111 +2629,111 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
       #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
 
       switch (item) {
         case COLORSETTINGS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Visual, VISUAL_COLOR_THEMES);
+            drawMenu(Visual, VISUAL_COLOR_THEMES);
           break;
         case COLORSETTINGS_CURSOR:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Cursor"));
-            Draw_Option(eeprom_settings.cursor_color, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Cursor"));
+            drawOption(eeprom_settings.cursor_color, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.cursor_color, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.cursor_color, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_SPLIT_LINE:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Split Line"));
-            Draw_Option(eeprom_settings.menu_split_line, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Menu Split Line"));
+            drawOption(eeprom_settings.menu_split_line, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.menu_split_line, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.menu_split_line, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_MENU_TOP_TXT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Text"));
-            Draw_Option(eeprom_settings.menu_top_txt, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Menu Header Text"));
+            drawOption(eeprom_settings.menu_top_txt, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.menu_top_txt, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.menu_top_txt, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_MENU_TOP_BG:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Bg"));
-            Draw_Option(eeprom_settings.menu_top_bg, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Menu Header Bg"));
+            drawOption(eeprom_settings.menu_top_bg, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.menu_top_bg, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.menu_top_bg, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_HIGHLIGHT_BORDER:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Highlight Box"));
-            Draw_Option(eeprom_settings.highlight_box, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Highlight Box"));
+            drawOption(eeprom_settings.highlight_box, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.highlight_box, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.highlight_box, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_PERCENT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Percent"));
-            Draw_Option(eeprom_settings.progress_percent, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Progress Percent"));
+            drawOption(eeprom_settings.progress_percent, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.progress_percent, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.progress_percent, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_TIME:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Time"));
-            Draw_Option(eeprom_settings.progress_time, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Progress Time"));
+            drawOption(eeprom_settings.progress_time, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.progress_time, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.progress_time, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_STATUS_BAR:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Bar Text"));
-            Draw_Option(eeprom_settings.status_bar_text, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Status Bar Text"));
+            drawOption(eeprom_settings.status_bar_text, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.status_bar_text, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.status_bar_text, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_STATUS_AREA:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Area Text"));
-            Draw_Option(eeprom_settings.status_area_text, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Status Area Text"));
+            drawOption(eeprom_settings.status_area_text, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.status_area_text, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.status_area_text, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_COORDINATES:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Text"));
-            Draw_Option(eeprom_settings.coordinates_text, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Coordinates Text"));
+            drawOption(eeprom_settings.coordinates_text, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.coordinates_text, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.coordinates_text, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_COORDINATES_LINE:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Line"));
-            Draw_Option(eeprom_settings.coordinates_split_line, color_names, row, false, true);
+            drawMenuItem(row, ICON_MaxSpeed, F("Coordinates Line"));
+            drawOption(eeprom_settings.coordinates_split_line, color_names, row, false, true);
           }
           else
-            Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
+            modifyOption(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
           break;
       } // switch (item)
       break;
 
     case Advanced:
 
       #define ADVANCED_BACK 0
       #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
       #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
       #define ADVANCED_TMC (ADVANCED_PROBE + ENABLED(HAS_TRINAMIC_CONFIG))
@@ -2747,141 +2743,141 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
       #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
 
       switch (item) {
         case ADVANCED_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Menu(Control, CONTROL_ADVANCED);
+            drawMenu(Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("LCD Beeper"));
-              Draw_Checkbox(row, ui.sound_on);
+              drawMenuItem(row, ICON_Version, F("LCD Beeper"));
+              drawCheckbox(row, ui.sound_on);
             }
             else {
               ui.sound_on = !ui.sound_on;
-              Draw_Checkbox(row, ui.sound_on);
+              drawCheckbox(row, ui.sound_on);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
-              Draw_Menu_Item(row, ICON_StepX, F("Probe"), nullptr, true);
+              drawMenuItem(row, ICON_StepX, F("Probe"), nullptr, true);
             else
-              Draw_Menu(ProbeMenu);
+              drawMenu(ProbeMenu);
             break;
         #endif
 
         #if HAS_TRINAMIC_CONFIG
           case ADVANCED_TMC:
             if (draw)
-              Draw_Menu_Item(row, ICON_Motion, F("TMC Drivers"), nullptr, true);
+              drawMenuItem(row, ICON_Motion, F("TMC Drivers"), nullptr, true);
             else
-              Draw_Menu(TMCMenu);
+              drawMenu(TMCMenu);
             break;
         #endif
 
         case ADVANCED_CORNER:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
-            Draw_Float(corner_pos, row, false, 10);
+            drawMenuItem(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
+            drawFloat(corner_pos, row, false, 10);
           }
           else
-            Modify_Value(corner_pos, 1, 100, 10);
+            modifyValue(corner_pos, 1, 100, 10);
           break;
 
         #if ENABLED(LIN_ADVANCE)
           case ADVANCED_LA:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccelerated, F("Lin Advance K"));
-              Draw_Float(planner.extruder_advance_K[0], row, false, 100);
+              drawMenuItem(row, ICON_MaxAccelerated, F("Lin Advance K"));
+              drawFloat(planner.extruder_advance_K[0], row, false, 100);
             }
             else
-              Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
+              modifyValue(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case ADVANCED_LOAD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Length"));
-              Draw_Float(fc_settings[0].load_length, row, false, 1);
+              drawMenuItem(row, ICON_WriteEEPROM, F("Load Length"));
+              drawFloat(fc_settings[0].load_length, row, false, 1);
             }
             else
-              Modify_Value(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
+              modifyValue(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
           case ADVANCED_UNLOAD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Length"));
-              Draw_Float(fc_settings[0].unload_length, row, false, 1);
+              drawMenuItem(row, ICON_ReadEEPROM, F("Unload Length"));
+              drawFloat(fc_settings[0].unload_length, row, false, 1);
             }
             else
-              Modify_Value(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
+              modifyValue(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
         #endif // ADVANCED_PAUSE_FEATURE
 
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           case ADVANCED_COLD_EXTRUDE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Cool, F("Min Extrusion T"));
-              Draw_Float(thermalManager.extrude_min_temp, row, false, 1);
+              drawMenuItem(row, ICON_Cool, F("Min Extrusion T"));
+              drawFloat(thermalManager.extrude_min_temp, row, false, 1);
             }
             else {
-              Modify_Value(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
+              modifyValue(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
               thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case ADVANCED_FILSENSORENABLED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
-              Draw_Checkbox(row, runout.enabled);
+              drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
+              drawCheckbox(row, runout.enabled);
             }
             else {
               runout.enabled = !runout.enabled;
-              Draw_Checkbox(row, runout.enabled);
+              drawCheckbox(row, runout.enabled);
             }
             break;
 
           #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
             case ADVANCED_FILSENSORDISTANCE:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxAccE, F("Runout Distance"));
-                Draw_Float(runout.runout_distance(), row, false, 10);
+                drawMenuItem(row, ICON_MaxAccE, F("Runout Distance"));
+                drawFloat(runout.runout_distance(), row, false, 10);
               }
               else
-                Modify_Value(runout.runout_distance(), 0, 999, 10);
+                modifyValue(runout.runout_distance(), 0, 999, 10);
               break;
           #endif
         #endif // FILAMENT_RUNOUT_SENSOR
 
         #if ENABLED(POWER_LOSS_RECOVERY)
           case ADVANCED_POWER_LOSS:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Motion, F("Power-loss recovery"));
-              Draw_Checkbox(row, recovery.enabled);
+              drawMenuItem(row, ICON_Motion, F("Power-loss recovery"));
+              drawCheckbox(row, recovery.enabled);
             }
             else {
               recovery.enable(!recovery.enabled);
-              Draw_Checkbox(row, recovery.enabled);
+              drawCheckbox(row, recovery.enabled);
             }
             break;
         #endif
       }
       break;
 
     #if HAS_BED_PROBE
       case ProbeMenu:
 
         #define PROBE_BACK 0
@@ -2889,140 +2885,140 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
         #define PROBE_TEST (PROBE_YOFFSET + 1)
         #define PROBE_TEST_COUNT (PROBE_TEST + 1)
         #define PROBE_TOTAL PROBE_TEST_COUNT
 
         static uint8_t testcount = 4;
 
         switch (item) {
           case PROBE_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Advanced, ADVANCED_PROBE);
+              drawMenu(Advanced, ADVANCED_PROBE);
             break;
 
             case PROBE_XOFFSET:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepX, F("Probe X Offset"));
-                Draw_Float(probe.offset.x, row, false, 10);
+                drawMenuItem(row, ICON_StepX, F("Probe X Offset"));
+                drawFloat(probe.offset.x, row, false, 10);
               }
               else
-                Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+                modifyValue(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_YOFFSET:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, F("Probe Y Offset"));
-                Draw_Float(probe.offset.y, row, false, 10);
+                drawMenuItem(row, ICON_StepY, F("Probe Y Offset"));
+                drawFloat(probe.offset.y, row, false, 10);
               }
               else
-                Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+                modifyValue(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_TEST:
               if (draw)
-                Draw_Menu_Item(row, ICON_StepY, F("M48 Probe Test"));
+                drawMenuItem(row, ICON_StepY, F("M48 Probe Test"));
               else {
                 sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
                 gcode.process_subcommands_now(cmd);
               }
               break;
             case PROBE_TEST_COUNT:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, F("Probe Test Count"));
-                Draw_Float(testcount, row, false, 1);
+                drawMenuItem(row, ICON_StepY, F("Probe Test Count"));
+                drawFloat(testcount, row, false, 1);
               }
               else
-                Modify_Value(testcount, 4, 50, 1);
+                modifyValue(testcount, 4, 50, 1);
               break;
         }
         break;
     #endif  // HAS_PROBE_MENU
 
     #if HAS_TRINAMIC_CONFIG
       case TMCMenu:
 
         #define TMC_BACK 0
         #define TMC_STEPPER_CURRENT_X (TMC_BACK + AXIS_IS_TMC(X))
         #define TMC_STEPPER_CURRENT_Y (TMC_STEPPER_CURRENT_X + AXIS_IS_TMC(Y))
         #define TMC_STEPPER_CURRENT_Z (TMC_STEPPER_CURRENT_Y + AXIS_IS_TMC(Z))
         #define TMC_STEPPER_CURRENT_E (TMC_STEPPER_CURRENT_Z + AXIS_IS_TMC(E0))
         #define TMC_TOTAL TMC_STEPPER_CURRENT_E
 
         switch (item) {
 
           case TMC_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Advanced, ADVANCED_TMC);
+              drawMenu(Advanced, ADVANCED_TMC);
             break;
 
           #if AXIS_IS_TMC(X)
             case TMC_STEPPER_CURRENT_X:
 
               static float stepper_current_x;
 
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepX, F("Stepper X current"));
+                drawMenuItem(row, ICON_StepX, F("Stepper X current"));
                 stepper_current_x = stepperX.getMilliamps();
-                Draw_Float(stepper_current_x, row, false, 1);
+                drawFloat(stepper_current_x, row, false, 1);
               }
               else {
-                Modify_Value(stepper_current_x, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperX.rms_current(stepper_current_x); });
+                modifyValue(stepper_current_x, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperX.rms_current(stepper_current_x); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(Y)
             case TMC_STEPPER_CURRENT_Y:
 
               static float stepper_current_y;
 
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, F("Stepper Y current"));
+                drawMenuItem(row, ICON_StepY, F("Stepper Y current"));
                 stepper_current_y = stepperY.getMilliamps();
-                Draw_Float(stepper_current_y, row, false, 1);
+                drawFloat(stepper_current_y, row, false, 1);
               }
               else {
-                Modify_Value(stepper_current_y, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperY.rms_current(stepper_current_y); });
+                modifyValue(stepper_current_y, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperY.rms_current(stepper_current_y); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(Z)
             case TMC_STEPPER_CURRENT_Z:
 
               static float stepper_current_z;
 
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepZ, F("Stepper Z current"));
+                drawMenuItem(row, ICON_StepZ, F("Stepper Z current"));
                 stepper_current_z = stepperZ.getMilliamps();
-                Draw_Float(stepper_current_z, row, false, 1);
+                drawFloat(stepper_current_z, row, false, 1);
               }
               else {
-                Modify_Value(stepper_current_z, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperZ.rms_current(stepper_current_z); });
+                modifyValue(stepper_current_z, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperZ.rms_current(stepper_current_z); });
               }
               break;
           #endif
 
           #if AXIS_IS_TMC(E0)
             case TMC_STEPPER_CURRENT_E:
 
               static float stepper_current_e;
 
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepE, F("Stepper E current"));
+                drawMenuItem(row, ICON_StepE, F("Stepper E current"));
                 stepper_current_e = stepperE0.getMilliamps();
-                Draw_Float(stepper_current_e, row, false, 1);
+                drawFloat(stepper_current_e, row, false, 1);
               }
               else {
-                Modify_Value(stepper_current_e, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperE0.rms_current(stepper_current_e); });
+                modifyValue(stepper_current_e, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperE0.rms_current(stepper_current_e); });
               }
               break;
           #endif
         };
         break;
     #endif // HAS_TRINAMIC_CONFIG
 
     case InfoMain:
     case Info:
 
@@ -3030,46 +3026,46 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
       #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
       #define INFO_SIZE (INFO_PRINTTIME + 1)
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
       #define INFO_TOTAL INFO_BACK
 
       switch (item) {
         case INFO_BACK:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
 
             #if ENABLED(PRINTCOUNTER)
               char row1[50], row2[50], buf[32];
               printStatistics ps = print_job_timer.getStats();
 
               sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
               sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
-              Draw_Menu_Item(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
+              drawMenuItem(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
 
               duration_t(print_job_timer.getStats().printTime).toString(buf);
               sprintf_P(row1, PSTR("Printed: %s"), buf);
               duration_t(print_job_timer.getStats().longestPrint).toString(buf);
               sprintf_P(row2, PSTR("Longest: %s"), buf);
-              Draw_Menu_Item(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
+              drawMenuItem(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
             #endif
 
-            Draw_Menu_Item(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
-            Draw_Menu_Item(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
-            Draw_Menu_Item(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
+            drawMenuItem(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
+            drawMenuItem(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
+            drawMenuItem(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
           }
           else {
             if (menu == Info)
-              Draw_Menu(Control, CONTROL_INFO);
+              drawMenu(Control, CONTROL_INFO);
             else
-              Draw_Main_Menu(3);
+              drawMainMenu(3);
           }
           break;
       }
       break;
 
     #if HAS_MESH
       case Leveling:
 
         #define LEVELING_BACK 0
         #define LEVELING_ACTIVE (LEVELING_BACK + 1)
@@ -3079,440 +3075,440 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define LEVELING_VIEW (LEVELING_MANUAL + 1)
         #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
         #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_TOTAL LEVELING_SAVE
 
         switch (item) {
           case LEVELING_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Main_Menu(3);
+              drawMainMenu(3);
             break;
           case LEVELING_ACTIVE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, F("Leveling Active"));
-              Draw_Checkbox(row, planner.leveling_active);
+              drawMenuItem(row, ICON_StockConfiguration, F("Leveling Active"));
+              drawCheckbox(row, planner.leveling_active);
             }
             else {
               if (!planner.leveling_active) {
                 set_bed_leveling_enabled(!planner.leveling_active);
                 if (!planner.leveling_active) {
-                  Confirm_Handler(LevelError);
+                  confirmHandler(LevelError);
                   break;
                 }
               }
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
-              Draw_Checkbox(row, planner.leveling_active);
+              drawCheckbox(row, planner.leveling_active);
             }
             break;
           #if ALL(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
-                Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
+                drawMenuItem(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
                 if (bedlevel.storage_slot < 0) {
-                  Popup_Handler(MeshSlot);
+                  popupHandler(MeshSlot);
                   break;
                 }
-                Popup_Handler(Home);
+                popupHandler(Home);
                 gcode.home_all_axes(true);
-                Popup_Handler(Level);
+                popupHandler(Level);
                 if (mesh_conf.tilt_grid > 1) {
                   sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
                   gcode.process_subcommands_now(cmd);
                 }
                 else
                   gcode.process_subcommands_now(F("G29 J"));
                 planner.synchronize();
-                Redraw_Menu();
+                redrawMenu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, F("Create New Mesh"));
+              drawMenuItem(row, ICON_Mesh, F("Create New Mesh"));
             else {
-              Popup_Handler(Home);
+              popupHandler(Home);
               gcode.home_all_axes(true);
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 #if ENABLED(PREHEAT_BEFORE_LEVELING)
-                  Popup_Handler(Heating);
+                  popupHandler(Heating);
                   probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
                 #endif
                 #if HAS_BED_PROBE
-                  Popup_Handler(Level);
+                  popupHandler(Level);
                   gcode.process_subcommands_now(F("G29 P0\nG29 P1"));
                   gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
                   planner.synchronize();
-                  Update_Status("Probed all reachable points");
-                  Popup_Handler(SaveLevel);
+                  updateStatus("Probed all reachable points");
+                  popupHandler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
-                  Popup_Handler(MoveWait);
+                  popupHandler(MoveWait);
                   mesh_conf.manual_mesh_move();
-                  Draw_Menu(UBLMesh);
+                  drawMenu(UBLMesh);
                 #endif
               #elif HAS_BED_PROBE
-                Popup_Handler(Level);
+                popupHandler(Level);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
-                Popup_Handler(SaveLevel);
+                popupHandler(SaveLevel);
               #else
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
                 gridpoint = 1;
-                Popup_Handler(MoveWait);
+                popupHandler(MoveWait);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
-                Draw_Menu(ManualMesh);
+                drawMenu(ManualMesh);
               #endif
             }
             break;
           case LEVELING_MANUAL:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
+              drawMenuItem(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
                 if (!leveling_is_valid()) {
-                  Confirm_Handler(InvalidMesh);
+                  confirmHandler(InvalidMesh);
                   break;
                 }
               #endif
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (bedlevel.storage_slot < 0) {
-                  Popup_Handler(MeshSlot);
+                  popupHandler(MeshSlot);
                   break;
                 }
               #endif
               if (axes_should_home()) {
-                Popup_Handler(Home);
+                popupHandler(Home);
                 gcode.home_all_axes(true);
               }
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
               mesh_conf.goto_mesh_value = false;
               #if ENABLED(PREHEAT_BEFORE_LEVELING)
-                Popup_Handler(Heating);
+                popupHandler(Heating);
                 #if HAS_HOTEND
                   if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
                     thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
                 #endif
                 #if HAS_HEATED_BED
                   if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
                     thermalManager.setTargetBed(LEVELING_BED_TEMP);
                 #endif
                 TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
                 TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
               #endif
-              Popup_Handler(MoveWait);
+              popupHandler(MoveWait);
               mesh_conf.manual_mesh_move();
-              Draw_Menu(LevelManual);
+              drawMenu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
+              drawMenuItem(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (bedlevel.storage_slot < 0) {
-                  Popup_Handler(MeshSlot);
+                  popupHandler(MeshSlot);
                   break;
                 }
               #endif
-              Draw_Menu(LevelView);
+              drawMenu(LevelView);
             }
             break;
           case LEVELING_SETTINGS:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, F("Leveling Settings"), nullptr, true);
+              drawMenuItem(row, ICON_Step, F("Leveling Settings"), nullptr, true);
             else
-              Draw_Menu(LevelSettings);
+              drawMenu(LevelSettings);
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_SLOT:
             if (draw) {
-              Draw_Menu_Item(row, ICON_PrintSize, F("Mesh Slot"));
-              Draw_Float(bedlevel.storage_slot, row, false, 1);
+              drawMenuItem(row, ICON_PrintSize, F("Mesh Slot"));
+              drawFloat(bedlevel.storage_slot, row, false, 1);
             }
             else
-              Modify_Value(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
+              modifyValue(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
             break;
           case LEVELING_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Load Mesh"));
+              drawMenuItem(row, ICON_ReadEEPROM, F("Load Mesh"));
             else {
               if (bedlevel.storage_slot < 0) {
-                Popup_Handler(MeshSlot);
+                popupHandler(MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 L"));
               planner.synchronize();
-              AudioFeedback(true);
+              audioFeedback(true);
             }
             break;
           case LEVELING_SAVE:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save Mesh"));
+              drawMenuItem(row, ICON_WriteEEPROM, F("Save Mesh"));
             else {
               if (bedlevel.storage_slot < 0) {
-                Popup_Handler(MeshSlot);
+                popupHandler(MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
-              AudioFeedback(true);
+              audioFeedback(true);
             }
             break;
           #endif
         }
         break;
 
       case LevelView:
 
         #define LEVELING_VIEW_BACK 0
         #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
         #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
         #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
         #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Leveling, LEVELING_VIEW);
+              drawMenu(Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
+              drawMenuItem(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
-              Draw_Menu(MeshViewer);
+              drawMenu(MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Contact, F("Viewer Show Values"));
-              Draw_Checkbox(row, mesh_conf.viewer_print_value);
+              drawMenuItem(row, ICON_Contact, F("Viewer Show Values"));
+              drawCheckbox(row, mesh_conf.viewer_print_value);
             }
             else {
               mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
-              Draw_Checkbox(row, mesh_conf.viewer_print_value);
+              drawCheckbox(row, mesh_conf.viewer_print_value);
             }
             break;
           case LEVELING_VIEW_ASYMMETRIC:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Axis, F("Viewer Asymmetric"));
-              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
+              drawMenuItem(row, ICON_Axis, F("Viewer Asymmetric"));
+              drawCheckbox(row, mesh_conf.viewer_asymmetric_range);
             }
             else {
               mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
-              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
+              drawCheckbox(row, mesh_conf.viewer_asymmetric_range);
             }
             break;
         }
         break;
 
       case LevelSettings:
 
         #define LEVELING_SETTINGS_BACK 0
         #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
         #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
 
         switch (item) {
           case LEVELING_SETTINGS_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else
-              Draw_Menu(Leveling, LEVELING_SETTINGS);
+              drawMenu(Leveling, LEVELING_SETTINGS);
             break;
           case LEVELING_SETTINGS_FADE:
               if (draw) {
-                Draw_Menu_Item(row, ICON_Fade, F("Fade Mesh within"));
-                Draw_Float(planner.z_fade_height, row, false, 1);
+                drawMenuItem(row, ICON_Fade, F("Fade Mesh within"));
+                drawFloat(planner.z_fade_height, row, false, 1);
               }
               else {
-                Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
+                modifyValue(planner.z_fade_height, 0, Z_MAX_POS, 1);
                 planner.z_fade_height = -1;
                 set_z_fade_height(planner.z_fade_height);
               }
               break;
 
           #if ENABLED(AUTO_BED_LEVELING_UBL)
             case LEVELING_SETTINGS_TILT:
               if (draw) {
-                Draw_Menu_Item(row, ICON_Tilt, F("Tilting Grid Size"));
-                Draw_Float(mesh_conf.tilt_grid, row, false, 1);
+                drawMenuItem(row, ICON_Tilt, F("Tilting Grid Size"));
+                drawFloat(mesh_conf.tilt_grid, row, false, 1);
               }
               else
-                Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
+                modifyValue(mesh_conf.tilt_grid, 1, 8, 1);
               break;
             case LEVELING_SETTINGS_PLANE:
               if (draw)
-                Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
+                drawMenuItem(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
               else {
                 if (mesh_conf.create_plane_from_mesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
-                AudioFeedback(true);
+                audioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
-                Draw_Menu_Item(row, ICON_Mesh, F("Zero Current Mesh"));
+                drawMenuItem(row, ICON_Mesh, F("Zero Current Mesh"));
               else
                 ZERO(bedlevel.z_values);
               break;
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
-                Draw_Menu_Item(row, ICON_Mesh, F("Clear Current Mesh"));
+                drawMenuItem(row, ICON_Mesh, F("Clear Current Mesh"));
               else
                 bedlevel.invalidate();
               break;
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
       case MeshViewer:
         #define MESHVIEW_BACK 0
         #define MESHVIEW_TOTAL MESHVIEW_BACK
 
         if (item == MESHVIEW_BACK) {
           if (draw) {
-            Draw_Menu_Item(0, ICON_Back, F("Back"));
-            mesh_conf.Draw_Bed_Mesh();
-            mesh_conf.Set_Mesh_Viewer_Status();
+            drawMenuItem(0, ICON_Back, F("Back"));
+            mesh_conf.drawBedMesh();
+            mesh_conf.setMeshViewerStatus();
           }
           else if (!mesh_conf.drawing_mesh) {
-            Draw_Menu(LevelView, LEVELING_VIEW_MESH);
-            Update_Status("");
+            drawMenu(LevelView, LEVELING_VIEW_MESH);
+            updateStatus("");
           }
         }
         break;
 
       case LevelManual:
 
         #define LEVELING_M_BACK 0
         #define LEVELING_M_X (LEVELING_M_BACK + 1)
         #define LEVELING_M_Y (LEVELING_M_X + 1)
         #define LEVELING_M_NEXT (LEVELING_M_Y + 1)
         #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
         #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
         #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
               TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
-              Draw_Menu(Leveling, LEVELING_MANUAL);
+              drawMenu(Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MoveX, F("Mesh Point X"));
-              Draw_Float(mesh_conf.mesh_x, row, 0, 1);
+              drawMenuItem(row, ICON_MoveX, F("Mesh Point X"));
+              drawFloat(mesh_conf.mesh_x, row, 0, 1);
             }
             else
-              Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
+              modifyValue(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
             break;
           case LEVELING_M_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MoveY, F("Mesh Point Y"));
-              Draw_Float(mesh_conf.mesh_y, row, 0, 1);
+              drawMenuItem(row, ICON_MoveY, F("Mesh Point Y"));
+              drawFloat(mesh_conf.mesh_y, row, 0, 1);
             }
             else
-              Modify_Value(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
+              modifyValue(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
             break;
           case LEVELING_M_NEXT:
             if (draw)
-              Draw_Menu_Item(row, ICON_More, F("Next Point"));
+              drawMenuItem(row, ICON_More, F("Next Point"));
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_mesh_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+              drawMenuItem(row, ICON_SetZOffset, F("Point Z Offset"));
+              drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              modifyValue(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case LEVELING_M_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+              drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case LEVELING_M_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
+              drawMenuItem(row, ICON_AxisD, F("Microstep Down"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+              drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
-              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
+              drawMenuItem(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
+              drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             else {
               mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
               current_position.z = 0;
               mesh_conf.manual_mesh_move(true);
-              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
+              drawCheckbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_M_UNDEF:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Clear Point Value"));
+              drawMenuItem(row, ICON_ResumeEEPROM, F("Clear Point Value"));
             else {
               mesh_conf.manual_value_update(true);
-              Redraw_Menu(false);
+              redrawMenu(false);
             }
             break;
           #endif
         }
         break;
     #endif // HAS_MESH
 
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case UBLMesh:
 
@@ -3520,200 +3516,200 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define UBL_M_NEXT (UBL_M_BACK + 1)
         #define UBL_M_PREV (UBL_M_NEXT + 1)
         #define UBL_M_OFFSET (UBL_M_PREV + 1)
         #define UBL_M_UP (UBL_M_OFFSET + 1)
         #define UBL_M_DOWN (UBL_M_UP + 1)
         #define UBL_M_TOTAL UBL_M_DOWN
 
         switch (item) {
           case UBL_M_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              drawMenuItem(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
-              Draw_Menu(Leveling, LEVELING_GET_MESH);
+              drawMenu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case UBL_M_NEXT:
             if (draw) {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
-                Draw_Menu_Item(row, ICON_More, F("Next Point"));
+                drawMenuItem(row, ICON_More, F("Next Point"));
               else
-                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
+                drawMenuItem(row, ICON_More, F("Save Mesh"));
             }
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_mesh_move();
               }
               else {
                 gcode.process_subcommands_now(F("G29 S"));
                 planner.synchronize();
-                AudioFeedback(true);
-                Draw_Menu(Leveling, LEVELING_GET_MESH);
+                audioFeedback(true);
+                drawMenu(Leveling, LEVELING_GET_MESH);
               }
             }
             break;
           case UBL_M_PREV:
             if (draw)
-              Draw_Menu_Item(row, ICON_More, F("Previous Point"));
+              drawMenuItem(row, ICON_More, F("Previous Point"));
             else {
               if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
                   mesh_conf.mesh_y--;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x--;
                 else
                   mesh_conf.mesh_x++;
                 mesh_conf.manual_mesh_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+              drawMenuItem(row, ICON_SetZOffset, F("Point Z Offset"));
+              drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              modifyValue(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case UBL_M_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+              drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case UBL_M_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Down"));
+              drawMenuItem(row, ICON_Axis, F("Microstep Down"));
             else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+              drawFloat(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
         break;
     #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
 
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:
 
         #define MMESH_BACK 0
         #define MMESH_NEXT (MMESH_BACK + 1)
         #define MMESH_OFFSET (MMESH_NEXT + 1)
         #define MMESH_UP (MMESH_OFFSET + 1)
         #define MMESH_DOWN (MMESH_UP + 1)
         #define MMESH_OLD (MMESH_DOWN + 1)
         #define MMESH_TOTAL MMESH_OLD
 
         switch (item) {
           case MMESH_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
+              drawMenuItem(row, ICON_Back, F("Cancel"));
             else {
               gcode.process_subcommands_now(F("G29 A"));
               planner.synchronize();
               set_bed_leveling_enabled(level_state);
-              Draw_Menu(Leveling, LEVELING_GET_MESH);
+              drawMenu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_NEXT:
             if (draw) {
               if (gridpoint < GRID_MAX_POINTS)
-                Draw_Menu_Item(row, ICON_More, F("Next Point"));
+                drawMenuItem(row, ICON_More, F("Next Point"));
               else
-                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
+                drawMenuItem(row, ICON_More, F("Save Mesh"));
             }
             else if (gridpoint < GRID_MAX_POINTS) {
-              Popup_Handler(MoveWait);
+              popupHandler(MoveWait);
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               gridpoint++;
-              Redraw_Menu();
+              redrawMenu();
             }
             else {
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
-              AudioFeedback(settings.save());
-              Draw_Menu(Leveling, LEVELING_GET_MESH);
+              audioFeedback(settings.save());
+              drawMenu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
+              drawMenuItem(row, ICON_SetZOffset, F("Z Position"));
               current_position.z = MANUAL_PROBE_START_Z;
-              Draw_Float(current_position.z, row, false, 100);
+              drawFloat(current_position.z, row, false, 100);
             }
             else
-              Modify_Value(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              modifyValue(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case MMESH_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+              drawMenuItem(row, ICON_Axis, F("Microstep Up"));
             else if (current_position.z < MAX_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(current_position.z, row - 1, false, 100);
+              drawFloat(current_position.z, row - 1, false, 100);
             }
             break;
           case MMESH_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
+              drawMenuItem(row, ICON_AxisD, F("Microstep Down"));
             else if (current_position.z > MIN_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(current_position.z, row - 2, false, 100);
+              drawFloat(current_position.z, row - 2, false, 100);
             }
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
             // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
             mesh_y = (gridpoint - 1) / (GRID_MAX_POINTS_Y);
             mesh_x = (gridpoint - 1) % (GRID_MAX_POINTS_X);
 
             if (mesh_y % 2 == 1)
               mesh_x = (GRID_MAX_POINTS_X) - mesh_x - 1;
 
             const float currval = bedlevel.z_values[mesh_x][mesh_y];
 
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, F("Goto Mesh Value"));
-              Draw_Float(currval, row, false, 100);
+              drawMenuItem(row, ICON_Zoffset, F("Goto Mesh Value"));
+              drawFloat(currval, row, false, 100);
             }
             else if (!isnan(currval)) {
               current_position.z = currval;
               planner.synchronize();
               planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
               planner.synchronize();
-              Draw_Float(current_position.z, row - 3, false, 100);
+              drawFloat(current_position.z, row - 3, false, 100);
             }
             break;
         }
         break;
     #endif // PROBE_MANUALLY
 
     case Tune:
 
       #define TUNE_BACK 0
       #define TUNE_SPEED (TUNE_BACK + 1)
@@ -3726,138 +3722,138 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_CHANGEFIL (TUNE_ZDOWN + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
       #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
       #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
       #define TUNE_TOTAL TUNE_BACKLIGHT
 
       switch (item) {
         case TUNE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            drawMenuItem(row, ICON_Back, F("Back"));
           else
-            Draw_Print_Screen();
+            drawPrintScreen();
           break;
         case TUNE_SPEED:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Speed, F("Print Speed"));
-            Draw_Float(feedrate_percentage, row, false, 1);
+            drawMenuItem(row, ICON_Speed, F("Print Speed"));
+            drawFloat(feedrate_percentage, row, false, 1);
           }
           else
-            Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
+            modifyValue(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
           break;
 
         #if HAS_HOTEND
           case TUNE_FLOW:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
-              Draw_Float(planner.flow_percentage[0], row, false, 1);
+              drawMenuItem(row, ICON_Speed, F("Flow Rate"));
+              drawFloat(planner.flow_percentage[0], row, false, 1);
             }
             else
-              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
+              modifyValue(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
           case TUNE_HOTEND:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+              drawMenuItem(row, ICON_SetEndTemp, F("Hotend"));
+              drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
-              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
+              modifyValue(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
 
         #if HAS_HEATED_BED
           case TUNE_BED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
+              drawMenuItem(row, ICON_SetBedTemp, F("Bed"));
+              drawFloat(thermalManager.temp_bed.target, row, false, 1);
             }
             else
-              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              modifyValue(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
 
         #if HAS_FAN
           case TUNE_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
+              drawMenuItem(row, ICON_FanSpeed, F("Fan"));
+              drawFloat(thermalManager.fan_speed[0], row, false, 1);
             }
             else
-              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              modifyValue(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
 
         #if HAS_ZOFFSET_ITEM
           case TUNE_ZOFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Z-Offset"));
-              Draw_Float(zoffsetvalue, row, false, 100);
+              drawMenuItem(row, ICON_FanSpeed, F("Z-Offset"));
+              drawFloat(zoffsetvalue, row, false, 100);
             }
             else
-              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              modifyValue(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case TUNE_ZUP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Z-Offset Up"));
+              drawMenuItem(row, ICON_Axis, F("Z-Offset Up"));
             else if (zoffsetvalue < MAX_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z0.01"));
               zoffsetvalue += 0.01;
-              Draw_Float(zoffsetvalue, row - 1, false, 100);
+              drawFloat(zoffsetvalue, row - 1, false, 100);
             }
             break;
           case TUNE_ZDOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Z-Offset Down"));
+              drawMenuItem(row, ICON_AxisD, F("Z-Offset Down"));
             else if (zoffsetvalue > MIN_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               zoffsetvalue -= 0.01;
-              Draw_Float(zoffsetvalue, row - 2, false, 100);
+              drawFloat(zoffsetvalue, row - 2, false, 100);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
+              drawMenuItem(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else
-              Popup_Handler(ConfFilChange);
+              popupHandler(ConfFilChange);
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
-              Draw_Checkbox(row, runout.enabled);
+              drawMenuItem(row, ICON_Extruder, F("Filament Sensor"));
+              drawCheckbox(row, runout.enabled);
             }
             else {
               runout.enabled = !runout.enabled;
-              Draw_Checkbox(row, runout.enabled);
+              drawCheckbox(row, runout.enabled);
             }
             break;
         #endif
 
         case TUNE_BACKLIGHT_OFF:
           if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
+            drawMenuItem(row, ICON_Brightness, F("Display Off"));
           else
             ui.set_brightness(0);
           break;
         case TUNE_BACKLIGHT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
-            Draw_Float(ui.brightness, row, false, 1);
+            drawMenuItem(row, ICON_Brightness, F("LCD Brightness"));
+            drawFloat(ui.brightness, row, false, 1);
           }
           else
-            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
+            modifyValue(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
       }
       break;
 
     #if HAS_PREHEAT && HAS_HOTEND
 
       case PreheatHotend:
 
         #define PREHEATHOTEND_BACK 0
         #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
@@ -3865,94 +3861,94 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
         #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
         #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
         #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
         #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
         #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
 
         switch (item) {
           case PREHEATHOTEND_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
+              drawMenuItem(row, ICON_Back, F("Cancel"));
             else {
               thermalManager.setTargetHotend(0, 0);
               TERN_(HAS_FAN, thermalManager.set_fan_speed(0, 0));
-              Redraw_Menu(false, true, true);
+              redrawMenu(false, true, true);
             }
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Continue"));
+              drawMenuItem(row, ICON_SetEndTemp, F("Continue"));
             else {
-              Popup_Handler(Heating);
+              popupHandler(Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
                 case Prepare:
-                  Popup_Handler(FilChange);
+                  popupHandler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                   gcode.process_subcommands_now(cmd);
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   case ChangeFilament:
                     switch (last_selection) {
                       case CHANGEFIL_LOAD:
-                        Popup_Handler(FilLoad);
+                        popupHandler(FilLoad);
                         gcode.process_subcommands_now(F("M701"));
                         planner.synchronize();
-                        Redraw_Menu(true, true, true);
+                        redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_UNLOAD:
-                        Popup_Handler(FilLoad, true);
+                        popupHandler(FilLoad, true);
                         gcode.process_subcommands_now(F("M702"));
                         planner.synchronize();
-                        Redraw_Menu(true, true, true);
+                        redrawMenu(true, true, true);
                         break;
                       case CHANGEFIL_CHANGE:
-                        Popup_Handler(FilChange);
+                        popupHandler(FilChange);
                         sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                         gcode.process_subcommands_now(cmd);
                         break;
                     }
                     break;
                 #endif
                 default:
-                  Redraw_Menu(true, true, true);
+                  redrawMenu(true, true, true);
                   break;
               }
             }
             break;
 
 
           #define _PREHEAT_HOTEND_CASE(N) \
             case PREHEATHOTEND_##N: \
-              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+              if (draw) drawMenuItem(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
               else ui.preheat_hotend_and_fan((N) - 1); \
               break;
 
           REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
 
           case PREHEATHOTEND_CUSTOM:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, F("Custom"));
-              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+              drawMenuItem(row, ICON_Temperature, F("Custom"));
+              drawFloat(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
-              Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
+              modifyValue(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
 
-FSTR_P CrealityDWINClass::Get_Menu_Title(const uint8_t menu) {
+FSTR_P CrealityDWIN::getMenuTitle(const uint8_t menu) {
   switch (menu) {
     case MainMenu:          return GET_TEXT_F(MSG_MAIN_MENU);
     case Prepare:           return GET_TEXT_F(MSG_PREPARE);
     case HomeMenu:          return F("Homing Menu");
     case Move:              return GET_TEXT_F(MSG_MOVE_AXIS);
     case ManualLevel:       return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return GET_TEXT_F(MSG_ZPROBE_ZOFFSET);
     #endif
     #if HAS_PREHEAT
@@ -4015,21 +4011,21 @@ FSTR_P CrealityDWINClass::Get_Menu_Title(const uint8_t menu) {
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:      return GET_TEXT_F(MSG_MANUAL_LEVELING);
     #endif
     case Tune:              return GET_TEXT_F(MSG_TUNE);
     case PreheatHotend:     return GET_TEXT_F(MSG_PREHEAT_HOTEND);
   }
   return F("");
 }
 
-uint8_t CrealityDWINClass::Get_Menu_Size(const uint8_t menu) {
+uint8_t CrealityDWIN::getMenuSize(const uint8_t menu) {
   switch (menu) {
     case Prepare:           return PREPARE_TOTAL;
     case HomeMenu:          return HOME_TOTAL;
     case Move:              return MOVE_TOTAL;
     case ManualLevel:       return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return ZOFFSET_TOTAL;
     #endif
     #if HAS_PREHEAT
       case Preheat:         return PREHEAT_TOTAL;
@@ -4092,122 +4088,122 @@ uint8_t CrealityDWINClass::Get_Menu_Size(const uint8_t menu) {
       case PreheatHotend:   return PREHEATHOTEND_TOTAL;
     #endif
 
     case ColorSettings:     return COLORSETTINGS_TOTAL;
   }
   return 0;
 }
 
 /* Popup Config */
 
-void CrealityDWINClass::Popup_Handler(const PopupID popupid, const bool option/*=false*/) {
+void CrealityDWIN::popupHandler(const PopupID popupid, const bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
-    case Pause:         Draw_Popup(F("Pause Print"), F(""), F(""), Popup); break;
-    case Stop:          Draw_Popup(F("Stop Print"), F(""), F(""), Popup); break;
-    case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
-    case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
-    case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
-    case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
-    case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
-    case ETemp:         Draw_Popup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
-    case ManualProbing: Draw_Popup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
-    case Level:         Draw_Popup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
-    case Home:          Draw_Popup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case MoveWait:      Draw_Popup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case Heating:       Draw_Popup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case FilChange:     Draw_Popup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
-    case TempWarn:      Draw_Popup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
-    case Runout:        Draw_Popup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
-    case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
-    case Resuming:      Draw_Popup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case Custom:        Draw_Popup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Pause:         drawPopup(F("Pause Print"), F(""), F(""), Popup); break;
+    case Stop:          drawPopup(F("Stop Print"), F(""), F(""), Popup); break;
+    case Resume:        drawPopup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
+    case ConfFilChange: drawPopup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
+    case PurgeMore:     drawPopup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
+    case SaveLevel:     drawPopup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
+    case MeshSlot:      drawPopup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
+    case ETemp:         drawPopup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
+    case ManualProbing: drawPopup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
+    case Level:         drawPopup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
+    case Home:          drawPopup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case MoveWait:      drawPopup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Heating:       drawPopup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case FilLoad:       drawPopup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case FilChange:     drawPopup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
+    case TempWarn:      drawPopup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
+    case Runout:        drawPopup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
+    case PIDWait:       drawPopup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
+    case Resuming:      drawPopup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Custom:        drawPopup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
-void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
+void CrealityDWIN::confirmHandler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
-    case FilInsert:   Draw_Popup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
-    case HeaterTime:  Draw_Popup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
-    case UserInput:   Draw_Popup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
-    case LevelError:  Draw_Popup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
-    case InvalidMesh: Draw_Popup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
+    case FilInsert:   drawPopup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
+    case HeaterTime:  drawPopup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
+    case UserInput:   drawPopup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
+    case LevelError:  drawPopup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
+    case InvalidMesh: drawPopup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
     default: break;
   }
 }
 
 /* Navigation and Control */
 
-void CrealityDWINClass::Main_Menu_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::mainMenuControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {
     selection++; // Select Down
-    Main_Menu_Icons();
+    mainMenuIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
-    Main_Menu_Icons();
+    mainMenuIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     switch (selection) {
-      case PAGE_PRINT: card.mount(); Draw_SD_List(); break;
-      case PAGE_PREPARE: Draw_Menu(Prepare); break;
-      case PAGE_CONTROL: Draw_Menu(Control); break;
-      case PAGE_INFO_LEVELING: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
+      case PAGE_PRINT: card.mount(); drawSDList(); break;
+      case PAGE_PREPARE: drawMenu(Prepare); break;
+      case PAGE_CONTROL: drawMenu(Control); break;
+      case PAGE_INFO_LEVELING: drawMenu(TERN(HAS_MESH, Leveling, InfoMain)); break;
     }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::Menu_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::menuControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < getMenuSize(active_menu)) {
+    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection++; // Select Down
     if (selection > scrollpos+MROWS) {
       scrollpos++;
-      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
-      Menu_Item_Handler(active_menu, selection);
+      dwinFrameAreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      menuItemHandler(active_menu, selection);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
-      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
-      Menu_Item_Handler(active_menu, selection);
+      dwinFrameAreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      menuItemHandler(active_menu, selection);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
-    Menu_Item_Handler(active_menu, selection, false);
-  DWIN_UpdateLCD();
+    menuItemHandler(active_menu, selection, false);
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::Value_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::valueControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
-    tempvalue += EncoderRate.encoderMoveValue;
+    tempvalue += encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
-    tempvalue -= EncoderRate.encoderMoveValue;
+    tempvalue -= encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
-    EncoderRate.enabled = false;
-    Draw_Float(tempvalue / valueunit, selection - scrollpos, false, valueunit);
-    DWIN_UpdateLCD();
+    encoderRate.enabled = false;
+    drawFloat(tempvalue / valueunit, selection - scrollpos, false, valueunit);
+    dwinUpdateLCD();
     if (active_menu == ZOffset && liveadjust) {
       planner.synchronize();
       current_position.z += (tempvalue / valueunit - zoffsetvalue);
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
       current_position.z = 0;
       sync_plan_position();
     }
     else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
       sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - zoffsetvalue), 1, 3, str_1));
       gcode.process_subcommands_now(cmd);
@@ -4236,160 +4232,160 @@ void CrealityDWINClass::Value_Control() {
           planner.synchronize();
           break;
         case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
         case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
       #endif
     }
     if (funcpointer) funcpointer();
     return;
   }
   LIMIT(tempvalue, valuemin * valueunit, valuemax * valueunit);
-  Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
-  DWIN_UpdateLCD();
+  drawFloat(tempvalue / valueunit, selection - scrollpos, true, valueunit);
+  dwinUpdateLCD();
   if (active_menu == Move && livemove) {
     *(float*)valuepointer = tempvalue / valueunit;
     planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
   }
 }
 
-void CrealityDWINClass::Option_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::optionControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
-    tempvalue += EncoderRate.encoderMoveValue;
+    tempvalue += encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
-    tempvalue -= EncoderRate.encoderMoveValue;
+    tempvalue -= encoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
-    EncoderRate.enabled = false;
+    encoderRate.enabled = false;
     if (valuepointer == &color_names) {
       switch (selection) {
         case COLORSETTINGS_CURSOR: eeprom_settings.cursor_color = tempvalue; break;
         case COLORSETTINGS_SPLIT_LINE: eeprom_settings.menu_split_line = tempvalue; break;
         case COLORSETTINGS_MENU_TOP_BG: eeprom_settings.menu_top_bg = tempvalue; break;
         case COLORSETTINGS_MENU_TOP_TXT: eeprom_settings.menu_top_txt = tempvalue; break;
         case COLORSETTINGS_HIGHLIGHT_BORDER: eeprom_settings.highlight_box = tempvalue; break;
         case COLORSETTINGS_PROGRESS_PERCENT: eeprom_settings.progress_percent = tempvalue; break;
         case COLORSETTINGS_PROGRESS_TIME: eeprom_settings.progress_time = tempvalue; break;
         case COLORSETTINGS_PROGRESS_STATUS_BAR: eeprom_settings.status_bar_text = tempvalue; break;
         case COLORSETTINGS_PROGRESS_STATUS_AREA: eeprom_settings.status_area_text = tempvalue; break;
         case COLORSETTINGS_PROGRESS_COORDINATES: eeprom_settings.coordinates_text = tempvalue; break;
         case COLORSETTINGS_PROGRESS_COORDINATES_LINE: eeprom_settings.coordinates_split_line = tempvalue; break;
       }
-      Redraw_Screen();
+      redrawScreen();
     }
     else if (valuepointer == &preheat_modes)
       preheatmode = tempvalue;
 
-    Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
-    DWIN_UpdateLCD();
+    drawOption(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
+    dwinUpdateLCD();
     return;
   }
   LIMIT(tempvalue, valuemin, valuemax);
-  Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
-  DWIN_UpdateLCD();
+  drawOption(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::File_Control() {
+void CrealityDWIN::fileControl() {
   typedef TextScroller<MENU_CHAR_LIMIT> Scroller;
   static Scroller scroller;
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) {
     if (selection > 0) {
       card.selectFileByIndexSorted(selection - 1);
       char * const filename = card.longest_filename();
       size_t len = strlen(filename);
       size_t pos = len;
       if (!card.flag.filenameIsDir)
         while (pos && filename[pos] != '.') pos--;
       if (pos > MENU_CHAR_LIMIT) {
         static millis_t time = 0;
         if (PENDING(millis(), time)) return;
         time = millis() + 200;
         Scroller::Buffer buf;
         const char* const name = scroller.scroll(pos, buf, filename);
-        DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
-        Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
-        DWIN_UpdateLCD();
+        dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+        drawMenuItem(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
+        dwinUpdateLCD();
       }
     }
     return;
   }
   if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_items()) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     if (selection > 0) {
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
-      Draw_SD_Item(selection, selection - scrollpos);
+      dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+      drawSDItem(selection, selection - scrollpos);
     }
     scroller.reset();
     selection++; // Select Down
     if (selection > scrollpos + MROWS) {
       scrollpos++;
-      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
-      Draw_SD_Item(selection, selection - scrollpos);
+      dwinFrameAreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      drawSDItem(selection, selection - scrollpos);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
-    Draw_SD_Item(selection, selection - scrollpos);
+    dwinDrawRectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+    drawSDItem(selection, selection - scrollpos);
     scroller.reset();
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
-      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
-      Draw_SD_Item(selection, selection - scrollpos);
+      dwinFrameAreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      drawSDItem(selection, selection - scrollpos);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    dwinDrawRectangle(1, getColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     if (selection == 0) {
       if (card.flag.workDirIsRoot) {
         process = Main;
-        Draw_Main_Menu();
+        drawMainMenu();
       }
       else {
         card.cdup();
-        Draw_SD_List();
+        drawSDList();
       }
     }
     else {
       card.selectFileByIndexSorted(selection - 1);
       if (card.flag.filenameIsDir) {
         card.cd(card.filename);
-        Draw_SD_List();
+        drawSDList();
       }
       else {
         card.openAndPrintFile(card.filename);
       }
     }
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::Print_Screen_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::printScreenControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
     selection++; // Select Down
-    Print_Screen_Icons();
+    printScreenIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
-    Print_Screen_Icons();
+    printScreenIcons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (selection) {
       case PRINT_SETUP:
-        Draw_Menu(Tune);
-        Update_Status_Bar(true);
+        drawMenu(Tune);
+        updateStatusBar(true);
         break;
       case PRINT_PAUSE_RESUME:
         if (paused) {
           if (sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
               char cmd[20];
@@ -4402,391 +4398,391 @@ void CrealityDWINClass::Print_Screen_Control() {
                 gcode.process_subcommands_now(cmd);
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
               TERN_(HAS_MEDIA, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
-          Draw_Print_Screen();
+          drawPrintScreen();
         }
         else
-          Popup_Handler(Pause);
+          popupHandler(Pause);
         break;
-      case PRINT_STOP: Popup_Handler(Stop); break;
+      case PRINT_STOP: popupHandler(Stop); break;
     }
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::Popup_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::popupControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
     selection++;
-    Popup_Select();
+    popupSelect();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--;
-    Popup_Select();
+    popupSelect();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
       case Pause:
         if (selection == 0) {
           if (sdprint) {
             #if ENABLED(POWER_LOSS_RECOVERY)
               if (recovery.enabled) recovery.save(true);
             #endif
             #if ENABLED(PARK_HEAD_ON_PAUSE)
-              Popup_Handler(Home, true);
+              popupHandler(Home, true);
               #if HAS_MEDIA
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
               queue.inject(F("M125"));
               planner.synchronize();
             #else
               queue.inject(F("M25"));
               TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
               TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
               thermalManager.cooldown();
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.pause());
           }
         }
-        Draw_Print_Screen();
+        drawPrintScreen();
         break;
       case Stop:
         if (selection == 0) {
           if (sdprint) {
             ui.abort_print();
             thermalManager.cooldown();
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
           }
         }
         else
-          Draw_Print_Screen();
+          drawPrintScreen();
         break;
       case Resume:
         if (selection == 0)
           queue.inject(F("M1000"));
         else {
           queue.inject(F("M1000 C"));
-          Draw_Main_Menu();
+          drawMainMenu();
         }
         break;
 
       #if HAS_HOTEND
         case ETemp:
           if (selection == 0) {
             thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
             TERN_(HAS_FAN, thermalManager.set_fan_speed(0, MAX_FAN_SPEED));
-            Draw_Menu(PreheatHotend);
+            drawMenu(PreheatHotend);
           }
           else
-            Redraw_Menu(true, true, false);
+            redrawMenu(true, true, false);
           break;
       #endif
 
       #if HAS_BED_PROBE
         case ManualProbing:
           if (selection == 0) {
             char buf[80];
             const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - corner_avg;
             sprintf_P(buf, dif > 0 ? PSTR("Corner is %smm high") : PSTR("Corner is %smm low"), dtostrf(abs(dif), 1, 3, str_1));
-            Update_Status(buf);
+            updateStatus(buf);
           }
           else {
-            Redraw_Menu(true, true, false);
-            Update_Status("");
+            redrawMenu(true, true, false);
+            updateStatus("");
           }
           break;
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         case ConfFilChange:
           if (selection == 0) {
             if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-              Popup_Handler(ETemp);
+              popupHandler(ETemp);
             else {
               if (thermalManager.temp_hotend[0].is_below_target(2)) {
-                Popup_Handler(Heating);
+                popupHandler(Heating);
                 thermalManager.wait_for_hotend(0);
               }
-              Popup_Handler(FilChange);
+              popupHandler(FilChange);
               sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
               gcode.process_subcommands_now(cmd);
             }
           }
           else
-            Redraw_Menu(true, true, false);
+            redrawMenu(true, true, false);
           break;
         case PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
-            Popup_Handler(FilChange);
+            popupHandler(FilChange);
           }
           else {
             pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
-            if (printing) Popup_Handler(Resuming);
-            else Redraw_Menu(true, true, active_menu == PreheatHotend);
+            if (printing) popupHandler(Resuming);
+            else redrawMenu(true, true, active_menu == PreheatHotend);
           }
           break;
       #endif // ADVANCED_PAUSE_FEATURE
 
       #if HAS_MESH
         case SaveLevel:
           if (selection == 0) {
             #if ENABLED(AUTO_BED_LEVELING_UBL)
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
-              AudioFeedback(true);
+              audioFeedback(true);
             #else
-              AudioFeedback(settings.save());
+              audioFeedback(settings.save());
             #endif
           }
-          Draw_Menu(Leveling, LEVELING_GET_MESH);
+          drawMenu(Leveling, LEVELING_GET_MESH);
           break;
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         case MeshSlot:
           if (selection == 0) bedlevel.storage_slot = 0;
-          Redraw_Menu(true, true);
+          redrawMenu(true, true);
           break;
       #endif
       default: break;
     }
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
-void CrealityDWINClass::Confirm_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+void CrealityDWIN::confirmControl() {
+  EncoderState encoder_diffState = encoderReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
       case Complete:
-        Draw_Main_Menu();
+        drawMainMenu();
         break;
       case FilInsert:
-        Popup_Handler(FilChange);
+        popupHandler(FilChange);
         wait_for_user = false;
         break;
       case HeaterTime:
-        Popup_Handler(Heating);
+        popupHandler(Heating);
         wait_for_user = false;
         break;
       default:
-        Redraw_Menu(true, true, false);
+        redrawMenu(true, true, false);
         wait_for_user = false;
         break;
     }
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 /* In-Menu Value Modification */
 
-void CrealityDWINClass::Setup_Value(const_float_t value, const_float_t min, const_float_t max, const_float_t unit, const uint8_t type) {
+void CrealityDWIN::setupValue(const_float_t value, const_float_t min, const_float_t max, const_float_t unit, const uint8_t type) {
   if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
     tempvalue = unscalePID_i(value) * unit;
   else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
     tempvalue = unscalePID_d(value) * unit;
   else
     tempvalue = value * unit;
   valuemin = min;
   valuemax = max;
   valueunit = unit;
   valuetype = type;
   process = Value;
-  EncoderRate.enabled = true;
-  Draw_Float(tempvalue / unit, selection - scrollpos, true, valueunit);
+  encoderRate.enabled = true;
+  drawFloat(tempvalue / unit, selection - scrollpos, true, valueunit);
 }
 
-void CrealityDWINClass::Modify_Value(float &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void CrealityDWIN::modifyValue(float &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 0);
+  setupValue((float)value, min, max, unit, 0);
 }
-void CrealityDWINClass::Modify_Value(uint8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void CrealityDWIN::modifyValue(uint8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 1);
+  setupValue((float)value, min, max, unit, 1);
 }
-void CrealityDWINClass::Modify_Value(uint16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void CrealityDWIN::modifyValue(uint16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 2);
+  setupValue((float)value, min, max, unit, 2);
 }
-void CrealityDWINClass::Modify_Value(int16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void CrealityDWIN::modifyValue(int16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 3);
+  setupValue((float)value, min, max, unit, 3);
 }
-void CrealityDWINClass::Modify_Value(uint32_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void CrealityDWIN::modifyValue(uint32_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 4);
+  setupValue((float)value, min, max, unit, 4);
 }
-void CrealityDWINClass::Modify_Value(int8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
+void CrealityDWIN::modifyValue(int8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 5);
+  setupValue((float)value, min, max, unit, 5);
 }
 
-void CrealityDWINClass::Modify_Option(const uint8_t value, const char * const * options, const uint8_t max) {
+void CrealityDWIN::modifyOption(const uint8_t value, const char * const * options, const uint8_t max) {
   tempvalue = value;
   valuepointer = const_cast<const char * *>(options);
   valuemin = 0;
   valuemax = max;
   process = Option;
-  EncoderRate.enabled = true;
-  Draw_Option(value, options, selection - scrollpos, true);
+  encoderRate.enabled = true;
+  drawOption(value, options, selection - scrollpos, true);
 }
 
 /* Main Functions */
 
-void CrealityDWINClass::Update_Status(const char * const text) {
+void CrealityDWIN::updateStatus(const char * const text) {
   if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
     for (uint8_t i = 0; i < _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text)); ++i) filename[i] = text[i + 3];
     filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
-    Draw_Print_Filename(true);
+    drawPrintFilename(true);
   }
   else {
     for (uint8_t i = 0; i < _MIN((size_t)64, strlen(text)); ++i) statusmsg[i] = text[i];
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
-void CrealityDWINClass::Start_Print(const bool sd) {
+void CrealityDWIN::startPrint(const bool sd) {
   sdprint = sd;
   if (!printing) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {
       #if ENABLED(POWER_LOSS_RECOVERY)
         if (recovery.valid()) {
           MediaFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
         }
       #endif
       strcpy(filename, card.longest_filename());
     }
     else
       strcpy_P(filename, PSTR("Host Print"));
     TERN_(SET_PROGRESS_PERCENT, ui.set_progress(0));
     TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
-    Draw_Print_Screen();
+    drawPrintScreen();
   }
 }
 
-void CrealityDWINClass::Stop_Print() {
+void CrealityDWIN::stopPrint() {
   printing = false;
   sdprint = false;
   thermalManager.cooldown();
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress(100 * (PROGRESS_SCALE)));
   TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
-  Draw_Print_confirm();
+  drawPrintConfirm();
 }
 
-void CrealityDWINClass::Update() {
-  State_Update();
-  Screen_Update();
+void CrealityDWIN::update() {
+  stateUpdate();
+  screenUpdate();
   switch (process) {
-    case Main:    Main_Menu_Control();    break;
-    case Menu:    Menu_Control();         break;
-    case Value:   Value_Control();        break;
-    case Option:  Option_Control();       break;
-    case File:    File_Control();         break;
-    case Print:   Print_Screen_Control(); break;
-    case Popup:   Popup_Control();        break;
-    case Confirm: Confirm_Control();      break;
+    case Main:    mainMenuControl();    break;
+    case Menu:    menuControl();         break;
+    case Value:   valueControl();        break;
+    case Option:  optionControl();       break;
+    case File:    fileControl();         break;
+    case Print:   printScreenControl(); break;
+    case Popup:   popupControl();        break;
+    case Confirm: confirmControl();      break;
   }
 }
 
-void MarlinUI::update() { CrealityDWIN.Update(); }
+void MarlinUI::update() { crealityDWIN.update(); }
 
 #if HAS_LCD_BRIGHTNESS
-  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+  void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
-void CrealityDWINClass::State_Update() {
+void CrealityDWIN::stateUpdate() {
   if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
-    if (!printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
-    else Stop_Print();
+    if (!printing) startPrint(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
+    else stopPrint();
   }
   if (print_job_timer.isPaused() != paused) {
     paused = print_job_timer.isPaused();
-    if (process == Print) Print_Screen_Icons();
-    if (process == Wait && !paused) Redraw_Menu(true, true);
+    if (process == Print) printScreenIcons();
+    if (process == Wait && !paused) redrawMenu(true, true);
   }
   if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
-    Confirm_Handler(UserInput);
+    confirmHandler(UserInput);
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     if (process == Popup && popup == PurgeMore) {
       if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
-        Popup_Handler(FilChange);
+        popupHandler(FilChange);
       else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
-        if (printing) Popup_Handler(Resuming);
-        else Redraw_Menu(true, true, active_menu == PreheatHotend);
+        if (printing) popupHandler(Resuming);
+        else redrawMenu(true, true, active_menu == PreheatHotend);
       }
     }
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     static bool ranout = false;
     if (runout.filament_ran_out != ranout) {
       ranout = runout.filament_ran_out;
-      if (ranout) Popup_Handler(Runout);
+      if (ranout) popupHandler(Runout);
     }
   #endif
 }
 
-void CrealityDWINClass::Screen_Update() {
+void CrealityDWIN::screenUpdate() {
   const millis_t ms = millis();
   static millis_t scrltime = 0;
   if (ELAPSED(ms, scrltime)) {
     scrltime = ms + 200;
-    Update_Status_Bar();
-    if (process == Print) Draw_Print_Filename();
+    updateStatusBar();
+    if (process == Print) drawPrintFilename();
   }
 
   static millis_t statustime = 0;
   if (ELAPSED(ms, statustime)) {
     statustime = ms + 500;
-    Draw_Status_Area();
+    drawStatusArea();
   }
 
   static millis_t printtime = 0;
   if (ELAPSED(ms, printtime)) {
     printtime = ms + 1000;
     if (process == Print) {
-      Draw_Print_ProgressBar();
-      Draw_Print_ProgressElapsed();
-      TERN_(SET_REMAINING_TIME, Draw_Print_ProgressRemain());
+      drawPrintProgressBar();
+      drawPrintProgressElapsed();
+      TERN_(SET_REMAINING_TIME, drawPrintProgressRemain());
     }
   }
 
   static bool mounted = card.isMounted();
   if (mounted != card.isMounted()) {
     mounted = card.isMounted();
     if (process == File)
-      Draw_SD_List();
+      drawSDList();
   }
 
   #if HAS_HOTEND
     static int16_t hotendtarget = -1;
   #endif
   #if HAS_HEATED_BED
     static int16_t bedtarget = -1;
   #endif
   #if HAS_FAN
     static int16_t fanspeed = -1;
@@ -4813,148 +4809,148 @@ void CrealityDWINClass::Screen_Update() {
   #endif // HAS_ZOFFSET_ITEM
 
   if (process == Menu || process == Value) {
     switch (active_menu) {
       case TempMenu:
         #if HAS_HOTEND
           if (thermalManager.temp_hotend[0].target != hotendtarget) {
             hotendtarget = thermalManager.temp_hotend[0].target;
             if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
+                drawFloat(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_HEATED_BED
           if (thermalManager.temp_bed.target != bedtarget) {
             bedtarget = thermalManager.temp_bed.target;
             if (scrollpos <= TEMP_BED && TEMP_BED <= scrollpos + MROWS) {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
+                drawFloat(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_FAN
           if (thermalManager.fan_speed[0] != fanspeed) {
             fanspeed = thermalManager.fan_speed[0];
             if (scrollpos <= TEMP_FAN && TEMP_FAN <= scrollpos + MROWS) {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
+                drawFloat(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
       case Tune:
         #if HAS_HOTEND
           if (thermalManager.temp_hotend[0].target != hotendtarget) {
             hotendtarget = thermalManager.temp_hotend[0].target;
             if (scrollpos <= TUNE_HOTEND && TUNE_HOTEND <= scrollpos + MROWS) {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
+                drawFloat(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_HEATED_BED
           if (thermalManager.temp_bed.target != bedtarget) {
             bedtarget = thermalManager.temp_bed.target;
             if (scrollpos <= TUNE_BED && TUNE_BED <= scrollpos + MROWS) {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
+                drawFloat(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
             }
           }
         #endif
         #if HAS_FAN
           if (thermalManager.fan_speed[0] != fanspeed) {
             fanspeed = thermalManager.fan_speed[0];
             if (scrollpos <= TUNE_FAN && TUNE_FAN <= scrollpos + MROWS) {
               if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
+                drawFloat(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
     }
   }
 }
 
-void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
+void CrealityDWIN::audioFeedback(const bool success/*=true*/) {
   if (ui.sound_on)
     DONE_BUZZ(success);
   else
-    Update_Status(success ? "Success" : "Failed");
+    updateStatus(success ? "Success" : "Failed");
 }
 
-void CrealityDWINClass::Save_Settings(char * const buff) {
+void CrealityDWIN::saveSettings(char * const buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
 
-void CrealityDWINClass::Load_Settings(const char * const buff) {
+void CrealityDWIN::loadSettings(const char * const buff) {
   memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
   corner_pos = eeprom_settings.corner_pos / 10.0f;
-  Redraw_Screen();
+  redrawScreen();
   #if ENABLED(POWER_LOSS_RECOVERY)
     static bool init = true;
     if (init) {
       init = false;
       queue.inject(F("M1000 S"));
     }
   #endif
 }
 
-void CrealityDWINClass::Reset_Settings() {
+void CrealityDWIN::resetSettings() {
   eeprom_settings.time_format_textual = false;
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
   eeprom_settings.corner_pos = 325;
   eeprom_settings.cursor_color = 0;
   eeprom_settings.menu_split_line = 0;
   eeprom_settings.menu_top_bg = 0;
   eeprom_settings.menu_top_txt = 0;
   eeprom_settings.highlight_box = 0;
   eeprom_settings.progress_percent = 0;
   eeprom_settings.progress_time = 0;
   eeprom_settings.status_bar_text = 0;
   eeprom_settings.status_area_text = 0;
   eeprom_settings.coordinates_text = 0;
   eeprom_settings.coordinates_split_line = 0;
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   corner_pos = eeprom_settings.corner_pos / 10.0f;
   TERN_(SOUND_MENU_ITEM, ui.sound_on = ENABLED(SOUND_ON_DEFAULT));
-  Redraw_Screen();
+  redrawScreen();
 }
 
 void MarlinUI::init_lcd() {
   delay(800);
   SERIAL_ECHOPGM("\nDWIN handshake ");
-  if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
-  DWIN_Frame_SetDir(1); // Orientation 90°
-  DWIN_UpdateLCD();     // Show bootscreen (first image)
-  Encoder_Configuration();
+  if (dwinHandshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
+  dwinFrameSetDir(1); // Orientation 90°
+  dwinUpdateLCD();     // Show bootscreen (first image)
+  encoderConfiguration();
   for (uint16_t t = 0; t <= 100; t += 2) {
-    DWIN_ICON_Show(ICON, ICON_Bar, 15, 260);
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
-    DWIN_UpdateLCD();
+    dwinIconShow(ICON, ICON_Bar, 15, 260);
+    dwinDrawRectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
+    dwinUpdateLCD();
     delay(20);
   }
 
-  DWIN_JPG_ShowAndCache(3);
-  DWIN_JPG_CacheTo1(Language_English);
-  CrealityDWIN.Redraw_Screen();
+  dwinJPGShowAndCache(3);
+  dwinJPGCacheTo1(Language_English);
+  crealityDWIN.redrawScreen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     switch (message) {
-      case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
+      case PAUSE_MESSAGE_INSERT:  crealityDWIN.confirmHandler(FilInsert);  break;
       case PAUSE_MESSAGE_PURGE:
-      case PAUSE_MESSAGE_OPTION:  CrealityDWIN.Popup_Handler(PurgeMore);    break;
-      case PAUSE_MESSAGE_HEAT:    CrealityDWIN.Confirm_Handler(HeaterTime); break;
-      case PAUSE_MESSAGE_WAITING: CrealityDWIN.Draw_Print_Screen();         break;
+      case PAUSE_MESSAGE_OPTION:  crealityDWIN.popupHandler(PurgeMore);    break;
+      case PAUSE_MESSAGE_HEAT:    crealityDWIN.confirmHandler(HeaterTime); break;
+      case PAUSE_MESSAGE_WAITING: crealityDWIN.drawPrintScreen();         break;
       default: break;
     }
   }
 #endif
 
 #endif // DWIN_CREALITY_LCD_JYERSUI

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ♻️ Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 1ef9ee8517..7b83e0171f 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -288,43 +288,31 @@ private:
 
         if (finish_incremental_LSF(&lsf_results)) {
           SERIAL_ECHOPGM("Could not complete LSF!");
           return true;
         }
 
         bedlevel.set_all_mesh_points_to_value(0);
 
         matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
         GRID_LOOP(i, j) {
-          float mx = bedlevel.get_mesh_x(i),
-                my = bedlevel.get_mesh_y(j),
-                mz = bedlevel.z_values[i][j];
+          float mx = bedlevel.get_mesh_x(i), my = bedlevel.get_mesh_y(j), mz = bedlevel.z_values[i][j];
 
           if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(my, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(mz, 7);
-            DEBUG_ECHOPGM("]   ---> ");
+            DEBUG_ECHOLN(F("before rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), F("]   ---> "));
             DEBUG_DELAY(20);
           }
 
           rotation.apply_rotation_xyz(mx, my, mz);
 
           if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(my, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(mz, 7);
-            DEBUG_ECHOLNPGM("]");
+            DEBUG_ECHOLN(F("after rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), AS_CHAR(']'));
             DEBUG_DELAY(20);
           }
 
           bedlevel.z_values[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
 

commit e116a99eda1bbfd97e4af1136618d80dcceb169e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 5 20:13:15 2023 -0500

    🩹 Fix JyersUI corner pos
    
    Followup to #25631

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index b453bc2031..1ef9ee8517 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1385,80 +1385,82 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
             Draw_Menu_Item(row, ICON_Axis, F("Live Movement"));
             Draw_Checkbox(row, livemove);
           }
           else {
             livemove = !livemove;
             Draw_Checkbox(row, livemove);
           }
           break;
       }
       break;
-    case ManualLevel:
+    case ManualLevel: {
 
       #define MLEVEL_BACK 0
       #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
       #define MLEVEL_BL (MLEVEL_PROBE + 1)
       #define MLEVEL_TL (MLEVEL_BL + 1)
       #define MLEVEL_TR (MLEVEL_TL + 1)
       #define MLEVEL_BR (MLEVEL_TR + 1)
       #define MLEVEL_C (MLEVEL_BR + 1)
       #define MLEVEL_ZPOS (MLEVEL_C + 1)
       #define MLEVEL_TOTAL MLEVEL_ZPOS
 
       static float mlev_z_pos = 0;
       static bool use_probe = false;
 
       #if HAS_BED_PROBE
-        constexpr float probe_x_min = _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x,
-                        probe_x_max = _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x,
-                        probe_y_min = _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y,
-                        probe_y_max = _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y;
+        const float probe_x_min = _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x,
+                    probe_x_max = _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x,
+                    probe_y_min = _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y,
+                    probe_y_max = _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y;
       #endif
 
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
             Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
           }
           break;
+
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
               Draw_Checkbox(row, use_probe);
             }
             else {
               use_probe ^= true;
               Draw_Checkbox(row, use_probe);
               if (use_probe) {
                 Popup_Handler(Level);
-                constexpr struct { xy_pos_t p, ProbePtRaise r } points[] = {
+                const struct { xy_pos_t p; ProbePtRaise r; } points[] = {
                   { { probe_x_min, probe_y_min }, PROBE_PT_RAISE },
                   { { probe_x_min, probe_y_max }, PROBE_PT_RAISE },
                   { { probe_x_max, probe_y_max }, PROBE_PT_RAISE },
                   { { probe_x_max, probe_y_min }, PROBE_PT_STOW }
                 };
                 corner_avg = 0;
                 for (uint8_t i = 0; i < COUNT(points); i++) {
                   const float mz = probe.probe_at_point(points[i].p, points[i].r, 0, false);
                   if (isnan(mz)) { corner_avg = 0; break; }
                   corner_avg += mz;
                 }
                 corner_avg /= 4;
                 Redraw_Menu();
               }
             }
             break;
         #endif
+
         case MLEVEL_BL:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisBL, F("Bottom Left"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
@@ -1559,21 +1561,23 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
           break;
         case MLEVEL_ZPOS:
           if (draw) {
             Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
             Draw_Float(mlev_z_pos, row, false, 100);
           }
           else
             Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
           break;
       }
-      break;
+
+    } break;
+
     #if HAS_ZOFFSET_ITEM
       case ZOffset:
 
         #define ZOFFSET_BACK 0
         #define ZOFFSET_HOME (ZOFFSET_BACK + 1)
         #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
         #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
         #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
         #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
         #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    🧑‍💻 Remove LOOP macros (#25917)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 81478887ce..b453bc2031 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -587,21 +587,21 @@ void CrealityDWINClass::Draw_Menu(const uint8_t menu, const uint8_t select/*=0*/
     if (process == Menu) last_selection = selection;
   }
   selection = _MIN(select, Get_Menu_Size(menu));
   scrollpos = scroll;
   if (selection - scrollpos > MROWS)
     scrollpos = selection - MROWS;
   process = Menu;
   active_menu = menu;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(menu));
-  LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
+  for (uint8_t i = 0; i < TROWS; ++i) Menu_Item_Handler(menu, i + scrollpos);
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
 
 void CrealityDWINClass::Redraw_Menu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
   switch (lastproc ? last_process : process) {
     case Menu:
       Draw_Menu(lastmenu ? last_menu : active_menu, lastsel ? last_selection : selection, lastmenu ? 0 : scrollpos);
       break;
     case Main:  Draw_Main_Menu(lastsel ? last_selection : selection); break;
     case Print: Draw_Print_Screen(); break;
@@ -807,36 +807,36 @@ void CrealityDWINClass::Draw_SD_Item(const uint8_t item, const uint8_t row) {
   else {
     card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
-    LOOP_L_N(i, len) name[i] = filename[i];
+    for (uint8_t i = 0; i < len; ++i) name[i] = filename[i];
     if (pos > max)
-      LOOP_S_L_N(i, len - 3, len) name[i] = '.';
+      for (uint8_t i = len - 3; i < len; ++i) name[i] = '.';
     name[len] = '\0';
     Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
 void CrealityDWINClass::Draw_SD_List(const bool removed/*=false*/) {
   Clear_Screen();
   Draw_Title("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
-    LOOP_L_N(i, _MIN(card.get_num_items() + 1, TROWS))
+    for (uint8_t i = 0; i < _MIN(card.get_num_items() + 1, TROWS); ++i)
       Draw_SD_Item(i, i);
   }
   else {
     Draw_Menu_Item(0, ICON_Back, F("Back"));
     DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
@@ -4657,26 +4657,26 @@ void CrealityDWINClass::Modify_Option(const uint8_t value, const char * const *
   valuemax = max;
   process = Option;
   EncoderRate.enabled = true;
   Draw_Option(value, options, selection - scrollpos, true);
 }
 
 /* Main Functions */
 
 void CrealityDWINClass::Update_Status(const char * const text) {
   if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
-    LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
+    for (uint8_t i = 0; i < _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text)); ++i) filename[i] = text[i + 3];
     filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
     Draw_Print_Filename(true);
   }
   else {
-    LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
+    for (uint8_t i = 0; i < _MIN((size_t)64, strlen(text)); ++i) statusmsg[i] = text[i];
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
 void CrealityDWINClass::Start_Print(const bool sd) {
   sdprint = sd;
   if (!printing) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    🧑‍💻 Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 53e4466bf8..81478887ce 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1097,21 +1097,21 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
   switch (menu) {
     case Prepare:
 
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
-      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + EITHER(HAS_HOTEND, HAS_HEATED_BED))
+      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ANY(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define PREPARE_CUSTOM_MENU (PREPARE_CHANGEFIL + ENABLED(HAS_CUSTOM_MENU))
       #define PREPARE_TOTAL PREPARE_CUSTOM_MENU
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Main_Menu(1);
@@ -3074,21 +3074,21 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
           }
           break;
       }
       break;
 
     #if HAS_MESH
       case Leveling:
 
         #define LEVELING_BACK 0
         #define LEVELING_ACTIVE (LEVELING_BACK + 1)
-        #define LEVELING_GET_TILT (LEVELING_ACTIVE + BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL))
+        #define LEVELING_GET_TILT (LEVELING_ACTIVE + ALL(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL))
         #define LEVELING_GET_MESH (LEVELING_GET_TILT + 1)
         #define LEVELING_MANUAL (LEVELING_GET_MESH + 1)
         #define LEVELING_VIEW (LEVELING_MANUAL + 1)
         #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
         #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_TOTAL LEVELING_SAVE
 
         switch (item) {
@@ -3109,21 +3109,21 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
                 if (!planner.leveling_active) {
                   Confirm_Handler(LevelError);
                   break;
                 }
               }
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
               Draw_Checkbox(row, planner.leveling_active);
             }
             break;
-          #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
+          #if ALL(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
                 Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
                 if (bedlevel.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
                 Popup_Handler(Home);
                 gcode.home_all_axes(true);

commit 37d0f49a82cd2e4d91dce4e62671b266924eb2a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 24 01:05:55 2023 -0500

    🧑‍💻 Misc. ExtUI LCD cleanup (#25872)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index ceaf147c3b..53e4466bf8 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2529,21 +2529,21 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define STEPS_Z (STEPS_Y + 1)
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_STEPS);
-            break;
+          break;
         #if HAS_X_AXIS
           case STEPS_X:
             if (draw) {
               Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
               Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
             }
             else
               Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
             break;
         #endif

commit b2f372b20f375852e3e009d490260307e399792c
Author: Krzysztof Błażewicz <blazewicz.krzysztof@gmail.com>
Date:   Thu May 18 07:38:21 2023 +0200

    🚸 Unify edit limits for some E3V2 LCDs (#25045)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index f430f6d1a9..ceaf147c3b 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -120,20 +120,25 @@
 
   #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
   #define MIN_E_TEMP    0
 #endif
 
 #if HAS_HEATED_BED
   #define MAX_BED_TEMP  BED_MAXTEMP
   #define MIN_BED_TEMP  0
 #endif
 
+#define FEEDRATE_UNIT 1
+#define ACCELERATION_UNIT 1
+#define JERK_UNIT 10
+#define STEPS_UNIT 10
+
 /**
  * Custom menu items with jyersLCD
  */
 #if ENABLED(CUSTOM_MENU_CONFIG)
   #ifdef CONFIG_MENU_ITEM_5_DESC
     #define CUSTOM_MENU_COUNT 5
   #elif defined(CONFIG_MENU_ITEM_4_DESC)
     #define CUSTOM_MENU_COUNT 4
   #elif defined(CONFIG_MENU_ITEM_3_DESC)
     #define CUSTOM_MENU_COUNT 3
@@ -148,27 +153,20 @@
 #endif
 
 constexpr uint16_t TROWS = 6, MROWS = TROWS - 1,
                    TITLE_HEIGHT = 30,
                    MLINE = 53,
                    LBLX = 60,
                    MENU_CHR_W = 8, MENU_CHR_H = 16, STAT_CHR_W = 10;
 
 #define MBASE(L) (49 + MLINE * (L))
 
-constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
-constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
-constexpr float default_steps[]               = DEFAULT_AXIS_STEPS_PER_UNIT;
-#if HAS_CLASSIC_JERK
-  constexpr float default_max_jerk[]            = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
-#endif
-
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
   PAGE_INFO_LEVELING,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
   PRINT_PAUSE_RESUME,
   PRINT_STOP,
@@ -2362,57 +2360,57 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         case SPEED_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_SPEED);
           break;
         #if HAS_X_AXIS
           case SPEED_X:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
+              Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
+              Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], min_feedrate_edit_values.x, max_feedrate_edit_values.x, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_Y_AXIS
           case SPEED_Y:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedY, F("Y Axis"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
+              Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
+              Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], min_feedrate_edit_values.y, max_feedrate_edit_values.y, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_Z_AXIS
           case SPEED_Z:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedZ, F("Z Axis"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, 1);
+              Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], 0, default_max_feedrate[Z_AXIS] * 2, 1);
+              Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], min_feedrate_edit_values.z, max_feedrate_edit_values.z, FEEDRATE_UNIT);
             break;
         #endif
 
         #if HAS_HOTEND
           case SPEED_E:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedE, F("Extruder"));
-              Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, 1);
+              Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, FEEDRATE_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], 0, default_max_feedrate[E_AXIS] * 2, 1);
+              Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], min_feedrate_edit_values.e, max_feedrate_edit_values.e, FEEDRATE_UNIT);
             break;
         #endif
       }
       break;
 
     case MaxAcceleration:
 
       #define ACCEL_BACK 0
       #define ACCEL_X (ACCEL_BACK + 1)
       #define ACCEL_Y (ACCEL_X + 1)
@@ -2423,49 +2421,49 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       switch (item) {
         case ACCEL_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_ACCEL);
           break;
         case ACCEL_X:
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxAccX, F("X Axis"));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, 1);
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], 0, default_max_acceleration[X_AXIS] * 2, 1);
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], min_acceleration_edit_values.x, max_acceleration_edit_values.x, ACCELERATION_UNIT);
           break;
         case ACCEL_Y:
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxAccY, F("Y Axis"));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, 1);
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], 0, default_max_acceleration[Y_AXIS] * 2, 1);
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], min_acceleration_edit_values.y, max_acceleration_edit_values.y, ACCELERATION_UNIT);
           break;
         case ACCEL_Z:
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxAccZ, F("Z Axis"));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, 1);
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, ACCELERATION_UNIT);
           }
           else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], 0, default_max_acceleration[Z_AXIS] * 2, 1);
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], min_acceleration_edit_values.z, max_acceleration_edit_values.z, ACCELERATION_UNIT);
           break;
         #if HAS_HOTEND
           case ACCEL_E:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxAccE, F("Extruder"));
-              Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, 1);
+              Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, ACCELERATION_UNIT);
             }
             else
-              Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], 0, default_max_acceleration[E_AXIS] * 2, 1);
+              Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], min_acceleration_edit_values.e, max_acceleration_edit_values.e, ACCELERATION_UNIT);
             break;
         #endif
       }
       break;
     #if HAS_CLASSIC_JERK
       case MaxJerk:
 
         #define JERK_BACK 0
         #define JERK_X (JERK_BACK + 1)
         #define JERK_Y (JERK_X + 1)
@@ -2473,105 +2471,117 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
           case JERK_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Motion, MOTION_JERK);
             break;
-          case JERK_X:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
-              Draw_Float(planner.max_jerk.x, row, false, 10);
-            }
-            else
-              Modify_Value(planner.max_jerk.x, 0, default_max_jerk[X_AXIS] * 2, 10);
-            break;
-          case JERK_Y:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
-              Draw_Float(planner.max_jerk.y, row, false, 10);
-            }
-            else
-              Modify_Value(planner.max_jerk.y, 0, default_max_jerk[Y_AXIS] * 2, 10);
-            break;
-          case JERK_Z:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
-              Draw_Float(planner.max_jerk.z, row, false, 10);
-            }
-            else
-              Modify_Value(planner.max_jerk.z, 0, default_max_jerk[Z_AXIS] * 2, 10);
-            break;
+          #if HAS_X_AXIS
+            case JERK_X:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
+                Draw_Float(planner.max_jerk.x, row, false, JERK_UNIT);
+              }
+              else
+                Modify_Value(planner.max_jerk.x, min_jerk_edit_values.x, max_jerk_edit_values.x, JERK_UNIT);
+              break;
+          #endif
+          #if HAS_Y_AXIS
+            case JERK_Y:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
+                Draw_Float(planner.max_jerk.y, row, false, JERK_UNIT);
+              }
+              else
+                Modify_Value(planner.max_jerk.y, min_jerk_edit_values.y, max_jerk_edit_values.y, JERK_UNIT);
+              break;
+          #endif
+          #if HAS_Z_AXIS
+            case JERK_Z:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
+                Draw_Float(planner.max_jerk.z, row, false, JERK_UNIT);
+              }
+              else
+                Modify_Value(planner.max_jerk.z, min_jerk_edit_values.z, max_jerk_edit_values.z, JERK_UNIT);
+              break;
+          #endif
           #if HAS_HOTEND
             case JERK_E:
               if (draw) {
                 Draw_Menu_Item(row, ICON_MaxSpeedJerkE, F("Extruder"));
-                Draw_Float(planner.max_jerk.e, row, false, 10);
+                Draw_Float(planner.max_jerk.e, row, false, JERK_UNIT);
               }
               else
-                Modify_Value(planner.max_jerk.e, 0, default_max_jerk[E_AXIS] * 2, 10);
+                Modify_Value(planner.max_jerk.e, min_jerk_edit_values.e, max_jerk_edit_values.e, JERK_UNIT);
               break;
           #endif
         }
         break;
     #endif
     case Steps:
 
       #define STEPS_BACK 0
       #define STEPS_X (STEPS_BACK + 1)
       #define STEPS_Y (STEPS_X + 1)
       #define STEPS_Z (STEPS_Y + 1)
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_STEPS);
-          break;
-        case STEPS_X:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
-            Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, 10);
-          }
-          else
-            Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], 0, default_steps[X_AXIS] * 2, 10);
-          break;
-        case STEPS_Y:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, F("Y Axis"));
-            Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, 10);
-          }
-          else
-            Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], 0, default_steps[Y_AXIS] * 2, 10);
-          break;
-        case STEPS_Z:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepZ, F("Z Axis"));
-            Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, 10);
-          }
-          else
-            Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], 0, default_steps[Z_AXIS] * 2, 10);
-          break;
+            break;
+        #if HAS_X_AXIS
+          case STEPS_X:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
+              Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, STEPS_UNIT);
+            }
+            else
+              Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], min_steps_edit_values.x, max_steps_edit_values.x, STEPS_UNIT);
+            break;
+        #endif
+        #if HAS_Y_AXIS
+          case STEPS_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepY, F("Y Axis"));
+              Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, STEPS_UNIT);
+            }
+            else
+              Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], min_steps_edit_values.y, max_steps_edit_values.y, STEPS_UNIT);
+            break;
+        #endif
+        #if HAS_Z_AXIS
+          case STEPS_Z:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepZ, F("Z Axis"));
+              Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, STEPS_UNIT);
+            }
+            else
+              Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], min_steps_edit_values.z, max_steps_edit_values.z, STEPS_UNIT);
+            break;
+        #endif
         #if HAS_HOTEND
           case STEPS_E:
             if (draw) {
               Draw_Menu_Item(row, ICON_StepE, F("Extruder"));
-              Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, 10);
+              Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, STEPS_UNIT);
             }
             else
-              Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], 0, 1000, 10);
+              Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], min_steps_edit_values.e, max_steps_edit_values.e, STEPS_UNIT);
             break;
         #endif
       }
       break;
 
     case Visual:
 
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)

commit 060ddf5e950b104b00f5d20adf858a9ad00ab72e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:52:52 2023 -0500

    🚸 Support Bed Leveling Mesh > 16x16
    
    Co-Authored-By: raTmole <ratmole@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index e7f15792f3..f430f6d1a9 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -195,21 +195,21 @@ char filename[LONG_FILENAME_LENGTH];
 bool printing = false;
 bool paused = false;
 bool sdprint = false;
 
 int16_t pausetemp, pausebed, pausefan;
 
 bool livemove = false;
 bool liveadjust = false;
 uint8_t preheatmode = 0;
 float zoffsetvalue = 0;
-uint8_t gridpoint;
+grid_count_t gridpoint;
 float corner_avg;
 float corner_pos;
 
 bool probe_deployed = false;
 
 CrealityDWINClass CrealityDWIN;
 
 template <unsigned N, unsigned S = N>
 class TextScroller {
 public:

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    🚸 Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index c4098bdb49..e7f15792f3 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2358,28 +2358,30 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
       #define SPEED_TOTAL SPEED_E
 
       switch (item) {
         case SPEED_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_SPEED);
           break;
-        case SPEED_X:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
-            Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
-          }
-          else
-            Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
-          break;
+        #if HAS_X_AXIS
+          case SPEED_X:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
+              Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
+            break;
+        #endif
 
         #if HAS_Y_AXIS
           case SPEED_Y:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedY, F("Y Axis"));
               Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
             break;

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    🐛 Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index e685fe16fd..c4098bdb49 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1402,126 +1402,136 @@ void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item
       #define MLEVEL_TL (MLEVEL_BL + 1)
       #define MLEVEL_TR (MLEVEL_TL + 1)
       #define MLEVEL_BR (MLEVEL_TR + 1)
       #define MLEVEL_C (MLEVEL_BR + 1)
       #define MLEVEL_ZPOS (MLEVEL_C + 1)
       #define MLEVEL_TOTAL MLEVEL_ZPOS
 
       static float mlev_z_pos = 0;
       static bool use_probe = false;
 
+      #if HAS_BED_PROBE
+        constexpr float probe_x_min = _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x,
+                        probe_x_max = _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x,
+                        probe_y_min = _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y,
+                        probe_y_max = _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y;
+      #endif
+
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
             Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
           }
           break;
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
               Draw_Checkbox(row, use_probe);
             }
             else {
-              use_probe = !use_probe;
+              use_probe ^= true;
               Draw_Checkbox(row, use_probe);
               if (use_probe) {
                 Popup_Handler(Level);
+                constexpr struct { xy_pos_t p, ProbePtRaise r } points[] = {
+                  { { probe_x_min, probe_y_min }, PROBE_PT_RAISE },
+                  { { probe_x_min, probe_y_max }, PROBE_PT_RAISE },
+                  { { probe_x_max, probe_y_max }, PROBE_PT_RAISE },
+                  { { probe_x_max, probe_y_min }, PROBE_PT_STOW }
+                };
                 corner_avg = 0;
-                #define PROBE_X_MIN _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x
-                #define PROBE_X_MAX _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x
-                #define PROBE_Y_MIN _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y
-                #define PROBE_Y_MAX _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y
-                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MIN, PROBE_PT_RAISE, 0, false);
-                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
-                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
-                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
+                for (uint8_t i = 0; i < COUNT(points); i++) {
+                  const float mz = probe.probe_at_point(points[i].p, points[i].r, 0, false);
+                  if (isnan(mz)) { corner_avg = 0; break; }
+                  corner_avg += mz;
+                }
                 corner_avg /= 4;
                 Redraw_Menu();
               }
             }
             break;
         #endif
         case MLEVEL_BL:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisBL, F("Bottom Left"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisTL, F("Top Left"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_min, 1, 3, str_1), dtostrf(probe_y_max, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisTR, F("Top Right"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_max, 1, 3, str_1), dtostrf(probe_y_max, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisBR, F("Bottom Right"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(probe_x_max, 1, 3, str_1), dtostrf(probe_y_min, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    🧑‍💻 Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index a24adec8e9..e685fe16fd 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4382,21 +4382,21 @@ void CrealityDWINClass::Print_Screen_Control() {
               #if HAS_HEATED_BED
                 sprintf_P(cmd, PSTR("M140 S%i"), pausebed);
                 gcode.process_subcommands_now(cmd);
               #endif
               #if HAS_EXTRUDERS
                 sprintf_P(cmd, PSTR("M109 S%i"), pausetemp);
                 gcode.process_subcommands_now(cmd);
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
-              TERN_(SDSUPPORT, queue.inject(F("M24")));
+              TERN_(HAS_MEDIA, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           Draw_Print_Screen();
         }
         else
           Popup_Handler(Pause);
         break;
@@ -4420,21 +4420,21 @@ void CrealityDWINClass::Popup_Control() {
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
       case Pause:
         if (selection == 0) {
           if (sdprint) {
             #if ENABLED(POWER_LOSS_RECOVERY)
               if (recovery.enabled) recovery.save(true);
             #endif
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               Popup_Handler(Home, true);
-              #if ENABLED(SDSUPPORT)
+              #if HAS_MEDIA
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
               queue.inject(F("M125"));
               planner.synchronize();
             #else
               queue.inject(F("M25"));
               TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
               TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);

commit 48b712fdc013cfbda94bc1e2452e4538999916a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 18:00:25 2023 -0500

    🧑‍💻 JyersUI code cleanup

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 285723e278..a24adec8e9 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -370,21 +370,21 @@ private:
 
     float get_min_value() {
       float min = __FLT_MAX__;
       GRID_LOOP(x, y) {
         if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
           min = bedlevel.z_values[x][y];
       }
       return min;
     }
 
-    void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
+    void Draw_Bed_Mesh(const int16_t selected=-1, const uint8_t gridline_width=1, const uint16_t padding_x=8, const uint16_t padding_y_top=40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
                      cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
                      cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
       const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
       DWIN_Draw_Rectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / (GRID_MAX_POINTS_X);
@@ -463,156 +463,156 @@ private:
 
 struct CrealityDWINClass::EEPROM_Settings CrealityDWINClass::eeprom_settings{0};
 constexpr const char * const CrealityDWINClass::color_names[11];
 constexpr const char * const CrealityDWINClass::preheat_modes[3];
 
 // Clear a part of the screen
 //  4=Entire screen
 //  3=Title bar and Menu area (default)
 //  2=Menu area
 //  1=Title bar
-void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
+void CrealityDWINClass::Clear_Screen(const uint8_t e/*=3*/) {
   if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
   if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
   if (e == 4) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
 }
 
-void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
+void CrealityDWINClass::Draw_Float(const_float_t value, const uint8_t row, const bool selected/*=false*/, const uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
-  const uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
+  const uint16_t bColor = selected ? Select_Color : Color_Bg_Black;
   const uint16_t xpos = 240 - (digits * 8);
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
     DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
     DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
     DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
-void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
-  uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black,
-           tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
+void CrealityDWINClass::Draw_Option(const uint8_t value, const char * const * options, const uint8_t row, const bool selected/*=false*/, const bool color/*=false*/) {
+  const uint16_t bColor = selected ? Select_Color : Color_Bg_Black,
+                 tColor = color ? GetColor(value, Color_White, false) : Color_White;
   DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
   DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
-uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
+uint16_t CrealityDWINClass::GetColor(const uint8_t color, const uint16_t original, const bool light/*=false*/) {
   switch (color) {
     case Default:
       return original;
       break;
     case White:
-      return (light) ? Color_Light_White : Color_White;
+      return light ? Color_Light_White : Color_White;
       break;
     case Green:
-      return (light) ? Color_Light_Green : Color_Green;
+      return light ? Color_Light_Green : Color_Green;
       break;
     case Cyan:
-      return (light) ? Color_Light_Cyan : Color_Cyan;
+      return light ? Color_Light_Cyan : Color_Cyan;
       break;
     case Blue:
-      return (light) ? Color_Light_Blue : Color_Blue;
+      return light ? Color_Light_Blue : Color_Blue;
       break;
     case Magenta:
-      return (light) ? Color_Light_Magenta : Color_Magenta;
+      return light ? Color_Light_Magenta : Color_Magenta;
       break;
     case Red:
-      return (light) ? Color_Light_Red : Color_Red;
+      return light ? Color_Light_Red : Color_Red;
       break;
     case Orange:
-      return (light) ? Color_Light_Orange : Color_Orange;
+      return light ? Color_Light_Orange : Color_Orange;
       break;
     case Yellow:
-      return (light) ? Color_Light_Yellow : Color_Yellow;
+      return light ? Color_Light_Yellow : Color_Yellow;
       break;
     case Brown:
-      return (light) ? Color_Light_Brown : Color_Brown;
+      return light ? Color_Light_Brown : Color_Brown;
       break;
     case Black:
       return Color_Black;
       break;
   }
   return Color_White;
 }
 
-void CrealityDWINClass::Draw_Title(const char * ctitle) {
+void CrealityDWINClass::Draw_Title(const char * const ctitle) {
   DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
 }
 void CrealityDWINClass::Draw_Title(FSTR_P const ftitle) {
   DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
 }
 
 void _Decorate_Menu_Item(uint8_t row, uint8_t icon, bool more) {
   if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
   if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
   DWIN_Draw_Line(CrealityDWIN.GetColor(CrealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
-void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
+void CrealityDWINClass::Draw_Menu_Item(const uint8_t row, const uint8_t icon/*=0*/, const char * const label1, const char * const label2, const bool more/*=false*/, const bool centered/*=false*/) {
   const uint8_t label_offset_y = (label1 || label2) ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
   if (label1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
   if (label2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
   _Decorate_Menu_Item(row, icon, more);
 }
 
-void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, bool more/*=false*/, bool centered/*=false*/) {
+void CrealityDWINClass::Draw_Menu_Item(const uint8_t row, const uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, const bool more/*=false*/, const bool centered/*=false*/) {
   const uint8_t label_offset_y = (flabel1 || flabel2) ? MENU_CHR_H * 3 / 5 : 0,
                 label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
                 label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
   if (flabel1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
   if (flabel2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
   _Decorate_Menu_Item(row, icon, more);
 }
 
-void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
+void CrealityDWINClass::Draw_Checkbox(const uint8_t row, const bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
     DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     DWIN_Draw_Rectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     if (value) {
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
     }
   #endif
 }
 
-void CrealityDWINClass::Draw_Menu(uint8_t menu, uint8_t select/*=0*/, uint8_t scroll/*=0*/) {
+void CrealityDWINClass::Draw_Menu(const uint8_t menu, const uint8_t select/*=0*/, const uint8_t scroll/*=0*/) {
   if (active_menu != menu) {
     last_menu = active_menu;
     if (process == Menu) last_selection = selection;
   }
   selection = _MIN(select, Get_Menu_Size(menu));
   scrollpos = scroll;
   if (selection - scrollpos > MROWS)
     scrollpos = selection - MROWS;
   process = Menu;
   active_menu = menu;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(menu));
   LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
 
-void CrealityDWINClass::Redraw_Menu(bool lastprocess/*=true*/, bool lastselection/*=false*/, bool lastmenu/*=false*/) {
-  switch ((lastprocess) ? last_process : process) {
+void CrealityDWINClass::Redraw_Menu(const bool lastproc/*=true*/, const bool lastsel/*=false*/, const bool lastmenu/*=false*/) {
+  switch (lastproc ? last_process : process) {
     case Menu:
-      Draw_Menu((lastmenu) ? last_menu : active_menu, (lastselection) ? last_selection : selection, (lastmenu) ? 0 : scrollpos);
+      Draw_Menu(lastmenu ? last_menu : active_menu, lastsel ? last_selection : selection, lastmenu ? 0 : scrollpos);
       break;
-    case Main:  Draw_Main_Menu((lastselection) ? last_selection : selection); break;
+    case Main:  Draw_Main_Menu(lastsel ? last_selection : selection); break;
     case Print: Draw_Print_Screen(); break;
     case File:  Draw_SD_List(); break;
     default: break;
   }
 }
 
 void CrealityDWINClass::Redraw_Screen() {
   Redraw_Menu(false);
   Draw_Status_Area(true);
   Update_Status_Bar(true);
@@ -664,21 +664,21 @@ void CrealityDWINClass::Main_Menu_Icons() {
       DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
       DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
     else {
       DWIN_ICON_Show(ICON, ICON_Info_0, 145, 246);
       DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
   #endif
 }
 
-void CrealityDWINClass::Draw_Main_Menu(uint8_t select/*=0*/) {
+void CrealityDWINClass::Draw_Main_Menu(const uint8_t select/*=0*/) {
   process = Main;
   active_menu = MainMenu;
   selection = select;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
   DWIN_ICON_Show(ICON, ICON_LOGO, 71, 72);
   Main_Menu_Icons();
 }
 
@@ -796,60 +796,60 @@ void CrealityDWINClass::Draw_Print_ProgressElapsed() {
 void CrealityDWINClass::Draw_Print_confirm() {
   Draw_Print_Screen();
   process = Confirm;
   popup = Complete;
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
   DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
 }
 
-void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
+void CrealityDWINClass::Draw_SD_Item(const uint8_t item, const uint8_t row) {
   if (item == 0)
     Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
   else {
     card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
     LOOP_L_N(i, len) name[i] = filename[i];
     if (pos > max)
       LOOP_S_L_N(i, len - 3, len) name[i] = '.';
     name[len] = '\0';
     Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
-void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
+void CrealityDWINClass::Draw_SD_List(const bool removed/*=false*/) {
   Clear_Screen();
   Draw_Title("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
     LOOP_L_N(i, _MIN(card.get_num_items() + 1, TROWS))
       Draw_SD_Item(i, i);
   }
   else {
     Draw_Menu_Item(0, ICON_Back, F("Back"));
     DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
-void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
+void CrealityDWINClass::Draw_Status_Area(const bool icons/*=false*/) {
 
   if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
       DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
@@ -958,21 +958,21 @@ void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
     if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
     else
       DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
   }
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z : 0);
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, current_position.z >= 0 ? current_position.z : 0);
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
   if (process != Confirm && process != Popup && process != Wait) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
   Clear_Screen();
   DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
@@ -994,29 +994,29 @@ void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_
     DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
   }
 }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
   CrealityDWIN.Draw_Popup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
 }
 
 void CrealityDWINClass::Popup_Select() {
-  const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
-                 c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
+  const uint16_t c1 = selection ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White),
+                 c2 = selection ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window;
   DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
   DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
   DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
   DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
 }
 
-void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
+void CrealityDWINClass::Update_Status_Bar(const bool refresh/*=false*/) {
   typedef TextScroller<30> Scroller;
   static bool new_msg;
   static Scroller scroller;
   static char lastmsg[64];
   if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
     strcpy(lastmsg, statusmsg);
     scroller.reset();
     new_msg = true;
   }
   Scroller::Buffer buf;
@@ -1032,21 +1032,21 @@ void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
     else {
       DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
       const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
       DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
     }
   }
 }
 
 /* Menu Item Config */
 
-void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
+void CrealityDWINClass::Menu_Item_Handler(const uint8_t menu, const uint8_t item, bool draw/*=true*/) {
   const uint8_t row = item - scrollpos;
   #if HAS_LEVELING
     static bool level_state;
   #endif
 
   #if HAS_PREHEAT
 
     #define PREHEAT_BACK 0
     #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
     #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
@@ -1192,21 +1192,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             if (draw)
               Draw_Menu_Item(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
             else
               Draw_Menu(MenuCustom);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament")
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 Draw_Menu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
@@ -1730,58 +1730,58 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         switch (item) {
           case CHANGEFIL_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Filament"));
+              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Filament"));
+              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
@@ -3798,21 +3798,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               zoffsetvalue -= 0.01;
               Draw_Float(zoffsetvalue, row - 2, false, 100);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else
               Popup_Handler(ConfFilChange);
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
               Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
               Draw_Checkbox(row, runout.enabled);
@@ -3924,98 +3924,98 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             else
               Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
 
-FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
+FSTR_P CrealityDWINClass::Get_Menu_Title(const uint8_t menu) {
   switch (menu) {
-    case MainMenu:          return F("Main Menu");
-    case Prepare:           return F("Prepare");
+    case MainMenu:          return GET_TEXT_F(MSG_MAIN_MENU);
+    case Prepare:           return GET_TEXT_F(MSG_PREPARE);
     case HomeMenu:          return F("Homing Menu");
-    case Move:              return F("Move");
-    case ManualLevel:       return F("Manual Leveling");
+    case Move:              return GET_TEXT_F(MSG_MOVE_AXIS);
+    case ManualLevel:       return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
     #if HAS_ZOFFSET_ITEM
-      case ZOffset:         return F("Z Offset");
+      case ZOffset:         return GET_TEXT_F(MSG_ZPROBE_ZOFFSET);
     #endif
     #if HAS_PREHEAT
       case Preheat:         return F("Preheat");
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return F("Change Filament");
+      case ChangeFilament:  return GET_TEXT_F(MSG_FILAMENTCHANGE);
     #endif
     #if HAS_CUSTOM_MENU
       case MenuCustom:
         #ifdef CUSTOM_MENU_CONFIG_TITLE
           return F(CUSTOM_MENU_CONFIG_TITLE);
         #else
-          return F("Custom Commands");
+          return GET_TEXT_F(MSG_CUSTOM_COMMANDS);
         #endif
     #endif
-    case Control:           return F("Control");
-    case TempMenu:          return F("Temperature");
+    case Control:           return GET_TEXT_F(MSG_CONTROL);
+    case TempMenu:          return GET_TEXT_F(MSG_TEMPERATURE);
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return F("PID Menu");
     #endif
     #if HAS_HOTEND
       case HotendPID:       return F("Hotend PID Settings");
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return F("Bed PID Settings");
     #endif
     #if HAS_PREHEAT
       #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
     case Motion:            return F("Motion Settings");
     case HomeOffsets:       return F("Home Offsets");
     case MaxSpeed:          return F("Max Speed");
     case MaxAcceleration:   return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return F("Max Jerk");
     #endif
-    case Steps:             return F("Steps/mm");
+    case Steps:             return GET_TEXT_F(MSG_STEPS_PER_MM);
     case Visual:            return F("Visual Settings");
-    case Advanced:          return F("Advanced Settings");
+    case Advanced:          return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
     #if HAS_BED_PROBE
       case ProbeMenu:       return F("Bed Probe");
     #endif
     #if HAS_TRINAMIC_CONFIG
-      case TMCMenu:         return F("TMC Drivers");
+      case TMCMenu:         return GET_TEXT_F(MSG_TMC_DRIVERS);
     #endif
     case ColorSettings:     return F("UI Color Settings");
     case Info:              return F("Info");
     case InfoMain:          return F("Info");
     #if HAS_MESH
       case Leveling:        return F("Leveling");
       case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelSettings:   return F("Leveling Settings");
       case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelManual:     return F("Manual Tuning");
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case UBLMesh:         return F("UBL Bed Leveling");
     #endif
     #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return F("Mesh Bed Leveling");
+      case ManualMesh:      return GET_TEXT_F(MSG_MANUAL_LEVELING);
     #endif
-    case Tune:              return F("Tune");
-    case PreheatHotend:     return F("Preheat Hotend");
+    case Tune:              return GET_TEXT_F(MSG_TUNE);
+    case PreheatHotend:     return GET_TEXT_F(MSG_PREHEAT_HOTEND);
   }
   return F("");
 }
 
-uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
+uint8_t CrealityDWINClass::Get_Menu_Size(const uint8_t menu) {
   switch (menu) {
     case Prepare:           return PREPARE_TOTAL;
     case HomeMenu:          return HOME_TOTAL;
     case Move:              return MOVE_TOTAL;
     case ManualLevel:       return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return ZOFFSET_TOTAL;
     #endif
     #if HAS_PREHEAT
       case Preheat:         return PREHEAT_TOTAL;
@@ -4078,21 +4078,21 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
       case PreheatHotend:   return PREHEATHOTEND_TOTAL;
     #endif
 
     case ColorSettings:     return COLORSETTINGS_TOTAL;
   }
   return 0;
 }
 
 /* Popup Config */
 
-void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
+void CrealityDWINClass::Popup_Handler(const PopupID popupid, const bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
     case Pause:         Draw_Popup(F("Pause Print"), F(""), F(""), Popup); break;
     case Stop:          Draw_Popup(F("Stop Print"), F(""), F(""), Popup); break;
     case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
     case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
     case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
     case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
     case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
     case ETemp:         Draw_Popup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
@@ -4515,21 +4515,21 @@ void CrealityDWINClass::Popup_Control() {
             Redraw_Menu(true, true, false);
           break;
         case PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
             Popup_Handler(FilChange);
           }
           else {
             pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
             if (printing) Popup_Handler(Resuming);
-            else Redraw_Menu(true, true, (active_menu==PreheatHotend));
+            else Redraw_Menu(true, true, active_menu == PreheatHotend);
           }
           break;
       #endif // ADVANCED_PAUSE_FEATURE
 
       #if HAS_MESH
         case SaveLevel:
           if (selection == 0) {
             #if ENABLED(AUTO_BED_LEVELING_UBL)
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
@@ -4574,68 +4574,68 @@ void CrealityDWINClass::Confirm_Control() {
         Redraw_Menu(true, true, false);
         wait_for_user = false;
         break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 /* In-Menu Value Modification */
 
-void CrealityDWINClass::Setup_Value(float value, float min, float max, float unit, uint8_t type) {
+void CrealityDWINClass::Setup_Value(const_float_t value, const_float_t min, const_float_t max, const_float_t unit, const uint8_t type) {
   if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
     tempvalue = unscalePID_i(value) * unit;
   else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
     tempvalue = unscalePID_d(value) * unit;
   else
     tempvalue = value * unit;
   valuemin = min;
   valuemax = max;
   valueunit = unit;
   valuetype = type;
   process = Value;
   EncoderRate.enabled = true;
   Draw_Float(tempvalue / unit, selection - scrollpos, true, valueunit);
 }
 
-void CrealityDWINClass::Modify_Value(float &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+void CrealityDWINClass::Modify_Value(float &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   Setup_Value((float)value, min, max, unit, 0);
 }
-void CrealityDWINClass::Modify_Value(uint8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+void CrealityDWINClass::Modify_Value(uint8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   Setup_Value((float)value, min, max, unit, 1);
 }
-void CrealityDWINClass::Modify_Value(uint16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+void CrealityDWINClass::Modify_Value(uint16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   Setup_Value((float)value, min, max, unit, 2);
 }
-void CrealityDWINClass::Modify_Value(int16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+void CrealityDWINClass::Modify_Value(int16_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   Setup_Value((float)value, min, max, unit, 3);
 }
-void CrealityDWINClass::Modify_Value(uint32_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+void CrealityDWINClass::Modify_Value(uint32_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   Setup_Value((float)value, min, max, unit, 4);
 }
-void CrealityDWINClass::Modify_Value(int8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+void CrealityDWINClass::Modify_Value(int8_t &value, const_float_t min, const_float_t max, const_float_t unit, void (*f)()/*=nullptr*/) {
   valuepointer = &value;
   funcpointer = f;
   Setup_Value((float)value, min, max, unit, 5);
 }
 
-void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * options, uint8_t max) {
+void CrealityDWINClass::Modify_Option(const uint8_t value, const char * const * options, const uint8_t max) {
   tempvalue = value;
   valuepointer = const_cast<const char * *>(options);
   valuemin = 0;
   valuemax = max;
   process = Option;
   EncoderRate.enabled = true;
   Draw_Option(value, options, selection - scrollpos, true);
 }
 
 /* Main Functions */
@@ -4645,21 +4645,21 @@ void CrealityDWINClass::Update_Status(const char * const text) {
     LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
     filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
     Draw_Print_Filename(true);
   }
   else {
     LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
-void CrealityDWINClass::Start_Print(bool sd) {
+void CrealityDWINClass::Start_Print(const bool sd) {
   sdprint = sd;
   if (!printing) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {
       #if ENABLED(POWER_LOSS_RECOVERY)
         if (recovery.valid()) {
           MediaFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
@@ -4716,21 +4716,21 @@ void CrealityDWINClass::State_Update() {
     if (process == Wait && !paused) Redraw_Menu(true, true);
   }
   if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
     Confirm_Handler(UserInput);
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     if (process == Popup && popup == PurgeMore) {
       if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
         Popup_Handler(FilChange);
       else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
         if (printing) Popup_Handler(Resuming);
-        else Redraw_Menu(true, true, (active_menu==PreheatHotend));
+        else Redraw_Menu(true, true, active_menu == PreheatHotend);
       }
     }
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     static bool ranout = false;
     if (runout.filament_ran_out != ranout) {
       ranout = runout.filament_ran_out;
       if (ranout) Popup_Handler(Runout);
     }
   #endif
@@ -4862,27 +4862,27 @@ void CrealityDWINClass::Screen_Update() {
   }
 }
 
 void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
   if (ui.sound_on)
     DONE_BUZZ(success);
   else
     Update_Status(success ? "Success" : "Failed");
 }
 
-void CrealityDWINClass::Save_Settings(char *buff) {
+void CrealityDWINClass::Save_Settings(char * const buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
 
-void CrealityDWINClass::Load_Settings(const char *buff) {
+void CrealityDWINClass::Load_Settings(const char * const buff) {
   memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
   corner_pos = eeprom_settings.corner_pos / 10.0f;
   Redraw_Screen();
   #if ENABLED(POWER_LOSS_RECOVERY)
     static bool init = true;
     if (init) {
       init = false;
       queue.inject(F("M1000 S"));

commit 06e5273d24776219253a9229621c034ab263cba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 18:18:25 2023 -0500

    🧑‍💻 CardReader adjustments (#25611)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index d4b4280671..285723e278 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -800,21 +800,21 @@ void CrealityDWINClass::Draw_Print_confirm() {
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
   DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
 }
 
 void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
   if (item == 0)
     Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
   else {
-    card.getfilename_sorted(SD_ORDER(item - 1, card.get_num_Files()));
+    card.selectFileByIndexSorted(item - 1);
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
     LOOP_L_N(i, len) name[i] = filename[i];
     if (pos > max)
@@ -824,21 +824,21 @@ void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
   }
 }
 
 void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
   Clear_Screen();
   Draw_Title("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
-    LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
+    LOOP_L_N(i, _MIN(card.get_num_items() + 1, TROWS))
       Draw_SD_Item(i, i);
   }
   else {
     Draw_Menu_Item(0, ICON_Back, F("Back"));
     DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
@@ -4274,40 +4274,40 @@ void CrealityDWINClass::Option_Control() {
   Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::File_Control() {
   typedef TextScroller<MENU_CHAR_LIMIT> Scroller;
   static Scroller scroller;
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) {
     if (selection > 0) {
-      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
+      card.selectFileByIndexSorted(selection - 1);
       char * const filename = card.longest_filename();
       size_t len = strlen(filename);
       size_t pos = len;
       if (!card.flag.filenameIsDir)
         while (pos && filename[pos] != '.') pos--;
       if (pos > MENU_CHAR_LIMIT) {
         static millis_t time = 0;
         if (PENDING(millis(), time)) return;
         time = millis() + 200;
         Scroller::Buffer buf;
         const char* const name = scroller.scroll(pos, buf, filename);
         DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
         Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
         DWIN_UpdateLCD();
       }
     }
     return;
   }
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_Files()) {
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_items()) {
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     if (selection > 0) {
       DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
       Draw_SD_Item(selection, selection - scrollpos);
     }
     scroller.reset();
     selection++; // Select Down
     if (selection > scrollpos + MROWS) {
       scrollpos++;
       DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
@@ -4333,21 +4333,21 @@ void CrealityDWINClass::File_Control() {
       if (card.flag.workDirIsRoot) {
         process = Main;
         Draw_Main_Menu();
       }
       else {
         card.cdup();
         Draw_SD_List();
       }
     }
     else {
-      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
+      card.selectFileByIndexSorted(selection - 1);
       if (card.flag.filenameIsDir) {
         card.cd(card.filename);
         Draw_SD_List();
       }
       else {
         card.openAndPrintFile(card.filename);
       }
     }
   }
   DWIN_UpdateLCD();

commit a8ac83bbca1b6aed52e6cfa9a7b219cadd8c20b7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 29 22:34:07 2023 -0500

    🐛 Fix _HAS_FAN for fan on Pin 0

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index d90e4df5af..d4b4280671 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -31,21 +31,20 @@
 #include "dwin.h"
 
 #include "../../marlinui.h"
 #include "../../../MarlinCore.h"
 
 #include "../../../gcode/gcode.h"
 #include "../../../module/temperature.h"
 #include "../../../module/planner.h"
 #include "../../../module/settings.h"
 #include "../../../libs/buzzer.h"
-#include "../../../inc/Conditionals_post.h"
 
 //#define DEBUG_OUT 1
 #include "../../../core/debug_out.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../../../feature/pause.h"
 #endif
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   #include "../../../feature/runout.h"

commit 6a8ebdcd5093a8fb393356dc0c1ee2a894576fdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 29 21:50:04 2023 -0500

    🩹 Fix Ender-3 V2 with no fan

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 3f13fe8b3b..d90e4df5af 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -3855,21 +3855,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
         #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
         #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
 
         switch (item) {
           case PREHEATHOTEND_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Cancel"));
             else {
               thermalManager.setTargetHotend(0, 0);
-              thermalManager.set_fan_speed(0, 0);
+              TERN_(HAS_FAN, thermalManager.set_fan_speed(0, 0));
               Redraw_Menu(false, true, true);
             }
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
               Draw_Menu_Item(row, ICON_SetEndTemp, F("Continue"));
             else {
               Popup_Handler(Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
@@ -4467,21 +4467,21 @@ void CrealityDWINClass::Popup_Control() {
         else {
           queue.inject(F("M1000 C"));
           Draw_Main_Menu();
         }
         break;
 
       #if HAS_HOTEND
         case ETemp:
           if (selection == 0) {
             thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
-            thermalManager.set_fan_speed(0, MAX_FAN_SPEED);
+            TERN_(HAS_FAN, thermalManager.set_fan_speed(0, MAX_FAN_SPEED));
             Draw_Menu(PreheatHotend);
           }
           else
             Redraw_Menu(true, true, false);
           break;
       #endif
 
       #if HAS_BED_PROBE
         case ManualProbing:
           if (selection == 0) {

commit acfde4e7e5e1fc4ad46a26700f25a6e60e325967
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 23 21:38:11 2023 -0600

    🎨 Use LIMIT macro

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 8894150c98..3f13fe8b3b 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4222,22 +4222,21 @@ void CrealityDWINClass::Value_Control() {
           planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
           planner.synchronize();
           break;
         case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
         case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
       #endif
     }
     if (funcpointer) funcpointer();
     return;
   }
-  NOLESS(tempvalue, (valuemin * valueunit));
-  NOMORE(tempvalue, (valuemax * valueunit));
+  LIMIT(tempvalue, valuemin * valueunit, valuemax * valueunit);
   Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
   DWIN_UpdateLCD();
   if (active_menu == Move && livemove) {
     *(float*)valuepointer = tempvalue / valueunit;
     planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
   }
 }
 
 void CrealityDWINClass::Option_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
@@ -4265,22 +4264,21 @@ void CrealityDWINClass::Option_Control() {
       }
       Redraw_Screen();
     }
     else if (valuepointer == &preheat_modes)
       preheatmode = tempvalue;
 
     Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
     DWIN_UpdateLCD();
     return;
   }
-  NOLESS(tempvalue, valuemin);
-  NOMORE(tempvalue, valuemax);
+  LIMIT(tempvalue, valuemin, valuemax);
   Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::File_Control() {
   typedef TextScroller<MENU_CHAR_LIMIT> Scroller;
   static Scroller scroller;
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) {
     if (selection > 0) {

commit 218ca0530432d6b1194ccac5fc32a72bbc9a7c96
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Feb 4 05:10:26 2023 -0300

    🧑‍💻 General 'MediaFile' type alias (#24424)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 0f78e58ef5..8894150c98 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4656,21 +4656,21 @@ void CrealityDWINClass::Update_Status(const char * const text) {
 }
 
 void CrealityDWINClass::Start_Print(bool sd) {
   sdprint = sd;
   if (!printing) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {
       #if ENABLED(POWER_LOSS_RECOVERY)
         if (recovery.valid()) {
-          SdFile *diveDir = nullptr;
+          MediaFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
         }
       #endif
       strcpy(filename, card.longest_filename());
     }
     else
       strcpy_P(filename, PSTR("Host Print"));
     TERN_(SET_PROGRESS_PERCENT, ui.set_progress(0));
     TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));

commit 0e72c90f49c8262fac0e6eafa9dde7d20acfe5fc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 3 19:40:23 2023 -0600

    🧑‍💻 Add Temperature::is_above_target

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index cf0d6dc8fc..0f78e58ef5 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1206,21 +1206,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 Draw_Menu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                   Popup_Handler(ETemp);
                 else {
-                  if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                  if (thermalManager.temp_hotend[0].is_below_target(2)) {
                     Popup_Handler(Heating);
                     thermalManager.wait_for_hotend(0);
                   }
                   Popup_Handler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                   gcode.process_subcommands_now(cmd);
                 }
               #endif
             }
             break;
@@ -1349,21 +1349,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_Extruder, F("Extruder"));
               current_position.e = 0;
               sync_plan_position();
               Draw_Float(current_position.e, row);
             }
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                   Redraw_Menu();
                 }
                 current_position.e = 0;
                 sync_plan_position();
                 Modify_Value(current_position.e, -500, 500, 10);
               }
             }
           break;
@@ -1736,58 +1736,58 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             else
               Draw_Menu(Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
               Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                if (thermalManager.temp_hotend[0].is_below_target(2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                 gcode.process_subcommands_now(cmd);
               }
             }
             break;
         }
@@ -4498,21 +4498,21 @@ void CrealityDWINClass::Popup_Control() {
           }
           break;
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         case ConfFilChange:
           if (selection == 0) {
             if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
               Popup_Handler(ETemp);
             else {
-              if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+              if (thermalManager.temp_hotend[0].is_below_target(2)) {
                 Popup_Handler(Heating);
                 thermalManager.wait_for_hotend(0);
               }
               Popup_Handler(FilChange);
               sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
               gcode.process_subcommands_now(cmd);
             }
           }
           else
             Redraw_Menu(true, true, false);

commit 1c045defa95faed744660469733e3d80f51cae0f
Author: Krzysztof Błażewicz <blazewicz.krzysztof@gmail.com>
Date:   Sun Dec 11 20:27:27 2022 +0100

    ✨ JyersUI TMC Settings (#25048)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index cba90c7ac5..cf0d6dc8fc 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -73,20 +73,27 @@
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
+#if HAS_TRINAMIC_CONFIG
+  #include "../../../module/stepper/trinamic.h"
+
+  #define TMC_MIN_CURRENT 400
+  #define TMC_MAX_CURRENT 1500
+#endif
+
 #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 
 #define DWIN_FONT_MENU font8x16
 #define DWIN_FONT_STAT font10x20
 #define DWIN_FONT_HEAD font10x20
 
 #define MENU_CHAR_LIMIT  24
 #define STATUS_Y 352
 
 #define MAX_PRINT_SPEED   500
@@ -2288,21 +2295,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           else
             Draw_Menu(Steps);
           break;
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
               Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
               Draw_Float(planner.flow_percentage[0], row, false, 1);
             }
             else
-              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
+              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
         #endif
       }
       break;
 
     case HomeOffsets:
 
       #define HOMEOFFSETS_BACK 0
       #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
       #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
@@ -2713,21 +2720,22 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
           break;
       } // switch (item)
       break;
 
     case Advanced:
 
       #define ADVANCED_BACK 0
       #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
       #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
-      #define ADVANCED_CORNER (ADVANCED_PROBE + 1)
+      #define ADVANCED_TMC (ADVANCED_PROBE + ENABLED(HAS_TRINAMIC_CONFIG))
+      #define ADVANCED_CORNER (ADVANCED_TMC + 1)
       #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
       #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
       #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
 
       switch (item) {
@@ -2753,20 +2761,29 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
               Draw_Menu_Item(row, ICON_StepX, F("Probe"), nullptr, true);
             else
               Draw_Menu(ProbeMenu);
             break;
         #endif
 
+        #if HAS_TRINAMIC_CONFIG
+          case ADVANCED_TMC:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Motion, F("TMC Drivers"), nullptr, true);
+            else
+              Draw_Menu(TMCMenu);
+            break;
+        #endif
+
         case ADVANCED_CORNER:
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
             Draw_Float(corner_pos, row, false, 10);
           }
           else
             Modify_Value(corner_pos, 1, 100, 10);
           break;
 
         #if ENABLED(LIN_ADVANCE)
@@ -2898,21 +2915,107 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             case PROBE_TEST_COUNT:
               if (draw) {
                 Draw_Menu_Item(row, ICON_StepY, F("Probe Test Count"));
                 Draw_Float(testcount, row, false, 1);
               }
               else
                 Modify_Value(testcount, 4, 50, 1);
               break;
         }
         break;
-    #endif
+    #endif  // HAS_PROBE_MENU
+
+    #if HAS_TRINAMIC_CONFIG
+      case TMCMenu:
+
+        #define TMC_BACK 0
+        #define TMC_STEPPER_CURRENT_X (TMC_BACK + AXIS_IS_TMC(X))
+        #define TMC_STEPPER_CURRENT_Y (TMC_STEPPER_CURRENT_X + AXIS_IS_TMC(Y))
+        #define TMC_STEPPER_CURRENT_Z (TMC_STEPPER_CURRENT_Y + AXIS_IS_TMC(Z))
+        #define TMC_STEPPER_CURRENT_E (TMC_STEPPER_CURRENT_Z + AXIS_IS_TMC(E0))
+        #define TMC_TOTAL TMC_STEPPER_CURRENT_E
+
+        switch (item) {
+
+          case TMC_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Advanced, ADVANCED_TMC);
+            break;
+
+          #if AXIS_IS_TMC(X)
+            case TMC_STEPPER_CURRENT_X:
+
+              static float stepper_current_x;
+
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepX, F("Stepper X current"));
+                stepper_current_x = stepperX.getMilliamps();
+                Draw_Float(stepper_current_x, row, false, 1);
+              }
+              else {
+                Modify_Value(stepper_current_x, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperX.rms_current(stepper_current_x); });
+              }
+              break;
+          #endif
+
+          #if AXIS_IS_TMC(Y)
+            case TMC_STEPPER_CURRENT_Y:
+
+              static float stepper_current_y;
+
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepY, F("Stepper Y current"));
+                stepper_current_y = stepperY.getMilliamps();
+                Draw_Float(stepper_current_y, row, false, 1);
+              }
+              else {
+                Modify_Value(stepper_current_y, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperY.rms_current(stepper_current_y); });
+              }
+              break;
+          #endif
+
+          #if AXIS_IS_TMC(Z)
+            case TMC_STEPPER_CURRENT_Z:
+
+              static float stepper_current_z;
+
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepZ, F("Stepper Z current"));
+                stepper_current_z = stepperZ.getMilliamps();
+                Draw_Float(stepper_current_z, row, false, 1);
+              }
+              else {
+                Modify_Value(stepper_current_z, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperZ.rms_current(stepper_current_z); });
+              }
+              break;
+          #endif
+
+          #if AXIS_IS_TMC(E0)
+            case TMC_STEPPER_CURRENT_E:
+
+              static float stepper_current_e;
+
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepE, F("Stepper E current"));
+                stepper_current_e = stepperE0.getMilliamps();
+                Draw_Float(stepper_current_e, row, false, 1);
+              }
+              else {
+                Modify_Value(stepper_current_e, TMC_MIN_CURRENT, TMC_MAX_CURRENT, 1, []{ stepperE0.rms_current(stepper_current_e); });
+              }
+              break;
+          #endif
+        };
+        break;
+    #endif // HAS_TRINAMIC_CONFIG
 
     case InfoMain:
     case Info:
 
       #define INFO_BACK 0
       #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
       #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
       #define INFO_SIZE (INFO_PRINTTIME + 1)
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
@@ -3630,21 +3733,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
           break;
 
         #if HAS_HOTEND
           case TUNE_FLOW:
             if (draw) {
               Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
               Draw_Float(planner.flow_percentage[0], row, false, 1);
             }
             else
-              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
+              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1, []{ planner.refresh_e_factor(0); });
             break;
           case TUNE_HOTEND:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
@@ -3872,21 +3975,24 @@ FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
     case HomeOffsets:       return F("Home Offsets");
     case MaxSpeed:          return F("Max Speed");
     case MaxAcceleration:   return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return F("Max Jerk");
     #endif
     case Steps:             return F("Steps/mm");
     case Visual:            return F("Visual Settings");
     case Advanced:          return F("Advanced Settings");
     #if HAS_BED_PROBE
-      case ProbeMenu:       return F("Probe Menu");
+      case ProbeMenu:       return F("Bed Probe");
+    #endif
+    #if HAS_TRINAMIC_CONFIG
+      case TMCMenu:         return F("TMC Drivers");
     #endif
     case ColorSettings:     return F("UI Color Settings");
     case Info:              return F("Info");
     case InfoMain:          return F("Info");
     #if HAS_MESH
       case Leveling:        return F("Leveling");
       case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelSettings:   return F("Leveling Settings");
       case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelManual:     return F("Manual Tuning");
@@ -3942,20 +4048,23 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
     case MaxAcceleration:   return ACCEL_TOTAL;
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return JERK_TOTAL;
     #endif
     case Steps:             return STEPS_TOTAL;
     case Visual:            return VISUAL_TOTAL;
     case Advanced:          return ADVANCED_TOTAL;
     #if HAS_BED_PROBE
       case ProbeMenu:       return PROBE_TOTAL;
     #endif
+    #if HAS_TRINAMIC_CONFIG
+      case TMCMenu:         return TMC_TOTAL;
+    #endif
     case Info:              return INFO_TOTAL;
     case InfoMain:          return INFO_TOTAL;
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case UBLMesh:         return UBL_M_TOTAL;
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:      return MMESH_TOTAL;
     #endif
     #if HAS_MESH
       case Leveling:        return LEVELING_TOTAL;
@@ -4110,22 +4219,20 @@ void CrealityDWINClass::Value_Control() {
       #if HAS_MESH
         case ManualMesh:
           planner.synchronize();
           planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
           planner.synchronize();
           break;
         case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
         case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
       #endif
     }
-    if (valuepointer == &planner.flow_percentage[0])
-      planner.refresh_e_factor(0);
     if (funcpointer) funcpointer();
     return;
   }
   NOLESS(tempvalue, (valuemin * valueunit));
   NOMORE(tempvalue, (valuemax * valueunit));
   Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
   DWIN_UpdateLCD();
   if (active_menu == Move && livemove) {
     *(float*)valuepointer = tempvalue / valueunit;
     planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);

commit d123ea7346c4a72b08e82e7c876a97296d5c8090
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 11 16:09:26 2022 -0600

    🎨 Prefer axis element over index

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 21f93c6b98..cba90c7ac5 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2458,49 +2458,49 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         switch (item) {
           case JERK_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Motion, MOTION_JERK);
             break;
           case JERK_X:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
-              Draw_Float(planner.max_jerk[X_AXIS], row, false, 10);
+              Draw_Float(planner.max_jerk.x, row, false, 10);
             }
             else
-              Modify_Value(planner.max_jerk[X_AXIS], 0, default_max_jerk[X_AXIS] * 2, 10);
+              Modify_Value(planner.max_jerk.x, 0, default_max_jerk[X_AXIS] * 2, 10);
             break;
           case JERK_Y:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
-              Draw_Float(planner.max_jerk[Y_AXIS], row, false, 10);
+              Draw_Float(planner.max_jerk.y, row, false, 10);
             }
             else
-              Modify_Value(planner.max_jerk[Y_AXIS], 0, default_max_jerk[Y_AXIS] * 2, 10);
+              Modify_Value(planner.max_jerk.y, 0, default_max_jerk[Y_AXIS] * 2, 10);
             break;
           case JERK_Z:
             if (draw) {
               Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
-              Draw_Float(planner.max_jerk[Z_AXIS], row, false, 10);
+              Draw_Float(planner.max_jerk.z, row, false, 10);
             }
             else
-              Modify_Value(planner.max_jerk[Z_AXIS], 0, default_max_jerk[Z_AXIS] * 2, 10);
+              Modify_Value(planner.max_jerk.z, 0, default_max_jerk[Z_AXIS] * 2, 10);
             break;
           #if HAS_HOTEND
             case JERK_E:
               if (draw) {
                 Draw_Menu_Item(row, ICON_MaxSpeedJerkE, F("Extruder"));
-                Draw_Float(planner.max_jerk[E_AXIS], row, false, 10);
+                Draw_Float(planner.max_jerk.e, row, false, 10);
               }
               else
-                Modify_Value(planner.max_jerk[E_AXIS], 0, default_max_jerk[E_AXIS] * 2, 10);
+                Modify_Value(planner.max_jerk.e, 0, default_max_jerk[E_AXIS] * 2, 10);
               break;
           #endif
         }
         break;
     #endif
     case Steps:
 
       #define STEPS_BACK 0
       #define STEPS_X (STEPS_BACK + 1)
       #define STEPS_Y (STEPS_X + 1)

commit efde96131d9e9288dc2ea28b548f691a184fb33e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Oct 10 20:49:37 2022 +0200

    ✨ ADVANCE_K per-extruder (#24821)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index d6f3d859c6..21f93c6b98 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2765,21 +2765,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
             Draw_Float(corner_pos, row, false, 10);
           }
           else
             Modify_Value(corner_pos, 1, 100, 10);
           break;
 
         #if ENABLED(LIN_ADVANCE)
           case ADVANCED_LA:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccelerated, F("Lin Advance Kp"));
+              Draw_Menu_Item(row, ICON_MaxAccelerated, F("Lin Advance K"));
               Draw_Float(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case ADVANCED_LOAD:
             if (draw) {

commit f595e40ceb0c79d7f0d6438636658dfcfa2a75b8
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Oct 9 18:30:47 2022 +0300

    ♻️ Set Progress without LCD (#24767)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index df758da617..d6f3d859c6 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -726,21 +726,21 @@ void CrealityDWINClass::Draw_Print_Screen() {
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
   Draw_Title("Printing...");
   Print_Screen_Icons();
   DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
   DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
   DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
   DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
   Update_Status_Bar(true);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
-  TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
+  TERN_(SET_REMAINING_TIME, Draw_Print_ProgressRemain());
   Draw_Print_Filename(true);
 }
 
 void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
   typedef TextScroller<30> Scroller;
   static Scroller scroller;
   if (reset) scroller.reset();
   if (process == Print) {
     Scroller::Buffer buf;
     size_t outlen = 0;
@@ -752,21 +752,21 @@ void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
 }
 
 void CrealityDWINClass::Draw_Print_ProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
   DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
   DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
   DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
 }
 
-#if ENABLED(USE_M73_REMAINING_TIME)
+#if ENABLED(SET_REMAINING_TIME)
 
   void CrealityDWINClass::Draw_Print_ProgressRemain() {
     uint16_t remainingtime = ui.get_remaining_time();
     DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
     DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
     if (eeprom_settings.time_format_textual) {
       DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
       DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
     }
     else
@@ -4558,32 +4558,32 @@ void CrealityDWINClass::Start_Print(bool sd) {
         if (recovery.valid()) {
           SdFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
         }
       #endif
       strcpy(filename, card.longest_filename());
     }
     else
       strcpy_P(filename, PSTR("Host Print"));
-    TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
-    TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
+    TERN_(SET_PROGRESS_PERCENT, ui.set_progress(0));
+    TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
     Draw_Print_Screen();
   }
 }
 
 void CrealityDWINClass::Stop_Print() {
   printing = false;
   sdprint = false;
   thermalManager.cooldown();
-  TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(100 * (PROGRESS_SCALE)));
-  TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
+  TERN_(SET_PROGRESS_PERCENT, ui.set_progress(100 * (PROGRESS_SCALE)));
+  TERN_(SET_REMAINING_TIME, ui.set_remaining_time(0));
   Draw_Print_confirm();
 }
 
 void CrealityDWINClass::Update() {
   State_Update();
   Screen_Update();
   switch (process) {
     case Main:    Main_Menu_Control();    break;
     case Menu:    Menu_Control();         break;
     case Value:   Value_Control();        break;
@@ -4646,21 +4646,21 @@ void CrealityDWINClass::Screen_Update() {
     statustime = ms + 500;
     Draw_Status_Area();
   }
 
   static millis_t printtime = 0;
   if (ELAPSED(ms, printtime)) {
     printtime = ms + 1000;
     if (process == Print) {
       Draw_Print_ProgressBar();
       Draw_Print_ProgressElapsed();
-      TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
+      TERN_(SET_REMAINING_TIME, Draw_Print_ProgressRemain());
     }
   }
 
   static bool mounted = card.isMounted();
   if (mounted != card.isMounted()) {
     mounted = card.isMounted();
     if (process == File)
       Draw_SD_List();
   }
 

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    🐛 Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index b29ad9e63a..df758da617 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2133,37 +2133,37 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             if (draw) {
               Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
               Draw_Float(PID_e_temp, row, false, 1);
             }
             else
               Modify_Value(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
           case HOTENDPID_KP:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
-              Draw_Float(thermalManager.temp_hotend[0].pid.Kp, row, false, 100);
+              Draw_Float(thermalManager.temp_hotend[0].pid.p(), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KI:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
-              Draw_Float(unscalePID_i(thermalManager.temp_hotend[0].pid.Ki), row, false, 100);
+              Draw_Float(thermalManager.temp_hotend[0].pid.i(), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KD:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
-              Draw_Float(unscalePID_d(thermalManager.temp_hotend[0].pid.Kd), row, false, 100);
+              Draw_Float(thermalManager.temp_hotend[0].pid.d(), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
       case BedPID:
@@ -2200,38 +2200,38 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             if (draw) {
               Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
               Draw_Float(PID_bed_temp, row, false, 1);
             }
             else
               Modify_Value(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
           case BEDPID_KP:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
-              Draw_Float(thermalManager.temp_bed.pid.Kp, row, false, 100);
+              Draw_Float(thermalManager.temp_bed.pid.p(), row, false, 100);
             }
             else {
               Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             }
             break;
           case BEDPID_KI:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
-              Draw_Float(unscalePID_i(thermalManager.temp_bed.pid.Ki), row, false, 100);
+              Draw_Float(thermalManager.temp_bed.pid.i(), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case BEDPID_KD:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
-              Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
+              Draw_Float(thermalManager.temp_bed.pid.d(), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HEATED_BED
 
     #if HAS_PREHEAT
       #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;

commit 20c72845a01020349c068842750fb6883ba067a1
Author: Alexey Galakhov <agalakhov@gmail.com>
Date:   Mon Aug 22 17:11:53 2022 +0200

    🐛 Fix JyersUI (#24652)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 285013d750..b29ad9e63a 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -197,20 +197,69 @@ bool liveadjust = false;
 uint8_t preheatmode = 0;
 float zoffsetvalue = 0;
 uint8_t gridpoint;
 float corner_avg;
 float corner_pos;
 
 bool probe_deployed = false;
 
 CrealityDWINClass CrealityDWIN;
 
+template <unsigned N, unsigned S = N>
+class TextScroller {
+public:
+  static const unsigned SIZE = N;
+  static const unsigned SPACE = S;
+  typedef char Buffer[SIZE + 1];
+
+  inline TextScroller()
+    : scrollpos(0)
+  { }
+
+  inline void reset() {
+    scrollpos = 0;
+  }
+
+  const char* scroll(size_t& pos, Buffer &buf, const char * text, bool *updated = nullptr) {
+    const size_t len = strlen(text);
+    if (len > SIZE) {
+      if (updated) *updated = true;
+      if (scrollpos >= len + SPACE) scrollpos = 0;
+      pos = 0;
+      if (scrollpos < len) {
+        const size_t n = min(len - scrollpos, SIZE);
+        memcpy(buf, text + scrollpos, n);
+        pos += n;
+      }
+      if (pos < SIZE) {
+        const size_t n = min(len + SPACE - scrollpos, SIZE - pos);
+        memset(buf + pos, ' ', n);
+        pos += n;
+      }
+      if (pos < SIZE) {
+        const size_t n = SIZE - pos;
+        memcpy(buf + pos, text, n);
+        pos += n;
+      }
+      buf[pos] = '\0';
+      ++scrollpos;
+      return buf;
+    } else {
+      pos = len;
+      return text;
+    }
+  }
+
+private:
+  uint16_t scrollpos;
+};
+
 #if HAS_MESH
 
   struct Mesh_Settings {
     bool viewer_asymmetric_range = false;
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
@@ -682,45 +731,27 @@ void CrealityDWINClass::Draw_Print_Screen() {
   DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
   DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
   Update_Status_Bar(true);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
   Draw_Print_Filename(true);
 }
 
 void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
-  static uint8_t namescrl = 0;
-  if (reset) namescrl = 0;
+  typedef TextScroller<30> Scroller;
+  static Scroller scroller;
+  if (reset) scroller.reset();
   if (process == Print) {
-    constexpr int8_t maxlen = 30;
-    char *outstr = filename;
-    size_t slen = strlen(filename);
-    int8_t outlen = slen;
-    if (slen > maxlen) {
-      char dispname[maxlen + 1];
-      int8_t pos = slen - namescrl, len = maxlen;
-      if (pos >= 0) {
-        NOMORE(len, pos);
-        LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
-      }
-      else {
-        const int8_t mp = maxlen + pos;
-        LOOP_L_N(i, mp) dispname[i] = ' ';
-        LOOP_S_L_N(i, mp, maxlen) dispname[i] = filename[i - mp];
-        if (mp <= 0) namescrl = 0;
-      }
-      dispname[len] = '\0';
-      outstr = dispname;
-      outlen = maxlen;
-      namescrl++;
-    }
+    Scroller::Buffer buf;
+    size_t outlen = 0;
+    const char* outstr = scroller.scroll(outlen, buf, filename);
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
     const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
     DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
   }
 }
 
 void CrealityDWINClass::Draw_Print_ProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
   DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
@@ -966,71 +997,44 @@ void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
 void CrealityDWINClass::Popup_Select() {
   const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
                  c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
   DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
   DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
   DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
   DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
 }
 
 void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
+  typedef TextScroller<30> Scroller;
   static bool new_msg;
-  static uint8_t msgscrl = 0;
+  static Scroller scroller;
   static char lastmsg[64];
   if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
     strcpy(lastmsg, statusmsg);
-    msgscrl = 0;
+    scroller.reset();
     new_msg = true;
   }
-  size_t len = strlen(statusmsg);
-  int8_t pos = len;
-  if (pos > 30) {
-    pos -= msgscrl;
-    len = pos;
-    if (len > 30)
-      len = 30;
-    char dispmsg[len + 1];
-    if (pos >= 0) {
-      LOOP_L_N(i, len) dispmsg[i] = statusmsg[i + msgscrl];
-    }
-    else {
-      LOOP_L_N(i, 30 + pos) dispmsg[i] = ' ';
-      LOOP_S_L_N(i, 30 + pos, 30) dispmsg[i] = statusmsg[i - (30 + pos)];
-    }
-    dispmsg[len] = '\0';
+  Scroller::Buffer buf;
+  size_t len = 0;
+  const char* dispmsg = scroller.scroll(len, buf, statusmsg, &new_msg);
+  if (new_msg) {
+    new_msg = false;
     if (process == Print) {
       DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
-      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
       DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
     }
     else {
       DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
-      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      const int8_t npos = (DWIN_WIDTH - len * MENU_CHR_W) / 2;
       DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
     }
-    if (-pos >= 30) msgscrl = 0;
-    msgscrl++;
-  }
-  else {
-    if (new_msg) {
-      new_msg = false;
-      if (process == Print) {
-        DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
-        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, statusmsg);
-      }
-      else {
-        DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
-        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
-      }
-    }
   }
 }
 
 /* Menu Item Config */
 
 void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
   const uint8_t row = item - scrollpos;
   #if HAS_LEVELING
     static bool level_state;
   #endif
@@ -4161,74 +4165,64 @@ void CrealityDWINClass::Option_Control() {
     DWIN_UpdateLCD();
     return;
   }
   NOLESS(tempvalue, valuemin);
   NOMORE(tempvalue, valuemax);
   Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::File_Control() {
+  typedef TextScroller<MENU_CHAR_LIMIT> Scroller;
+  static Scroller scroller;
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  static uint8_t filescrl = 0;
   if (encoder_diffState == ENCODER_DIFF_NO) {
     if (selection > 0) {
       card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
       char * const filename = card.longest_filename();
       size_t len = strlen(filename);
-      int8_t pos = len;
+      size_t pos = len;
       if (!card.flag.filenameIsDir)
         while (pos && filename[pos] != '.') pos--;
       if (pos > MENU_CHAR_LIMIT) {
         static millis_t time = 0;
         if (PENDING(millis(), time)) return;
         time = millis() + 200;
-        pos -= filescrl;
-        len = _MIN(pos, MENU_CHAR_LIMIT);
-        char name[len + 1];
-        if (pos >= 0) {
-          LOOP_L_N(i, len) name[i] = filename[i + filescrl];
-        }
-        else {
-          LOOP_L_N(i, MENU_CHAR_LIMIT + pos) name[i] = ' ';
-          LOOP_S_L_N(i, MENU_CHAR_LIMIT + pos, MENU_CHAR_LIMIT) name[i] = filename[i - (MENU_CHAR_LIMIT + pos)];
-        }
-        name[len] = '\0';
+        Scroller::Buffer buf;
+        const char* const name = scroller.scroll(pos, buf, filename);
         DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
         Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
-        if (-pos >= MENU_CHAR_LIMIT) filescrl = 0;
-        filescrl++;
         DWIN_UpdateLCD();
       }
     }
     return;
   }
   if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_Files()) {
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     if (selection > 0) {
       DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
       Draw_SD_Item(selection, selection - scrollpos);
     }
-    filescrl = 0;
+    scroller.reset();
     selection++; // Select Down
     if (selection > scrollpos + MROWS) {
       scrollpos++;
       DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
       Draw_SD_Item(selection, selection - scrollpos);
     }
     DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
     Draw_SD_Item(selection, selection - scrollpos);
-    filescrl = 0;
+    scroller.reset();
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
       DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
       Draw_SD_Item(selection, selection - scrollpos);
     }
     DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     if (selection == 0) {

commit 007af4776880fda761e925bce383ac41a7769833
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 22 21:59:00 2022 -0500

    ✨ Reinstate JyersUI

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
new file mode 100644
index 0000000000..285013d750
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -0,0 +1,4848 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * lcd/e3v2/jyersui/dwin.cpp
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+
+#include "dwin.h"
+
+#include "../../marlinui.h"
+#include "../../../MarlinCore.h"
+
+#include "../../../gcode/gcode.h"
+#include "../../../module/temperature.h"
+#include "../../../module/planner.h"
+#include "../../../module/settings.h"
+#include "../../../libs/buzzer.h"
+#include "../../../inc/Conditionals_post.h"
+
+//#define DEBUG_OUT 1
+#include "../../../core/debug_out.h"
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../../../feature/pause.h"
+#endif
+
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #include "../../../feature/runout.h"
+#endif
+
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "../../../feature/host_actions.h"
+#endif
+
+#if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
+  #define HAS_ZOFFSET_ITEM 1
+#endif
+
+#ifndef strcasecmp_P
+  #define strcasecmp_P(a, b) strcasecmp((a), (b))
+#endif
+
+#if HAS_LEVELING
+  #include "../../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../../libs/least_squares_fit.h"
+  #include "../../../libs/vector_3.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../../module/probe.h"
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../../feature/powerloss.h"
+#endif
+
+#define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
+
+#define DWIN_FONT_MENU font8x16
+#define DWIN_FONT_STAT font10x20
+#define DWIN_FONT_HEAD font10x20
+
+#define MENU_CHAR_LIMIT  24
+#define STATUS_Y 352
+
+#define MAX_PRINT_SPEED   500
+#define MIN_PRINT_SPEED   10
+
+#if HAS_FAN
+  #define MAX_FAN_SPEED     255
+  #define MIN_FAN_SPEED     0
+#endif
+
+#define MAX_XY_OFFSET 100
+
+#if HAS_ZOFFSET_ITEM
+  #define MAX_Z_OFFSET 9.99
+  #if HAS_BED_PROBE
+    #define MIN_Z_OFFSET -9.99
+  #else
+    #define MIN_Z_OFFSET -1
+  #endif
+#endif
+
+#if HAS_HOTEND
+  #define MAX_FLOW_RATE   200
+  #define MIN_FLOW_RATE   10
+
+  #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+  #define MIN_E_TEMP    0
+#endif
+
+#if HAS_HEATED_BED
+  #define MAX_BED_TEMP  BED_MAXTEMP
+  #define MIN_BED_TEMP  0
+#endif
+
+/**
+ * Custom menu items with jyersLCD
+ */
+#if ENABLED(CUSTOM_MENU_CONFIG)
+  #ifdef CONFIG_MENU_ITEM_5_DESC
+    #define CUSTOM_MENU_COUNT 5
+  #elif defined(CONFIG_MENU_ITEM_4_DESC)
+    #define CUSTOM_MENU_COUNT 4
+  #elif defined(CONFIG_MENU_ITEM_3_DESC)
+    #define CUSTOM_MENU_COUNT 3
+  #elif defined(CONFIG_MENU_ITEM_2_DESC)
+    #define CUSTOM_MENU_COUNT 2
+  #elif defined(CONFIG_MENU_ITEM_1_DESC)
+    #define CUSTOM_MENU_COUNT 1
+  #endif
+  #if CUSTOM_MENU_COUNT
+    #define HAS_CUSTOM_MENU 1
+  #endif
+#endif
+
+constexpr uint16_t TROWS = 6, MROWS = TROWS - 1,
+                   TITLE_HEIGHT = 30,
+                   MLINE = 53,
+                   LBLX = 60,
+                   MENU_CHR_W = 8, MENU_CHR_H = 16, STAT_CHR_W = 10;
+
+#define MBASE(L) (49 + MLINE * (L))
+
+constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
+constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
+constexpr float default_steps[]               = DEFAULT_AXIS_STEPS_PER_UNIT;
+#if HAS_CLASSIC_JERK
+  constexpr float default_max_jerk[]            = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+#endif
+
+enum SelectItem : uint8_t {
+  PAGE_PRINT = 0,
+  PAGE_PREPARE,
+  PAGE_CONTROL,
+  PAGE_INFO_LEVELING,
+  PAGE_COUNT,
+
+  PRINT_SETUP = 0,
+  PRINT_PAUSE_RESUME,
+  PRINT_STOP,
+  PRINT_COUNT
+};
+
+uint8_t active_menu = MainMenu, last_menu = MainMenu;
+uint8_t selection = 0, last_selection = 0;
+uint8_t scrollpos = 0;
+uint8_t process = Main, last_process = Main;
+PopupID popup, last_popup;
+
+void (*funcpointer)() = nullptr;
+void *valuepointer = nullptr;
+float tempvalue;
+float valuemin;
+float valuemax;
+uint8_t valueunit;
+uint8_t valuetype;
+
+char cmd[MAX_CMD_SIZE+16], str_1[16], str_2[16], str_3[16];
+char statusmsg[64];
+char filename[LONG_FILENAME_LENGTH];
+bool printing = false;
+bool paused = false;
+bool sdprint = false;
+
+int16_t pausetemp, pausebed, pausefan;
+
+bool livemove = false;
+bool liveadjust = false;
+uint8_t preheatmode = 0;
+float zoffsetvalue = 0;
+uint8_t gridpoint;
+float corner_avg;
+float corner_pos;
+
+bool probe_deployed = false;
+
+CrealityDWINClass CrealityDWIN;
+
+#if HAS_MESH
+
+  struct Mesh_Settings {
+    bool viewer_asymmetric_range = false;
+    bool viewer_print_value = false;
+    bool goto_mesh_value = false;
+    bool drawing_mesh = false;
+    uint8_t mesh_x = 0;
+    uint8_t mesh_y = 0;
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      uint8_t tilt_grid = 1;
+
+      void manual_value_update(bool undefined=false) {
+        sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
+        gcode.process_subcommands_now(cmd);
+        planner.synchronize();
+      }
+
+      bool create_plane_from_mesh() {
+        struct linear_fit_data lsf_results;
+        incremental_LSF_reset(&lsf_results);
+        GRID_LOOP(x, y) {
+          if (!isnan(bedlevel.z_values[x][y])) {
+            xy_pos_t rpos = { bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) };
+            incremental_LSF(&lsf_results, rpos, bedlevel.z_values[x][y]);
+          }
+        }
+
+        if (finish_incremental_LSF(&lsf_results)) {
+          SERIAL_ECHOPGM("Could not complete LSF!");
+          return true;
+        }
+
+        bedlevel.set_all_mesh_points_to_value(0);
+
+        matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
+        GRID_LOOP(i, j) {
+          float mx = bedlevel.get_mesh_x(i),
+                my = bedlevel.get_mesh_y(j),
+                mz = bedlevel.z_values[i][j];
+
+          if (DEBUGGING(LEVELING)) {
+            DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(my, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(mz, 7);
+            DEBUG_ECHOPGM("]   ---> ");
+            DEBUG_DELAY(20);
+          }
+
+          rotation.apply_rotation_xyz(mx, my, mz);
+
+          if (DEBUGGING(LEVELING)) {
+            DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(my, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(mz, 7);
+            DEBUG_ECHOLNPGM("]");
+            DEBUG_DELAY(20);
+          }
+
+          bedlevel.z_values[i][j] = mz - lsf_results.D;
+        }
+        return false;
+      }
+
+    #else
+
+      void manual_value_update() {
+        sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
+        gcode.process_subcommands_now(cmd);
+        planner.synchronize();
+      }
+
+    #endif
+
+    void manual_mesh_move(const bool zmove=false) {
+      if (zmove) {
+        planner.synchronize();
+        current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+        planner.synchronize();
+      }
+      else {
+        CrealityDWIN.Popup_Handler(MoveWait);
+        sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
+        gcode.process_subcommands_now(cmd);
+        sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
+        gcode.process_subcommands_now(cmd);
+        planner.synchronize();
+        current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+        planner.synchronize();
+        CrealityDWIN.Redraw_Menu();
+      }
+    }
+
+    float get_max_value() {
+      float max = __FLT_MIN__;
+      GRID_LOOP(x, y) {
+        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
+          max = bedlevel.z_values[x][y];
+      }
+      return max;
+    }
+
+    float get_min_value() {
+      float min = __FLT_MAX__;
+      GRID_LOOP(x, y) {
+        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
+          min = bedlevel.z_values[x][y];
+      }
+      return min;
+    }
+
+    void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
+      drawing_mesh = true;
+      const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
+                     cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
+                     cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
+      const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
+
+      // Clear background from previous selection and select new square
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
+      if (selected >= 0) {
+        const auto selected_y = selected / (GRID_MAX_POINTS_X);
+        const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
+        const auto start_y_px = padding_y_top + selected_y * cell_height_px;
+        const auto start_x_px = padding_x + selected_x * cell_width_px;
+        DWIN_Draw_Rectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
+      }
+
+      // Draw value square grid
+      char buf[8];
+      GRID_LOOP(x, y) {
+        const auto start_x_px = padding_x + x * cell_width_px;
+        const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
+        const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
+        const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
+        DWIN_Draw_Rectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
+          isnan(bedlevel.z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
+            (bedlevel.z_values[x][y] < 0 ?
+              (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
+              (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
+                _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
+          start_x_px, start_y_px, end_x_px, end_y_px
+        );
+
+        safe_delay(10);
+        LCD_SERIAL.flushTX();
+
+        // Draw value text on
+        if (viewer_print_value) {
+          int8_t offset_x, offset_y = cell_height_px / 2 - 6;
+          if (isnan(bedlevel.z_values[x][y])) {  // undefined
+            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+          }
+          else {                          // has value
+            if (GRID_MAX_POINTS_X < 10)
+              sprintf_P(buf, PSTR("%s"), dtostrf(abs(bedlevel.z_values[x][y]), 1, 2, str_1));
+            else
+              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(bedlevel.z_values[x][y] - (int16_t)bedlevel.z_values[x][y]) * 100));
+            offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
+            if (!(GRID_MAX_POINTS_X < 10))
+              DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
+          }
+          safe_delay(10);
+          LCD_SERIAL.flushTX();
+        }
+      }
+    }
+
+    void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
+      float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
+      if (v_min > 3e+10F) v_min = 0.0000001;
+      if (v_max > 3e+10F) v_max = 0.0000001;
+      if (range > 3e+10F) range = 0.0000001;
+      char msg[46];
+      if (viewer_asymmetric_range) {
+        dtostrf(-v_min, 1, 3, str_1);
+        dtostrf( v_max, 1, 3, str_2);
+      }
+      else {
+        dtostrf(-range, 1, 3, str_1);
+        dtostrf( range, 1, 3, str_2);
+      }
+      sprintf_P(msg, PSTR("Red %s..0..%s Green"), str_1, str_2);
+      CrealityDWIN.Update_Status(msg);
+      drawing_mesh = false;
+    }
+
+  };
+  Mesh_Settings mesh_conf;
+
+#endif // HAS_MESH
+
+/* General Display Functions */
+
+struct CrealityDWINClass::EEPROM_Settings CrealityDWINClass::eeprom_settings{0};
+constexpr const char * const CrealityDWINClass::color_names[11];
+constexpr const char * const CrealityDWINClass::preheat_modes[3];
+
+// Clear a part of the screen
+//  4=Entire screen
+//  3=Title bar and Menu area (default)
+//  2=Menu area
+//  1=Title bar
+void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
+  if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
+  if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
+  if (e == 4) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
+}
+
+void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
+  const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
+  const uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
+  const uint16_t xpos = 240 - (digits * 8);
+  DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
+  if (isnan(value))
+    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
+  else {
+    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
+    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
+  }
+}
+
+void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
+  uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black,
+           tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
+  DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
+  DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
+}
+
+uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
+  switch (color) {
+    case Default:
+      return original;
+      break;
+    case White:
+      return (light) ? Color_Light_White : Color_White;
+      break;
+    case Green:
+      return (light) ? Color_Light_Green : Color_Green;
+      break;
+    case Cyan:
+      return (light) ? Color_Light_Cyan : Color_Cyan;
+      break;
+    case Blue:
+      return (light) ? Color_Light_Blue : Color_Blue;
+      break;
+    case Magenta:
+      return (light) ? Color_Light_Magenta : Color_Magenta;
+      break;
+    case Red:
+      return (light) ? Color_Light_Red : Color_Red;
+      break;
+    case Orange:
+      return (light) ? Color_Light_Orange : Color_Orange;
+      break;
+    case Yellow:
+      return (light) ? Color_Light_Yellow : Color_Yellow;
+      break;
+    case Brown:
+      return (light) ? Color_Light_Brown : Color_Brown;
+      break;
+    case Black:
+      return Color_Black;
+      break;
+  }
+  return Color_White;
+}
+
+void CrealityDWINClass::Draw_Title(const char * ctitle) {
+  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
+}
+void CrealityDWINClass::Draw_Title(FSTR_P const ftitle) {
+  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
+}
+
+void _Decorate_Menu_Item(uint8_t row, uint8_t icon, bool more) {
+  if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
+  if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
+  DWIN_Draw_Line(CrealityDWIN.GetColor(CrealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+}
+
+void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
+  const uint8_t label_offset_y = (label1 || label2) ? MENU_CHR_H * 3 / 5 : 0,
+                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
+                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
+  if (label1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
+  if (label2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
+  _Decorate_Menu_Item(row, icon, more);
+}
+
+void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, bool more/*=false*/, bool centered/*=false*/) {
+  const uint8_t label_offset_y = (flabel1 || flabel2) ? MENU_CHR_H * 3 / 5 : 0,
+                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
+                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
+  if (flabel1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
+  if (flabel2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
+  _Decorate_Menu_Item(row, icon, more);
+}
+
+void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
+  #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
+    DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
+  #else                                         // Draw a basic checkbox using rectangles and lines
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    DWIN_Draw_Rectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    if (value) {
+      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
+      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
+      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
+      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
+      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
+      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
+    }
+  #endif
+}
+
+void CrealityDWINClass::Draw_Menu(uint8_t menu, uint8_t select/*=0*/, uint8_t scroll/*=0*/) {
+  if (active_menu != menu) {
+    last_menu = active_menu;
+    if (process == Menu) last_selection = selection;
+  }
+  selection = _MIN(select, Get_Menu_Size(menu));
+  scrollpos = scroll;
+  if (selection - scrollpos > MROWS)
+    scrollpos = selection - MROWS;
+  process = Menu;
+  active_menu = menu;
+  Clear_Screen();
+  Draw_Title(Get_Menu_Title(menu));
+  LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
+  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+}
+
+void CrealityDWINClass::Redraw_Menu(bool lastprocess/*=true*/, bool lastselection/*=false*/, bool lastmenu/*=false*/) {
+  switch ((lastprocess) ? last_process : process) {
+    case Menu:
+      Draw_Menu((lastmenu) ? last_menu : active_menu, (lastselection) ? last_selection : selection, (lastmenu) ? 0 : scrollpos);
+      break;
+    case Main:  Draw_Main_Menu((lastselection) ? last_selection : selection); break;
+    case Print: Draw_Print_Screen(); break;
+    case File:  Draw_SD_List(); break;
+    default: break;
+  }
+}
+
+void CrealityDWINClass::Redraw_Screen() {
+  Redraw_Menu(false);
+  Draw_Status_Area(true);
+  Update_Status_Bar(true);
+}
+
+/* Primary Menus and Screen Elements */
+
+void CrealityDWINClass::Main_Menu_Icons() {
+  if (selection == 0) {
+    DWIN_ICON_Show(ICON, ICON_Print_1, 17, 130);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Print_0, 17, 130);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+  }
+  if (selection == 1) {
+    DWIN_ICON_Show(ICON, ICON_Prepare_1, 145, 130);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Prepare_0, 145, 130);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+  }
+  if (selection == 2) {
+    DWIN_ICON_Show(ICON, ICON_Control_1, 17, 246);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Control_0, 17, 246);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+  }
+  #if HAS_ABL_OR_UBL
+    if (selection == 3) {
+      DWIN_ICON_Show(ICON, ICON_Leveling_1, 145, 246);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Leveling_0, 145, 246);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+    }
+  #else
+    if (selection == 3) {
+      DWIN_ICON_Show(ICON, ICON_Info_1, 145, 246);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Info_0, 145, 246);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+    }
+  #endif
+}
+
+void CrealityDWINClass::Draw_Main_Menu(uint8_t select/*=0*/) {
+  process = Main;
+  active_menu = MainMenu;
+  selection = select;
+  Clear_Screen();
+  Draw_Title(Get_Menu_Title(MainMenu));
+  SERIAL_ECHOPGM("\nDWIN handshake ");
+  DWIN_ICON_Show(ICON, ICON_LOGO, 71, 72);
+  Main_Menu_Icons();
+}
+
+void CrealityDWINClass::Print_Screen_Icons() {
+  if (selection == 0) {
+    DWIN_ICON_Show(ICON, ICON_Setup_1, 8, 252);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Setup_0, 8, 252);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+  }
+  if (selection == 2) {
+    DWIN_ICON_Show(ICON, ICON_Stop_1, 184, 252);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Stop_0, 184, 252);
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+  }
+  if (paused) {
+    if (selection == 1) {
+      DWIN_ICON_Show(ICON, ICON_Continue_1, 96, 252);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Continue_0, 96, 252);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+    }
+  }
+  else {
+    if (selection == 1) {
+      DWIN_ICON_Show(ICON, ICON_Pause_1, 96, 252);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Pause_0, 96, 252);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+    }
+  }
+}
+
+void CrealityDWINClass::Draw_Print_Screen() {
+  process = Print;
+  selection = 0;
+  Clear_Screen();
+  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+  Draw_Title("Printing...");
+  Print_Screen_Icons();
+  DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
+  DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
+  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
+  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
+  Update_Status_Bar(true);
+  Draw_Print_ProgressBar();
+  Draw_Print_ProgressElapsed();
+  TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
+  Draw_Print_Filename(true);
+}
+
+void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
+  static uint8_t namescrl = 0;
+  if (reset) namescrl = 0;
+  if (process == Print) {
+    constexpr int8_t maxlen = 30;
+    char *outstr = filename;
+    size_t slen = strlen(filename);
+    int8_t outlen = slen;
+    if (slen > maxlen) {
+      char dispname[maxlen + 1];
+      int8_t pos = slen - namescrl, len = maxlen;
+      if (pos >= 0) {
+        NOMORE(len, pos);
+        LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
+      }
+      else {
+        const int8_t mp = maxlen + pos;
+        LOOP_L_N(i, mp) dispname[i] = ' ';
+        LOOP_S_L_N(i, mp, maxlen) dispname[i] = filename[i - mp];
+        if (mp <= 0) namescrl = 0;
+      }
+      dispname[len] = '\0';
+      outstr = dispname;
+      outlen = maxlen;
+      namescrl++;
+    }
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
+    const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
+  }
+}
+
+void CrealityDWINClass::Draw_Print_ProgressBar() {
+  uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
+  DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
+  DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
+  DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
+  DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
+}
+
+#if ENABLED(USE_M73_REMAINING_TIME)
+
+  void CrealityDWINClass::Draw_Print_ProgressRemain() {
+    uint16_t remainingtime = ui.get_remaining_time();
+    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
+    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
+    if (eeprom_settings.time_format_textual) {
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
+    }
+    else
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
+  }
+
+#endif
+
+void CrealityDWINClass::Draw_Print_ProgressElapsed() {
+  duration_t elapsed = print_job_timer.duration();
+  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
+  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
+  if (eeprom_settings.time_format_textual) {
+    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
+  }
+  else
+    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
+}
+
+void CrealityDWINClass::Draw_Print_confirm() {
+  Draw_Print_Screen();
+  process = Confirm;
+  popup = Complete;
+  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
+  DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
+  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
+  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
+}
+
+void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
+  if (item == 0)
+    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
+  else {
+    card.getfilename_sorted(SD_ORDER(item - 1, card.get_num_Files()));
+    char * const filename = card.longest_filename();
+    size_t max = MENU_CHAR_LIMIT;
+    size_t pos = strlen(filename), len = pos;
+    if (!card.flag.filenameIsDir)
+      while (pos && filename[pos] != '.') pos--;
+    len = pos;
+    if (len > max) len = max;
+    char name[len + 1];
+    LOOP_L_N(i, len) name[i] = filename[i];
+    if (pos > max)
+      LOOP_S_L_N(i, len - 3, len) name[i] = '.';
+    name[len] = '\0';
+    Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
+  }
+}
+
+void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
+  Clear_Screen();
+  Draw_Title("Select File");
+  selection = 0;
+  scrollpos = 0;
+  process = File;
+  if (card.isMounted() && !removed) {
+    LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
+      Draw_SD_Item(i, i);
+  }
+  else {
+    Draw_Menu_Item(0, ICON_Back, F("Back"));
+    DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
+  }
+  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
+}
+
+void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
+
+  if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
+
+  #if HAS_HOTEND
+    static float hotend = -1;
+    static int16_t hotendtarget = -1, flow = -1;
+    if (icons) {
+      hotend = -1;
+      hotendtarget = -1;
+      DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
+      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+    }
+    if (thermalManager.temp_hotend[0].celsius != hotend) {
+      hotend = thermalManager.temp_hotend[0].celsius;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
+    }
+    if (thermalManager.temp_hotend[0].target != hotendtarget) {
+      hotendtarget = thermalManager.temp_hotend[0].target;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
+    }
+    if (icons) {
+      flow = -1;
+      DWIN_ICON_Show(ICON, ICON_StepE, 112, 417);
+      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+    }
+    if (planner.flow_percentage[0] != flow) {
+      flow = planner.flow_percentage[0];
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+    }
+  #endif
+
+  #if HAS_HEATED_BED
+    static float bed = -1;
+    static int16_t bedtarget = -1;
+    if (icons) {
+      bed = -1;
+      bedtarget = -1;
+      DWIN_ICON_Show(ICON, ICON_BedTemp, 10, 416);
+      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+    }
+    if (thermalManager.temp_bed.celsius != bed) {
+      bed = thermalManager.temp_bed.celsius;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
+    }
+    if (thermalManager.temp_bed.target != bedtarget) {
+      bedtarget = thermalManager.temp_bed.target;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
+    }
+  #endif
+
+  #if HAS_FAN
+    static uint8_t fan = -1;
+    if (icons) {
+      fan = -1;
+      DWIN_ICON_Show(ICON, ICON_FanSpeed, 187, 383);
+    }
+    if (thermalManager.fan_speed[0] != fan) {
+      fan = thermalManager.fan_speed[0];
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+    }
+  #endif
+
+  #if HAS_ZOFFSET_ITEM
+    static float offset = -1;
+
+    if (icons) {
+      offset = -1;
+      DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
+    }
+    if (zoffsetvalue != offset) {
+      offset = zoffsetvalue;
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
+    }
+  #endif
+
+  static int16_t feedrate = -1;
+  if (icons) {
+    feedrate = -1;
+    DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
+    DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+  }
+  if (feedrate_percentage != feedrate) {
+    feedrate = feedrate_percentage;
+    DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+  }
+
+  static float x = -1, y = -1, z = -1;
+  static bool update_x = false, update_y = false, update_z = false;
+  update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
+  update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
+  update_z = (current_position.z != z || axis_should_home(Z_AXIS) || update_z);
+  if (icons) {
+    x = y = z = -1;
+    DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
+    DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
+    DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
+    DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
+  }
+  if (update_x) {
+    x = current_position.x;
+    if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
+    else
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x);
+  }
+  if (update_y) {
+    y = current_position.y;
+    if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
+    else
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
+  }
+  if (update_z) {
+    z = current_position.z;
+    if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
+    else
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z : 0);
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
+  if (process != Confirm && process != Popup && process != Wait) last_process = process;
+  if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
+  process = mode;
+  Clear_Screen();
+  DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
+  DWIN_Draw_Rectangle(1, Color_Bg_Window, 14, 60, 258, 350);
+  const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
+  if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
+  if (mode == Popup) {
+    selection = 0;
+    DWIN_Draw_Rectangle(1, Confirm_Color, 26, 280, 125, 317);
+    DWIN_Draw_Rectangle(1, Cancel_Color, 146, 280, 245, 317);
+    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
+    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
+    Popup_Select();
+  }
+  else if (mode == Confirm) {
+    DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
+    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
+  }
+}
+
+void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
+  CrealityDWIN.Draw_Popup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
+}
+
+void CrealityDWINClass::Popup_Select() {
+  const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
+                 c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
+  DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
+  DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
+  DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
+  DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
+}
+
+void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
+  static bool new_msg;
+  static uint8_t msgscrl = 0;
+  static char lastmsg[64];
+  if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
+    strcpy(lastmsg, statusmsg);
+    msgscrl = 0;
+    new_msg = true;
+  }
+  size_t len = strlen(statusmsg);
+  int8_t pos = len;
+  if (pos > 30) {
+    pos -= msgscrl;
+    len = pos;
+    if (len > 30)
+      len = 30;
+    char dispmsg[len + 1];
+    if (pos >= 0) {
+      LOOP_L_N(i, len) dispmsg[i] = statusmsg[i + msgscrl];
+    }
+    else {
+      LOOP_L_N(i, 30 + pos) dispmsg[i] = ' ';
+      LOOP_S_L_N(i, 30 + pos, 30) dispmsg[i] = statusmsg[i - (30 + pos)];
+    }
+    dispmsg[len] = '\0';
+    if (process == Print) {
+      DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
+    }
+    else {
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
+    }
+    if (-pos >= 30) msgscrl = 0;
+    msgscrl++;
+  }
+  else {
+    if (new_msg) {
+      new_msg = false;
+      if (process == Print) {
+        DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
+        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, statusmsg);
+      }
+      else {
+        DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
+        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
+      }
+    }
+  }
+}
+
+/* Menu Item Config */
+
+void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
+  const uint8_t row = item - scrollpos;
+  #if HAS_LEVELING
+    static bool level_state;
+  #endif
+
+  #if HAS_PREHEAT
+
+    #define PREHEAT_BACK 0
+    #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
+    #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
+    #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
+    #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
+
+    auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
+      switch (item) {
+        case PREHEAT_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(TempMenu, sel);
+          break;
+        #if HAS_HOTEND
+          case PREHEAT_SUBMENU_HOTEND:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
+              Draw_Float(ui.material_preset[index].hotend_temp, row, false, 1);
+            }
+            else
+              Modify_Value(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+        #endif
+        #if HAS_HEATED_BED
+          case PREHEAT_SUBMENU_BED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
+              Draw_Float(ui.material_preset[index].bed_temp, row, false, 1);
+            }
+            else
+              Modify_Value(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+        #endif
+        #if HAS_FAN
+          case PREHEAT_SUBMENU_FAN:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Float(ui.material_preset[index].fan_speed, row, false, 1);
+            }
+            else
+              Modify_Value(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+            break;
+        #endif
+      }
+    };
+
+  #endif
+
+  switch (menu) {
+    case Prepare:
+
+      #define PREPARE_BACK 0
+      #define PREPARE_MOVE (PREPARE_BACK + 1)
+      #define PREPARE_DISABLE (PREPARE_MOVE + 1)
+      #define PREPARE_HOME (PREPARE_DISABLE + 1)
+      #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
+      #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
+      #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
+      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + EITHER(HAS_HOTEND, HAS_HEATED_BED))
+      #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
+      #define PREPARE_CUSTOM_MENU (PREPARE_CHANGEFIL + ENABLED(HAS_CUSTOM_MENU))
+      #define PREPARE_TOTAL PREPARE_CUSTOM_MENU
+
+      switch (item) {
+        case PREPARE_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Main_Menu(1);
+          break;
+        case PREPARE_MOVE:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Axis, F("Move"), nullptr, true);
+          else
+            Draw_Menu(Move);
+          break;
+        case PREPARE_DISABLE:
+          if (draw)
+            Draw_Menu_Item(row, ICON_CloseMotor, F("Disable Stepper"));
+          else
+            queue.inject(F("M84"));
+          break;
+        case PREPARE_HOME:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, F("Homing"), nullptr, true);
+          else
+            Draw_Menu(HomeMenu);
+          break;
+        case PREPARE_MANUALLEVEL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
+          else {
+            if (axes_should_home()) {
+              Popup_Handler(Home);
+              gcode.home_all_axes(true);
+            }
+            #if HAS_LEVELING
+              level_state = planner.leveling_active;
+              set_bed_leveling_enabled(false);
+            #endif
+            Draw_Menu(ManualLevel);
+          }
+          break;
+
+        #if HAS_ZOFFSET_ITEM
+          case PREPARE_ZOFFSET:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Zoffset, F("Z-Offset"), nullptr, true);
+            else {
+              #if HAS_LEVELING
+                level_state = planner.leveling_active;
+                set_bed_leveling_enabled(false);
+              #endif
+              Draw_Menu(ZOffset);
+            }
+            break;
+        #endif
+
+        #if HAS_PREHEAT
+          case PREPARE_PREHEAT:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Temperature, F("Preheat"), nullptr, true);
+            else
+              Draw_Menu(Preheat);
+            break;
+        #endif
+
+        #if HAS_HOTEND || HAS_HEATED_BED
+          case PREPARE_COOLDOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Cool, F("Cooldown"));
+            else
+              thermalManager.cooldown();
+            break;
+        #endif
+
+        #if HAS_CUSTOM_MENU
+          case PREPARE_CUSTOM_MENU:
+            #ifndef CUSTOM_MENU_CONFIG_TITLE
+              #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
+            #endif
+            if (draw)
+              Draw_Menu_Item(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
+            else
+              Draw_Menu(MenuCustom);
+            break;
+        #endif
+
+        #if ENABLED(ADVANCED_PAUSE_FEATURE)
+          case PREPARE_CHANGEFIL:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament")
+                #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                  , nullptr, true
+                #endif
+              );
+            }
+            else {
+              #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                Draw_Menu(ChangeFilament);
+              #else
+                if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                  Popup_Handler(ETemp);
+                else {
+                  if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                    Popup_Handler(Heating);
+                    thermalManager.wait_for_hotend(0);
+                  }
+                  Popup_Handler(FilChange);
+                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                  gcode.process_subcommands_now(cmd);
+                }
+              #endif
+            }
+            break;
+        #endif
+      }
+      break;
+
+    case HomeMenu:
+
+      #define HOME_BACK  0
+      #define HOME_ALL   (HOME_BACK + 1)
+      #define HOME_X     (HOME_ALL + 1)
+      #define HOME_Y     (HOME_X + 1)
+      #define HOME_Z     (HOME_Y + 1)
+      #define HOME_SET   (HOME_Z + 1)
+      #define HOME_TOTAL HOME_SET
+
+      switch (item) {
+        case HOME_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Prepare, PREPARE_HOME);
+          break;
+        case HOME_ALL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Homing, F("Home All"));
+          else {
+            Popup_Handler(Home);
+            gcode.home_all_axes(true);
+            Redraw_Menu();
+          }
+          break;
+        case HOME_X:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MoveX, F("Home X"));
+          else {
+            Popup_Handler(Home);
+            gcode.process_subcommands_now(F("G28 X"));
+            planner.synchronize();
+            Redraw_Menu();
+          }
+          break;
+        case HOME_Y:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MoveY, F("Home Y"));
+          else {
+            Popup_Handler(Home);
+            gcode.process_subcommands_now(F("G28 Y"));
+            planner.synchronize();
+            Redraw_Menu();
+          }
+          break;
+        case HOME_Z:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MoveZ, F("Home Z"));
+          else {
+            Popup_Handler(Home);
+            gcode.process_subcommands_now(F("G28 Z"));
+            planner.synchronize();
+            Redraw_Menu();
+          }
+          break;
+        case HOME_SET:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, F("Set Home Position"));
+          else {
+            gcode.process_subcommands_now(F("G92X0Y0Z0"));
+            AudioFeedback();
+          }
+          break;
+      }
+      break;
+
+    case Move:
+
+      #define MOVE_BACK 0
+      #define MOVE_X (MOVE_BACK + 1)
+      #define MOVE_Y (MOVE_X + 1)
+      #define MOVE_Z (MOVE_Y + 1)
+      #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
+      #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
+      #define MOVE_LIVE (MOVE_P + 1)
+      #define MOVE_TOTAL MOVE_LIVE
+
+      switch (item) {
+        case MOVE_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else {
+            #if HAS_BED_PROBE
+              probe_deployed = false;
+              probe.set_deployed(probe_deployed);
+            #endif
+            Draw_Menu(Prepare, PREPARE_MOVE);
+          }
+          break;
+        case MOVE_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MoveX, F("Move X"));
+            Draw_Float(current_position.x, row, false);
+          }
+          else
+            Modify_Value(current_position.x, X_MIN_POS, X_MAX_POS, 10);
+          break;
+        case MOVE_Y:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MoveY, F("Move Y"));
+            Draw_Float(current_position.y, row);
+          }
+          else
+            Modify_Value(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
+          break;
+        case MOVE_Z:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MoveZ, F("Move Z"));
+            Draw_Float(current_position.z, row);
+          }
+          else
+            Modify_Value(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
+          break;
+
+        #if HAS_HOTEND
+          case MOVE_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Extruder, F("Extruder"));
+              current_position.e = 0;
+              sync_plan_position();
+              Draw_Float(current_position.e, row);
+            }
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+                Popup_Handler(ETemp);
+              }
+              else {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                  Redraw_Menu();
+                }
+                current_position.e = 0;
+                sync_plan_position();
+                Modify_Value(current_position.e, -500, 500, 10);
+              }
+            }
+          break;
+        #endif // HAS_HOTEND
+
+        #if HAS_BED_PROBE
+          case MOVE_P:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StockConfiguration, F("Probe"));
+              Draw_Checkbox(row, probe_deployed);
+            }
+            else {
+              probe_deployed = !probe_deployed;
+              probe.set_deployed(probe_deployed);
+              Draw_Checkbox(row, probe_deployed);
+            }
+            break;
+        #endif
+
+        case MOVE_LIVE:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Axis, F("Live Movement"));
+            Draw_Checkbox(row, livemove);
+          }
+          else {
+            livemove = !livemove;
+            Draw_Checkbox(row, livemove);
+          }
+          break;
+      }
+      break;
+    case ManualLevel:
+
+      #define MLEVEL_BACK 0
+      #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
+      #define MLEVEL_BL (MLEVEL_PROBE + 1)
+      #define MLEVEL_TL (MLEVEL_BL + 1)
+      #define MLEVEL_TR (MLEVEL_TL + 1)
+      #define MLEVEL_BR (MLEVEL_TR + 1)
+      #define MLEVEL_C (MLEVEL_BR + 1)
+      #define MLEVEL_ZPOS (MLEVEL_C + 1)
+      #define MLEVEL_TOTAL MLEVEL_ZPOS
+
+      static float mlev_z_pos = 0;
+      static bool use_probe = false;
+
+      switch (item) {
+        case MLEVEL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else {
+            TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
+            Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
+          }
+          break;
+        #if HAS_BED_PROBE
+          case MLEVEL_PROBE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
+              Draw_Checkbox(row, use_probe);
+            }
+            else {
+              use_probe = !use_probe;
+              Draw_Checkbox(row, use_probe);
+              if (use_probe) {
+                Popup_Handler(Level);
+                corner_avg = 0;
+                #define PROBE_X_MIN _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x
+                #define PROBE_X_MAX _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x
+                #define PROBE_Y_MIN _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y
+                #define PROBE_Y_MAX _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y
+                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MIN, PROBE_PT_RAISE, 0, false);
+                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
+                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
+                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
+                corner_avg /= 4;
+                Redraw_Menu();
+              }
+            }
+            break;
+        #endif
+        case MLEVEL_BL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisBL, F("Bottom Left"));
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_TL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisTL, F("Top Left"));
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_TR:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisTR, F("Top Right"));
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_BR:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisBR, F("Bottom Right"));
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_C:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisC, F("Center"));
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_ZPOS:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
+            Draw_Float(mlev_z_pos, row, false, 100);
+          }
+          else
+            Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
+          break;
+      }
+      break;
+    #if HAS_ZOFFSET_ITEM
+      case ZOffset:
+
+        #define ZOFFSET_BACK 0
+        #define ZOFFSET_HOME (ZOFFSET_BACK + 1)
+        #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
+        #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
+        #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
+        #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
+        #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
+        #define ZOFFSET_TOTAL ZOFFSET_SAVE
+
+        switch (item) {
+          case ZOFFSET_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else {
+              liveadjust = false;
+              TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
+              Draw_Menu(Prepare, PREPARE_ZOFFSET);
+            }
+            break;
+          case ZOFFSET_HOME:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Homing, F("Home Z Axis"));
+            else {
+              Popup_Handler(Home);
+              gcode.process_subcommands_now(F("G28 Z"));
+              Popup_Handler(MoveWait);
+              #if ENABLED(Z_SAFE_HOMING)
+                planner.synchronize();
+                sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
+              #else
+                gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
+              #endif
+              gcode.process_subcommands_now(F("G0 F300 Z0"));
+              planner.synchronize();
+              Redraw_Menu();
+            }
+            break;
+          case ZOFFSET_MODE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Zoffset, F("Live Adjustment"));
+              Draw_Checkbox(row, liveadjust);
+            }
+            else {
+              if (!liveadjust) {
+                if (axes_should_home()) {
+                  Popup_Handler(Home);
+                  gcode.home_all_axes(true);
+                }
+                Popup_Handler(MoveWait);
+                #if ENABLED(Z_SAFE_HOMING)
+                  planner.synchronize();
+                  sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
+                  gcode.process_subcommands_now(cmd);
+                #else
+                  gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
+                #endif
+                gcode.process_subcommands_now(F("G0 F300 Z0"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+              liveadjust = !liveadjust;
+              Draw_Checkbox(row, liveadjust);
+            }
+            break;
+          case ZOFFSET_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Offset"));
+              Draw_Float(zoffsetvalue, row, false, 100);
+            }
+            else
+              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          case ZOFFSET_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+            else {
+              if (zoffsetvalue < MAX_Z_OFFSET) {
+                if (liveadjust) {
+                  gcode.process_subcommands_now(F("M290 Z0.01"));
+                  planner.synchronize();
+                }
+                zoffsetvalue += 0.01;
+                Draw_Float(zoffsetvalue, row - 1, false, 100);
+              }
+            }
+            break;
+          case ZOFFSET_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
+            else {
+              if (zoffsetvalue > MIN_Z_OFFSET) {
+                if (liveadjust) {
+                  gcode.process_subcommands_now(F("M290 Z-0.01"));
+                  planner.synchronize();
+                }
+                zoffsetvalue -= 0.01;
+                Draw_Float(zoffsetvalue, row - 2, false, 100);
+              }
+            }
+            break;
+          #if ENABLED(EEPROM_SETTINGS)
+            case ZOFFSET_SAVE:
+              if (draw)
+                Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save"));
+              else
+                AudioFeedback(settings.save());
+              break;
+          #endif
+        }
+        break;
+    #endif
+
+    #if HAS_PREHEAT
+      case Preheat: {
+        #define PREHEAT_MODE (PREHEAT_BACK + 1)
+        #define PREHEAT_1 (PREHEAT_MODE + 1)
+        #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
+        #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
+        #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
+        #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
+        #define PREHEAT_TOTAL PREHEAT_5
+
+        auto do_preheat = [](const uint8_t m) {
+          thermalManager.cooldown();
+          if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
+          if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
+        };
+
+        switch (item) {
+          case PREHEAT_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Prepare, PREPARE_PREHEAT);
+            break;
+
+          case PREHEAT_MODE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
+              Draw_Option(preheatmode, preheat_modes, row);
+            }
+            else
+              Modify_Option(preheatmode, preheat_modes, 2);
+            break;
+
+          #define _PREHEAT_CASE(N) \
+            case PREHEAT_##N: { \
+              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+              else do_preheat(N - 1); \
+            } break;
+
+          REPEAT_1(PREHEAT_COUNT, _PREHEAT_CASE)
+        }
+      } break;
+    #endif // HAS_PREHEAT
+
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      case ChangeFilament:
+
+        #define CHANGEFIL_BACK 0
+        #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
+        #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
+        #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
+        #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
+
+        switch (item) {
+          case CHANGEFIL_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Prepare, PREPARE_CHANGEFIL);
+            break;
+          case CHANGEFIL_LOAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Filament"));
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                Popup_Handler(ETemp);
+              else {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                }
+                Popup_Handler(FilLoad);
+                gcode.process_subcommands_now(F("M701"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+            }
+            break;
+          case CHANGEFIL_UNLOAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Filament"));
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+                Popup_Handler(ETemp);
+              }
+              else {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                }
+                Popup_Handler(FilLoad, true);
+                gcode.process_subcommands_now(F("M702"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+            }
+            break;
+          case CHANGEFIL_CHANGE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                Popup_Handler(ETemp);
+              else {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                }
+                Popup_Handler(FilChange);
+                sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                gcode.process_subcommands_now(cmd);
+              }
+            }
+            break;
+        }
+        break;
+    #endif // FILAMENT_LOAD_UNLOAD_GCODES
+
+    #if HAS_CUSTOM_MENU
+
+      case MenuCustom:
+
+        #define CUSTOM_MENU_BACK 0
+        #define CUSTOM_MENU_1 1
+        #define CUSTOM_MENU_2 2
+        #define CUSTOM_MENU_3 3
+        #define CUSTOM_MENU_4 4
+        #define CUSTOM_MENU_5 5
+        #define CUSTOM_MENU_TOTAL CUSTOM_MENU_COUNT
+
+        switch (item) {
+          case CUSTOM_MENU_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Prepare, PREPARE_CUSTOM_MENU);
+            break;
+
+          #if CUSTOM_MENU_COUNT >= 1
+            case CUSTOM_MENU_1:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
+              else {
+                Popup_Handler(Custom);
+                //queue.inject(F(CONFIG_MENU_ITEM_1_GCODE)); // Old code
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_1_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 2
+            case CUSTOM_MENU_2:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_2_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_2_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 3
+            case CUSTOM_MENU_3:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_3_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_3_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 4
+            case CUSTOM_MENU_4:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_4_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_4_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 5
+            case CUSTOM_MENU_5:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_5_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_5_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif // Custom Menu
+        }
+        break;
+
+    #endif // HAS_CUSTOM_MENU
+
+    case Control:
+
+      #define CONTROL_BACK 0
+      #define CONTROL_TEMP (CONTROL_BACK + 1)
+      #define CONTROL_MOTION (CONTROL_TEMP + 1)
+      #define CONTROL_VISUAL (CONTROL_MOTION + 1)
+      #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
+      #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_INFO (CONTROL_RESET + 1)
+      #define CONTROL_TOTAL CONTROL_INFO
+
+      switch (item) {
+        case CONTROL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Main_Menu(2);
+          break;
+        case CONTROL_TEMP:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Temperature, F("Temperature"), nullptr, true);
+          else
+            Draw_Menu(TempMenu);
+          break;
+        case CONTROL_MOTION:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Motion, F("Motion"), nullptr, true);
+          else
+            Draw_Menu(Motion);
+          break;
+        case CONTROL_VISUAL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_PrintSize, F("Visual"), nullptr, true);
+          else
+            Draw_Menu(Visual);
+          break;
+        case CONTROL_ADVANCED:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Version, F("Advanced"), nullptr, true);
+          else
+            Draw_Menu(Advanced);
+          break;
+        #if ENABLED(EEPROM_SETTINGS)
+          case CONTROL_SAVE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Store Settings"));
+            else
+              AudioFeedback(settings.save());
+            break;
+          case CONTROL_RESTORE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Restore Settings"));
+            else
+              AudioFeedback(settings.load());
+            break;
+          case CONTROL_RESET:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Temperature, F("Reset to Defaults"));
+            else {
+              settings.reset();
+              AudioFeedback();
+            }
+            break;
+        #endif
+        case CONTROL_INFO:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Info, F("Info"));
+          else
+            Draw_Menu(Info);
+          break;
+      }
+      break;
+
+    case TempMenu:
+
+      #define TEMP_BACK 0
+      #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
+      #define TEMP_BED (TEMP_HOTEND + ENABLED(HAS_HEATED_BED))
+      #define TEMP_FAN (TEMP_BED + ENABLED(HAS_FAN))
+      #define TEMP_PID (TEMP_FAN + ANY(HAS_HOTEND, HAS_HEATED_BED))
+      #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
+      #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
+      #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
+      #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
+      #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
+      #define TEMP_TOTAL TEMP_PREHEAT5
+
+      switch (item) {
+        case TEMP_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Control, CONTROL_TEMP);
+          break;
+        #if HAS_HOTEND
+          case TEMP_HOTEND:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
+              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+        #endif
+        #if HAS_HEATED_BED
+          case TEMP_BED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
+              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+        #endif
+        #if HAS_FAN
+          case TEMP_FAN:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+            break;
+        #endif
+        #if HAS_HOTEND || HAS_HEATED_BED
+          case TEMP_PID:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, F("PID"), nullptr, true);
+            else
+              Draw_Menu(PID);
+            break;
+        #endif
+
+        #define _TEMP_PREHEAT_CASE(N) \
+          case TEMP_PREHEAT##N: { \
+            if (draw) Draw_Menu_Item(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
+            else Draw_Menu(Preheat##N); \
+          } break;
+
+        REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
+      }
+      break;
+
+    #if HAS_HOTEND || HAS_HEATED_BED
+      case PID:
+
+        #define PID_BACK 0
+        #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
+        #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PID_CYCLES (PID_BED + 1)
+        #define PID_TOTAL PID_CYCLES
+
+        static uint8_t PID_cycles = 5;
+
+        switch (item) {
+          case PID_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(TempMenu, TEMP_PID);
+            break;
+          #if HAS_HOTEND
+            case PID_HOTEND:
+              if (draw)
+                Draw_Menu_Item(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
+              else
+                Draw_Menu(HotendPID);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PID_BED:
+              if (draw)
+                Draw_Menu_Item(row, ICON_BedTemp, F("Bed"), nullptr, true);
+              else
+                Draw_Menu(BedPID);
+              break;
+          #endif
+          case PID_CYCLES:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Cycles"));
+              Draw_Float(PID_cycles, row, false, 1);
+            }
+            else
+              Modify_Value(PID_cycles, 3, 50, 1);
+            break;
+        }
+        break;
+    #endif // HAS_HOTEND || HAS_HEATED_BED
+
+    #if HAS_HOTEND
+      case HotendPID:
+
+        #define HOTENDPID_BACK 0
+        #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
+        #define HOTENDPID_TEMP (HOTENDPID_TUNE + 1)
+        #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
+        #define HOTENDPID_KI (HOTENDPID_KP + 1)
+        #define HOTENDPID_KD (HOTENDPID_KI + 1)
+        #define HOTENDPID_TOTAL HOTENDPID_KD
+
+        static uint16_t PID_e_temp = 180;
+
+        switch (item) {
+          case HOTENDPID_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(PID, PID_HOTEND);
+            break;
+          case HOTENDPID_TUNE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
+            else {
+              Popup_Handler(PIDWait);
+              sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+            break;
+          case HOTENDPID_TEMP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
+              Draw_Float(PID_e_temp, row, false, 1);
+            }
+            else
+              Modify_Value(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+          case HOTENDPID_KP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
+              Draw_Float(thermalManager.temp_hotend[0].pid.Kp, row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
+            break;
+          case HOTENDPID_KI:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
+              Draw_Float(unscalePID_i(thermalManager.temp_hotend[0].pid.Ki), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+            break;
+          case HOTENDPID_KD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
+              Draw_Float(unscalePID_d(thermalManager.temp_hotend[0].pid.Kd), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+            break;
+        }
+        break;
+    #endif // HAS_HOTEND
+
+    #if HAS_HEATED_BED
+      case BedPID:
+
+        #define BEDPID_BACK 0
+        #define BEDPID_TUNE (BEDPID_BACK + 1)
+        #define BEDPID_TEMP (BEDPID_TUNE + 1)
+        #define BEDPID_KP (BEDPID_TEMP + 1)
+        #define BEDPID_KI (BEDPID_KP + 1)
+        #define BEDPID_KD (BEDPID_KI + 1)
+        #define BEDPID_TOTAL BEDPID_KD
+
+        static uint16_t PID_bed_temp = 60;
+
+        switch (item) {
+          case BEDPID_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(PID, PID_BED);
+            break;
+          case BEDPID_TUNE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
+            else {
+              Popup_Handler(PIDWait);
+              sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
+              gcode.process_subcommands_now(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+            break;
+          case BEDPID_TEMP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
+              Draw_Float(PID_bed_temp, row, false, 1);
+            }
+            else
+              Modify_Value(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+          case BEDPID_KP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
+              Draw_Float(thermalManager.temp_bed.pid.Kp, row, false, 100);
+            }
+            else {
+              Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
+            }
+            break;
+          case BEDPID_KI:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
+              Draw_Float(unscalePID_i(thermalManager.temp_bed.pid.Ki), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+            break;
+          case BEDPID_KD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
+              Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+            break;
+        }
+        break;
+    #endif // HAS_HEATED_BED
+
+    #if HAS_PREHEAT
+      #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
+      REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
+    #endif
+
+    case Motion:
+
+      #define MOTION_BACK 0
+      #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
+      #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
+      #define MOTION_ACCEL (MOTION_SPEED + 1)
+      #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
+      #define MOTION_STEPS (MOTION_JERK + 1)
+      #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
+      #define MOTION_TOTAL MOTION_FLOW
+
+      switch (item) {
+        case MOTION_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Control, CONTROL_MOTION);
+          break;
+        case MOTION_HOMEOFFSETS:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
+          else
+            Draw_Menu(HomeOffsets);
+          break;
+        case MOTION_SPEED:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
+          else
+            Draw_Menu(MaxSpeed);
+          break;
+        case MOTION_ACCEL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
+          else
+            Draw_Menu(MaxAcceleration);
+          break;
+        #if HAS_CLASSIC_JERK
+          case MOTION_JERK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
+            else
+              Draw_Menu(MaxJerk);
+            break;
+        #endif
+        case MOTION_STEPS:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Step, F("Steps/mm"), nullptr, true);
+          else
+            Draw_Menu(Steps);
+          break;
+        #if HAS_HOTEND
+          case MOTION_FLOW:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
+              Draw_Float(planner.flow_percentage[0], row, false, 1);
+            }
+            else
+              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
+            break;
+        #endif
+      }
+      break;
+
+    case HomeOffsets:
+
+      #define HOMEOFFSETS_BACK 0
+      #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
+      #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
+      #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
+
+      switch (item) {
+        case HOMEOFFSETS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Motion, MOTION_HOMEOFFSETS);
+          break;
+        case HOMEOFFSETS_XOFFSET:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepX, F("X Offset"));
+            Draw_Float(home_offset.x, row, false, 100);
+          }
+          else
+            Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+          break;
+        case HOMEOFFSETS_YOFFSET:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepY, F("Y Offset"));
+            Draw_Float(home_offset.y, row, false, 100);
+          }
+          else
+            Modify_Value(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+          break;
+      }
+      break;
+    case MaxSpeed:
+
+      #define SPEED_BACK 0
+      #define SPEED_X (SPEED_BACK + 1)
+      #define SPEED_Y (SPEED_X + 1)
+      #define SPEED_Z (SPEED_Y + 1)
+      #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
+      #define SPEED_TOTAL SPEED_E
+
+      switch (item) {
+        case SPEED_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Motion, MOTION_SPEED);
+          break;
+        case SPEED_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
+            Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
+          break;
+
+        #if HAS_Y_AXIS
+          case SPEED_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedY, F("Y Axis"));
+              Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
+            break;
+        #endif
+
+        #if HAS_Z_AXIS
+          case SPEED_Z:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedZ, F("Z Axis"));
+              Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], 0, default_max_feedrate[Z_AXIS] * 2, 1);
+            break;
+        #endif
+
+        #if HAS_HOTEND
+          case SPEED_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedE, F("Extruder"));
+              Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], 0, default_max_feedrate[E_AXIS] * 2, 1);
+            break;
+        #endif
+      }
+      break;
+
+    case MaxAcceleration:
+
+      #define ACCEL_BACK 0
+      #define ACCEL_X (ACCEL_BACK + 1)
+      #define ACCEL_Y (ACCEL_X + 1)
+      #define ACCEL_Z (ACCEL_Y + 1)
+      #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
+      #define ACCEL_TOTAL ACCEL_E
+
+      switch (item) {
+        case ACCEL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Motion, MOTION_ACCEL);
+          break;
+        case ACCEL_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccX, F("X Axis"));
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], 0, default_max_acceleration[X_AXIS] * 2, 1);
+          break;
+        case ACCEL_Y:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccY, F("Y Axis"));
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], 0, default_max_acceleration[Y_AXIS] * 2, 1);
+          break;
+        case ACCEL_Z:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccZ, F("Z Axis"));
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], 0, default_max_acceleration[Z_AXIS] * 2, 1);
+          break;
+        #if HAS_HOTEND
+          case ACCEL_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxAccE, F("Extruder"));
+              Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], 0, default_max_acceleration[E_AXIS] * 2, 1);
+            break;
+        #endif
+      }
+      break;
+    #if HAS_CLASSIC_JERK
+      case MaxJerk:
+
+        #define JERK_BACK 0
+        #define JERK_X (JERK_BACK + 1)
+        #define JERK_Y (JERK_X + 1)
+        #define JERK_Z (JERK_Y + 1)
+        #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
+        #define JERK_TOTAL JERK_E
+
+        switch (item) {
+          case JERK_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Motion, MOTION_JERK);
+            break;
+          case JERK_X:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
+              Draw_Float(planner.max_jerk[X_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.max_jerk[X_AXIS], 0, default_max_jerk[X_AXIS] * 2, 10);
+            break;
+          case JERK_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
+              Draw_Float(planner.max_jerk[Y_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.max_jerk[Y_AXIS], 0, default_max_jerk[Y_AXIS] * 2, 10);
+            break;
+          case JERK_Z:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
+              Draw_Float(planner.max_jerk[Z_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.max_jerk[Z_AXIS], 0, default_max_jerk[Z_AXIS] * 2, 10);
+            break;
+          #if HAS_HOTEND
+            case JERK_E:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, F("Extruder"));
+                Draw_Float(planner.max_jerk[E_AXIS], row, false, 10);
+              }
+              else
+                Modify_Value(planner.max_jerk[E_AXIS], 0, default_max_jerk[E_AXIS] * 2, 10);
+              break;
+          #endif
+        }
+        break;
+    #endif
+    case Steps:
+
+      #define STEPS_BACK 0
+      #define STEPS_X (STEPS_BACK + 1)
+      #define STEPS_Y (STEPS_X + 1)
+      #define STEPS_Z (STEPS_Y + 1)
+      #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
+      #define STEPS_TOTAL STEPS_E
+
+      switch (item) {
+        case STEPS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Motion, MOTION_STEPS);
+          break;
+        case STEPS_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
+            Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, 10);
+          }
+          else
+            Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], 0, default_steps[X_AXIS] * 2, 10);
+          break;
+        case STEPS_Y:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepY, F("Y Axis"));
+            Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, 10);
+          }
+          else
+            Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], 0, default_steps[Y_AXIS] * 2, 10);
+          break;
+        case STEPS_Z:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepZ, F("Z Axis"));
+            Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, 10);
+          }
+          else
+            Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], 0, default_steps[Z_AXIS] * 2, 10);
+          break;
+        #if HAS_HOTEND
+          case STEPS_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepE, F("Extruder"));
+              Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], 0, 1000, 10);
+            break;
+        #endif
+      }
+      break;
+
+    case Visual:
+
+      #define VISUAL_BACK 0
+      #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
+      #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
+      #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
+      #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
+      #define VISUAL_TOTAL VISUAL_COLOR_THEMES
+
+      switch (item) {
+        case VISUAL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Control, CONTROL_VISUAL);
+          break;
+        case VISUAL_BACKLIGHT:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
+          else
+            ui.set_brightness(0);
+          break;
+        case VISUAL_BRIGHTNESS:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
+            Draw_Float(ui.brightness, row, false, 1);
+          }
+          else
+            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
+          break;
+        case VISUAL_TIME_FORMAT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_PrintTime, F("Progress as __h__m"));
+            Draw_Checkbox(row, eeprom_settings.time_format_textual);
+          }
+          else {
+            eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
+            Draw_Checkbox(row, eeprom_settings.time_format_textual);
+          }
+          break;
+        case VISUAL_COLOR_THEMES:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
+          else
+            Draw_Menu(ColorSettings);
+        break;
+      }
+      break;
+
+    case ColorSettings:
+
+      #define COLORSETTINGS_BACK 0
+      #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
+      #define COLORSETTINGS_SPLIT_LINE (COLORSETTINGS_CURSOR + 1)
+      #define COLORSETTINGS_MENU_TOP_TXT (COLORSETTINGS_SPLIT_LINE + 1)
+      #define COLORSETTINGS_MENU_TOP_BG (COLORSETTINGS_MENU_TOP_TXT + 1)
+      #define COLORSETTINGS_HIGHLIGHT_BORDER (COLORSETTINGS_MENU_TOP_BG + 1)
+      #define COLORSETTINGS_PROGRESS_PERCENT (COLORSETTINGS_HIGHLIGHT_BORDER + 1)
+      #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
+      #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
+      #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
+      #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
+      #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
+      #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
+
+      switch (item) {
+        case COLORSETTINGS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Visual, VISUAL_COLOR_THEMES);
+          break;
+        case COLORSETTINGS_CURSOR:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Cursor"));
+            Draw_Option(eeprom_settings.cursor_color, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.cursor_color, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_SPLIT_LINE:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Split Line"));
+            Draw_Option(eeprom_settings.menu_split_line, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.menu_split_line, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_MENU_TOP_TXT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Text"));
+            Draw_Option(eeprom_settings.menu_top_txt, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.menu_top_txt, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_MENU_TOP_BG:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Bg"));
+            Draw_Option(eeprom_settings.menu_top_bg, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.menu_top_bg, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_HIGHLIGHT_BORDER:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Highlight Box"));
+            Draw_Option(eeprom_settings.highlight_box, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.highlight_box, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_PERCENT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Percent"));
+            Draw_Option(eeprom_settings.progress_percent, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.progress_percent, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_TIME:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Time"));
+            Draw_Option(eeprom_settings.progress_time, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.progress_time, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_STATUS_BAR:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Bar Text"));
+            Draw_Option(eeprom_settings.status_bar_text, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.status_bar_text, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_STATUS_AREA:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Area Text"));
+            Draw_Option(eeprom_settings.status_area_text, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.status_area_text, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_COORDINATES:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Text"));
+            Draw_Option(eeprom_settings.coordinates_text, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.coordinates_text, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_COORDINATES_LINE:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Line"));
+            Draw_Option(eeprom_settings.coordinates_split_line, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
+          break;
+      } // switch (item)
+      break;
+
+    case Advanced:
+
+      #define ADVANCED_BACK 0
+      #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
+      #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
+      #define ADVANCED_CORNER (ADVANCED_PROBE + 1)
+      #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
+      #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
+      #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
+      #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
+      #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
+      #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
+      #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
+      #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
+
+      switch (item) {
+        case ADVANCED_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(Control, CONTROL_ADVANCED);
+          break;
+
+        #if ENABLED(SOUND_MENU_ITEM)
+          case ADVANCED_BEEPER:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, F("LCD Beeper"));
+              Draw_Checkbox(row, ui.sound_on);
+            }
+            else {
+              ui.sound_on = !ui.sound_on;
+              Draw_Checkbox(row, ui.sound_on);
+            }
+            break;
+        #endif
+
+        #if HAS_BED_PROBE
+          case ADVANCED_PROBE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_StepX, F("Probe"), nullptr, true);
+            else
+              Draw_Menu(ProbeMenu);
+            break;
+        #endif
+
+        case ADVANCED_CORNER:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
+            Draw_Float(corner_pos, row, false, 10);
+          }
+          else
+            Modify_Value(corner_pos, 1, 100, 10);
+          break;
+
+        #if ENABLED(LIN_ADVANCE)
+          case ADVANCED_LA:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxAccelerated, F("Lin Advance Kp"));
+              Draw_Float(planner.extruder_advance_K[0], row, false, 100);
+            }
+            else
+              Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
+            break;
+        #endif
+
+        #if ENABLED(ADVANCED_PAUSE_FEATURE)
+          case ADVANCED_LOAD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Length"));
+              Draw_Float(fc_settings[0].load_length, row, false, 1);
+            }
+            else
+              Modify_Value(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
+            break;
+          case ADVANCED_UNLOAD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Length"));
+              Draw_Float(fc_settings[0].unload_length, row, false, 1);
+            }
+            else
+              Modify_Value(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
+            break;
+        #endif // ADVANCED_PAUSE_FEATURE
+
+        #if ENABLED(PREVENT_COLD_EXTRUSION)
+          case ADVANCED_COLD_EXTRUDE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Cool, F("Min Extrusion T"));
+              Draw_Float(thermalManager.extrude_min_temp, row, false, 1);
+            }
+            else {
+              Modify_Value(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
+              thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
+            }
+            break;
+        #endif
+
+        #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+          case ADVANCED_FILSENSORENABLED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
+              Draw_Checkbox(row, runout.enabled);
+            }
+            else {
+              runout.enabled = !runout.enabled;
+              Draw_Checkbox(row, runout.enabled);
+            }
+            break;
+
+          #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
+            case ADVANCED_FILSENSORDISTANCE:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxAccE, F("Runout Distance"));
+                Draw_Float(runout.runout_distance(), row, false, 10);
+              }
+              else
+                Modify_Value(runout.runout_distance(), 0, 999, 10);
+              break;
+          #endif
+        #endif // FILAMENT_RUNOUT_SENSOR
+
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          case ADVANCED_POWER_LOSS:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Motion, F("Power-loss recovery"));
+              Draw_Checkbox(row, recovery.enabled);
+            }
+            else {
+              recovery.enable(!recovery.enabled);
+              Draw_Checkbox(row, recovery.enabled);
+            }
+            break;
+        #endif
+      }
+      break;
+
+    #if HAS_BED_PROBE
+      case ProbeMenu:
+
+        #define PROBE_BACK 0
+        #define PROBE_XOFFSET (PROBE_BACK + 1)
+        #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
+        #define PROBE_TEST (PROBE_YOFFSET + 1)
+        #define PROBE_TEST_COUNT (PROBE_TEST + 1)
+        #define PROBE_TOTAL PROBE_TEST_COUNT
+
+        static uint8_t testcount = 4;
+
+        switch (item) {
+          case PROBE_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Advanced, ADVANCED_PROBE);
+            break;
+
+            case PROBE_XOFFSET:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepX, F("Probe X Offset"));
+                Draw_Float(probe.offset.x, row, false, 10);
+              }
+              else
+                Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+              break;
+            case PROBE_YOFFSET:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepY, F("Probe Y Offset"));
+                Draw_Float(probe.offset.y, row, false, 10);
+              }
+              else
+                Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+              break;
+            case PROBE_TEST:
+              if (draw)
+                Draw_Menu_Item(row, ICON_StepY, F("M48 Probe Test"));
+              else {
+                sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
+                gcode.process_subcommands_now(cmd);
+              }
+              break;
+            case PROBE_TEST_COUNT:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepY, F("Probe Test Count"));
+                Draw_Float(testcount, row, false, 1);
+              }
+              else
+                Modify_Value(testcount, 4, 50, 1);
+              break;
+        }
+        break;
+    #endif
+
+    case InfoMain:
+    case Info:
+
+      #define INFO_BACK 0
+      #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
+      #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
+      #define INFO_SIZE (INFO_PRINTTIME + 1)
+      #define INFO_VERSION (INFO_SIZE + 1)
+      #define INFO_CONTACT (INFO_VERSION + 1)
+      #define INFO_TOTAL INFO_BACK
+
+      switch (item) {
+        case INFO_BACK:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+
+            #if ENABLED(PRINTCOUNTER)
+              char row1[50], row2[50], buf[32];
+              printStatistics ps = print_job_timer.getStats();
+
+              sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
+              sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
+              Draw_Menu_Item(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
+
+              duration_t(print_job_timer.getStats().printTime).toString(buf);
+              sprintf_P(row1, PSTR("Printed: %s"), buf);
+              duration_t(print_job_timer.getStats().longestPrint).toString(buf);
+              sprintf_P(row2, PSTR("Longest: %s"), buf);
+              Draw_Menu_Item(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
+            #endif
+
+            Draw_Menu_Item(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
+            Draw_Menu_Item(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
+            Draw_Menu_Item(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
+          }
+          else {
+            if (menu == Info)
+              Draw_Menu(Control, CONTROL_INFO);
+            else
+              Draw_Main_Menu(3);
+          }
+          break;
+      }
+      break;
+
+    #if HAS_MESH
+      case Leveling:
+
+        #define LEVELING_BACK 0
+        #define LEVELING_ACTIVE (LEVELING_BACK + 1)
+        #define LEVELING_GET_TILT (LEVELING_ACTIVE + BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL))
+        #define LEVELING_GET_MESH (LEVELING_GET_TILT + 1)
+        #define LEVELING_MANUAL (LEVELING_GET_MESH + 1)
+        #define LEVELING_VIEW (LEVELING_MANUAL + 1)
+        #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
+        #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_TOTAL LEVELING_SAVE
+
+        switch (item) {
+          case LEVELING_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Main_Menu(3);
+            break;
+          case LEVELING_ACTIVE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StockConfiguration, F("Leveling Active"));
+              Draw_Checkbox(row, planner.leveling_active);
+            }
+            else {
+              if (!planner.leveling_active) {
+                set_bed_leveling_enabled(!planner.leveling_active);
+                if (!planner.leveling_active) {
+                  Confirm_Handler(LevelError);
+                  break;
+                }
+              }
+              else
+                set_bed_leveling_enabled(!planner.leveling_active);
+              Draw_Checkbox(row, planner.leveling_active);
+            }
+            break;
+          #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
+            case LEVELING_GET_TILT:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
+              else {
+                if (bedlevel.storage_slot < 0) {
+                  Popup_Handler(MeshSlot);
+                  break;
+                }
+                Popup_Handler(Home);
+                gcode.home_all_axes(true);
+                Popup_Handler(Level);
+                if (mesh_conf.tilt_grid > 1) {
+                  sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
+                  gcode.process_subcommands_now(cmd);
+                }
+                else
+                  gcode.process_subcommands_now(F("G29 J"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+              break;
+          #endif
+          case LEVELING_GET_MESH:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Mesh, F("Create New Mesh"));
+            else {
+              Popup_Handler(Home);
+              gcode.home_all_axes(true);
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                #if ENABLED(PREHEAT_BEFORE_LEVELING)
+                  Popup_Handler(Heating);
+                  probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
+                #endif
+                #if HAS_BED_PROBE
+                  Popup_Handler(Level);
+                  gcode.process_subcommands_now(F("G29 P0\nG29 P1"));
+                  gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
+                  planner.synchronize();
+                  Update_Status("Probed all reachable points");
+                  Popup_Handler(SaveLevel);
+                #else
+                  level_state = planner.leveling_active;
+                  set_bed_leveling_enabled(false);
+                  mesh_conf.goto_mesh_value = true;
+                  mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
+                  Popup_Handler(MoveWait);
+                  mesh_conf.manual_mesh_move();
+                  Draw_Menu(UBLMesh);
+                #endif
+              #elif HAS_BED_PROBE
+                Popup_Handler(Level);
+                gcode.process_subcommands_now(F("G29"));
+                planner.synchronize();
+                Popup_Handler(SaveLevel);
+              #else
+                level_state = planner.leveling_active;
+                set_bed_leveling_enabled(false);
+                gridpoint = 1;
+                Popup_Handler(MoveWait);
+                gcode.process_subcommands_now(F("G29"));
+                planner.synchronize();
+                Draw_Menu(ManualMesh);
+              #endif
+            }
+            break;
+          case LEVELING_MANUAL:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
+            else {
+              #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+                if (!leveling_is_valid()) {
+                  Confirm_Handler(InvalidMesh);
+                  break;
+                }
+              #endif
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                if (bedlevel.storage_slot < 0) {
+                  Popup_Handler(MeshSlot);
+                  break;
+                }
+              #endif
+              if (axes_should_home()) {
+                Popup_Handler(Home);
+                gcode.home_all_axes(true);
+              }
+              level_state = planner.leveling_active;
+              set_bed_leveling_enabled(false);
+              mesh_conf.goto_mesh_value = false;
+              #if ENABLED(PREHEAT_BEFORE_LEVELING)
+                Popup_Handler(Heating);
+                #if HAS_HOTEND
+                  if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
+                    thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
+                #endif
+                #if HAS_HEATED_BED
+                  if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
+                    thermalManager.setTargetBed(LEVELING_BED_TEMP);
+                #endif
+                TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
+                TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
+              #endif
+              Popup_Handler(MoveWait);
+              mesh_conf.manual_mesh_move();
+              Draw_Menu(LevelManual);
+            }
+            break;
+          case LEVELING_VIEW:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
+            else {
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                if (bedlevel.storage_slot < 0) {
+                  Popup_Handler(MeshSlot);
+                  break;
+                }
+              #endif
+              Draw_Menu(LevelView);
+            }
+            break;
+          case LEVELING_SETTINGS:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, F("Leveling Settings"), nullptr, true);
+            else
+              Draw_Menu(LevelSettings);
+            break;
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+          case LEVELING_SLOT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_PrintSize, F("Mesh Slot"));
+              Draw_Float(bedlevel.storage_slot, row, false, 1);
+            }
+            else
+              Modify_Value(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
+            break;
+          case LEVELING_LOAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Load Mesh"));
+            else {
+              if (bedlevel.storage_slot < 0) {
+                Popup_Handler(MeshSlot);
+                break;
+              }
+              gcode.process_subcommands_now(F("G29 L"));
+              planner.synchronize();
+              AudioFeedback(true);
+            }
+            break;
+          case LEVELING_SAVE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save Mesh"));
+            else {
+              if (bedlevel.storage_slot < 0) {
+                Popup_Handler(MeshSlot);
+                break;
+              }
+              gcode.process_subcommands_now(F("G29 S"));
+              planner.synchronize();
+              AudioFeedback(true);
+            }
+            break;
+          #endif
+        }
+        break;
+
+      case LevelView:
+
+        #define LEVELING_VIEW_BACK 0
+        #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
+        #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
+        #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
+        #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
+
+        switch (item) {
+          case LEVELING_VIEW_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Leveling, LEVELING_VIEW);
+            break;
+          case LEVELING_VIEW_MESH:
+            if (draw)
+              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
+            else
+              Draw_Menu(MeshViewer);
+            break;
+          case LEVELING_VIEW_TEXT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Contact, F("Viewer Show Values"));
+              Draw_Checkbox(row, mesh_conf.viewer_print_value);
+            }
+            else {
+              mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
+              Draw_Checkbox(row, mesh_conf.viewer_print_value);
+            }
+            break;
+          case LEVELING_VIEW_ASYMMETRIC:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Axis, F("Viewer Asymmetric"));
+              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
+            }
+            else {
+              mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
+              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
+            }
+            break;
+        }
+        break;
+
+      case LevelSettings:
+
+        #define LEVELING_SETTINGS_BACK 0
+        #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
+        #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
+
+        switch (item) {
+          case LEVELING_SETTINGS_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Leveling, LEVELING_SETTINGS);
+            break;
+          case LEVELING_SETTINGS_FADE:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_Fade, F("Fade Mesh within"));
+                Draw_Float(planner.z_fade_height, row, false, 1);
+              }
+              else {
+                Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
+                planner.z_fade_height = -1;
+                set_z_fade_height(planner.z_fade_height);
+              }
+              break;
+
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+            case LEVELING_SETTINGS_TILT:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_Tilt, F("Tilting Grid Size"));
+                Draw_Float(mesh_conf.tilt_grid, row, false, 1);
+              }
+              else
+                Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
+              break;
+            case LEVELING_SETTINGS_PLANE:
+              if (draw)
+                Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
+              else {
+                if (mesh_conf.create_plane_from_mesh()) break;
+                gcode.process_subcommands_now(F("M420 S1"));
+                planner.synchronize();
+                AudioFeedback(true);
+              }
+              break;
+            case LEVELING_SETTINGS_ZERO:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Mesh, F("Zero Current Mesh"));
+              else
+                ZERO(bedlevel.z_values);
+              break;
+            case LEVELING_SETTINGS_UNDEF:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Mesh, F("Clear Current Mesh"));
+              else
+                bedlevel.invalidate();
+              break;
+          #endif // AUTO_BED_LEVELING_UBL
+        }
+        break;
+
+      case MeshViewer:
+        #define MESHVIEW_BACK 0
+        #define MESHVIEW_TOTAL MESHVIEW_BACK
+
+        if (item == MESHVIEW_BACK) {
+          if (draw) {
+            Draw_Menu_Item(0, ICON_Back, F("Back"));
+            mesh_conf.Draw_Bed_Mesh();
+            mesh_conf.Set_Mesh_Viewer_Status();
+          }
+          else if (!mesh_conf.drawing_mesh) {
+            Draw_Menu(LevelView, LEVELING_VIEW_MESH);
+            Update_Status("");
+          }
+        }
+        break;
+
+      case LevelManual:
+
+        #define LEVELING_M_BACK 0
+        #define LEVELING_M_X (LEVELING_M_BACK + 1)
+        #define LEVELING_M_Y (LEVELING_M_X + 1)
+        #define LEVELING_M_NEXT (LEVELING_M_Y + 1)
+        #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
+        #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
+        #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
+        #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
+        #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_M_TOTAL LEVELING_M_UNDEF
+
+        switch (item) {
+          case LEVELING_M_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else {
+              set_bed_leveling_enabled(level_state);
+              TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
+              Draw_Menu(Leveling, LEVELING_MANUAL);
+            }
+            break;
+          case LEVELING_M_X:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MoveX, F("Mesh Point X"));
+              Draw_Float(mesh_conf.mesh_x, row, 0, 1);
+            }
+            else
+              Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
+            break;
+          case LEVELING_M_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MoveY, F("Mesh Point Y"));
+              Draw_Float(mesh_conf.mesh_y, row, 0, 1);
+            }
+            else
+              Modify_Value(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
+            break;
+          case LEVELING_M_NEXT:
+            if (draw)
+              Draw_Menu_Item(row, ICON_More, F("Next Point"));
+            else {
+              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
+                  mesh_conf.mesh_y++;
+                else if (mesh_conf.mesh_y % 2 == 0)
+                  mesh_conf.mesh_x++;
+                else
+                  mesh_conf.mesh_x--;
+                mesh_conf.manual_mesh_move();
+              }
+            }
+            break;
+          case LEVELING_M_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+            }
+            else {
+              if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            }
+            break;
+          case LEVELING_M_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+              gcode.process_subcommands_now(F("M290 Z0.01"));
+              planner.synchronize();
+              current_position.z += 0.01f;
+              sync_plan_position();
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+            }
+            break;
+          case LEVELING_M_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
+              planner.synchronize();
+              current_position.z -= 0.01f;
+              sync_plan_position();
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+            }
+            break;
+          case LEVELING_M_GOTO_VALUE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
+              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
+            }
+            else {
+              mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
+              current_position.z = 0;
+              mesh_conf.manual_mesh_move(true);
+              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
+            }
+            break;
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+          case LEVELING_M_UNDEF:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Clear Point Value"));
+            else {
+              mesh_conf.manual_value_update(true);
+              Redraw_Menu(false);
+            }
+            break;
+          #endif
+        }
+        break;
+    #endif // HAS_MESH
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+      case UBLMesh:
+
+        #define UBL_M_BACK 0
+        #define UBL_M_NEXT (UBL_M_BACK + 1)
+        #define UBL_M_PREV (UBL_M_NEXT + 1)
+        #define UBL_M_OFFSET (UBL_M_PREV + 1)
+        #define UBL_M_UP (UBL_M_OFFSET + 1)
+        #define UBL_M_DOWN (UBL_M_UP + 1)
+        #define UBL_M_TOTAL UBL_M_DOWN
+
+        switch (item) {
+          case UBL_M_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else {
+              set_bed_leveling_enabled(level_state);
+              Draw_Menu(Leveling, LEVELING_GET_MESH);
+            }
+            break;
+          case UBL_M_NEXT:
+            if (draw) {
+              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
+                Draw_Menu_Item(row, ICON_More, F("Next Point"));
+              else
+                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
+            }
+            else {
+              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
+                  mesh_conf.mesh_y++;
+                else if (mesh_conf.mesh_y % 2 == 0)
+                  mesh_conf.mesh_x++;
+                else
+                  mesh_conf.mesh_x--;
+                mesh_conf.manual_mesh_move();
+              }
+              else {
+                gcode.process_subcommands_now(F("G29 S"));
+                planner.synchronize();
+                AudioFeedback(true);
+                Draw_Menu(Leveling, LEVELING_GET_MESH);
+              }
+            }
+            break;
+          case UBL_M_PREV:
+            if (draw)
+              Draw_Menu_Item(row, ICON_More, F("Previous Point"));
+            else {
+              if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
+                  mesh_conf.mesh_y--;
+                else if (mesh_conf.mesh_y % 2 == 0)
+                  mesh_conf.mesh_x--;
+                else
+                  mesh_conf.mesh_x++;
+                mesh_conf.manual_mesh_move();
+              }
+            }
+            break;
+          case UBL_M_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+            }
+            else {
+              if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            }
+            break;
+          case UBL_M_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+              gcode.process_subcommands_now(F("M290 Z0.01"));
+              planner.synchronize();
+              current_position.z += 0.01f;
+              sync_plan_position();
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+            }
+            break;
+          case UBL_M_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Down"));
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
+              planner.synchronize();
+              current_position.z -= 0.01f;
+              sync_plan_position();
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+            }
+            break;
+        }
+        break;
+    #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
+
+    #if ENABLED(PROBE_MANUALLY)
+      case ManualMesh:
+
+        #define MMESH_BACK 0
+        #define MMESH_NEXT (MMESH_BACK + 1)
+        #define MMESH_OFFSET (MMESH_NEXT + 1)
+        #define MMESH_UP (MMESH_OFFSET + 1)
+        #define MMESH_DOWN (MMESH_UP + 1)
+        #define MMESH_OLD (MMESH_DOWN + 1)
+        #define MMESH_TOTAL MMESH_OLD
+
+        switch (item) {
+          case MMESH_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
+            else {
+              gcode.process_subcommands_now(F("G29 A"));
+              planner.synchronize();
+              set_bed_leveling_enabled(level_state);
+              Draw_Menu(Leveling, LEVELING_GET_MESH);
+            }
+            break;
+          case MMESH_NEXT:
+            if (draw) {
+              if (gridpoint < GRID_MAX_POINTS)
+                Draw_Menu_Item(row, ICON_More, F("Next Point"));
+              else
+                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
+            }
+            else if (gridpoint < GRID_MAX_POINTS) {
+              Popup_Handler(MoveWait);
+              gcode.process_subcommands_now(F("G29"));
+              planner.synchronize();
+              gridpoint++;
+              Redraw_Menu();
+            }
+            else {
+              gcode.process_subcommands_now(F("G29"));
+              planner.synchronize();
+              AudioFeedback(settings.save());
+              Draw_Menu(Leveling, LEVELING_GET_MESH);
+            }
+            break;
+          case MMESH_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
+              current_position.z = MANUAL_PROBE_START_Z;
+              Draw_Float(current_position.z, row, false, 100);
+            }
+            else
+              Modify_Value(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          case MMESH_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
+            else if (current_position.z < MAX_Z_OFFSET) {
+              gcode.process_subcommands_now(F("M290 Z0.01"));
+              planner.synchronize();
+              current_position.z += 0.01f;
+              sync_plan_position();
+              Draw_Float(current_position.z, row - 1, false, 100);
+            }
+            break;
+          case MMESH_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
+            else if (current_position.z > MIN_Z_OFFSET) {
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
+              planner.synchronize();
+              current_position.z -= 0.01f;
+              sync_plan_position();
+              Draw_Float(current_position.z, row - 2, false, 100);
+            }
+            break;
+          case MMESH_OLD:
+            uint8_t mesh_x, mesh_y;
+            // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
+            mesh_y = (gridpoint - 1) / (GRID_MAX_POINTS_Y);
+            mesh_x = (gridpoint - 1) % (GRID_MAX_POINTS_X);
+
+            if (mesh_y % 2 == 1)
+              mesh_x = (GRID_MAX_POINTS_X) - mesh_x - 1;
+
+            const float currval = bedlevel.z_values[mesh_x][mesh_y];
+
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Zoffset, F("Goto Mesh Value"));
+              Draw_Float(currval, row, false, 100);
+            }
+            else if (!isnan(currval)) {
+              current_position.z = currval;
+              planner.synchronize();
+              planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+              planner.synchronize();
+              Draw_Float(current_position.z, row - 3, false, 100);
+            }
+            break;
+        }
+        break;
+    #endif // PROBE_MANUALLY
+
+    case Tune:
+
+      #define TUNE_BACK 0
+      #define TUNE_SPEED (TUNE_BACK + 1)
+      #define TUNE_FLOW (TUNE_SPEED + ENABLED(HAS_HOTEND))
+      #define TUNE_HOTEND (TUNE_FLOW + ENABLED(HAS_HOTEND))
+      #define TUNE_BED (TUNE_HOTEND + ENABLED(HAS_HEATED_BED))
+      #define TUNE_FAN (TUNE_BED + ENABLED(HAS_FAN))
+      #define TUNE_ZOFFSET (TUNE_FAN + ENABLED(HAS_ZOFFSET_ITEM))
+      #define TUNE_ZUP (TUNE_ZOFFSET + ENABLED(HAS_ZOFFSET_ITEM))
+      #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
+      #define TUNE_CHANGEFIL (TUNE_ZDOWN + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
+      #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
+      #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
+      #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
+      #define TUNE_TOTAL TUNE_BACKLIGHT
+
+      switch (item) {
+        case TUNE_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Print_Screen();
+          break;
+        case TUNE_SPEED:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Speed, F("Print Speed"));
+            Draw_Float(feedrate_percentage, row, false, 1);
+          }
+          else
+            Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
+          break;
+
+        #if HAS_HOTEND
+          case TUNE_FLOW:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
+              Draw_Float(planner.flow_percentage[0], row, false, 1);
+            }
+            else
+              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
+            break;
+          case TUNE_HOTEND:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
+              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+        #endif
+
+        #if HAS_HEATED_BED
+          case TUNE_BED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
+              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+        #endif
+
+        #if HAS_FAN
+          case TUNE_FAN:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+            break;
+        #endif
+
+        #if HAS_ZOFFSET_ITEM
+          case TUNE_ZOFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Z-Offset"));
+              Draw_Float(zoffsetvalue, row, false, 100);
+            }
+            else
+              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          case TUNE_ZUP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, F("Z-Offset Up"));
+            else if (zoffsetvalue < MAX_Z_OFFSET) {
+              gcode.process_subcommands_now(F("M290 Z0.01"));
+              zoffsetvalue += 0.01;
+              Draw_Float(zoffsetvalue, row - 1, false, 100);
+            }
+            break;
+          case TUNE_ZDOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, F("Z-Offset Down"));
+            else if (zoffsetvalue > MIN_Z_OFFSET) {
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
+              zoffsetvalue -= 0.01;
+              Draw_Float(zoffsetvalue, row - 2, false, 100);
+            }
+            break;
+        #endif
+
+        #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+          case TUNE_CHANGEFIL:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
+            else
+              Popup_Handler(ConfFilChange);
+            break;
+        #endif
+
+        #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+          case TUNE_FILSENSORENABLED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
+              Draw_Checkbox(row, runout.enabled);
+            }
+            else {
+              runout.enabled = !runout.enabled;
+              Draw_Checkbox(row, runout.enabled);
+            }
+            break;
+        #endif
+
+        case TUNE_BACKLIGHT_OFF:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
+          else
+            ui.set_brightness(0);
+          break;
+        case TUNE_BACKLIGHT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
+            Draw_Float(ui.brightness, row, false, 1);
+          }
+          else
+            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
+          break;
+      }
+      break;
+
+    #if HAS_PREHEAT && HAS_HOTEND
+
+      case PreheatHotend:
+
+        #define PREHEATHOTEND_BACK 0
+        #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
+        #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
+        #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
+        #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
+        #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
+        #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
+        #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
+        #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
+
+        switch (item) {
+          case PREHEATHOTEND_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
+            else {
+              thermalManager.setTargetHotend(0, 0);
+              thermalManager.set_fan_speed(0, 0);
+              Redraw_Menu(false, true, true);
+            }
+            break;
+          case PREHEATHOTEND_CONTINUE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Continue"));
+            else {
+              Popup_Handler(Heating);
+              thermalManager.wait_for_hotend(0);
+              switch (last_menu) {
+                case Prepare:
+                  Popup_Handler(FilChange);
+                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                  gcode.process_subcommands_now(cmd);
+                  break;
+                #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                  case ChangeFilament:
+                    switch (last_selection) {
+                      case CHANGEFIL_LOAD:
+                        Popup_Handler(FilLoad);
+                        gcode.process_subcommands_now(F("M701"));
+                        planner.synchronize();
+                        Redraw_Menu(true, true, true);
+                        break;
+                      case CHANGEFIL_UNLOAD:
+                        Popup_Handler(FilLoad, true);
+                        gcode.process_subcommands_now(F("M702"));
+                        planner.synchronize();
+                        Redraw_Menu(true, true, true);
+                        break;
+                      case CHANGEFIL_CHANGE:
+                        Popup_Handler(FilChange);
+                        sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                        gcode.process_subcommands_now(cmd);
+                        break;
+                    }
+                    break;
+                #endif
+                default:
+                  Redraw_Menu(true, true, true);
+                  break;
+              }
+            }
+            break;
+
+
+          #define _PREHEAT_HOTEND_CASE(N) \
+            case PREHEATHOTEND_##N: \
+              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+              else ui.preheat_hotend_and_fan((N) - 1); \
+              break;
+
+          REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
+
+          case PREHEATHOTEND_CUSTOM:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Temperature, F("Custom"));
+              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
+            break;
+        }
+        break;
+
+    #endif // HAS_PREHEAT && HAS_HOTEND
+  }
+}
+
+FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
+  switch (menu) {
+    case MainMenu:          return F("Main Menu");
+    case Prepare:           return F("Prepare");
+    case HomeMenu:          return F("Homing Menu");
+    case Move:              return F("Move");
+    case ManualLevel:       return F("Manual Leveling");
+    #if HAS_ZOFFSET_ITEM
+      case ZOffset:         return F("Z Offset");
+    #endif
+    #if HAS_PREHEAT
+      case Preheat:         return F("Preheat");
+    #endif
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      case ChangeFilament:  return F("Change Filament");
+    #endif
+    #if HAS_CUSTOM_MENU
+      case MenuCustom:
+        #ifdef CUSTOM_MENU_CONFIG_TITLE
+          return F(CUSTOM_MENU_CONFIG_TITLE);
+        #else
+          return F("Custom Commands");
+        #endif
+    #endif
+    case Control:           return F("Control");
+    case TempMenu:          return F("Temperature");
+    #if HAS_HOTEND || HAS_HEATED_BED
+      case PID:             return F("PID Menu");
+    #endif
+    #if HAS_HOTEND
+      case HotendPID:       return F("Hotend PID Settings");
+    #endif
+    #if HAS_HEATED_BED
+      case BedPID:          return F("Bed PID Settings");
+    #endif
+    #if HAS_PREHEAT
+      #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
+      REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
+    #endif
+    case Motion:            return F("Motion Settings");
+    case HomeOffsets:       return F("Home Offsets");
+    case MaxSpeed:          return F("Max Speed");
+    case MaxAcceleration:   return F("Max Acceleration");
+    #if HAS_CLASSIC_JERK
+      case MaxJerk:         return F("Max Jerk");
+    #endif
+    case Steps:             return F("Steps/mm");
+    case Visual:            return F("Visual Settings");
+    case Advanced:          return F("Advanced Settings");
+    #if HAS_BED_PROBE
+      case ProbeMenu:       return F("Probe Menu");
+    #endif
+    case ColorSettings:     return F("UI Color Settings");
+    case Info:              return F("Info");
+    case InfoMain:          return F("Info");
+    #if HAS_MESH
+      case Leveling:        return F("Leveling");
+      case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
+      case LevelSettings:   return F("Leveling Settings");
+      case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
+      case LevelManual:     return F("Manual Tuning");
+    #endif
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+      case UBLMesh:         return F("UBL Bed Leveling");
+    #endif
+    #if ENABLED(PROBE_MANUALLY)
+      case ManualMesh:      return F("Mesh Bed Leveling");
+    #endif
+    case Tune:              return F("Tune");
+    case PreheatHotend:     return F("Preheat Hotend");
+  }
+  return F("");
+}
+
+uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
+  switch (menu) {
+    case Prepare:           return PREPARE_TOTAL;
+    case HomeMenu:          return HOME_TOTAL;
+    case Move:              return MOVE_TOTAL;
+    case ManualLevel:       return MLEVEL_TOTAL;
+    #if HAS_ZOFFSET_ITEM
+      case ZOffset:         return ZOFFSET_TOTAL;
+    #endif
+    #if HAS_PREHEAT
+      case Preheat:         return PREHEAT_TOTAL;
+    #endif
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      case ChangeFilament:  return CHANGEFIL_TOTAL;
+    #endif
+    #if HAS_CUSTOM_MENU
+      case MenuCustom:      return CUSTOM_MENU_TOTAL;
+    #endif
+    case Control:           return CONTROL_TOTAL;
+    case TempMenu:          return TEMP_TOTAL;
+    #if HAS_HOTEND || HAS_HEATED_BED
+      case PID:             return PID_TOTAL;
+    #endif
+    #if HAS_HOTEND
+      case HotendPID:       return HOTENDPID_TOTAL;
+    #endif
+    #if HAS_HEATED_BED
+      case BedPID:          return BEDPID_TOTAL;
+    #endif
+    #if HAS_PREHEAT
+      case Preheat1 ... CAT(Preheat, PREHEAT_COUNT):
+                            return PREHEAT_SUBMENU_TOTAL;
+    #endif
+    case Motion:            return MOTION_TOTAL;
+    case HomeOffsets:       return HOMEOFFSETS_TOTAL;
+    case MaxSpeed:          return SPEED_TOTAL;
+    case MaxAcceleration:   return ACCEL_TOTAL;
+    #if HAS_CLASSIC_JERK
+      case MaxJerk:         return JERK_TOTAL;
+    #endif
+    case Steps:             return STEPS_TOTAL;
+    case Visual:            return VISUAL_TOTAL;
+    case Advanced:          return ADVANCED_TOTAL;
+    #if HAS_BED_PROBE
+      case ProbeMenu:       return PROBE_TOTAL;
+    #endif
+    case Info:              return INFO_TOTAL;
+    case InfoMain:          return INFO_TOTAL;
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+      case UBLMesh:         return UBL_M_TOTAL;
+    #endif
+    #if ENABLED(PROBE_MANUALLY)
+      case ManualMesh:      return MMESH_TOTAL;
+    #endif
+    #if HAS_MESH
+      case Leveling:        return LEVELING_TOTAL;
+      case LevelView:       return LEVELING_VIEW_TOTAL;
+      case LevelSettings:   return LEVELING_SETTINGS_TOTAL;
+      case MeshViewer:      return MESHVIEW_TOTAL;
+      case LevelManual:     return LEVELING_M_TOTAL;
+    #endif
+    case Tune:              return TUNE_TOTAL;
+
+    #if HAS_PREHEAT && HAS_HOTEND
+      case PreheatHotend:   return PREHEATHOTEND_TOTAL;
+    #endif
+
+    case ColorSettings:     return COLORSETTINGS_TOTAL;
+  }
+  return 0;
+}
+
+/* Popup Config */
+
+void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
+  popup = last_popup = popupid;
+  switch (popupid) {
+    case Pause:         Draw_Popup(F("Pause Print"), F(""), F(""), Popup); break;
+    case Stop:          Draw_Popup(F("Stop Print"), F(""), F(""), Popup); break;
+    case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
+    case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
+    case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
+    case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
+    case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
+    case ETemp:         Draw_Popup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
+    case ManualProbing: Draw_Popup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
+    case Level:         Draw_Popup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
+    case Home:          Draw_Popup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case MoveWait:      Draw_Popup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Heating:       Draw_Popup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case FilChange:     Draw_Popup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
+    case TempWarn:      Draw_Popup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
+    case Runout:        Draw_Popup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
+    case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
+    case Resuming:      Draw_Popup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Custom:        Draw_Popup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    default: break;
+  }
+}
+
+void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
+  popup = popupid;
+  switch (popupid) {
+    case FilInsert:   Draw_Popup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
+    case HeaterTime:  Draw_Popup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
+    case UserInput:   Draw_Popup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
+    case LevelError:  Draw_Popup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
+    case InvalidMesh: Draw_Popup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
+    default: break;
+  }
+}
+
+/* Navigation and Control */
+
+void CrealityDWINClass::Main_Menu_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {
+    selection++; // Select Down
+    Main_Menu_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    selection--; // Select Up
+    Main_Menu_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER)
+    switch (selection) {
+      case PAGE_PRINT: card.mount(); Draw_SD_List(); break;
+      case PAGE_PREPARE: Draw_Menu(Prepare); break;
+      case PAGE_CONTROL: Draw_Menu(Control); break;
+      case PAGE_INFO_LEVELING: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
+    }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Menu_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    selection++; // Select Down
+    if (selection > scrollpos+MROWS) {
+      scrollpos++;
+      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Menu_Item_Handler(active_menu, selection);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    selection--; // Select Up
+    if (selection < scrollpos) {
+      scrollpos--;
+      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Menu_Item_Handler(active_menu, selection);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER)
+    Menu_Item_Handler(active_menu, selection, false);
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Value_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    tempvalue += EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    tempvalue -= EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    process = Menu;
+    EncoderRate.enabled = false;
+    Draw_Float(tempvalue / valueunit, selection - scrollpos, false, valueunit);
+    DWIN_UpdateLCD();
+    if (active_menu == ZOffset && liveadjust) {
+      planner.synchronize();
+      current_position.z += (tempvalue / valueunit - zoffsetvalue);
+      planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+      current_position.z = 0;
+      sync_plan_position();
+    }
+    else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
+      sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - zoffsetvalue), 1, 3, str_1));
+      gcode.process_subcommands_now(cmd);
+    }
+    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
+      tempvalue = scalePID_i(tempvalue);
+    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
+      tempvalue = scalePID_d(tempvalue);
+    switch (valuetype) {
+      case 0: *(float*)valuepointer = tempvalue / valueunit; break;
+      case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
+      case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
+      case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
+      case 4: *(uint32_t*)valuepointer = tempvalue / valueunit; break;
+      case 5: *(int8_t*)valuepointer = tempvalue / valueunit; break;
+    }
+    switch (active_menu) {
+      case Move:
+        planner.synchronize();
+        planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
+        break;
+      #if HAS_MESH
+        case ManualMesh:
+          planner.synchronize();
+          planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+          planner.synchronize();
+          break;
+        case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
+        case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
+      #endif
+    }
+    if (valuepointer == &planner.flow_percentage[0])
+      planner.refresh_e_factor(0);
+    if (funcpointer) funcpointer();
+    return;
+  }
+  NOLESS(tempvalue, (valuemin * valueunit));
+  NOMORE(tempvalue, (valuemax * valueunit));
+  Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
+  DWIN_UpdateLCD();
+  if (active_menu == Move && livemove) {
+    *(float*)valuepointer = tempvalue / valueunit;
+    planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
+  }
+}
+
+void CrealityDWINClass::Option_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    tempvalue += EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    tempvalue -= EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    process = Menu;
+    EncoderRate.enabled = false;
+    if (valuepointer == &color_names) {
+      switch (selection) {
+        case COLORSETTINGS_CURSOR: eeprom_settings.cursor_color = tempvalue; break;
+        case COLORSETTINGS_SPLIT_LINE: eeprom_settings.menu_split_line = tempvalue; break;
+        case COLORSETTINGS_MENU_TOP_BG: eeprom_settings.menu_top_bg = tempvalue; break;
+        case COLORSETTINGS_MENU_TOP_TXT: eeprom_settings.menu_top_txt = tempvalue; break;
+        case COLORSETTINGS_HIGHLIGHT_BORDER: eeprom_settings.highlight_box = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_PERCENT: eeprom_settings.progress_percent = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_TIME: eeprom_settings.progress_time = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_STATUS_BAR: eeprom_settings.status_bar_text = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_STATUS_AREA: eeprom_settings.status_area_text = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_COORDINATES: eeprom_settings.coordinates_text = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_COORDINATES_LINE: eeprom_settings.coordinates_split_line = tempvalue; break;
+      }
+      Redraw_Screen();
+    }
+    else if (valuepointer == &preheat_modes)
+      preheatmode = tempvalue;
+
+    Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
+    DWIN_UpdateLCD();
+    return;
+  }
+  NOLESS(tempvalue, valuemin);
+  NOMORE(tempvalue, valuemax);
+  Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::File_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  static uint8_t filescrl = 0;
+  if (encoder_diffState == ENCODER_DIFF_NO) {
+    if (selection > 0) {
+      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
+      char * const filename = card.longest_filename();
+      size_t len = strlen(filename);
+      int8_t pos = len;
+      if (!card.flag.filenameIsDir)
+        while (pos && filename[pos] != '.') pos--;
+      if (pos > MENU_CHAR_LIMIT) {
+        static millis_t time = 0;
+        if (PENDING(millis(), time)) return;
+        time = millis() + 200;
+        pos -= filescrl;
+        len = _MIN(pos, MENU_CHAR_LIMIT);
+        char name[len + 1];
+        if (pos >= 0) {
+          LOOP_L_N(i, len) name[i] = filename[i + filescrl];
+        }
+        else {
+          LOOP_L_N(i, MENU_CHAR_LIMIT + pos) name[i] = ' ';
+          LOOP_S_L_N(i, MENU_CHAR_LIMIT + pos, MENU_CHAR_LIMIT) name[i] = filename[i - (MENU_CHAR_LIMIT + pos)];
+        }
+        name[len] = '\0';
+        DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+        Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
+        if (-pos >= MENU_CHAR_LIMIT) filescrl = 0;
+        filescrl++;
+        DWIN_UpdateLCD();
+      }
+    }
+    return;
+  }
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_Files()) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    if (selection > 0) {
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+      Draw_SD_Item(selection, selection - scrollpos);
+    }
+    filescrl = 0;
+    selection++; // Select Down
+    if (selection > scrollpos + MROWS) {
+      scrollpos++;
+      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Draw_SD_Item(selection, selection - scrollpos);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+    Draw_SD_Item(selection, selection - scrollpos);
+    filescrl = 0;
+    selection--; // Select Up
+    if (selection < scrollpos) {
+      scrollpos--;
+      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Draw_SD_Item(selection, selection - scrollpos);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    if (selection == 0) {
+      if (card.flag.workDirIsRoot) {
+        process = Main;
+        Draw_Main_Menu();
+      }
+      else {
+        card.cdup();
+        Draw_SD_List();
+      }
+    }
+    else {
+      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
+      if (card.flag.filenameIsDir) {
+        card.cd(card.filename);
+        Draw_SD_List();
+      }
+      else {
+        card.openAndPrintFile(card.filename);
+      }
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Print_Screen_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
+    selection++; // Select Down
+    Print_Screen_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    selection--; // Select Up
+    Print_Screen_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (selection) {
+      case PRINT_SETUP:
+        Draw_Menu(Tune);
+        Update_Status_Bar(true);
+        break;
+      case PRINT_PAUSE_RESUME:
+        if (paused) {
+          if (sdprint) {
+            wait_for_user = false;
+            #if ENABLED(PARK_HEAD_ON_PAUSE)
+              card.startOrResumeFilePrinting();
+              TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
+            #else
+              char cmd[20];
+              #if HAS_HEATED_BED
+                sprintf_P(cmd, PSTR("M140 S%i"), pausebed);
+                gcode.process_subcommands_now(cmd);
+              #endif
+              #if HAS_EXTRUDERS
+                sprintf_P(cmd, PSTR("M109 S%i"), pausetemp);
+                gcode.process_subcommands_now(cmd);
+              #endif
+              TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
+              planner.synchronize();
+              TERN_(SDSUPPORT, queue.inject(F("M24")));
+            #endif
+          }
+          else {
+            TERN_(HOST_ACTION_COMMANDS, hostui.resume());
+          }
+          Draw_Print_Screen();
+        }
+        else
+          Popup_Handler(Pause);
+        break;
+      case PRINT_STOP: Popup_Handler(Stop); break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Popup_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
+    selection++;
+    Popup_Select();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    selection--;
+    Popup_Select();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (popup) {
+      case Pause:
+        if (selection == 0) {
+          if (sdprint) {
+            #if ENABLED(POWER_LOSS_RECOVERY)
+              if (recovery.enabled) recovery.save(true);
+            #endif
+            #if ENABLED(PARK_HEAD_ON_PAUSE)
+              Popup_Handler(Home, true);
+              #if ENABLED(SDSUPPORT)
+                if (IS_SD_PRINTING()) card.pauseSDPrint();
+              #endif
+              planner.synchronize();
+              queue.inject(F("M125"));
+              planner.synchronize();
+            #else
+              queue.inject(F("M25"));
+              TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
+              TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
+              TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
+              thermalManager.cooldown();
+            #endif
+          }
+          else {
+            TERN_(HOST_ACTION_COMMANDS, hostui.pause());
+          }
+        }
+        Draw_Print_Screen();
+        break;
+      case Stop:
+        if (selection == 0) {
+          if (sdprint) {
+            ui.abort_print();
+            thermalManager.cooldown();
+          }
+          else {
+            TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
+          }
+        }
+        else
+          Draw_Print_Screen();
+        break;
+      case Resume:
+        if (selection == 0)
+          queue.inject(F("M1000"));
+        else {
+          queue.inject(F("M1000 C"));
+          Draw_Main_Menu();
+        }
+        break;
+
+      #if HAS_HOTEND
+        case ETemp:
+          if (selection == 0) {
+            thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
+            thermalManager.set_fan_speed(0, MAX_FAN_SPEED);
+            Draw_Menu(PreheatHotend);
+          }
+          else
+            Redraw_Menu(true, true, false);
+          break;
+      #endif
+
+      #if HAS_BED_PROBE
+        case ManualProbing:
+          if (selection == 0) {
+            char buf[80];
+            const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - corner_avg;
+            sprintf_P(buf, dif > 0 ? PSTR("Corner is %smm high") : PSTR("Corner is %smm low"), dtostrf(abs(dif), 1, 3, str_1));
+            Update_Status(buf);
+          }
+          else {
+            Redraw_Menu(true, true, false);
+            Update_Status("");
+          }
+          break;
+      #endif
+
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        case ConfFilChange:
+          if (selection == 0) {
+            if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+              Popup_Handler(ETemp);
+            else {
+              if (thermalManager.temp_hotend[0].is_below_target(-2)) {
+                Popup_Handler(Heating);
+                thermalManager.wait_for_hotend(0);
+              }
+              Popup_Handler(FilChange);
+              sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+              gcode.process_subcommands_now(cmd);
+            }
+          }
+          else
+            Redraw_Menu(true, true, false);
+          break;
+        case PurgeMore:
+          if (selection == 0) {
+            pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
+            Popup_Handler(FilChange);
+          }
+          else {
+            pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
+            if (printing) Popup_Handler(Resuming);
+            else Redraw_Menu(true, true, (active_menu==PreheatHotend));
+          }
+          break;
+      #endif // ADVANCED_PAUSE_FEATURE
+
+      #if HAS_MESH
+        case SaveLevel:
+          if (selection == 0) {
+            #if ENABLED(AUTO_BED_LEVELING_UBL)
+              gcode.process_subcommands_now(F("G29 S"));
+              planner.synchronize();
+              AudioFeedback(true);
+            #else
+              AudioFeedback(settings.save());
+            #endif
+          }
+          Draw_Menu(Leveling, LEVELING_GET_MESH);
+          break;
+      #endif
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        case MeshSlot:
+          if (selection == 0) bedlevel.storage_slot = 0;
+          Redraw_Menu(true, true);
+          break;
+      #endif
+      default: break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Confirm_Control() {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (popup) {
+      case Complete:
+        Draw_Main_Menu();
+        break;
+      case FilInsert:
+        Popup_Handler(FilChange);
+        wait_for_user = false;
+        break;
+      case HeaterTime:
+        Popup_Handler(Heating);
+        wait_for_user = false;
+        break;
+      default:
+        Redraw_Menu(true, true, false);
+        wait_for_user = false;
+        break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+/* In-Menu Value Modification */
+
+void CrealityDWINClass::Setup_Value(float value, float min, float max, float unit, uint8_t type) {
+  if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
+    tempvalue = unscalePID_i(value) * unit;
+  else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
+    tempvalue = unscalePID_d(value) * unit;
+  else
+    tempvalue = value * unit;
+  valuemin = min;
+  valuemax = max;
+  valueunit = unit;
+  valuetype = type;
+  process = Value;
+  EncoderRate.enabled = true;
+  Draw_Float(tempvalue / unit, selection - scrollpos, true, valueunit);
+}
+
+void CrealityDWINClass::Modify_Value(float &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 0);
+}
+void CrealityDWINClass::Modify_Value(uint8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 1);
+}
+void CrealityDWINClass::Modify_Value(uint16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 2);
+}
+void CrealityDWINClass::Modify_Value(int16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 3);
+}
+void CrealityDWINClass::Modify_Value(uint32_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 4);
+}
+void CrealityDWINClass::Modify_Value(int8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 5);
+}
+
+void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * options, uint8_t max) {
+  tempvalue = value;
+  valuepointer = const_cast<const char * *>(options);
+  valuemin = 0;
+  valuemax = max;
+  process = Option;
+  EncoderRate.enabled = true;
+  Draw_Option(value, options, selection - scrollpos, true);
+}
+
+/* Main Functions */
+
+void CrealityDWINClass::Update_Status(const char * const text) {
+  if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
+    LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
+    filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
+    Draw_Print_Filename(true);
+  }
+  else {
+    LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
+    statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
+  }
+}
+
+void CrealityDWINClass::Start_Print(bool sd) {
+  sdprint = sd;
+  if (!printing) {
+    printing = true;
+    statusmsg[0] = '\0';
+    if (sd) {
+      #if ENABLED(POWER_LOSS_RECOVERY)
+        if (recovery.valid()) {
+          SdFile *diveDir = nullptr;
+          const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
+          card.selectFileByName(fname);
+        }
+      #endif
+      strcpy(filename, card.longest_filename());
+    }
+    else
+      strcpy_P(filename, PSTR("Host Print"));
+    TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
+    TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
+    Draw_Print_Screen();
+  }
+}
+
+void CrealityDWINClass::Stop_Print() {
+  printing = false;
+  sdprint = false;
+  thermalManager.cooldown();
+  TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(100 * (PROGRESS_SCALE)));
+  TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
+  Draw_Print_confirm();
+}
+
+void CrealityDWINClass::Update() {
+  State_Update();
+  Screen_Update();
+  switch (process) {
+    case Main:    Main_Menu_Control();    break;
+    case Menu:    Menu_Control();         break;
+    case Value:   Value_Control();        break;
+    case Option:  Option_Control();       break;
+    case File:    File_Control();         break;
+    case Print:   Print_Screen_Control(); break;
+    case Popup:   Popup_Control();        break;
+    case Confirm: Confirm_Control();      break;
+  }
+}
+
+void MarlinUI::update() { CrealityDWIN.Update(); }
+
+#if HAS_LCD_BRIGHTNESS
+  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+#endif
+
+void CrealityDWINClass::State_Update() {
+  if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
+    if (!printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
+    else Stop_Print();
+  }
+  if (print_job_timer.isPaused() != paused) {
+    paused = print_job_timer.isPaused();
+    if (process == Print) Print_Screen_Icons();
+    if (process == Wait && !paused) Redraw_Menu(true, true);
+  }
+  if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
+    Confirm_Handler(UserInput);
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    if (process == Popup && popup == PurgeMore) {
+      if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
+        Popup_Handler(FilChange);
+      else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
+        if (printing) Popup_Handler(Resuming);
+        else Redraw_Menu(true, true, (active_menu==PreheatHotend));
+      }
+    }
+  #endif
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    static bool ranout = false;
+    if (runout.filament_ran_out != ranout) {
+      ranout = runout.filament_ran_out;
+      if (ranout) Popup_Handler(Runout);
+    }
+  #endif
+}
+
+void CrealityDWINClass::Screen_Update() {
+  const millis_t ms = millis();
+  static millis_t scrltime = 0;
+  if (ELAPSED(ms, scrltime)) {
+    scrltime = ms + 200;
+    Update_Status_Bar();
+    if (process == Print) Draw_Print_Filename();
+  }
+
+  static millis_t statustime = 0;
+  if (ELAPSED(ms, statustime)) {
+    statustime = ms + 500;
+    Draw_Status_Area();
+  }
+
+  static millis_t printtime = 0;
+  if (ELAPSED(ms, printtime)) {
+    printtime = ms + 1000;
+    if (process == Print) {
+      Draw_Print_ProgressBar();
+      Draw_Print_ProgressElapsed();
+      TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
+    }
+  }
+
+  static bool mounted = card.isMounted();
+  if (mounted != card.isMounted()) {
+    mounted = card.isMounted();
+    if (process == File)
+      Draw_SD_List();
+  }
+
+  #if HAS_HOTEND
+    static int16_t hotendtarget = -1;
+  #endif
+  #if HAS_HEATED_BED
+    static int16_t bedtarget = -1;
+  #endif
+  #if HAS_FAN
+    static int16_t fanspeed = -1;
+  #endif
+
+  #if HAS_ZOFFSET_ITEM
+    static float lastzoffset = zoffsetvalue;
+    if (zoffsetvalue != lastzoffset) {
+      lastzoffset = zoffsetvalue;
+      #if HAS_BED_PROBE
+        probe.offset.z = zoffsetvalue;
+      #else
+        set_home_offset(Z_AXIS, -zoffsetvalue);
+      #endif
+    }
+
+    #if HAS_BED_PROBE
+      if (probe.offset.z != lastzoffset)
+        zoffsetvalue = lastzoffset = probe.offset.z;
+    #else
+      if (-home_offset.z != lastzoffset)
+        zoffsetvalue = lastzoffset = -home_offset.z;
+    #endif
+  #endif // HAS_ZOFFSET_ITEM
+
+  if (process == Menu || process == Value) {
+    switch (active_menu) {
+      case TempMenu:
+        #if HAS_HOTEND
+          if (thermalManager.temp_hotend[0].target != hotendtarget) {
+            hotendtarget = thermalManager.temp_hotend[0].target;
+            if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_HEATED_BED
+          if (thermalManager.temp_bed.target != bedtarget) {
+            bedtarget = thermalManager.temp_bed.target;
+            if (scrollpos <= TEMP_BED && TEMP_BED <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_FAN
+          if (thermalManager.fan_speed[0] != fanspeed) {
+            fanspeed = thermalManager.fan_speed[0];
+            if (scrollpos <= TEMP_FAN && TEMP_FAN <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
+            }
+          }
+        #endif
+        break;
+      case Tune:
+        #if HAS_HOTEND
+          if (thermalManager.temp_hotend[0].target != hotendtarget) {
+            hotendtarget = thermalManager.temp_hotend[0].target;
+            if (scrollpos <= TUNE_HOTEND && TUNE_HOTEND <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_HEATED_BED
+          if (thermalManager.temp_bed.target != bedtarget) {
+            bedtarget = thermalManager.temp_bed.target;
+            if (scrollpos <= TUNE_BED && TUNE_BED <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_FAN
+          if (thermalManager.fan_speed[0] != fanspeed) {
+            fanspeed = thermalManager.fan_speed[0];
+            if (scrollpos <= TUNE_FAN && TUNE_FAN <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
+            }
+          }
+        #endif
+        break;
+    }
+  }
+}
+
+void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
+  if (ui.sound_on)
+    DONE_BUZZ(success);
+  else
+    Update_Status(success ? "Success" : "Failed");
+}
+
+void CrealityDWINClass::Save_Settings(char *buff) {
+  TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
+  eeprom_settings.corner_pos = corner_pos * 10;
+  memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
+}
+
+void CrealityDWINClass::Load_Settings(const char *buff) {
+  memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
+  TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
+  if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
+  corner_pos = eeprom_settings.corner_pos / 10.0f;
+  Redraw_Screen();
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    static bool init = true;
+    if (init) {
+      init = false;
+      queue.inject(F("M1000 S"));
+    }
+  #endif
+}
+
+void CrealityDWINClass::Reset_Settings() {
+  eeprom_settings.time_format_textual = false;
+  TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
+  eeprom_settings.corner_pos = 325;
+  eeprom_settings.cursor_color = 0;
+  eeprom_settings.menu_split_line = 0;
+  eeprom_settings.menu_top_bg = 0;
+  eeprom_settings.menu_top_txt = 0;
+  eeprom_settings.highlight_box = 0;
+  eeprom_settings.progress_percent = 0;
+  eeprom_settings.progress_time = 0;
+  eeprom_settings.status_bar_text = 0;
+  eeprom_settings.status_area_text = 0;
+  eeprom_settings.coordinates_text = 0;
+  eeprom_settings.coordinates_split_line = 0;
+  TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
+  corner_pos = eeprom_settings.corner_pos / 10.0f;
+  TERN_(SOUND_MENU_ITEM, ui.sound_on = ENABLED(SOUND_ON_DEFAULT));
+  Redraw_Screen();
+}
+
+void MarlinUI::init_lcd() {
+  delay(800);
+  SERIAL_ECHOPGM("\nDWIN handshake ");
+  if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
+  DWIN_Frame_SetDir(1); // Orientation 90°
+  DWIN_UpdateLCD();     // Show bootscreen (first image)
+  Encoder_Configuration();
+  for (uint16_t t = 0; t <= 100; t += 2) {
+    DWIN_ICON_Show(ICON, ICON_Bar, 15, 260);
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
+    DWIN_UpdateLCD();
+    delay(20);
+  }
+
+  DWIN_JPG_ShowAndCache(3);
+  DWIN_JPG_CacheTo1(Language_English);
+  CrealityDWIN.Redraw_Screen();
+}
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
+    switch (message) {
+      case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
+      case PAUSE_MESSAGE_PURGE:
+      case PAUSE_MESSAGE_OPTION:  CrealityDWIN.Popup_Handler(PurgeMore);    break;
+      case PAUSE_MESSAGE_HEAT:    CrealityDWIN.Confirm_Handler(HeaterTime); break;
+      case PAUSE_MESSAGE_WAITING: CrealityDWIN.Draw_Print_Screen();         break;
+      default: break;
+    }
+  }
+#endif
+
+#endif // DWIN_CREALITY_LCD_JYERSUI

commit f73fad1b2fa6e70b3d632969ecf2773bee826643
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 6 19:34:45 2022 -0500

    🔥 Remove JyersUI (#24459)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
deleted file mode 100644
index e62bb04a43..0000000000
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ /dev/null
@@ -1,6194 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * lcd/e3v2/jyersui/dwin.cpp
- * JYERSUI Author: Jacob Myers
- *
- * JYERSUI Enhanced by LCH-77
- * Version: 1.9
- * Date: Jun 16, 2022
- */
-
-#include "../../../inc/MarlinConfigPre.h"
-
-#if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-
-#include "dwin_defines.h"
-#include "dwin.h"
-#include "dwinui.h"
-
-#include "../../marlinui.h"
-#include "../../../MarlinCore.h"
-#include "../../../gcode/gcode.h"
-#include "../../../module/temperature.h"
-#include "../../../module/planner.h"
-#include "../../../module/settings.h"
-#include "../../../libs/buzzer.h"
-#include "../../../inc/Conditionals_post.h"
-#include "../common/encoder.h"
-
-//#define DEBUG_OUT 1
-#include "../../../core/debug_out.h"
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "../../../feature/pause.h"
-#endif
-
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-  #include "../../../feature/runout.h"
-#endif
-
-#if ENABLED(HOST_ACTION_COMMANDS)
-  #include "../../../feature/host_actions.h"
-#endif
-
-#if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
-  #define HAS_ZOFFSET_ITEM 1
-#endif
-
-#ifndef strcasecmp_P
-  #define strcasecmp_P(a, b) strcasecmp((a), (b))
-#endif
-
-#if HAS_LEVELING
-  #include "../../../feature/bedlevel/bedlevel.h"
-#endif
-
-#ifdef BLTOUCH_HS_MODE
-  #include "../../../feature/bltouch.h"
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../../../libs/least_squares_fit.h"
-  #include "../../../libs/vector_3.h"
-#endif
-
-#if HAS_BED_PROBE
-  #include "../../../module/probe.h"
-#endif
-
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../../../feature/powerloss.h"
-#endif
-
-#if HAS_ESDIAG
-  #include "endstop_diag.h"
-#endif
-
-#if HAS_LOCKSCREEN
-  #include "lockscreen.h"
-#endif
-
-#if ENABLED(CASE_LIGHT_MENU)
-  #include "../../../feature/caselight.h"
-#endif
-
-#if ENABLED(LED_CONTROL_MENU)
-  #include "../../../feature/leds/leds.h"
-#endif
-
-#if HAS_PIDPLOT
-  #include "plot.h"
-#endif
-#if HAS_GCODE_PREVIEW
-  #include "gcode_preview.h"
-#endif
-
-#define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
-
-#define MENU_CHAR_LIMIT 24
-#define STATUS_CHAR_LIMIT 30
-
-#define MAX_PRINT_SPEED 500
-#define MIN_PRINT_SPEED 10
-
-#if HAS_FAN
-  #define MAX_FAN_SPEED 255
-  #define MIN_FAN_SPEED 0
-#endif
-
-#define MAX_XY_OFFSET 100
-
-#if HAS_ZOFFSET_ITEM
-  #define MAX_Z_OFFSET 9.99
-  #if HAS_BED_PROBE
-    #define MIN_Z_OFFSET -9.99
-  #else
-    #define MIN_Z_OFFSET -1
-  #endif
-#endif
-
-#if HAS_HOTEND
-  #define MAX_FLOW_RATE 200
-  #define MIN_FLOW_RATE 10
-
-  #define MAX_E_TEMP (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
-  #define MIN_E_TEMP 0
-#endif
-
-#if HAS_HEATED_BED
-  #define MAX_BED_TEMP BED_MAXTEMP
-  #define MIN_BED_TEMP 0
-#endif
-
-#if HAS_JUNCTION_DEVIATION
-  #define MIN_JD_MM 0.01
-  #define MAX_JD_MM 0.3
-#endif
-
-/**
- * Custom menu items with jyersLCD
- */
-#if ENABLED(CUSTOM_MENU_CONFIG)
-  #ifdef CONFIG_MENU_ITEM_5_DESC
-    #define CUSTOM_MENU_COUNT 5
-  #elif defined(CONFIG_MENU_ITEM_4_DESC)
-    #define CUSTOM_MENU_COUNT 4
-  #elif defined(CONFIG_MENU_ITEM_3_DESC)
-    #define CUSTOM_MENU_COUNT 3
-  #elif defined(CONFIG_MENU_ITEM_2_DESC)
-    #define CUSTOM_MENU_COUNT 2
-  #elif defined(CONFIG_MENU_ITEM_1_DESC)
-    #define CUSTOM_MENU_COUNT 1
-  #endif
-  #if CUSTOM_MENU_COUNT
-    #define HAS_CUSTOM_MENU 1
-  #endif
-#endif
-
-constexpr float default_max_feedrate[]     = DEFAULT_MAX_FEEDRATE;
-constexpr float default_max_acceleration[] = DEFAULT_MAX_ACCELERATION;
-constexpr float default_steps[]            = DEFAULT_AXIS_STEPS_PER_UNIT;
-#if HAS_CLASSIC_JERK
-  constexpr float default_max_jerk[]       = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
-#endif
-
-enum SelectItem : uint8_t {
-  PAGE_PRINT = 0,
-  PAGE_PREPARE,
-  PAGE_CONTROL,
-  PAGE_INFO_LEVELING,
-  PAGE_COUNT,
-
-  PRINT_SETUP = 0,
-  PRINT_PAUSE_RESUME,
-  PRINT_STOP,
-  PRINT_COUNT
-};
-
-eeprom_settings_t eeprom_settings = {0};
-temp_val_t temp_val = {0};
-uint8_t active_menu = MainMenu, last_menu = MainMenu;
-uint8_t selection = 0, last_selection = 0, last_pos_selection = 0;
-uint8_t scrollpos = 0;
-uint8_t process = Main, last_process = Main;
-PopupID popup, last_popup;
-
-void (*funcpointer)() = nullptr;
-void *valuepointer = nullptr;
-float tempvalue;
-float valuemin;
-float valuemax;
-uint8_t valueunit;
-uint8_t valuetype;
-
-char cmd[MAX_CMD_SIZE + 16], str_1[16], str_2[16], str_3[16];
-char statusmsg[64];
-char filename[LONG_FILENAME_LENGTH];
-
-#if HAS_HOSTACTION_MENUS
-  #define KEY_WIDTH 26
-  #define KEY_HEIGHT 30
-  #define KEY_INSET 5
-  #define KEY_PADDING 3
-  #define KEY_Y_START DWIN_HEIGHT - (4 * (KEY_HEIGHT) + 2 * (KEY_INSET + 1))
-
-  bool keyboard_restrict, reset_keyboard, numeric_keyboard = false;
-  uint8_t maxstringlen;
-  char *stringpointer = nullptr;
-  char action1[9], action2[9], action3[9];
-#endif
-
-CrealityDWINClass CrealityDWIN;
-
-#if HAS_MESH
-
-  struct Mesh_Settings {
-    bool viewer_asymmetric_range = false;
-    bool viewer_print_value = false;
-    bool goto_mesh_value = false;
-    bool drawing_mesh = false;
-    uint8_t mesh_x = 0;
-    uint8_t mesh_y = 0;
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-      uint8_t tilt_grid = 1;
-
-      void manual_value_update(bool undefined=false) {
-        sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
-        gcode.process_subcommands_now(cmd);
-        planner.synchronize();
-      }
-
-      bool create_plane_from_mesh() {
-        struct linear_fit_data lsf_results;
-        incremental_LSF_reset(&lsf_results);
-        GRID_LOOP(x, y) {
-          if (!isnan(bedlevel.z_values[x][y])) {
-            xy_pos_t rpos = { bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) };
-            incremental_LSF(&lsf_results, rpos, bedlevel.z_values[x][y]);
-          }
-        }
-
-        if (finish_incremental_LSF(&lsf_results)) {
-          SERIAL_ECHOPGM("Could not complete LSF!");
-          return true;
-        }
-
-        bedlevel.set_all_mesh_points_to_value(0);
-
-        matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
-        GRID_LOOP(i, j) {
-          float mx = bedlevel.get_mesh_x(i),
-                my = bedlevel.get_mesh_y(j),
-                mz = bedlevel.z_values[i][j];
-
-          if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(my, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(mz, 7);
-            DEBUG_ECHOPGM("]   ---> ");
-            DEBUG_DELAY(20);
-          }
-
-          rotation.apply_rotation_xyz(mx, my, mz);
-
-          if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(my, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(mz, 7);
-            DEBUG_ECHOLNPGM("]");
-            DEBUG_DELAY(20);
-          }
-
-          bedlevel.z_values[i][j] = mz - lsf_results.D;
-        }
-        return false;
-      }
-
-    #else
-
-      void manual_value_update() {
-        sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
-        gcode.process_subcommands_now(cmd);
-        planner.synchronize();
-      }
-
-    #endif
-
-    void manual_mesh_move(const bool zmove=false) {
-      if (zmove) {
-        planner.synchronize();
-        current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
-        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
-        planner.synchronize();
-      }
-      else {
-        CrealityDWIN.Popup_Handler(MoveWait);
-        sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
-        gcode.process_subcommands_now(cmd);
-        sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
-        gcode.process_subcommands_now(cmd);
-        planner.synchronize();
-        current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
-        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
-        planner.synchronize();
-        CrealityDWIN.Redraw_Menu();
-      }
-    }
-
-    float get_max_value() {
-      float max = __FLT_MIN__;
-      GRID_LOOP(x, y) {
-        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
-          max = bedlevel.z_values[x][y];
-      }
-      return max;
-    }
-
-    float get_min_value() {
-      float min = __FLT_MAX__;
-      GRID_LOOP(x, y) {
-        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
-          min = bedlevel.z_values[x][y];
-      }
-      return min;
-    }
-
-    void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
-      drawing_mesh = true;
-      const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
-                     cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
-                     cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
-      const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
-
-      // Clear background from previous selection and select new square
-      DWIN_Draw_Rectangle(1, Def_Background_Color, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
-      if (selected >= 0) {
-        const auto selected_y = selected / (GRID_MAX_POINTS_X);
-        const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
-        const auto start_y_px = padding_y_top + selected_y * cell_height_px;
-        const auto start_x_px = padding_x + selected_x * cell_width_px;
-        DWIN_Draw_Rectangle(1, Def_Highlight_Color, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
-      }
-
-      // Draw value square grid
-      char buf[8];
-      GRID_LOOP(x, y) {
-        const auto start_x_px = padding_x + x * cell_width_px;
-        const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
-        const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
-        const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
-        DWIN_Draw_Rectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
-          isnan(bedlevel.z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
-            (bedlevel.z_values[x][y] < 0 ?
-              (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
-              (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
-                _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
-          start_x_px, start_y_px, end_x_px, end_y_px
-        );
-
-        safe_delay(10);
-        LCD_SERIAL.flushTX();
-
-        // Draw value text on
-        if (viewer_print_value) {
-          int8_t offset_x, offset_y = cell_height_px / 2 - 6;
-          if (isnan(bedlevel.z_values[x][y])) {  // undefined
-            DWINUI::Draw_String(font6x12, Def_Text_Color, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
-          }
-          else {                          // has value
-            if (GRID_MAX_POINTS_X < 10)
-              sprintf_P(buf, PSTR("%s"), dtostrf(abs(bedlevel.z_values[x][y]), 1, 2, str_1));
-            else
-              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(bedlevel.z_values[x][y] - (int16_t)bedlevel.z_values[x][y]) * 100));
-            offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
-            if (!(GRID_MAX_POINTS_X < 10))
-              DWINUI::Draw_String(font6x12, Def_Text_Color, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            DWINUI::Draw_String(font6x12, Def_Text_Color, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
-          }
-          safe_delay(10);
-          LCD_SERIAL.flushTX();
-        }
-      }
-    }
-
-    void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
-      float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
-      if (v_min > 3e+10F) v_min = 0.0000001;
-      if (v_max > 3e+10F) v_max = 0.0000001;
-      if (range > 3e+10F) range = 0.0000001;
-      char msg[46];
-      if (viewer_asymmetric_range) {
-        dtostrf(-v_min, 1, 3, str_1);
-        dtostrf( v_max, 1, 3, str_2);
-      }
-      else {
-        dtostrf(-range, 1, 3, str_1);
-        dtostrf( range, 1, 3, str_2);
-      }
-      sprintf_P(msg, PSTR("Red %s..0..%s Green"), str_1, str_2);
-      CrealityDWIN.Update_Status(msg);
-      drawing_mesh = false;
-    }
-
-  };
-  Mesh_Settings mesh_conf;
-
-#endif // HAS_MESH
-
-/* General Display Functions */
-constexpr const char * const CrealityDWINClass::color_names[11];
-constexpr const char * const CrealityDWINClass::preheat_modes[3];
-constexpr const char * const CrealityDWINClass::zoffset_modes[3];
-#if ENABLED(PREHEAT_BEFORE_LEVELING)
-  constexpr const char * const CrealityDWINClass::preheat_levmodes[4];
-#endif
-
-// Clear a part of the screen
-//  4=Entire screen
-//  3=Title bar and Menu area (default)
-//  2=Menu area
-//  1=Title bar
-void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
-  if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Def_TitleBg_color, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
-  if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Def_Background_Color, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
-  if (e == 4) DWIN_Draw_Rectangle(1, Def_Background_Color, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
-}
-
-void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
-  const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
-  const uint16_t bColor = (selected) ? Def_Selected_Color : Def_Background_Color;
-  const uint16_t xpos = 240 - (digits * 8);
-  DWIN_Draw_Rectangle(1, Def_Background_Color, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
-  if (isnan(value))
-    DWINUI::Draw_String(Def_Text_Color, bColor, xpos - 8, MBASE(row), F(" NaN"));
-  else {
-    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Def_Text_Color, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
-    DWINUI::Draw_String(Def_Text_Color, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
-  }
-}
-
-void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
-  uint16_t bColor = (selected) ? Def_Selected_Color : Def_Background_Color,
-           tColor = (color) ? GetColor(value, Def_Text_Color, false) : Def_Text_Color;
-  DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
-  DWINUI::Draw_String(tColor, bColor, 202, MBASE(row) - 1, options[value]);
-}
-
-#if HAS_HOSTACTION_MENUS
-
-  void CrealityDWINClass::Draw_String(char * string, uint8_t row, bool selected/*=false*/, bool below/*=false*/) {
-    if (!string) string[0] = '\0';
-    const uint8_t offset_x = DWIN_WIDTH - strlen(string) * 8 - 20;
-    const uint8_t offset_y = (below) ? MENU_CHR_H * 3 / 5 : 0;
-    DWIN_Draw_Rectangle(1, Def_Background_Color, offset_x - 10, MBASE(row) + offset_y - 1, offset_x, MBASE(row) + 16 + offset_y);
-    DWINUI::Draw_String(Def_Text_Color, (selected) ? Def_Selected_Color : Def_Background_Color, offset_x, MBASE(row) - 1 + offset_y, string);
-  }
-
-  const uint64_t CrealityDWINClass::Encode_String(const char * string) {
-    const char table[65] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
-    uint64_t output = 0;
-    LOOP_L_N(i, strlen(string)) {
-      uint8_t upper_bound = 63, lower_bound = 0;
-      uint8_t midpoint;
-      LOOP_L_N(x, 6) {
-        midpoint = (uint8_t)(0.5 * (upper_bound + lower_bound));
-        if (string[i] == table[midpoint]) break;
-        if (string[i] > table[midpoint])
-          lower_bound = midpoint;
-        else
-          upper_bound = midpoint;
-      }
-      output += midpoint * pow(64, i);
-    }
-    return output;
-  }
-
-  void CrealityDWINClass::Decode_String(uint64_t num, char * string) {
-    const char table[65] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
-    LOOP_L_N(i, 30) {
-      string[i] = table[num % 64];
-      num /= 64;
-      if (num == 0) {
-        string[i + 1] = '\0';
-        break;
-      }
-    }
-  }
-
-#endif // HAS_HOSTACTION_MENUS
-
-uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
-  switch (color) {
-    case Default: return original;
-    case White:   return (light) ? Color_Light_White   : Color_White;
-    case Green:   return (light) ? Color_Light_Green   : Color_Green;
-    case Cyan:    return (light) ? Color_Light_Cyan    : Color_Cyan;
-    case Blue:    return (light) ? Color_Light_Blue    : Color_Blue;
-    case Magenta: return (light) ? Color_Light_Magenta : Color_Magenta;
-    case Red:     return (light) ? Color_Light_Red     : Color_Red;
-    case Orange:  return (light) ? Color_Light_Orange  : Color_Orange;
-    case Yellow:  return (light) ? Color_Light_Yellow  : Color_Yellow;
-    case Brown:   return (light) ? Color_Light_Brown   : Color_Brown;
-    case Black:   return Color_Black;
-  }
-  return Color_White;
-}
-
-void CrealityDWINClass::Draw_Title(const char * ctitle) {
-  DWINUI::Draw_CenteredString((uint8_t)DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Def_TitleTxt_color, false), 5, ctitle);
-}
-void CrealityDWINClass::Draw_Title(FSTR_P const ftitle) {
-   DWINUI::Draw_CenteredString((uint8_t)DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Def_TitleTxt_color, false), 5, ftitle);
-}
-
-void _Decorate_Menu_Item(uint8_t row, uint8_t icon, bool more) {
-  if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
-  if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
-  DWIN_Draw_HLine(CrealityDWIN.GetColor(eeprom_settings.menu_split_line, Def_SplitLine_Color, true), 16, MBASE(row) + 33, 240); // Draw Menu Line
-}
-
-void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
-  const uint8_t label_offset_y = (label1 && label2) ? MENU_CHR_H * 3 / 5 : 0,
-                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
-                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
-  if (label1) DWINUI::Draw_String(label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
-  if (label2) DWINUI::Draw_String(label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
-  _Decorate_Menu_Item(row, icon, more);
-}
-
-void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, bool more/*=false*/, bool centered/*=false*/) {
-  const uint8_t label_offset_y = (flabel1 && flabel2) ? MENU_CHR_H * 3 / 5 : 0,
-                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
-                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
-  if (flabel1) DWINUI::Draw_String(label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
-  if (flabel2) DWINUI::Draw_String(label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
-  _Decorate_Menu_Item(row, icon, more);
-}
-
-void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
-  #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
-    DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
-  #else                                         // Draw a basic checkbox using rectangles and lines
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
-    DWIN_Draw_Rectangle(0, Def_Text_Color, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
-    if (value) {
-      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
-      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
-      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
-      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
-      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
-      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
-    }
-  #endif
-}
-
-void CrealityDWINClass::Draw_Menu(uint8_t menu, uint8_t select/*=0*/, uint8_t scroll/*=0*/) {
-  if (active_menu != menu) {
-    last_menu = active_menu;
-    if (process == Menu) last_selection = selection;
-  }
-  selection = _MIN(select, Get_Menu_Size(menu));
-  scrollpos = scroll;
-  if (selection - scrollpos > MROWS)
-    scrollpos = selection - MROWS;
-  process = Menu;
-  active_menu = menu;
-  Clear_Screen();
-  Draw_Title(Get_Menu_Title(menu));
-  LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
-  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-}
-
-void CrealityDWINClass::Redraw_Menu(bool lastprocess/*=true*/, bool lastselection/*=false*/, bool lastmenu/*=false*/) {
-  switch ((lastprocess) ? last_process : process) {
-    case Menu:
-      Draw_Menu((lastmenu) ? last_menu : active_menu, (lastselection) ? last_selection : selection, (lastmenu) ? 0 : scrollpos);
-      break;
-    case Main:  Draw_Main_Menu((lastselection) ? last_selection : selection); break;
-    case Print: Draw_Print_Screen(); break;
-    case File:  Draw_SD_List(); break;
-    default: break;
-  }
-}
-
-void CrealityDWINClass::Redraw_Screen() {
-  if (printingIsActive()) Draw_Print_Screen();
-  else Redraw_Menu(false);
-  Draw_Status_Area(true);
-  Update_Status_Bar(true);
-}
-
-/* Primary Menus and Screen Elements */
-
-void CrealityDWINClass::Main_Menu_Icons() {
-
-  if (selection == 0) {
-    DWINUI::DRAW_IconWB(ICON, ICON_Print_1, 17, 110);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 17, 110, 126, 209);
-  }
-  else
-    DWINUI::DRAW_IconWB(ICON, ICON_Print_0, 17, 110);
-
-  DWINUI::Draw_String(52, 180, GET_TEXT_F(MSG_BUTTON_PRINT));
-
-  if (selection == 1) {
-    DWINUI::DRAW_IconWB(ICON, ICON_Prepare_1, 145, 110);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 145, 110, 254, 209);
-  }
-  else
-    DWINUI::DRAW_IconWB(ICON, ICON_Prepare_0, 145, 110);
-
-  DWINUI::Draw_String(170, 180, GET_TEXT_F(MSG_PREPARE));
-
-  if (selection == 2) {
-    DWINUI::DRAW_IconWB(ICON, ICON_Control_1, 17, 226);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 17, 226, 126, 325);
-  }
-  else
-    DWINUI::DRAW_IconWB(ICON, ICON_Control_0, 17, 226);
-
-  DWINUI::Draw_String(43, 297, GET_TEXT_F(MSG_CONTROL));
-
-  #if HAS_ABL_OR_UBL
-
-    if (selection == 3) {
-      DWINUI::DRAW_IconWB(ICON, ICON_Leveling_1, 145, 226);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 145, 226, 254, 325);
-    }
-    else
-      DWINUI::DRAW_IconWB(ICON, ICON_Leveling_0, 145, 226);
-
-    DWINUI::Draw_String(179, 297, GET_TEXT_F(MSG_BUTTON_LEVEL));
-
-  #else
-
-    if (selection == 3) {
-      DWINUI::DRAW_IconWB(ICON, ICON_Info_1, 145, 226);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 145, 226, 254, 325);
-    }
-    else
-      DWINUI::DRAW_IconWB(ICON, ICON_Info_0, 145, 226);
-
-    DWINUI::Draw_String(181, 297, GET_TEXT_F(MSG_BUTTON_INFO));
-
-  #endif
-}
-
-void CrealityDWINClass::Draw_Main_Menu(uint8_t select/*=0*/) {
-  process = Main;
-  active_menu = MainMenu;
-  selection = select;
-  Clear_Screen();
-  Draw_Title(Get_Menu_Title(MainMenu));
-  SERIAL_ECHOPGM("\nDWIN handshake ");
-  DWIN_ICON_Show(ICON, ICON_LOGO, 71, 62);
-  Main_Menu_Icons();
-}
-
-void CrealityDWINClass::Print_Screen_Icons() {
-  if (selection == 0) {
-    DWINUI::DRAW_IconWB(ICON, ICON_Setup_1, 8, 252);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 8, 252, 87, 351);
-  }
-  else
-    DWINUI::DRAW_IconWB(ICON, ICON_Setup_0, 8, 252);
-
-  DWINUI::Draw_String(30, 322, GET_TEXT_F(MSG_TUNE));
-
-  if (selection == 2) {
-    DWINUI::DRAW_IconWB(ICON, ICON_Stop_1, 184, 252);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 184, 252, 263, 351);
-  }
-  else
-    DWINUI::DRAW_IconWB(ICON, ICON_Stop_0, 184, 252);
-
-  DWINUI::Draw_String(205, 322, GET_TEXT_F(MSG_BUTTON_STOP));
-
-  if (temp_val.paused) {
-    if (selection == 1) {
-      DWINUI::DRAW_IconWB(ICON, ICON_Continue_1, 96, 252);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 96, 252, 175, 351);
-    }
-    else
-      DWINUI::DRAW_IconWB(ICON, ICON_Continue_0, 96, 252);
-
-    DWINUI::Draw_String(114, 322, GET_TEXT_F(MSG_BUTTON_RESUME));
-  }
-  else {
-    if (selection == 1) {
-      DWINUI::DRAW_IconWB(ICON, ICON_Pause_1, 96, 252);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 96, 252, 175, 351);
-    }
-    else
-      DWINUI::DRAW_IconWB(ICON, ICON_Pause_0, 96, 252);
-
-    DWINUI::Draw_String(114, 322, GET_TEXT_F(MSG_BUTTON_PAUSE));
-  }
-}
-
-void CrealityDWINClass::Draw_Print_Screen() {
-  process = Print;
-  selection = 0;
-  Clear_Screen();
-  DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 352, DWIN_WIDTH - 8, 376);
-  Draw_Title(GET_TEXT(MSG_PRINTING));
-  Print_Screen_Icons();
-  DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
-  DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
-  DWINUI::Draw_String(Def_PercentTxt_Color, 41, 163, GET_TEXT_F(MSG_INFO_PRINT_TIME));
-  DWINUI::Draw_String(Def_PercentTxt_Color, 176, 163, GET_TEXT_F(MSG_REMAINING_TIME));
-  Update_Status_Bar(true);
-  Draw_Print_ProgressBar();
-  Draw_Print_ProgressElapsed();
-  TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
-  Draw_Print_Filename(true);
-}
-
-void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
-  static uint8_t namescrl = 0;
-  if (reset) namescrl = 0;
-  if (process == Print) {
-    size_t len = strlen(filename);
-    int8_t pos = len;
-    if (pos > STATUS_CHAR_LIMIT) {
-      pos -= namescrl;
-      len = _MIN((size_t)pos, (size_t)STATUS_CHAR_LIMIT);
-      char dispname[len + 1];
-      if (pos >= 0) {
-        LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
-      }
-      else {
-        LOOP_L_N(i, STATUS_CHAR_LIMIT + pos) dispname[i] = ' ';
-        LOOP_S_L_N(i, STATUS_CHAR_LIMIT + pos, STATUS_CHAR_LIMIT) dispname[i] = filename[i - (STATUS_CHAR_LIMIT + pos)];
-      }
-      dispname[len] = '\0';
-      DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 50, DWIN_WIDTH - 8, 80);
-      const int8_t npos = (DWIN_WIDTH - STATUS_CHAR_LIMIT * MENU_CHR_W) / 2;
-      DWINUI::Draw_String(npos, 60, dispname);
-      if (-pos >= STATUS_CHAR_LIMIT) namescrl = 0;
-      namescrl++;
-    }
-    else {
-      DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 50, DWIN_WIDTH - 8, 80);
-      const int8_t npos = (DWIN_WIDTH - strlen(filename) * MENU_CHR_W) / 2;
-      DWINUI::Draw_String(npos, 60, filename);
-    }
-  }
-}
-
-void CrealityDWINClass::Draw_Print_ProgressBar() {
-  uint8_t printpercent = temp_val.sdprint ? card.percentDone() : (ui._get_progress() / 100);
-  DWINUI::DRAW_IconWB(ICON, ICON_Bar, 15, 93);
-  DWIN_Draw_Rectangle(1, Def_Barfill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
-  DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Def_PercentTxt_Color), Def_Background_Color, 3, 109, 133, printpercent);
-  DWINUI::Draw_String(GetColor(eeprom_settings.progress_percent, Def_PercentTxt_Color), Def_Background_Color, 134, 133, F("%"));
-}
-
-#if ENABLED(USE_M73_REMAINING_TIME)
-
-  void CrealityDWINClass::Draw_Print_ProgressRemain() {
-    uint16_t remainingtime = ui.get_remaining_time();
-    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 176, 187, remainingtime / 3600);
-    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 201, 187, (remainingtime % 3600) / 60);
-    if (eeprom_settings.time_format_textual) {
-      DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 193, 187, F("h"));
-      DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 217, 187, F("m"));
-    }
-    else
-      DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 193, 187, F(":"));
-  }
-
-#endif
-
-void CrealityDWINClass::Draw_Print_ProgressElapsed() {
-  duration_t elapsed = print_job_timer.duration();
-  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 42, 187, elapsed.value / 3600);
-  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 67, 187, (elapsed.value % 3600) / 60);
-  if (eeprom_settings.time_format_textual) {
-    DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 59, 187, F("h"));
-    DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 83, 187, F("m"));
-  }
-  else
-    DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 59, 187, F(":"));
-}
-
-void CrealityDWINClass::Draw_PrintDone_confirm() {
-  process = Confirm;
-  popup = Complete;
-  if (TERN0(HAS_GCODE_PREVIEW, Preview_Valid())) {
-    Clear_Screen();
-    Draw_Title(GET_TEXT(MSG_PRINT_DONE));
-    DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
-    DWINUI::Draw_Button(BTN_Continue, 87, 300);
-  }
-  else {
-    Draw_Print_Screen();
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 252, 263, 351);
-    DWINUI::Draw_Button(BTN_Continue, 87, 283);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 86, 282, 187, 321);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 85, 281, 188, 322);
-  }
-}
-
-void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
-  if (item == 0)
-    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? GET_TEXT_F(MSG_BACK) : F(".."));
-  else {
-    card.getfilename_sorted(SD_ORDER(item - 1, card.get_num_Files()));
-    char * const filename = card.longest_filename();
-    size_t max = MENU_CHAR_LIMIT;
-    size_t pos = strlen(filename), len = pos;
-    if (!card.flag.filenameIsDir)
-      while (pos && filename[pos] != '.') pos--;
-    len = pos;
-    NOMORE(len, max);
-    char name[len + 1];
-    memcpy(name, filename, len);
-    if (pos > max) LOOP_S_L_N(i, len - 3, len) name[i] = '.';
-    name[len] = '\0';
-    Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
-  }
-}
-
-void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
-  Clear_Screen();
-  Draw_Title("Select File");
-  selection = 0;
-  scrollpos = 0;
-  process = File;
-  if (card.isMounted() && !removed) {
-    LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
-      Draw_SD_Item(i, i);
-  }
-  else {
-    Draw_Menu_Item(0, ICON_Back, GET_TEXT_F(MSG_BACK));
-    DWIN_Draw_Rectangle(1, Def_AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    DWINUI::Draw_String(font16x32, Def_AlertTxt_Color, Def_AlertBg_Color, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), GET_TEXT_F(MSG_NO_MEDIA));
-  }
-  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
-}
-
-void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
-
-  if (icons) DWIN_Draw_Rectangle(1, Def_Background_Color, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
-
-  #if HAS_HOTEND
-    static float hotend = -1;
-    static int16_t hotendtarget = -1, flow = -1;
-    if (icons) {
-      hotend = -1;
-      hotendtarget = -1;
-      DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
-      DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
-    }
-    if (thermalManager.temp_hotend[0].celsius != hotend) {
-      hotend = thermalManager.temp_hotend[0].celsius;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 3 * STAT_CHR_W + 5, 386);
-    }
-    if (thermalManager.temp_hotend[0].target != hotendtarget) {
-      hotendtarget = thermalManager.temp_hotend[0].target;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 4 * STAT_CHR_W + 39, 386);
-    }
-    if (icons) {
-      flow = -1;
-      DWIN_ICON_Show(ICON, ICON_StepE, 112, 417);
-      DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
-    }
-    if (planner.flow_percentage[0] != flow) {
-      flow = planner.flow_percentage[0];
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
-    }
-  #endif
-
-  #if HAS_HEATED_BED
-    static float bed = -1;
-    static int16_t bedtarget = -1;
-    if (icons) {
-      bed = -1;
-      bedtarget = -1;
-      DWIN_ICON_Show(ICON, ICON_BedTemp, 10, 416);
-      DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
-    }
-    if (thermalManager.temp_bed.celsius != bed) {
-      bed = thermalManager.temp_bed.celsius;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 28, 417, thermalManager.temp_bed.celsius);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 3 * STAT_CHR_W + 5, 419);
-    }
-    if (thermalManager.temp_bed.target != bedtarget) {
-      bedtarget = thermalManager.temp_bed.target;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 4 * STAT_CHR_W + 39, 419);
-    }
-  #endif
-
-  #if HAS_FAN
-    static uint8_t fan = -1;
-    if (icons) {
-      fan = -1;
-      DWIN_ICON_Show(ICON, ICON_FanSpeed, 187, 383);
-    }
-    if (thermalManager.fan_speed[0] != fan) {
-      fan = thermalManager.fan_speed[0];
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
-    }
-  #endif
-
-  #if HAS_ZOFFSET_ITEM
-    static float offset = -1;
-
-    #if HAS_MESH
-      static bool _leveling_active = false,
-                  _printing_leveling_active = false;
-      if (printingIsActive()) {
-        _printing_leveling_active = ((planner.leveling_active && planner.leveling_active_at_z(current_position.z)) || _printing_leveling_active );
-        if ((_printing_leveling_active = (planner.leveling_active && planner.leveling_active_at_z(current_position.z)) && ui.get_blink()))
-          DWIN_Draw_Rectangle(1, Def_SplitLine_Color, 186, 415, 205, 436);
-        else
-          DWIN_Draw_Rectangle(1, Def_Background_Color, 186, 415, 205, 436);
-      }
-      else {
-        _leveling_active = (planner.leveling_active || _leveling_active);
-        if ((_leveling_active = planner.leveling_active && ui.get_blink()))
-          DWIN_Draw_Rectangle(1, Def_SplitLine_Color, 186, 415, 205, 436);
-        else
-          DWIN_Draw_Rectangle(1, Def_Background_Color, 186, 415, 205, 436);
-      }
-      DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
-    #else
-      if (icons) DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
-    #endif
-    if (temp_val.zoffsetvalue != offset || icons) {
-      offset = temp_val.zoffsetvalue;
-      DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color),Def_Background_Color, 1, 2, 202, 417, temp_val.zoffsetvalue);
-    }
-  #endif
-
-  static int16_t feedrate = -1;
-  if (icons) {
-    feedrate = -1;
-    DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
-    DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
-  }
-  if (feedrate_percentage != feedrate) {
-    feedrate = feedrate_percentage;
-    DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
-  }
-
-  static float x = -1, y = -1, z = -1;
-  static bool update_x = false, update_y = false, update_z = false;
-  update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
-  update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
-  update_z = (current_position.z != z || axis_should_home(Z_AXIS) || update_z);
-  if (icons) {
-    x = y = z = -1;
-    DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Def_SplitLine_Color, true), 16, 450, 256, 450);
-    DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
-    DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
-    DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
-  }
-  if (update_x) {
-    x = current_position.x;
-    if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
-      DWINUI::Draw_String(GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 39, 459, F("  -?-  "));
-    else
-      DWINUI::Draw_Signed_Float(DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 3, 1, 31, 459, current_position.x);
-  }
-  if (update_y) {
-    y = current_position.y;
-    if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
-      DWINUI::Draw_String(GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 124, 459, F("  -?-  "));
-    else
-      DWINUI::Draw_Signed_Float(DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 3, 1, 116, 459, current_position.y);
-  }
-  if (update_z) {
-    z = current_position.z;
-    if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
-      DWINUI::Draw_String(GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 205, 459, F("  -?-  "));
-    else
-      DWINUI::Draw_Signed_Float(DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 3, 2, 197, 459, current_position.z);
-  }
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
-  if (process != Confirm && process != Popup && process != Wait && process != Cancel) last_process = process;
-  if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
-  process = mode;
-  if (popup != PrintConfirm) {
-    Clear_Screen();
-    DWIN_Draw_Rectangle(0, Def_Highlight_Color, 13, 59, 259, 346);
-    DWIN_Draw_Rectangle(1, Def_PopupBg_color, 14, 60, 258, 345);
-  }
-  else DWIN_Draw_Rectangle(1, Def_Background_Color, 0, 0, DWIN_WIDTH, STATUS_Y - 1);
-  const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : (mode == Cancel) ? 200 : 230;
-  if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
-  if (line1) DWINUI::Draw_String(Def_PopupTxt_Color, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
-  if (line2) DWINUI::Draw_String(Def_PopupTxt_Color, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
-  if (line3) DWINUI::Draw_String(Def_PopupTxt_Color, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
-  if (mode == Popup) {
-    selection = 0;
-    DWINUI::Draw_Button(BTN_Confirm, 26, 280);
-    DWINUI::Draw_Button(BTN_Cancel, 146, 280);
-    Popup_Select();
-  }
-  else if (mode == Confirm) DWINUI::Draw_Button(BTN_Continue, 87, 280);
-  else if (mode == Cancel) DWINUI::Draw_Button(BTN_Cancel, 87, 280);
-}
-
-void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
-  CrealityDWIN.Draw_Popup(GET_TEXT_F(MSG_KILLED), error, GET_TEXT_F(MSG_SWITCH_PS_OFF), Wait, ICON_BLTouch);
-}
-
-void CrealityDWINClass::Popup_Select() {
-  const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Def_Highlight_Color) : Def_Background_Color,
-                 c2 = (selection == 0) ? Def_Background_Color : GetColor(eeprom_settings.highlight_box, Def_Highlight_Color);
-  DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
-  DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
-  DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
-  DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
-}
-
-void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
-  static bool new_msg;
-  static uint8_t msgscrl = 0;
-  static char lastmsg[128];
-  if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
-    strcpy(lastmsg, statusmsg);
-    msgscrl = 0;
-    new_msg = true;
-  }
-  size_t len = strlen(statusmsg);
-  int8_t pos = len;
-  if (pos > STATUS_CHAR_LIMIT) {
-    pos -= msgscrl;
-    len = _MIN((size_t)pos, (size_t)STATUS_CHAR_LIMIT);
-    char dispmsg[len + 1];
-    if (pos >= 0) {
-      LOOP_L_N(i, len) dispmsg[i] = statusmsg[i + msgscrl];
-    }
-    else {
-      LOOP_L_N(i, STATUS_CHAR_LIMIT + pos) dispmsg[i] = ' ';
-      LOOP_S_L_N(i, STATUS_CHAR_LIMIT + pos, STATUS_CHAR_LIMIT) dispmsg[i] = statusmsg[i - (STATUS_CHAR_LIMIT + pos)];
-    }
-    dispmsg[len] = '\0';
-    if (process == Print) {
-      DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 214, DWIN_WIDTH - 8, 238);
-      const int8_t npos = (DWIN_WIDTH - STATUS_CHAR_LIMIT * MENU_CHR_W) / 2;
-      DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 219, dispmsg);
-    }
-    else {
-      DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 352, DWIN_WIDTH - 8, 376);
-      const int8_t npos = (DWIN_WIDTH - STATUS_CHAR_LIMIT * MENU_CHR_W) / 2;
-      DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 357, dispmsg);
-    }
-    if (-pos >= STATUS_CHAR_LIMIT) msgscrl = 0;
-    msgscrl++;
-  }
-  else {
-    if (new_msg) {
-      new_msg = false;
-      if (process == Print) {
-        DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 214, DWIN_WIDTH - 8, 238);
-        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 219, statusmsg);
-      }
-      else {
-        DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 352, DWIN_WIDTH - 8, 376);
-        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 357, statusmsg);
-      }
-    }
-  }
-}
-
-#if HAS_HOSTACTION_MENUS
-
-  void CrealityDWINClass::Draw_Keyboard(bool restrict, bool numeric, uint8_t selected, bool uppercase/*=false*/, bool lock/*=false*/) {
-    process = Keyboard;
-    keyboard_restrict = restrict;
-    numeric_keyboard = numeric;
-    DWIN_Draw_Rectangle(0, Def_SplitLine_Color, 0, KEY_Y_START, DWIN_WIDTH-2, DWIN_HEIGHT-2);
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 1, KEY_Y_START+1, DWIN_WIDTH-3, DWIN_HEIGHT-3);
-    LOOP_L_N(i, 36) Draw_Keys(i, (i == selected), uppercase, lock);
-  }
-
-  void CrealityDWINClass::Draw_Keys(uint8_t index, bool selected, bool uppercase/*=false*/, bool lock/*=false*/) {
-    const char *keys;
-    if (numeric_keyboard) keys = "1234567890&<>() {}[]*\"\':;!?";
-    else keys = (uppercase) ? "QWERTYUIOPASDFGHJKLZXCVBNM" : "qwertyuiopasdfghjklzxcvbnm";
-    #define KEY_X1(x) x*KEY_WIDTH+KEY_INSET+KEY_PADDING
-    #define KEY_X2(x) (x+1) * KEY_WIDTH+KEY_INSET-KEY_PADDING
-    #define KEY_Y1(y) KEY_Y_START+KEY_INSET+KEY_PADDING+y*KEY_HEIGHT
-    #define KEY_Y2(y) KEY_Y_START+KEY_INSET-KEY_PADDING+(y+1) * KEY_HEIGHT
-
-    const uint8_t rowCount[3] = { 10, 9, 7 };
-    const float xOffset[3] = { 0, 0.5f * KEY_WIDTH, 1.5f * KEY_WIDTH };
-
-    if (index < 28) {
-      if (index == 19) {
-        DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(0), KEY_Y1(2), KEY_X2(0) + xOffset[1], KEY_Y2(2));
-        DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(0) + 1, KEY_Y1(2) + 1, KEY_X2(0) + xOffset[1] - 1, KEY_Y2(2) - 1);
-        if (!numeric_keyboard) {
-          if (lock) {
-            DWIN_Draw_Line(Def_Selected_Color, KEY_X1(0) + 17, KEY_Y1(2) + 16, KEY_X1(0) + 25, KEY_Y1(2) + 8);
-            DWIN_Draw_Line(Def_Selected_Color, KEY_X1(0) + 17, KEY_Y1(2) + 16, KEY_X1(0) + 9, KEY_Y1(2) + 8);
-          }
-          else {
-            DWIN_Draw_Line((uppercase) ? Def_Selected_Color : Def_Text_Color, KEY_X1(0) + 17, KEY_Y1(2) + 8, KEY_X1(0) + 25, KEY_Y1(2) + 16);
-            DWIN_Draw_Line((uppercase) ? Def_Selected_Color : Def_Text_Color, KEY_X1(0) + 17, KEY_Y1(2) + 8, KEY_X1(0) + 9, KEY_Y1(2) + 16);
-          }
-        }
-      }
-      else if (index == 27) {
-        DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(7) + xOffset[2], KEY_Y1(2), KEY_X2(9), KEY_Y2(2));
-        DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(7) + xOffset[2] + 1, KEY_Y1(2) + 1, KEY_X2(9) - 1, KEY_Y2(2) - 1);
-        DWINUI::Draw_String(Color_Red, KEY_X1(7) + xOffset[2] + 3, KEY_Y1(2) + 5, F("<--"));
-      }
-      else {
-        if (index > 19) index--;
-        if (index > 27) index--;
-        uint8_t y, x;
-        if (index < rowCount[0]) y = 0, x = index;
-        else if (index < (rowCount[0] + rowCount[1])) y = 1, x = index-rowCount[0];
-        else y = 2, x = index-(rowCount[0] + rowCount[1]);
-        const char keyStr[2] = {keys[(y > 0) * rowCount[0] + (y > 1) * rowCount[1] + x], '\0'};
-        DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(x) + xOffset[y], KEY_Y1(y), KEY_X2(x) + xOffset[y], KEY_Y2(y));
-        DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(x) + xOffset[y] + 1, KEY_Y1(y) + 1, KEY_X2(x) + xOffset[y] - 1, KEY_Y2(y) - 1);
-        DWINUI::Draw_String(KEY_X1(x) + xOffset[y] + 5, KEY_Y1(y) + 5, keyStr);
-        if (keyboard_restrict && numeric_keyboard && index > 9) {
-          DWIN_Draw_Line(Color_Light_Red, KEY_X1(x) + xOffset[y] + 1, KEY_Y1(y) + 1, KEY_X2(x) + xOffset[y] - 1, KEY_Y2(y) - 1);
-          DWIN_Draw_Line(Color_Light_Red, KEY_X1(x) + xOffset[y] + 1, KEY_Y2(y) - 1, KEY_X2(x) + xOffset[y] - 1, KEY_Y1(y) + 1);
-        }
-      }
-    }
-    else {
-      switch (index) {
-        case 28:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(0), KEY_Y1(3), KEY_X2(0) + xOffset[1], KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(0) + 1, KEY_Y1(3) + 1, KEY_X2(0) + xOffset[1] - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(KEY_X1(0) - 1, KEY_Y1(3) + 5, F("?123"));
-          break;
-        case 29:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(1) + xOffset[1], KEY_Y1(3), KEY_X2(1) + xOffset[1], KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(1) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(1) + xOffset[1] - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(KEY_X1(1) + xOffset[1] + 5, KEY_Y1(3) + 5, F("-"));
-          break;
-        case 30:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(2) + xOffset[1], KEY_Y1(3), KEY_X2(2) + xOffset[1], KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(2) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(2) + xOffset[1] - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(KEY_X1(2) + xOffset[1] + 5, KEY_Y1(3) + 5, F("_"));
-          break;
-        case 31:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(3) + xOffset[1], KEY_Y1(3), KEY_X2(5) + xOffset[1], KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(3) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(5) + xOffset[1] - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(KEY_X1(3) + xOffset[1] + 14, KEY_Y1(3) + 5, F("Space"));
-          if (keyboard_restrict) {
-            DWIN_Draw_Line(Color_Light_Red, KEY_X1(3) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(5) + xOffset[1] - 1, KEY_Y2(3) - 1);
-            DWIN_Draw_Line(Color_Light_Red, KEY_X1(3) + xOffset[1] + 1, KEY_Y2(3) - 1, KEY_X2(5) + xOffset[1] - 1, KEY_Y1(3) + 1);
-          }
-          break;
-        case 32:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(6) + xOffset[1], KEY_Y1(3), KEY_X2(6) + xOffset[1], KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(6) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(6) + xOffset[1] - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(KEY_X1(6) + xOffset[1] + 7, KEY_Y1(3) + 5, F("."));
-          if (keyboard_restrict) {
-            DWIN_Draw_Line(Color_Light_Red, KEY_X1(6) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(6) + xOffset[1] - 1, KEY_Y2(3) - 1);
-            DWIN_Draw_Line(Color_Light_Red, KEY_X1(6) + xOffset[1] + 1, KEY_Y2(3) - 1, KEY_X2(6) + xOffset[1] - 1, KEY_Y1(3) + 1);
-          }
-          break;
-        case 33:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(7) + xOffset[1], KEY_Y1(3), KEY_X2(7) + xOffset[1], KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(7) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(7) + xOffset[1] - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(KEY_X1(7) + xOffset[1] + 4, KEY_Y1(3) + 5, F("/"));
-          if (keyboard_restrict) {
-            DWIN_Draw_Line(Color_Light_Red, KEY_X1(7) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(7) + xOffset[1] - 1, KEY_Y2(3) - 1);
-            DWIN_Draw_Line(Color_Light_Red, KEY_X1(7) + xOffset[1] + 1, KEY_Y2(3) - 1, KEY_X2(7) + xOffset[1] - 1, KEY_Y1(3) + 1);
-          }
-          break;
-        case 34:
-          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(7) + xOffset[2], KEY_Y1(3), KEY_X2(9), KEY_Y2(3));
-          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(7) + xOffset[2] + 1, KEY_Y1(3) + 1, KEY_X2(9) - 1, KEY_Y2(3) - 1);
-          DWINUI::Draw_String(Color_Cyan, KEY_X1(7) + xOffset[2] + 3, KEY_Y1(3) + 5, F("-->"));
-          break;
-      }
-    }
-  }
-#endif // HAS_HOSTACTION_MENUS
-
-/* Menu Item Config */
-
-void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
-  const uint8_t row = item - scrollpos;
-  #if HAS_LEVELING
-    static bool level_state;
-  #endif
-
-  #if HAS_PREHEAT
-
-    #define PREHEAT_BACK 0
-    #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
-    #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
-    #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
-    #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
-
-    auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
-      switch (item) {
-        case PREHEAT_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(TempMenu, sel);
-          break;
-        #if HAS_HOTEND
-          case PREHEAT_SUBMENU_HOTEND:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-              Draw_Float(ui.material_preset[index].hotend_temp, row, false, 1);
-            }
-            else
-              Modify_Value(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-            break;
-        #endif
-        #if HAS_HEATED_BED
-          case PREHEAT_SUBMENU_BED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-              Draw_Float(ui.material_preset[index].bed_temp, row, false, 1);
-            }
-            else
-              Modify_Value(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-            break;
-        #endif
-        #if HAS_FAN
-          case PREHEAT_SUBMENU_FAN:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
-              Draw_Float(ui.material_preset[index].fan_speed, row, false, 1);
-            }
-            else
-              Modify_Value(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-            break;
-        #endif
-      }
-    };
-
-  #endif
-
-  switch (menu) {
-    case Prepare:
-
-      #define PREPARE_BACK 0
-      #define PREPARE_MOVE (PREPARE_BACK + 1)
-      #define PREPARE_DISABLE (PREPARE_MOVE + 1)
-      #define PREPARE_HOME (PREPARE_DISABLE + 1)
-      #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
-      #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
-      #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
-      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + EITHER(HAS_HOTEND, HAS_HEATED_BED))
-      #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
-      #define PREPARE_ACTIONCOMMANDS (PREPARE_CHANGEFIL + ENABLED(HAS_HOSTACTION_MENUS))
-      #define PREPARE_CUSTOM_MENU (PREPARE_ACTIONCOMMANDS + ENABLED(HAS_CUSTOM_MENU))
-      #define PREPARE_TOTAL PREPARE_ACTIONCOMMANDS
-
-      switch (item) {
-        case PREPARE_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Main_Menu(1);
-          break;
-        case PREPARE_MOVE:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Axis, GET_TEXT_F(MSG_MOVE_AXIS), nullptr, true);
-          else
-            Draw_Menu(Move);
-          break;
-        case PREPARE_DISABLE:
-          if (draw)
-            Draw_Menu_Item(row, ICON_CloseMotor, GET_TEXT_F(MSG_DISABLE_STEPPERS));
-          else
-            queue.inject(F("M84"));
-          break;
-        case PREPARE_HOME:
-          if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, GET_TEXT_F(MSG_HOMING), nullptr, true);
-          else
-            Draw_Menu(HomeMenu);
-          break;
-        case PREPARE_MANUALLEVEL:
-          if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_BED_TRAMMING_MANUAL), nullptr, true);
-          else {
-            if (axes_should_home()) {
-              Popup_Handler(Home);
-              gcode.home_all_axes(true);
-            }
-            #if HAS_LEVELING
-              level_state = planner.leveling_active;
-              set_bed_leveling_enabled(false);
-            #endif
-            Draw_Menu(ManualLevel);
-          }
-          break;
-
-        #if HAS_ZOFFSET_ITEM
-          case PREPARE_ZOFFSET:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Zoffset, F("Z-Offset"), nullptr, true);
-            else {
-              #if HAS_LEVELING
-                level_state = planner.leveling_active;
-                set_bed_leveling_enabled(false);
-              #endif
-              Draw_Menu(ZOffset);
-            }
-            break;
-        #endif
-
-        #if HAS_PREHEAT
-          case PREPARE_PREHEAT:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, F("Preheat"), nullptr, true);
-            else
-              Draw_Menu(Preheat);
-            break;
-        #endif
-
-        #if HAS_HOTEND || HAS_HEATED_BED
-          case PREPARE_COOLDOWN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Cool, GET_TEXT_F(MSG_COOLDOWN));
-            else {
-              thermalManager.cooldown();
-              Update_Status(GET_TEXT(MSG_COOLDOWN));
-            }
-            break;
-        #endif
-
-        #if HAS_HOSTACTION_MENUS
-          case PREPARE_ACTIONCOMMANDS:
-          if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Host Actions"), nullptr, true);
-          else
-            Draw_Menu(HostActions);
-          break;
-        #endif
-
-        #if HAS_CUSTOM_MENU
-          case PREPARE_CUSTOM_MENU:
-            #ifndef CUSTOM_MENU_CONFIG_TITLE
-              #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
-            #endif
-            if (draw)
-              Draw_Menu_Item(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
-            else
-              Draw_Menu(MenuCustom);
-            break;
-        #endif
-
-        #if ENABLED(ADVANCED_PAUSE_FEATURE)
-          case PREPARE_CHANGEFIL:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
-                #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                  , nullptr, true
-                #endif
-              );
-            }
-            else {
-              #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                Draw_Menu(ChangeFilament);
-              #else
-                if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                  Popup_Handler(ETemp);
-                else {
-                  if (thermalManager.temp_hotend[0].is_below_target(-2)) {
-                    Popup_Handler(Heating);
-                    thermalManager.wait_for_hotend(0);
-                  }
-                  Popup_Handler(FilChange);
-                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                  gcode.process_subcommands_now(cmd);
-                }
-              #endif
-            }
-            break;
-        #endif
-      }
-      break;
-
-    case HomeMenu:
-
-      #define HOME_BACK  0
-      #define HOME_ALL   (HOME_BACK + 1)
-      #define HOME_X     (HOME_ALL + 1)
-      #define HOME_Y     (HOME_X + 1)
-      #define HOME_Z     (HOME_Y + 1)
-      #define HOME_SET   (HOME_Z + 1)
-      #define HOME_TOTAL HOME_SET
-
-      switch (item) {
-        case HOME_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Prepare, PREPARE_HOME);
-          break;
-        case HOME_ALL:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME));
-          else {
-            Popup_Handler(Home);
-            gcode.home_all_axes(true);
-            Redraw_Menu();
-          }
-          break;
-        case HOME_X:
-          if (draw)
-            Draw_Menu_Item(row, ICON_MoveX, GET_TEXT_F(MSG_AUTO_HOME_X));
-          else {
-            Popup_Handler(Home);
-            gcode.process_subcommands_now(F("G28 X"));
-            planner.synchronize();
-            Redraw_Menu();
-          }
-          break;
-        case HOME_Y:
-          if (draw)
-            Draw_Menu_Item(row, ICON_MoveY, GET_TEXT_F(MSG_AUTO_HOME_Y));
-          else {
-            Popup_Handler(Home);
-            gcode.process_subcommands_now(F("G28 Y"));
-            planner.synchronize();
-            Redraw_Menu();
-          }
-          break;
-        case HOME_Z:
-          if (draw)
-            Draw_Menu_Item(row, ICON_MoveZ, GET_TEXT_F(MSG_AUTO_HOME_Z));
-          else {
-            Popup_Handler(Home);
-            gcode.process_subcommands_now(F("G28 Z"));
-            planner.synchronize();
-            Redraw_Menu();
-          }
-          break;
-        case HOME_SET:
-          if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS));
-          else {
-            gcode.process_subcommands_now(F("G92X0Y0Z0"));
-            AudioFeedback();
-          }
-          break;
-      }
-      break;
-
-    case Move:
-
-      #define MOVE_BACK 0
-      #define MOVE_X (MOVE_BACK + 1)
-      #define MOVE_Y (MOVE_X + 1)
-      #define MOVE_Z (MOVE_Y + 1)
-      #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
-      #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
-      #define MOVE_LIVE (MOVE_P + 1)
-      #define MOVE_TOTAL MOVE_LIVE
-
-      switch (item) {
-        case MOVE_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else {
-            #if HAS_BED_PROBE
-              temp_val.probe_deployed = false;
-              probe.set_deployed(temp_val.probe_deployed);
-            #endif
-            Draw_Menu(Prepare, PREPARE_MOVE);
-          }
-          break;
-        case MOVE_X:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MoveX, GET_TEXT_F(MSG_MOVE_X));
-            Draw_Float(current_position.x, row, false);
-          }
-          else
-            Modify_Value(current_position.x, X_MIN_POS, X_MAX_POS, 10);
-          break;
-        case MOVE_Y:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MoveY, GET_TEXT_F(MSG_MOVE_Y));
-            Draw_Float(current_position.y, row);
-          }
-          else
-            Modify_Value(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
-          break;
-        case MOVE_Z:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MoveZ, GET_TEXT_F(MSG_MOVE_Z));
-            Draw_Float(current_position.z, row);
-          }
-          else
-            Modify_Value(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
-          break;
-
-        #if HAS_HOTEND
-          case MOVE_E:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, GET_TEXT_F(MSG_MOVE_E));
-              current_position.e = 0;
-              sync_plan_position();
-              Draw_Float(current_position.e, row);
-            }
-            else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                Popup_Handler(ETemp);
-              else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
-                  Popup_Handler(Heating);
-                  thermalManager.wait_for_hotend(0);
-                  Redraw_Menu();
-                }
-                current_position.e = 0;
-                sync_plan_position();
-                Modify_Value(current_position.e, -500, 500, 10);
-              }
-            }
-          break;
-        #endif // HAS_HOTEND
-
-        #if HAS_BED_PROBE
-          case MOVE_P:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_ProbeDeploy, GET_TEXT_F(MSG_MANUAL_DEPLOY));
-              Draw_Checkbox(row, temp_val.probe_deployed);
-            }
-            else {
-              temp_val.probe_deployed = !temp_val.probe_deployed;
-              probe.set_deployed(temp_val.probe_deployed);
-              Draw_Checkbox(row, temp_val.probe_deployed);
-            }
-            break;
-        #endif
-
-        case MOVE_LIVE:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_Axis, F("Live Movement"));
-            Draw_Checkbox(row, temp_val.livemove);
-          }
-          else {
-            temp_val.livemove = !temp_val.livemove;
-            Draw_Checkbox(row, temp_val.livemove);
-          }
-          break;
-      }
-      break;
-    case ManualLevel:
-
-      #define MLEVEL_BACK 0
-      #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
-      #define MLEVEL_FL (MLEVEL_PROBE + 1)
-      #define MLEVEL_BL (MLEVEL_FL + 1)
-      #define MLEVEL_BR (MLEVEL_BL + 1)
-      #define MLEVEL_FR (MLEVEL_BR + 1)
-      #define MLEVEL_C (MLEVEL_FR + 1)
-      #define MLEVEL_ZPOS (MLEVEL_C + 1)
-      #define MLEVEL_TOTAL MLEVEL_ZPOS
-
-      static float mlev_z_pos = 0;
-      static bool use_probe = false;
-
-      switch (item) {
-        case MLEVEL_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else {
-            TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
-            Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
-          }
-          break;
-        #if HAS_BED_PROBE
-          case MLEVEL_PROBE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
-              Draw_Checkbox(row, use_probe);
-            }
-            else {
-              use_probe = !use_probe;
-              Draw_Checkbox(row, use_probe);
-              if (use_probe) {
-                Popup_Handler(Level);
-                do_z_clearance(Z_HOMING_HEIGHT);
-                temp_val.corner_avg = 0;
-                #define PROBE_X_MIN _MAX(temp_val.corner_pos, PROBING_MARGIN, MESH_MIN_X) - probe.offset.x
-                #define PROBE_X_MAX _MIN(X_BED_SIZE - temp_val.corner_pos, X_BED_SIZE - PROBING_MARGIN, MESH_MAX_X) - probe.offset.x
-                #define PROBE_Y_MIN _MAX(temp_val.corner_pos, PROBING_MARGIN, MESH_MIN_Y) - probe.offset.y
-                #define PROBE_Y_MAX _MIN(Y_BED_SIZE - temp_val.corner_pos, Y_BED_SIZE - PROBING_MARGIN, MESH_MAX_Y) - probe.offset.y
-                temp_val.zval = probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MIN, PROBE_PT_RAISE, 0, false);
-                const char * MSG_UNREACHABLE = "Position unreachable. Check Probe Offsets and Bed Screw Inset.";
-                if (isnan(temp_val.zval)) {
-                  Update_Status(MSG_UNREACHABLE);
-                  Redraw_Menu();
-                }
-                temp_val.corner_avg += temp_val.zval;
-                temp_val.zval = probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
-                if (isnan(temp_val.zval)) {
-                  Update_Status(MSG_UNREACHABLE);
-                  Redraw_Menu();
-                }
-                temp_val.corner_avg += temp_val.zval;
-                temp_val.zval = probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
-                if (isnan(temp_val.zval)) {
-                  Update_Status(MSG_UNREACHABLE);
-                  Redraw_Menu();
-                }
-                temp_val.corner_avg += temp_val.zval;
-                temp_val.zval = probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
-                if (isnan(temp_val.zval)) {
-                  Update_Status(MSG_UNREACHABLE);
-                  Redraw_Menu();
-                }
-                temp_val.corner_avg += temp_val.zval;
-                temp_val.corner_avg /= 4;
-                Redraw_Menu();
-              }
-            }
-            break;
-        #endif
-        case MLEVEL_FL:
-          if (draw)
-            Draw_Menu_Item(row, ICON_AxisBL, GET_TEXT_F(MSG_LEVBED_FL));
-          else {
-            Popup_Handler(MoveWait);
-            if (use_probe) {
-              #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-                planner.synchronize();
-                Popup_Handler(ManualProbing);
-              #endif
-            }
-            else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(temp_val.corner_pos, 1, 3, str_1), dtostrf(temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-          }
-          break;
-        case MLEVEL_BL:
-          if (draw)
-            Draw_Menu_Item(row, ICON_AxisTL, GET_TEXT_F(MSG_LEVBED_BL));
-          else {
-            Popup_Handler(MoveWait);
-            if (use_probe) {
-              #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-                planner.synchronize();
-                Popup_Handler(ManualProbing);
-              #endif
-            }
-            else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(temp_val.corner_pos, 1, 3, str_1), dtostrf(Y_BED_SIZE - temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-          }
-          break;
-        case MLEVEL_BR:
-          if (draw)
-            Draw_Menu_Item(row, ICON_AxisTR, GET_TEXT_F(MSG_LEVBED_BR));
-          else {
-            Popup_Handler(MoveWait);
-            if (use_probe) {
-              #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-                planner.synchronize();
-                Popup_Handler(ManualProbing);
-              #endif
-            }
-            else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(X_BED_SIZE - temp_val.corner_pos, 1, 3, str_1), dtostrf(Y_BED_SIZE - temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-          }
-          break;
-        case MLEVEL_FR:
-          if (draw)
-            Draw_Menu_Item(row, ICON_AxisBR, GET_TEXT_F(MSG_LEVBED_FR));
-          else {
-            Popup_Handler(MoveWait);
-            if (use_probe) {
-              #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-                planner.synchronize();
-                Popup_Handler(ManualProbing);
-              #endif
-            }
-            else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(X_BED_SIZE - temp_val.corner_pos, 1, 3, str_1), dtostrf(temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-          }
-          break;
-        case MLEVEL_C:
-          if (draw)
-            Draw_Menu_Item(row, ICON_AxisC, GET_TEXT_F(MSG_LEVBED_C));
-          else {
-            Popup_Handler(MoveWait);
-            if (use_probe) {
-              #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf((PROBE_X_MIN + PROBE_X_MAX) / 2.0f, 1, 3, str_1), dtostrf((PROBE_Y_MIN + PROBE_Y_MAX) / 2.0f, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-                planner.synchronize();
-                Popup_Handler(ManualProbing);
-              #endif
-            }
-            else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(X_BED_SIZE / 2.0f, 1, 3, str_1), dtostrf(Y_BED_SIZE / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-          }
-          break;
-        case MLEVEL_ZPOS:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_SetZOffset, GET_TEXT_F(MSG_MOVE_Z));
-            Draw_Float(mlev_z_pos, row, false, 100);
-          }
-          else
-            Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
-          break;
-      }
-      break;
-    #if HAS_ZOFFSET_ITEM
-      case ZOffset:
-
-        #define ZOFFSET_BACK 0
-        #define ZOFFSET_HOME (ZOFFSET_BACK + 1)
-        #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
-        #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
-        #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
-        #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
-        #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
-        #define ZOFFSET_TOTAL ZOFFSET_SAVE
-
-        switch (item) {
-          case ZOFFSET_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else {
-              temp_val.zoffsetmode = 0;
-              #if !HAS_BED_PROBE
-                gcode.process_subcommands_now(F("M211 S1"));  // Soft end-stops
-              #endif
-              TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
-              Draw_Menu(Prepare, PREPARE_ZOFFSET);
-            }
-            break;
-          case ZOFFSET_HOME:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME_Z));
-            else {
-              Popup_Handler(Home);
-              gcode.process_subcommands_now(F("G28 Z"));
-              Popup_Handler(MoveWait);
-              #if ENABLED(Z_SAFE_HOMING)
-                planner.synchronize();
-                sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-              #else
-                sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2));
-                gcode.process_subcommands_now(cmd);
-              #endif
-              gcode.process_subcommands_now(F("G0 F300 Z0"));
-              planner.synchronize();
-              Redraw_Menu();
-            }
-            break;
-          case ZOFFSET_MODE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, F("Live Adjustment"));
-              Draw_Option(temp_val.zoffsetmode, zoffset_modes, row);
-            }
-            else
-              Modify_Option(temp_val.zoffsetmode, zoffset_modes, 2);
-            break;
-          case ZOFFSET_OFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Offset"));
-              Draw_Float(temp_val.zoffsetvalue, row, false, 100);
-            }
-            else
-              Modify_Value(temp_val.zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
-            break;
-          case ZOFFSET_UP:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
-            else {
-              if (temp_val.zoffsetvalue < MAX_Z_OFFSET) {
-                if (temp_val.zoffsetmode != 0) {
-                  gcode.process_subcommands_now(F("M290 Z0.01"));
-                  planner.synchronize();
-                }
-                temp_val.zoffsetvalue += 0.01;
-                Draw_Float(temp_val.zoffsetvalue, row - 1, false, 100);
-              }
-            }
-            break;
-          case ZOFFSET_DOWN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
-            else {
-              if (temp_val.zoffsetvalue > MIN_Z_OFFSET) {
-                if (temp_val.zoffsetmode != 0) {
-                  gcode.process_subcommands_now(F("M290 Z-0.01"));
-                  planner.synchronize();
-                }
-                temp_val.zoffsetvalue -= 0.01;
-                Draw_Float(temp_val.zoffsetvalue, row - 2, false, 100);
-              }
-            }
-            break;
-          #if ENABLED(EEPROM_SETTINGS)
-            case ZOFFSET_SAVE:
-              if (draw)
-                Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_BUTTON_SAVE));
-              else
-                AudioFeedback(settings.save());
-              break;
-          #endif
-        }
-        break;
-    #endif
-
-    #if HAS_PREHEAT
-      case Preheat: {
-        #define PREHEAT_MODE (PREHEAT_BACK + 1)
-        #define PREHEAT_1 (PREHEAT_MODE + 1)
-        #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
-        #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
-        #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
-        #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
-        #define PREHEAT_TOTAL PREHEAT_5
-
-        auto do_preheat = [](const uint8_t m) {
-          thermalManager.cooldown();
-          if (temp_val.preheatmode == 0 || temp_val.preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
-          if (temp_val.preheatmode == 0 || temp_val.preheatmode == 2) ui.preheat_bed(m);
-        };
-
-        switch (item) {
-          case PREHEAT_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Prepare, PREPARE_PREHEAT);
-            break;
-
-          case PREHEAT_MODE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Homing, GET_TEXT_F(MSG_CONFIGURATION));
-              Draw_Option(temp_val.preheatmode, preheat_modes, row);
-            }
-            else
-              Modify_Option(temp_val.preheatmode, preheat_modes, 2);
-            break;
-
-          #define _PREHEAT_CASE(N) \
-            case PREHEAT_##N: { \
-              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
-              else do_preheat(N - 1); \
-            } break;
-
-          REPEAT_1(PREHEAT_COUNT, _PREHEAT_CASE)
-        }
-      } break;
-    #endif // HAS_PREHEAT
-
-    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:
-
-        #define CHANGEFIL_BACK 0
-        #define CHANGEFIL_PARKHEAD (CHANGEFIL_BACK + 1)
-        #define CHANGEFIL_LOAD (CHANGEFIL_PARKHEAD + 1)
-        #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
-        #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
-        #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
-
-        switch (item) {
-          case CHANGEFIL_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Prepare, PREPARE_CHANGEFIL);
-            break;
-          case CHANGEFIL_PARKHEAD:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Park, GET_TEXT_F(MSG_FILAMENT_PARK_ENABLED));
-            else {
-              #if ENABLED(NOZZLE_PARK_FEATURE)
-                queue.inject(F("G28O\nG27 P2"));
-              #else
-                sprintf_P(cmd, PSTR("G28O\nG0 F4000 X%i Y%i\nG0 F3000 Z%i"), 0 , 0, 20);
-                queue.inject(cmd);
-              #endif
-            }
-            break;
-          case CHANGEFIL_LOAD:
-            if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
-            else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                Popup_Handler(ETemp);
-              else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
-                  Popup_Handler(Heating);
-                  thermalManager.wait_for_hotend(0);
-                }
-                Popup_Handler(FilLoad);
-                gcode.process_subcommands_now(F("M701"));
-                planner.synchronize();
-                Redraw_Menu();
-              }
-            }
-            break;
-          case CHANGEFIL_UNLOAD:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
-            else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
-                Popup_Handler(ETemp);
-              }
-              else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
-                  Popup_Handler(Heating);
-                  thermalManager.wait_for_hotend(0);
-                }
-                Popup_Handler(FilLoad, true);
-                gcode.process_subcommands_now(F("M702"));
-                planner.synchronize();
-                Redraw_Menu();
-              }
-            }
-            break;
-          case CHANGEFIL_CHANGE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
-            else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-                Popup_Handler(ETemp);
-              else {
-                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
-                  Popup_Handler(Heating);
-                  thermalManager.wait_for_hotend(0);
-                }
-                Popup_Handler(FilChange);
-                sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                gcode.process_subcommands_now(cmd);
-              }
-            }
-            break;
-        }
-        break;
-    #endif // FILAMENT_LOAD_UNLOAD_GCODES
-
-    #if HAS_HOSTACTION_MENUS
-      case HostActions:
-
-        #define HOSTACTIONS_BACK 0
-        #define HOSTACTIONS_1 (HOSTACTIONS_BACK + 1)
-        #define HOSTACTIONS_2 (HOSTACTIONS_1 + 1)
-        #define HOSTACTIONS_3 (HOSTACTIONS_2 + 1)
-        #define HOSTACTIONS_TOTAL HOSTACTIONS_3
-
-        switch (item) {
-          case HOSTACTIONS_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else {
-              if (temp_val.flag_tune) {
-                temp_val.flag_tune = false;
-                Redraw_Menu(false, true, true);
-              }
-              else
-                Draw_Menu(Prepare, PREPARE_ACTIONCOMMANDS);
-            }
-            break;
-          case HOSTACTIONS_1:
-            if (draw) Draw_Menu_Item(row, ICON_File, action1);
-            else if (!strcmp(action1, "-") == 0) hostui.action(F(action1));
-            break;
-          case HOSTACTIONS_2:
-            if (draw) Draw_Menu_Item(row, ICON_File, action2);
-            else if (!strcmp(action2, "-") == 0) hostui.action(F(action2));
-            break;
-          case HOSTACTIONS_3:
-            if (draw) Draw_Menu_Item(row, ICON_File, action3);
-            else if (!strcmp(action3, "-") == 0) hostui.action(F(action3));
-            break;
-        }
-        break;
-    #endif
-
-    #if HAS_CUSTOM_MENU
-
-      case MenuCustom:
-
-        #define CUSTOM_MENU_BACK 0
-        #define CUSTOM_MENU_1 1
-        #define CUSTOM_MENU_2 2
-        #define CUSTOM_MENU_3 3
-        #define CUSTOM_MENU_4 4
-        #define CUSTOM_MENU_5 5
-        #define CUSTOM_MENU_TOTAL CUSTOM_MENU_COUNT
-
-        switch (item) {
-          case CUSTOM_MENU_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
-            else
-              Draw_Menu(Prepare, PREPARE_CUSTOM_MENU);
-            break;
-
-          #if CUSTOM_MENU_COUNT >= 1
-            case CUSTOM_MENU_1:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
-              else {
-                Popup_Handler(Custom);
-                //queue.inject(F(CONFIG_MENU_ITEM_1_GCODE)); // Old code
-                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_1_GCODE));
-                planner.synchronize();
-                Redraw_Menu();
-                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
-                #endif
-                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
-                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
-                #endif
-              }
-              break;
-          #endif
-
-          #if CUSTOM_MENU_COUNT >= 2
-            case CUSTOM_MENU_2:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_2_DESC));
-              else {
-                Popup_Handler(Custom);
-                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_2_GCODE));
-                planner.synchronize();
-                Redraw_Menu();
-                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
-                #endif
-                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
-                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
-                #endif
-              }
-              break;
-          #endif
-
-          #if CUSTOM_MENU_COUNT >= 3
-            case CUSTOM_MENU_3:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_3_DESC));
-              else {
-                Popup_Handler(Custom);
-                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_3_GCODE));
-                planner.synchronize();
-                Redraw_Menu();
-                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
-                #endif
-                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
-                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
-                #endif
-              }
-              break;
-          #endif
-
-          #if CUSTOM_MENU_COUNT >= 4
-            case CUSTOM_MENU_4:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_4_DESC));
-              else {
-                Popup_Handler(Custom);
-                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_4_GCODE));
-                planner.synchronize();
-                Redraw_Menu();
-                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
-                #endif
-                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
-                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
-                #endif
-              }
-              break;
-          #endif
-
-          #if CUSTOM_MENU_COUNT >= 5
-            case CUSTOM_MENU_5:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_5_DESC));
-              else {
-                Popup_Handler(Custom);
-                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_5_GCODE));
-                planner.synchronize();
-                Redraw_Menu();
-                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
-                  AudioFeedback();
-                #endif
-                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
-                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
-                #endif
-              }
-              break;
-          #endif // Custom Menu
-        }
-        break;
-
-    #endif // HAS_CUSTOM_MENU
-
-    case Control:
-
-      #define CONTROL_BACK 0
-      #define CONTROL_TEMP (CONTROL_BACK + 1)
-      #define CONTROL_MOTION (CONTROL_TEMP + 1)
-      #define CONTROL_FWRETRACT (CONTROL_MOTION + ENABLED(FWRETRACT))
-      #define CONTROL_LEDS (CONTROL_FWRETRACT + ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU))
-      #define CONTROL_VISUAL (CONTROL_LEDS + 1)
-      #define CONTROL_HOSTSETTINGS (CONTROL_VISUAL + ENABLED(HAS_HOSTACTION_MENUS))
-      #define CONTROL_ADVANCED (CONTROL_HOSTSETTINGS + 1)
-      #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
-      #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
-      #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
-      #define CONTROL_REBOOT (CONTROL_RESET + 1)
-      #define CONTROL_INFO (CONTROL_REBOOT + 1)
-      #define CONTROL_TOTAL CONTROL_INFO
-
-      switch (item) {
-        case CONTROL_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Main_Menu(2);
-          break;
-        case CONTROL_TEMP:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), nullptr, true);
-          else
-            Draw_Menu(TempMenu);
-          break;
-        case CONTROL_MOTION:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Motion, GET_TEXT_F(MSG_MOTION), nullptr, true);
-          else
-            Draw_Menu(Motion);
-          break;
-        #if ENABLED(FWRETRACT)
-          case CONTROL_FWRETRACT:
-          if (draw)
-            Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_AUTORETRACT), nullptr, true);
-          else
-            Draw_Menu(FwRetraction);
-          break;
-        #endif
-        #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
-          case CONTROL_LEDS:
-            if (draw)
-              Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LEDS), nullptr, true);
-            else
-              Draw_Menu(Ledsmenu);
-            break;
-        #endif
-        case CONTROL_VISUAL:
-          if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, F("Visual"), nullptr, true);
-          else
-            Draw_Menu(Visual);
-          break;
-        #if HAS_HOSTACTION_MENUS
-          case CONTROL_HOSTSETTINGS:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Contact, F("Host Settings"), nullptr, true);
-            else
-              Draw_Menu(HostSettings);
-            break;
-        #endif
-        case CONTROL_ADVANCED:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Version, GET_TEXT_F(MSG_ADVANCED_SETTINGS), nullptr, true);
-          else
-            Draw_Menu(Advanced);
-          break;
-        #if ENABLED(EEPROM_SETTINGS)
-          case CONTROL_SAVE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM));
-            else
-              AudioFeedback(settings.save());
-            break;
-          case CONTROL_RESTORE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM));
-            else
-              AudioFeedback(settings.load());
-            break;
-          case CONTROL_RESET:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_RESTORE_DEFAULTS));
-            else {
-              settings.reset();
-              AudioFeedback();
-            }
-            break;
-        #endif
-        case CONTROL_REBOOT:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Reboot, GET_TEXT_F(MSG_RESET_PRINTER));
-          else
-            RebootPrinter();
-          break;
-        case CONTROL_INFO:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN));
-          else
-            Draw_Menu(Info);
-          break;
-      }
-      break;
-
-    case TempMenu:
-
-      #define TEMP_BACK 0
-      #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
-      #define TEMP_BED (TEMP_HOTEND + ENABLED(HAS_HEATED_BED))
-      #define TEMP_FAN (TEMP_BED + ENABLED(HAS_FAN))
-      #define TEMP_PID (TEMP_FAN + ANY(HAS_HOTEND, HAS_HEATED_BED))
-      #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
-      #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
-      #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
-      #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
-      #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
-      #define TEMP_TOTAL TEMP_PREHEAT5
-
-      switch (item) {
-        case TEMP_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Control, CONTROL_TEMP);
-          break;
-        #if HAS_HOTEND
-          case TEMP_HOTEND:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
-            break;
-        #endif
-        #if HAS_HEATED_BED
-          case TEMP_BED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-            break;
-        #endif
-        #if HAS_FAN
-          case TEMP_FAN:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
-              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-            break;
-        #endif
-        #if HAS_HOTEND || HAS_HEATED_BED
-          case TEMP_PID:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, F("PID"), nullptr, true);
-            else
-              Draw_Menu(PID);
-            break;
-        #endif
-
-        #define _TEMP_PREHEAT_CASE(N) \
-          case TEMP_PREHEAT##N: { \
-            if (draw) Draw_Menu_Item(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
-            else Draw_Menu(Preheat##N); \
-          } break;
-
-        REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
-      }
-      break;
-
-    #if HAS_HOTEND || HAS_HEATED_BED
-      case PID:
-
-        #define PID_BACK 0
-        #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
-        #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
-        #define PID_CYCLES (PID_BED + 1)
-        #define PID_TOTAL PID_CYCLES
-
-        static uint8_t PID_cycles = 5;
-
-        switch (item) {
-          case PID_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(TempMenu, TEMP_PID);
-            break;
-          #if HAS_HOTEND
-            case PID_HOTEND:
-              if (draw)
-                Draw_Menu_Item(row, ICON_HotendTemp, F(STR_HOTEND_PID), nullptr, true);
-              else
-                Draw_Menu(HotendPID);
-              break;
-          #endif
-          #if HAS_HEATED_BED
-            case PID_BED:
-              if (draw)
-                Draw_Menu_Item(row, ICON_BedTemp, F(STR_BED_PID), nullptr, true);
-              else
-                Draw_Menu(BedPID);
-              break;
-          #endif
-          case PID_CYCLES:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_PID_CYCLE));
-              Draw_Float(PID_cycles, row, false, 1);
-            }
-            else
-              Modify_Value(PID_cycles, 3, 50, 1);
-            break;
-        }
-        break;
-    #endif // HAS_HOTEND || HAS_HEATED_BED
-
-    #if HAS_HOTEND
-      case HotendPID:
-
-        #define HOTENDPID_BACK 0
-        #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
-        #define HOTENDPID_TEMP (HOTENDPID_TUNE + 1)
-        #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
-        #define HOTENDPID_KI (HOTENDPID_KP + 1)
-        #define HOTENDPID_KD (HOTENDPID_KI + 1)
-        #define HOTENDPID_TOTAL HOTENDPID_KD
-
-        switch (item) {
-          case HOTENDPID_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(PID, PID_HOTEND);
-            break;
-          case HOTENDPID_TUNE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
-            else {
-              Popup_Handler(PIDWait);
-              sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, temp_val.PID_e_temp);
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-            break;
-          case HOTENDPID_TEMP:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE));
-              Draw_Float(temp_val.PID_e_temp, row, false, 1);
-            }
-            else
-              Modify_Value(temp_val.PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-            break;
-          case HOTENDPID_KP:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
-              Draw_Float(thermalManager.temp_hotend[0].pid.Kp, row, false, 100);
-            }
-            else
-              Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
-            break;
-          case HOTENDPID_KI:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
-              Draw_Float(unscalePID_i(thermalManager.temp_hotend[0].pid.Ki), row, false, 100);
-            }
-            else
-              Modify_Value(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
-            break;
-          case HOTENDPID_KD:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
-              Draw_Float(unscalePID_d(thermalManager.temp_hotend[0].pid.Kd), row, false, 100);
-            }
-            else
-              Modify_Value(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
-            break;
-        }
-        break;
-    #endif // HAS_HOTEND
-
-    #if HAS_HEATED_BED
-      case BedPID:
-
-        #define BEDPID_BACK 0
-        #define BEDPID_TUNE (BEDPID_BACK + 1)
-        #define BEDPID_TEMP (BEDPID_TUNE + 1)
-        #define BEDPID_KP (BEDPID_TEMP + 1)
-        #define BEDPID_KI (BEDPID_KP + 1)
-        #define BEDPID_KD (BEDPID_KI + 1)
-        #define BEDPID_TOTAL BEDPID_KD
-
-        switch (item) {
-          case BEDPID_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(PID, PID_BED);
-            break;
-          case BEDPID_TUNE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
-            else {
-              Popup_Handler(PIDWait);
-              sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, temp_val.PID_bed_temp);
-              gcode.process_subcommands_now(cmd);
-              planner.synchronize();
-              Redraw_Menu();
-            }
-            break;
-          case BEDPID_TEMP:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE));
-              Draw_Float(temp_val.PID_bed_temp, row, false, 1);
-            }
-            else
-              Modify_Value(temp_val.PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-            break;
-          case BEDPID_KP:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
-              Draw_Float(thermalManager.temp_bed.pid.Kp, row, false, 100);
-            }
-            else
-              Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
-            break;
-          case BEDPID_KI:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
-              Draw_Float(unscalePID_i(thermalManager.temp_bed.pid.Ki), row, false, 100);
-            }
-            else
-              Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
-            break;
-          case BEDPID_KD:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
-              Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
-            }
-            else
-              Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
-            break;
-        }
-        break;
-    #endif // HAS_HEATED_BED
-
-    #if HAS_PREHEAT
-      #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
-      REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
-    #endif
-
-    case Motion:
-
-      #define MOTION_BACK 0
-      #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
-      #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
-      #define MOTION_ACCEL (MOTION_SPEED + 1)
-      #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
-      #define MOTION_JD (MOTION_JERK + ENABLED(HAS_JUNCTION_DEVIATION))
-      #define MOTION_STEPS (MOTION_JD + 1)
-      #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
-      #define MOTION_TOTAL MOTION_FLOW
-
-      switch (item) {
-        case MOTION_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Control, CONTROL_MOTION);
-          break;
-        case MOTION_HOMEOFFSETS:
-          if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS), nullptr, true);
-          else
-            Draw_Menu(HomeOffsets);
-          break;
-        case MOTION_SPEED:
-          if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, GET_TEXT_F(MSG_MAX_SPEED), nullptr, true);
-          else
-            Draw_Menu(MaxSpeed);
-          break;
-        case MOTION_ACCEL:
-          if (draw)
-            Draw_Menu_Item(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_AMAX_EN), nullptr, true);
-          else
-            Draw_Menu(MaxAcceleration);
-          break;
-        #if HAS_CLASSIC_JERK
-          case MOTION_JERK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_MaxJerk, GET_TEXT_F(MSG_JERK), nullptr, true);
-            else
-              Draw_Menu(MaxJerk);
-            break;
-        #endif
-        #if HAS_JUNCTION_DEVIATION
-          case MOTION_JD:
-            if (draw)
-              Draw_Menu_Item(row, ICON_MaxJerk, GET_TEXT_F(MSG_JUNCTION_DEVIATION), nullptr, true);
-            else
-              Draw_Menu(JDmenu);
-            break;
-        #endif
-        case MOTION_STEPS:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), nullptr, true);
-          else
-            Draw_Menu(Steps);
-          break;
-        #if HAS_HOTEND
-          case MOTION_FLOW:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
-              Draw_Float(planner.flow_percentage[0], row, false, 1);
-            }
-            else
-              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
-            break;
-        #endif
-      }
-      break;
-
-    #if ENABLED(FWRETRACT)
-      case FwRetraction:
-
-        #define FWR_BACK 0
-        #define FWR_RET_AUTO (FWR_BACK + 1)
-        #define FWR_RET_LENGTH (FWR_RET_AUTO + 1)
-        #define FWR_RET_SPEED (FWR_RET_LENGTH + 1)
-        #define FWR_ZLIFT (FWR_RET_SPEED + 1)
-        #define FWR_REC_EXT_LENGTH (FWR_ZLIFT + 1)
-        #define FWR_REC_SPEED (FWR_REC_EXT_LENGTH + 1)
-        #define FWR_RESET (FWR_REC_SPEED + 1)
-        #define FWR_TOTAL FWR_RESET
-
-        switch (item) {
-
-          case FWR_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else {
-            if (temp_val.flag_tune) {
-              temp_val.flag_tune = false;
-              Redraw_Menu(false, true, true);
-            }
-            else
-              Draw_Menu(Control, CONTROL_FWRETRACT);
-          }
-          break;
-          case FWR_RET_AUTO:
-            if (draw) {
-              temp_val.auto_fw_retract = fwretract.autoretract_enabled;
-              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_AUTORETRACT));
-              Draw_Checkbox(row, temp_val.auto_fw_retract);
-            }
-            else {
-              if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
-                temp_val.auto_fw_retract = !temp_val.auto_fw_retract;
-                fwretract.enable_autoretract(temp_val.auto_fw_retract);
-                Draw_Checkbox(row, temp_val.auto_fw_retract);
-              }
-            }
-            break;
-          case FWR_RET_LENGTH:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT));
-              Draw_Float(fwretract.settings.retract_length, row, false, 10);
-            }
-            else
-              Modify_Value(fwretract.settings.retract_length, 0, 10, 10);
-            break;
-          case FWR_RET_SPEED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED));
-              Draw_Float(fwretract.settings.retract_feedrate_mm_s, row, false, 10);
-            }
-            else
-              Modify_Value(fwretract.settings.retract_feedrate_mm_s, 1, 90, 10);
-            break;
-          case FWR_ZLIFT:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP));
-              Draw_Float(fwretract.settings.retract_zraise, row, false, 100);
-            }
-            else
-              Modify_Value(fwretract.settings.retract_zraise, 0, 10, 100);
-            break;
-          case FWR_REC_EXT_LENGTH:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FWRecExtLength, GET_TEXT_F(MSG_CONTROL_RETRACT_RECOVER));
-              Draw_Float(fwretract.settings.retract_recover_extra, row, false, 10);
-            }
-            else
-              Modify_Value(fwretract.settings.retract_recover_extra, -10, 10, 10);
-            break;
-          case FWR_REC_SPEED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED));
-              Draw_Float(fwretract.settings.retract_recover_feedrate_mm_s, row, false, 10);
-            }
-            else
-              Modify_Value(fwretract.settings.retract_recover_feedrate_mm_s, 1, 90, 10);
-            break;
-          case FWR_RESET:
-            if (draw)
-              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_BUTTON_RESET));
-            else {
-              fwretract.reset();
-              Draw_Menu(FwRetraction);
-            }
-            break;
-        }
-        break;
-    #endif
-
-    case HomeOffsets:
-
-      #define HOMEOFFSETS_BACK 0
-      #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
-      #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
-      #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
-
-      switch (item) {
-        case HOMEOFFSETS_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Motion, MOTION_HOMEOFFSETS);
-          break;
-        case HOMEOFFSETS_XOFFSET:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, GET_TEXT_F(MSG_HOME_OFFSET_X));
-            Draw_Float(home_offset.x, row, false, 100);
-          }
-          else
-            Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
-          break;
-        case HOMEOFFSETS_YOFFSET:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, GET_TEXT_F(MSG_HOME_OFFSET_Y));
-            Draw_Float(home_offset.y, row, false, 100);
-          }
-          else
-            Modify_Value(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
-          break;
-      }
-      break;
-    case MaxSpeed:
-
-      #define SPEED_BACK 0
-      #define SPEED_X (SPEED_BACK + 1)
-      #define SPEED_Y (SPEED_X + 1)
-      #define SPEED_Z (SPEED_Y + 1)
-      #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
-      #define SPEED_TOTAL SPEED_E
-
-      switch (item) {
-        case SPEED_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Motion, MOTION_SPEED);
-          break;
-        case SPEED_X:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeedX, GET_TEXT_F(MSG_VMAX_A));
-            Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
-          }
-          else
-            Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
-          break;
-
-        #if HAS_Y_AXIS
-          case SPEED_Y:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedY, GET_TEXT_F(MSG_VMAX_B));
-              Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
-            }
-            else
-              Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
-            break;
-        #endif
-
-        #if HAS_Z_AXIS
-          case SPEED_Z:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedZ, GET_TEXT_F(MSG_VMAX_C));
-              Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, 1);
-            }
-            else
-              Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], 0, default_max_feedrate[Z_AXIS] * 2, 1);
-            break;
-        #endif
-
-        #if HAS_HOTEND
-          case SPEED_E:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedE, GET_TEXT_F(MSG_VMAX_E));
-              Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, 1);
-            }
-            else
-              Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], 0, default_max_feedrate[E_AXIS] * 2, 1);
-            break;
-        #endif
-      }
-      break;
-
-    case MaxAcceleration:
-
-      #define ACCEL_BACK 0
-      #define ACCEL_X (ACCEL_BACK + 1)
-      #define ACCEL_Y (ACCEL_X + 1)
-      #define ACCEL_Z (ACCEL_Y + 1)
-      #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
-      #define ACCEL_TOTAL ACCEL_E
-
-      switch (item) {
-        case ACCEL_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Motion, MOTION_ACCEL);
-          break;
-        case ACCEL_X:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccX, GET_TEXT_F(MSG_AMAX_A));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, 1);
-          }
-          else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], 0, default_max_acceleration[X_AXIS] * 2, 1);
-          break;
-        case ACCEL_Y:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccY, GET_TEXT_F(MSG_AMAX_B));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, 1);
-          }
-          else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], 0, default_max_acceleration[Y_AXIS] * 2, 1);
-          break;
-        case ACCEL_Z:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccZ, GET_TEXT_F(MSG_AMAX_C));
-            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, 1);
-          }
-          else
-            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], 0, default_max_acceleration[Z_AXIS] * 2, 1);
-          break;
-        #if HAS_HOTEND
-          case ACCEL_E:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E));
-              Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, 1);
-            }
-            else
-              Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], 0, default_max_acceleration[E_AXIS] * 2, 1);
-            break;
-        #endif
-      }
-      break;
-    #if HAS_CLASSIC_JERK
-      case MaxJerk:
-
-        #define JERK_BACK 0
-        #define JERK_X (JERK_BACK + 1)
-        #define JERK_Y (JERK_X + 1)
-        #define JERK_Z (JERK_Y + 1)
-        #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
-        #define JERK_TOTAL JERK_E
-
-        switch (item) {
-          case JERK_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Motion, MOTION_JERK);
-            break;
-          case JERK_X:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkX,  GET_TEXT_F(MSG_VA_JERK));
-              Draw_Float(planner.max_jerk[X_AXIS], row, false, 10);
-            }
-            else
-              Modify_Value(planner.max_jerk[X_AXIS], 0, default_max_jerk[X_AXIS] * 2, 10);
-            break;
-          case JERK_Y:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, GET_TEXT_F(MSG_VB_JERK));
-              Draw_Float(planner.max_jerk[Y_AXIS], row, false, 10);
-            }
-            else
-              Modify_Value(planner.max_jerk[Y_AXIS], 0, default_max_jerk[Y_AXIS] * 2, 10);
-            break;
-          case JERK_Z:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, GET_TEXT_F(MSG_VC_JERK));
-              Draw_Float(planner.max_jerk[Z_AXIS], row, false, 10);
-            }
-            else
-              Modify_Value(planner.max_jerk[Z_AXIS], 0, default_max_jerk[Z_AXIS] * 2, 10);
-            break;
-          #if HAS_HOTEND
-            case JERK_E:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK));
-                Draw_Float(planner.max_jerk[E_AXIS], row, false, 10);
-              }
-              else
-                Modify_Value(planner.max_jerk[E_AXIS], 0, default_max_jerk[E_AXIS] * 2, 10);
-              break;
-          #endif
-        }
-        break;
-    #endif
-    #if HAS_JUNCTION_DEVIATION
-      case JDmenu:
-
-        #define JD_BACK 0
-        #define JD_SETTING_JD_MM (JD_BACK + ENABLED(HAS_HOTEND))
-        #define JD_TOTAL JD_SETTING_JD_MM
-
-        switch (item) {
-          case JD_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Motion, MOTION_JD);
-            break;
-          #if HAS_HOTEND
-            case JD_SETTING_JD_MM:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_MaxJerk, GET_TEXT_F(MSG_JUNCTION_DEVIATION));
-                Draw_Float(planner.junction_deviation_mm, row, false, 100);
-              }
-              else
-                Modify_Value(planner.junction_deviation_mm, MIN_JD_MM, MAX_JD_MM, 100);
-              break;
-            #endif
-        }
-        break;
-    #endif
-    case Steps:
-
-      #define STEPS_BACK 0
-      #define STEPS_X (STEPS_BACK + 1)
-      #define STEPS_Y (STEPS_X + 1)
-      #define STEPS_Z (STEPS_Y + 1)
-      #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
-      #define STEPS_TOTAL STEPS_E
-
-      switch (item) {
-        case STEPS_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Motion, MOTION_STEPS);
-          break;
-        case STEPS_X:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, GET_TEXT_F(MSG_A_STEPS));
-            Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, 10);
-          }
-          else
-            Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], 0, default_steps[X_AXIS] * 2, 10);
-          break;
-        case STEPS_Y:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, GET_TEXT_F(MSG_B_STEPS));
-            Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, 10);
-          }
-          else
-            Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], 0, default_steps[Y_AXIS] * 2, 10);
-          break;
-        case STEPS_Z:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepZ, GET_TEXT_F(MSG_C_STEPS));
-            Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, 10);
-          }
-          else
-            Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], 0, default_steps[Z_AXIS] * 2, 10);
-          break;
-        #if HAS_HOTEND
-          case STEPS_E:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_E_STEPS));
-              Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, 10);
-            }
-            else
-              Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], 0, 1000, 10);
-            break;
-        #endif
-      }
-      break;
-
-    #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
-      case Ledsmenu:
-
-        #define LEDS_BACK 0
-        #define LEDS_CASELIGHT (LEDS_BACK + ENABLED(CASE_LIGHT_MENU))
-        #define LEDS_LED_CONTROL_MENU (LEDS_CASELIGHT + ENABLED(LED_CONTROL_MENU))
-        #define LEDS_TOTAL LEDS_LED_CONTROL_MENU
-
-        switch (item) {
-
-        case LEDS_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Control, CONTROL_LEDS);
-          break;
-        #if ENABLED(CASE_LIGHT_MENU)
-          case LEDS_CASELIGHT:
-            if (draw) {
-              #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-                Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), nullptr, true);
-              #else
-                Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT));
-                Draw_Checkbox(row, caselight.on);
-              #endif
-            }
-            else {
-              #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-                Draw_Menu(CaseLightmenu);
-              #else
-                caselight.on = !caselight.on;
-                caselight.update_enabled();
-                Draw_Checkbox(row, caselight.on);
-                DWIN_UpdateLCD();
-              #endif
-            }
-            break;
-        #endif
-        #if ENABLED(LED_CONTROL_MENU)
-          case LEDS_LED_CONTROL_MENU:
-            if (draw)
-              Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LED_CONTROL), nullptr, true);
-            else
-              Draw_Menu(LedControlmenu);
-            break;
-        #endif
-        }
-      break;
-    #endif
-
-    #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-      case CaseLightmenu:
-
-        #define CASE_LIGHT_BACK 0
-        #define CASE_LIGHT_ON (CASE_LIGHT_BACK + 1)
-        #define CASE_LIGHT_USES_BRIGHT (CASE_LIGHT_ON + 1)
-        #define CASE_LIGHT_TOTAL CASE_LIGHT_USES_BRIGHT
-
-        switch (item) {
-
-          case CASE_LIGHT_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Ledsmenu, LEDS_CASELIGHT);
-            break;
-          case CASE_LIGHT_ON:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT));
-              Draw_Checkbox(row, caselight.on);
-            }
-            else {
-              caselight.on = !caselight.on;
-              caselight.update_enabled();
-              Draw_Checkbox(row, caselight.on);
-              DWIN_UpdateLCD();
-            }
-            break;
-          case CASE_LIGHT_USES_BRIGHT:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Brightness, GET_TEXT_F(MSG_CASE_LIGHT_BRIGHTNESS));
-              Draw_Float(caselight.brightness, row);
-            }
-            else
-              Modify_Value(caselight.brightness, 0, 255, 1);
-            break;
-        }
-      break;
-    #endif
-
-    #if ENABLED(LED_CONTROL_MENU)
-      case LedControlmenu:
-
-        #define LEDCONTROL_BACK 0
-        #define LEDCONTROL_LIGHTON (LEDCONTROL_BACK + !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL))
-        #define LEDCONTROL_PRESETS_MENU (LEDCONTROL_LIGHTON + BOTH(HAS_COLOR_LEDS, LED_COLOR_PRESETS))
-        #define LEDCONTROL_CUSTOM_MENU (LEDCONTROL_PRESETS_MENU + ENABLED(HAS_COLOR_LEDS) - DISABLED(LED_COLOR_PRESETS))
-        #define LEDCONTROL_TOTAL LEDCONTROL_CUSTOM_MENU
-
-        switch (item) {
-          case LEDCONTROL_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Ledsmenu, LEDS_LED_CONTROL_MENU);
-            break;
-          #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-            case LEDCONTROL_LIGHTON:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LEDS));
-                Draw_Checkbox(row, leds.lights_on);
-              }
-              else {
-                leds.toggle();
-                Draw_Checkbox(row, leds.lights_on);
-                DWIN_UpdateLCD();
-              }
-              break;
-          #endif
-          #if HAS_COLOR_LEDS
-            #if ENABLED(LED_COLOR_PRESETS)
-              case LEDCONTROL_PRESETS_MENU:
-                  if (draw)
-                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LED_PRESETS));
-                  else
-                    Draw_Menu(LedControlpresets);
-                break;
-            #else
-              case LEDCONTROL_CUSTOM_MENU:
-                if (draw)
-                  Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_CUSTOM_LEDS));
-                else
-                  Draw_Menu(LedControlcustom);
-                break;
-            #endif
-          #endif
-        }
-        break;
-
-        #if HAS_COLOR_LEDS
-          #if ENABLED(LED_COLOR_PRESETS)
-            case LedControlpresets:
-
-              #define LEDCONTROL_PRESETS_BACK 0
-              #define LEDCONTROL_PRESETS_WHITE (LEDCONTROL_PRESETS_BACK + 1)
-              #define LEDCONTROL_PRESETS_RED (LEDCONTROL_PRESETS_WHITE + 1)
-              #define LEDCONTROL_PRESETS_ORANGE (LEDCONTROL_PRESETS_RED + 1)
-              #define LEDCONTROL_PRESETS_YELLOW (LEDCONTROL_PRESETS_ORANGE + 1)
-              #define LEDCONTROL_PRESETS_GREEN (LEDCONTROL_PRESETS_YELLOW + 1)
-              #define LEDCONTROL_PRESETS_BLUE (LEDCONTROL_PRESETS_GREEN + 1)
-              #define LEDCONTROL_PRESETS_INDIGO (LEDCONTROL_PRESETS_BLUE + 1)
-              #define LEDCONTROL_PRESETS_VIOLET (LEDCONTROL_PRESETS_INDIGO + 1)
-              #define LEDCONTROL_PRESETS_TOTAL LEDCONTROL_PRESETS_VIOLET
-
-              #define LEDCOLORITEM(MSG,FUNC) if (draw) Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG)); else FUNC; break;
-
-              switch (item) {
-                case LEDCONTROL_PRESETS_BACK:
-                  if (draw)
-                    Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-                  else
-                    Draw_Menu(LedControlmenu, LEDCONTROL_PRESETS_MENU);
-                  break;
-                case LEDCONTROL_PRESETS_WHITE:  LEDCOLORITEM(MSG_SET_LEDS_WHITE, leds.set_white());
-                case LEDCONTROL_PRESETS_RED:    LEDCOLORITEM(MSG_SET_LEDS_RED, leds.set_red());
-                case LEDCONTROL_PRESETS_ORANGE: LEDCOLORITEM(MSG_SET_LEDS_ORANGE, leds.set_orange());
-                case LEDCONTROL_PRESETS_YELLOW: LEDCOLORITEM(MSG_SET_LEDS_YELLOW, leds.set_yellow());
-                case LEDCONTROL_PRESETS_GREEN:  LEDCOLORITEM(MSG_SET_LEDS_GREEN, leds.set_green());
-                case LEDCONTROL_PRESETS_BLUE:   LEDCOLORITEM(MSG_SET_LEDS_BLUE, leds.set_blue());
-                case LEDCONTROL_PRESETS_INDIGO: LEDCOLORITEM(MSG_SET_LEDS_INDIGO, leds.set_indigo());
-                case LEDCONTROL_PRESETS_VIOLET: LEDCOLORITEM(MSG_SET_LEDS_VIOLET, leds.set_violet());
-              }
-              break;
-          #else
-            case LedControlcustom:
-
-              #define LEDCONTROL_CUSTOM_BACK 0
-              #define LEDCONTROL_CUSTOM_RED (LEDCONTROL_CUSTOM_BACK + 1)
-              #define LEDCONTROL_CUSTOM_GREEN (LEDCONTROL_CUSTOM_RED + 1)
-              #define LEDCONTROL_CUSTOM_BLUE (LEDCONTROL_CUSTOM_GREEN + 1)
-              #define LEDCONTROL_CUSTOM_WHITE (LEDCONTROL_CUSTOM_BLUE + ENABLED(HAS_WHITE_LED))
-              #define LEDCONTROL_CUSTOM_TOTAL LEDCONTROL_CUSTOM_WHITE
-
-              switch (item) {
-                case LEDCONTROL_PRESETS_BACK:
-                  Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-                  else
-                    Draw_Menu(LedControlmenu, LEDCONTROL_CUSTOM_MENU);
-                  break;
-                case LEDCONTROL_CUSTOM_RED:
-                  if (draw) {
-                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_R));
-                    Draw_Float(leds.color.r, row);
-                  }
-                  else
-                    Modify_Value(leds.color.r, 0, 255, 1);
-                  break;
-                case LEDCONTROL_CUSTOM_GREEN:
-                  if (draw) {
-                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_G));
-                    Draw_Float(leds.color.g, row);
-                  }
-                  else
-                    Modify_Value(leds.color.g, 0, 255, 1);
-                  break;
-                case LEDCONTROL_CUSTOM_BLUE:
-                  if (draw) {
-                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_B));
-                    Draw_Float(leds.color.b, row);
-                  }
-                  else
-                    Modify_Value(leds.color.b, 0, 255, 1);
-                  break;
-                #if HAS_WHITE_LED
-                  case case LEDCONTROL_CUSTOM_WHITE:
-                    if (draw) {
-                      Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_W));
-                      Draw_Float(leds.color.w, row);
-                    }
-                    else
-                      Modify_Value(leds.color.w, 0, 255, 1);
-                    break;
-                #endif
-              }
-              break;
-          #endif
-        #endif
-    #endif
-
-    case Visual:
-
-      #define VISUAL_BACK 0
-      #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
-      #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
-      #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
-      #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
-      #define VISUAL_TOTAL VISUAL_COLOR_THEMES
-
-      switch (item) {
-        case VISUAL_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Control, CONTROL_VISUAL);
-          break;
-        case VISUAL_BACKLIGHT:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF));
-          else
-            ui.set_brightness(0);
-          break;
-        case VISUAL_BRIGHTNESS:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness,  GET_TEXT_F(MSG_BRIGHTNESS));
-            Draw_Float(ui.brightness, row, false, 1);
-          }
-          else
-            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
-          break;
-        case VISUAL_TIME_FORMAT:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_PrintTime, F("Progress as __h__m"));
-            Draw_Checkbox(row, eeprom_settings.time_format_textual);
-          }
-          else {
-            eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
-            Draw_Checkbox(row, eeprom_settings.time_format_textual);
-          }
-          break;
-        case VISUAL_COLOR_THEMES:
-          if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, GET_TEXT_F(MSG_COLORS_SELECT), nullptr, true);
-          else
-            Draw_Menu(ColorSettings);
-        break;
-      }
-      break;
-
-    case ColorSettings:
-
-      #define COLORSETTINGS_BACK 0
-      #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
-      #define COLORSETTINGS_SPLIT_LINE (COLORSETTINGS_CURSOR + 1)
-      #define COLORSETTINGS_MENU_TOP_TXT (COLORSETTINGS_SPLIT_LINE + 1)
-      #define COLORSETTINGS_MENU_TOP_BG (COLORSETTINGS_MENU_TOP_TXT + 1)
-      #define COLORSETTINGS_HIGHLIGHT_BORDER (COLORSETTINGS_MENU_TOP_BG + 1)
-      #define COLORSETTINGS_PROGRESS_PERCENT (COLORSETTINGS_HIGHLIGHT_BORDER + 1)
-      #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
-      #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
-      #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
-      #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
-      #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
-      #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
-
-      switch (item) {
-        case COLORSETTINGS_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Visual, VISUAL_COLOR_THEMES);
-          break;
-        case COLORSETTINGS_CURSOR:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Cursor"));
-            Draw_Option(eeprom_settings.cursor_color, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.cursor_color, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_SPLIT_LINE:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Split Line"));
-            Draw_Option(eeprom_settings.menu_split_line, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.menu_split_line, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_MENU_TOP_TXT:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Text"));
-            Draw_Option(eeprom_settings.menu_top_txt, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.menu_top_txt, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_MENU_TOP_BG:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Bg"));
-            Draw_Option(eeprom_settings.menu_top_bg, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.menu_top_bg, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_HIGHLIGHT_BORDER:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Highlight Box"));
-            Draw_Option(eeprom_settings.highlight_box, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.highlight_box, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_PROGRESS_PERCENT:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Percent"));
-            Draw_Option(eeprom_settings.progress_percent, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.progress_percent, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_PROGRESS_TIME:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Time"));
-            Draw_Option(eeprom_settings.progress_time, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.progress_time, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_PROGRESS_STATUS_BAR:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Bar Text"));
-            Draw_Option(eeprom_settings.status_bar_text, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.status_bar_text, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_PROGRESS_STATUS_AREA:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Area Text"));
-            Draw_Option(eeprom_settings.status_area_text, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.status_area_text, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_PROGRESS_COORDINATES:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Text"));
-            Draw_Option(eeprom_settings.coordinates_text, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.coordinates_text, color_names, Custom_Colors);
-          break;
-        case COLORSETTINGS_PROGRESS_COORDINATES_LINE:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Line"));
-            Draw_Option(eeprom_settings.coordinates_split_line, color_names, row, false, true);
-          }
-          else
-            Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
-          break;
-      } // switch (item)
-      break;
-
-    #if HAS_HOSTACTION_MENUS
-      case HostSettings:
-
-        #define HOSTSETTINGS_BACK 0
-        #define HOSTSETTINGS_ACTIONCOMMANDS (HOSTSETTINGS_BACK + 1)
-        #define HOSTSETTINGS_TOTAL HOSTSETTINGS_ACTIONCOMMANDS
-
-        switch (item) {
-          case HOSTSETTINGS_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Control, CONTROL_HOSTSETTINGS);
-            break;
-            case HOSTSETTINGS_ACTIONCOMMANDS:
-              if (draw) Draw_Menu_Item(row, ICON_File, F("Host Actions"));
-              else Draw_Menu(ActionCommands);
-              break;
-        }
-        break;
-
-      case ActionCommands:
-
-        #define ACTIONCOMMANDS_BACK 0
-        #define ACTIONCOMMANDS_1 (ACTIONCOMMANDS_BACK + 1)
-        #define ACTIONCOMMANDS_2 (ACTIONCOMMANDS_1 + 1)
-        #define ACTIONCOMMANDS_3 (ACTIONCOMMANDS_2 + 1)
-        #define ACTIONCOMMANDS_TOTAL ACTIONCOMMANDS_3
-
-        switch (item) {
-          case ACTIONCOMMANDS_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(HostSettings, HOSTSETTINGS_ACTIONCOMMANDS);
-            break;
-          case ACTIONCOMMANDS_1:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_File, F("Action #1"));
-              Draw_String(action1, row);
-            }
-            else
-              Modify_String(action1, 8, true);
-            break;
-          case ACTIONCOMMANDS_2:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_File, F("Action #2"));
-              Draw_String(action2, row);
-            }
-            else
-              Modify_String(action2, 8, true);
-            break;
-          case ACTIONCOMMANDS_3:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_File, F("Action #3"));
-              Draw_String(action3, row);
-            }
-            else
-              Modify_String(action3, 8, true);
-            break;
-        }
-        break;
-    #endif
-
-    case Advanced:
-
-      #define ADVANCED_BACK 0
-      #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
-      #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
-      #define ADVANCED_CORNER (ADVANCED_PROBE + 1)
-      #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
-      #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
-      #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
-      #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
-      #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
-      #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
-      #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
-      #define ADVANCED_BAUDRATE_MODE (ADVANCED_POWER_LOSS + ENABLED(BAUD_RATE_GCODE))
-      #define ADVANCED_ESDIAG (ADVANCED_BAUDRATE_MODE + ENABLED(HAS_ESDIAG))
-      #define ADVANCED_LOCKSCREEN (ADVANCED_ESDIAG + ENABLED(HAS_LOCKSCREEN))
-      #define ADVANCED_TOTAL ADVANCED_LOCKSCREEN
-
-      switch (item) {
-        case ADVANCED_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else
-            Draw_Menu(Control, CONTROL_ADVANCED);
-          break;
-
-        #if ENABLED(SOUND_MENU_ITEM)
-          case ADVANCED_BEEPER:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Sound, GET_TEXT_F(MSG_SOUND_ENABLE));
-              Draw_Checkbox(row, ui.sound_on);
-            }
-            else {
-              ui.sound_on = !ui.sound_on;
-              Draw_Checkbox(row, ui.sound_on);
-            }
-            break;
-        #endif
-
-        #if HAS_BED_PROBE
-          case ADVANCED_PROBE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ProbeSet, GET_TEXT_F(MSG_ZPROBE_SETTINGS), nullptr, true);
-            else
-              Draw_Menu(ProbeMenu);
-            break;
-        #endif
-
-        case ADVANCED_CORNER:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
-            Draw_Float(temp_val.corner_pos, row, false, 10);
-          }
-          else
-            Modify_Value(temp_val.corner_pos, 1, 100, 10);
-          break;
-
-        #if ENABLED(LIN_ADVANCE)
-          case ADVANCED_LA:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K_E));
-              Draw_Float(planner.extruder_advance_K[0], row, false, 100);
-            }
-            else
-              Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
-            break;
-        #endif
-
-        #if ENABLED(ADVANCED_PAUSE_FEATURE)
-          case ADVANCED_LOAD:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENT_LOAD));
-              Draw_Float(fc_settings[0].load_length, row, false, 1);
-            }
-            else
-              Modify_Value(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
-            break;
-          case ADVANCED_UNLOAD:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENT_UNLOAD));
-              Draw_Float(fc_settings[0].unload_length, row, false, 1);
-            }
-            else
-              Modify_Value(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
-            break;
-        #endif // ADVANCED_PAUSE_FEATURE
-
-        #if ENABLED(PREVENT_COLD_EXTRUSION)
-          case ADVANCED_COLD_EXTRUDE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Cool, F("Min Extrusion T"));
-              Draw_Float(thermalManager.extrude_min_temp, row, false, 1);
-            }
-            else {
-              Modify_Value(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
-              thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
-            }
-            break;
-        #endif
-
-        #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-          case ADVANCED_FILSENSORENABLED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, GET_TEXT_F(MSG_RUNOUT_ENABLE));
-              Draw_Checkbox(row, runout.enabled);
-            }
-            else {
-              runout.enabled = !runout.enabled;
-              Draw_Checkbox(row, runout.enabled);
-            }
-            break;
-
-          #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
-            case ADVANCED_FILSENSORDISTANCE:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_MaxAccE, GET_TEXT_F(MSG_RUNOUT_DISTANCE_MM));
-                Draw_Float(runout.runout_distance(), row, false, 10);
-              }
-              else
-                Modify_Value(runout.runout_distance(), 0, 999, 10);
-              break;
-          #endif
-        #endif // FILAMENT_RUNOUT_SENSOR
-
-        #if ENABLED(POWER_LOSS_RECOVERY)
-          case ADVANCED_POWER_LOSS:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Motion, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
-              Draw_Checkbox(row, recovery.enabled);
-            }
-            else {
-              recovery.enable(!recovery.enabled);
-              Draw_Checkbox(row, recovery.enabled);
-            }
-            break;
-        #endif
-        #if ENABLED(BAUD_RATE_GCODE)
-          case ADVANCED_BAUDRATE_MODE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Setspeed, F("115k Baud"));
-              Draw_Checkbox(row, eeprom_settings.Baud115k);
-            }
-            else {
-              eeprom_settings.Baud115k = !eeprom_settings.Baud115k;
-              queue.inject(eeprom_settings.Baud115k ? F("M575 P0 B115200") : F("M575 P0 B250000"));
-            }
-            break;
-        #endif
-        #if HAS_ESDIAG
-          case ADVANCED_ESDIAG:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ESDiag, F("End-stops diagnostic"));
-            else
-              DWIN_EndstopsDiag();
-            break;
-        #endif
-        #if HAS_LOCKSCREEN
-          case ADVANCED_LOCKSCREEN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN));
-            else
-              DWIN_LockScreen();
-            break;
-        #endif
-      }
-      break;
-
-    #if HAS_BED_PROBE
-      case ProbeMenu:
-
-        #define PROBE_BACK 0
-        #define PROBE_XOFFSET (PROBE_BACK + 1)
-        #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
-        #define PROBE_ZOFFSET (PROBE_YOFFSET + 1)
-        #define PROBE_HSMODE (PROBE_ZOFFSET + ENABLED(BLTOUCH))
-        #define PROBE_ALARMR (PROBE_HSMODE + ENABLED(BLTOUCH))
-        #define PROBE_SELFTEST (PROBE_ALARMR + ENABLED(BLTOUCH))
-        #define PROBE_MOVEP (PROBE_SELFTEST + ENABLED(BLTOUCH))
-        #define PROBE_TEST (PROBE_MOVEP + 1)
-        #define PROBE_TEST_COUNT (PROBE_TEST + 1)
-        #define PROBE_TOTAL PROBE_TEST_COUNT
-
-        static uint8_t testcount = 4;
-
-        switch (item) {
-          case PROBE_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Advanced, ADVANCED_PROBE);
-            break;
-          case PROBE_XOFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_StepX, GET_TEXT_F(MSG_ZPROBE_XOFFSET));
-              Draw_Float(probe.offset.x, row, false, 10);
-            }
-            else
-              Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
-            break;
-          case PROBE_YOFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_StepY, GET_TEXT_F(MSG_ZPROBE_YOFFSET));
-              Draw_Float(probe.offset.y, row, false, 10);
-            }
-            else
-              Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
-            break;
-          case PROBE_ZOFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_StepZ, GET_TEXT_F(MSG_ZPROBE_ZOFFSET));
-              Draw_Float(probe.offset.z, row, false, 100);
-            }
-            else
-              Modify_Value(probe.offset.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
-            break;
-          #if ENABLED(BLTOUCH)
-            case PROBE_HSMODE:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_HSMode, GET_TEXT(MSG_BLTOUCH_SPEED_MODE));
-                Draw_Checkbox(row, bltouch.high_speed_mode);
-              }
-              else {
-                bltouch.high_speed_mode = !bltouch.high_speed_mode;
-                Draw_Checkbox(row, bltouch.high_speed_mode);
-              }
-              break;
-            case PROBE_ALARMR:
-              if (draw)
-                Draw_Menu_Item(row, ICON_ProbeAlarm, GET_TEXT_F(MSG_BLTOUCH_RESET));
-              else {
-                gcode.process_subcommands_now(F("M280 P0 S160"));
-                AudioFeedback();
-              }
-              break;
-            case PROBE_SELFTEST:
-              if (draw)
-                Draw_Menu_Item(row, ICON_ProbeSelfTest, GET_TEXT_F(MSG_BLTOUCH_SELFTEST));
-              else {
-                gcode.process_subcommands_now(F("M280 P0 S120\nG4 P1000\nM280 P0 S160"));
-                planner.synchronize();
-                AudioFeedback();
-              }
-              break;
-            case PROBE_MOVEP:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_ProbeDeploy, GET_TEXT_F(MSG_BLTOUCH_DEPLOY));
-                Draw_Checkbox(row, temp_val.probe_deployed);
-              }
-              else {
-                temp_val.probe_deployed = !temp_val.probe_deployed;
-                if (temp_val.probe_deployed == true)  gcode.process_subcommands_now(F("M280 P0 S10"));
-                else  gcode.process_subcommands_now(F("M280 P0 S90"));
-                Draw_Checkbox(row, temp_val.probe_deployed);
-              }
-              break;
-          #endif
-          case PROBE_TEST:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ProbeTest, GET_TEXT_F(MSG_M48_TEST));
-            else {
-              sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
-              gcode.process_subcommands_now(cmd);
-            }
-            break;
-          case PROBE_TEST_COUNT:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_ProbeTestCount, F("Probe Test Count"));
-              Draw_Float(testcount, row, false, 1);
-            }
-            else
-              Modify_Value(testcount, 4, 50, 1);
-            break;
-        }
-        break;
-    #endif
-
-    case InfoMain:
-    case Info:
-
-      #define INFO_BACK 0
-      #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
-      #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
-      #define INFO_SIZE (INFO_PRINTTIME + 1)
-      #define INFO_VERSION (INFO_SIZE + 1)
-      #define INFO_CONTACT (INFO_VERSION + 1)
-      #define INFO_TOTAL INFO_BACK
-
-      switch (item) {
-        case INFO_BACK:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-
-            #if ENABLED(PRINTCOUNTER)
-              char row1[50], row2[50], buf[32];
-              printStatistics ps = print_job_timer.getStats();
-
-              sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
-              sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
-              Draw_Menu_Item(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
-
-              duration_t(print_job_timer.getStats().printTime).toString(buf);
-              sprintf_P(row1, PSTR("Printed: %s"), buf);
-              duration_t(print_job_timer.getStats().longestPrint).toString(buf);
-              sprintf_P(row2, PSTR("Longest: %s"), buf);
-              Draw_Menu_Item(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
-            #endif
-
-            Draw_Menu_Item(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
-            Draw_Menu_Item(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
-            Draw_Menu_Item(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
-          }
-          else {
-            if (menu == Info)
-              Draw_Menu(Control, CONTROL_INFO);
-            else
-              Draw_Main_Menu(3);
-          }
-          break;
-      }
-      break;
-
-    #if HAS_MESH
-      case Leveling:
-
-        #define LEVELING_BACK 0
-        #define LEVELING_ACTIVE (LEVELING_BACK + 1)
-        #define LEVELING_GET_TILT (LEVELING_ACTIVE + BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL))
-        #define LEVELING_GET_MESH (LEVELING_GET_TILT + 1)
-        #define LEVELING_MANUAL (LEVELING_GET_MESH + 1)
-        #define LEVELING_VIEW (LEVELING_MANUAL + 1)
-        #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
-        #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_TOTAL LEVELING_SAVE
-
-        switch (item) {
-          case LEVELING_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Main_Menu(3);
-            break;
-          case LEVELING_ACTIVE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MeshActive, GET_TEXT_F(MSG_MESH_LEVELING));
-              Draw_Checkbox(row, planner.leveling_active);
-            }
-            else {
-              if (!planner.leveling_active) {
-                set_bed_leveling_enabled(!planner.leveling_active);
-                if (!planner.leveling_active) { Confirm_Handler(LevelError); break; }
-              }
-              else
-                set_bed_leveling_enabled(!planner.leveling_active);
-              Draw_Checkbox(row, planner.leveling_active);
-            }
-            break;
-          #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
-            case LEVELING_GET_TILT:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
-              else {
-                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
-                PreheatBefore();
-                Popup_Handler(Home);
-                gcode.home_all_axes(true);
-                Popup_Handler(Level);
-                if (mesh_conf.tilt_grid > 1) {
-                  sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
-                  gcode.process_subcommands_now(cmd);
-                }
-                else
-                  gcode.process_subcommands_now(F("G29 J"));
-                planner.synchronize();
-                Redraw_Menu();
-              }
-              break;
-          #endif
-          case LEVELING_GET_MESH:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_UBL_BUILD_MESH_MENU));
-            else {
-              #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot, true); break; }
-              #endif
-              PreheatBefore();
-              Popup_Handler(Home);
-              gcode.home_all_axes(true);
-              #if ENABLED(AUTO_BED_LEVELING_UBL)
-                #if HAS_BED_PROBE
-                  Popup_Handler(Level);
-                  gcode.process_subcommands_now(F("G29 P1"));
-                  gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
-                  planner.synchronize();
-                  Update_Status(GET_TEXT_F(MSG_MESH_DONE));
-                  Popup_Handler(SaveLevel);
-                #else
-                  level_state = planner.leveling_active;
-                  set_bed_leveling_enabled(false);
-                  mesh_conf.goto_mesh_value = true;
-                  mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
-                  Popup_Handler(MoveWait);
-                  mesh_conf.manual_mesh_move();
-                  Draw_Menu(UBLMesh);
-                #endif
-              #elif HAS_BED_PROBE
-                Popup_Handler(Level);
-                gcode.process_subcommands_now(F("G29"));
-                planner.synchronize();
-                Update_Status(GET_TEXT_F(MSG_MESH_DONE));
-                Popup_Handler(SaveLevel);
-              #else
-                level_state = planner.leveling_active;
-                set_bed_leveling_enabled(false);
-                temp_val.gridpoint = 1;
-                Popup_Handler(MoveWait);
-                gcode.process_subcommands_now(F("M211 S0\nG29"));
-                planner.synchronize();
-                Draw_Menu(ManualMesh);
-              #endif
-            }
-            break;
-          case LEVELING_MANUAL:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_UBL_MESH_EDIT), nullptr, true);
-            else {
-              #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-                if (!leveling_is_valid()) { Confirm_Handler(InvalidMesh); break; }
-              #endif
-              #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
-              #endif
-              PreheatBefore();
-              if (axes_should_home()) { Popup_Handler(Home); gcode.home_all_axes(true); }
-              level_state = planner.leveling_active;
-              set_bed_leveling_enabled(false);
-              mesh_conf.goto_mesh_value = false;
-              Popup_Handler(MoveWait);
-              mesh_conf.manual_mesh_move();
-              gcode.process_subcommands_now(F("M211 S0"));
-              Draw_Menu(LevelManual);
-            }
-            break;
-          case LEVELING_VIEW:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
-            else {
-              #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
-              #endif
-              Draw_Menu(LevelView);
-            }
-            break;
-          case LEVELING_SETTINGS:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, GET_TEXT_F(MSG_ADVANCED_SETTINGS), nullptr, true);
-            else
-              Draw_Menu(LevelSettings);
-            break;
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-          case LEVELING_SLOT:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_UBL_STORAGE_SLOT));
-              Draw_Float(bedlevel.storage_slot, row, false, 1);
-            }
-            else
-              Modify_Value(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
-            break;
-          case LEVELING_LOAD:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_UBL_LOAD_MESH));
-            else {
-              if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
-              gcode.process_subcommands_now(F("G29 L"));
-              planner.synchronize();
-              AudioFeedback(true);
-            }
-            break;
-          case LEVELING_SAVE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_UBL_SAVE_MESH));
-            else {
-              if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
-              gcode.process_subcommands_now(F("G29 S"));
-              planner.synchronize();
-              AudioFeedback(true);
-            }
-            break;
-          #endif
-        }
-        break;
-
-      case LevelView:
-
-        #define LEVELING_VIEW_BACK 0
-        #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
-        #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
-        #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
-        #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
-
-        switch (item) {
-          case LEVELING_VIEW_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Leveling, LEVELING_VIEW);
-            break;
-          case LEVELING_VIEW_MESH:
-            if (draw)
-              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
-            else
-              Draw_Menu(MeshViewer);
-            break;
-          case LEVELING_VIEW_TEXT:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Contact, F("Viewer Show Values"));
-              Draw_Checkbox(row, mesh_conf.viewer_print_value);
-            }
-            else {
-              mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
-              Draw_Checkbox(row, mesh_conf.viewer_print_value);
-            }
-            break;
-          case LEVELING_VIEW_ASYMMETRIC:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Axis, F("Viewer Asymmetric"));
-              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
-            }
-            else {
-              mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
-              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
-            }
-            break;
-        }
-        break;
-
-      case LevelSettings:
-
-        #define LEVELING_SETTINGS_BACK 0
-        #define LEVELING_SETTINGS_LEVELTEMP_MODE (LEVELING_SETTINGS_BACK + ENABLED(PREHEAT_BEFORE_LEVELING))
-        #define LEVELING_SETTINGS_HOTENDTEMP (LEVELING_SETTINGS_LEVELTEMP_MODE + ENABLED(PREHEAT_BEFORE_LEVELING))
-        #define LEVELING_SETTINGS_BEDTEMP (LEVELING_SETTINGS_HOTENDTEMP + ENABLED(PREHEAT_BEFORE_LEVELING))
-        #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BEDTEMP + 1)
-        #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
-
-        switch (item) {
-          case LEVELING_SETTINGS_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else
-              Draw_Menu(Leveling, LEVELING_SETTINGS);
-            break;
-          #if ENABLED(PREHEAT_BEFORE_LEVELING)
-            case LEVELING_SETTINGS_LEVELTEMP_MODE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
-              Draw_Option(temp_val.LevelingTempmode, preheat_levmodes, row);
-            }
-            else
-              Modify_Option(temp_val.LevelingTempmode, preheat_levmodes, 3);
-            break;
-            case LEVELING_SETTINGS_HOTENDTEMP:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, F("Preheat Hotend"));
-                Draw_Float(eeprom_settings.hotend_levtemp, row, false, 1);
-              }
-              else
-                Modify_Value(eeprom_settings.hotend_levtemp, MIN_E_TEMP, MAX_E_TEMP, 1);
-              break;
-            case LEVELING_SETTINGS_BEDTEMP:
-              if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Preheat Bed"));
-              Draw_Float(eeprom_settings.bed_levtemp, row, false, 1);
-            }
-            else
-              Modify_Value(eeprom_settings.bed_levtemp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-            break;
-          #endif
-          case LEVELING_SETTINGS_FADE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Fade, GET_TEXT_F(MSG_Z_FADE_HEIGHT));
-              Draw_Float(planner.z_fade_height, row, false, 1);
-            }
-            else {
-              Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
-              planner.z_fade_height = -1;
-              set_z_fade_height(planner.z_fade_height);
-            }
-            break;
-
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-            case LEVELING_SETTINGS_TILT:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_Tilt, F("Tilting Grid"));
-                Draw_Float(mesh_conf.tilt_grid, row, false, 1);
-              }
-              else
-                Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
-              break;
-
-            case LEVELING_SETTINGS_PLANE:
-              if (draw)
-                Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
-              else {
-                if (mesh_conf.create_plane_from_mesh()) break;
-                gcode.process_subcommands_now(F("M420 S1"));
-                planner.synchronize();
-                AudioFeedback(true);
-              }
-              break;
-
-            case LEVELING_SETTINGS_ZERO:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Mesh, F("Zero Current Mesh"));
-              else
-                ZERO(bedlevel.z_values);
-              break;
-
-            case LEVELING_SETTINGS_UNDEF:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Mesh, F("Clear Current Mesh"));
-              else
-                bedlevel.invalidate();
-              break;
-
-          #endif // AUTO_BED_LEVELING_UBL
-        }
-        break;
-
-      case MeshViewer:
-        #define MESHVIEW_BACK 0
-        #define MESHVIEW_TOTAL MESHVIEW_BACK
-
-        if (item == MESHVIEW_BACK) {
-          if (draw) {
-            Draw_Menu_Item(0, ICON_Back, GET_TEXT_F(MSG_BACK));
-            mesh_conf.Draw_Bed_Mesh();
-            mesh_conf.Set_Mesh_Viewer_Status();
-          }
-          else if (!mesh_conf.drawing_mesh) {
-            Draw_Menu(LevelView, LEVELING_VIEW_MESH);
-            Update_Status("");
-          }
-        }
-        break;
-
-      case LevelManual:
-
-        #define LEVELING_M_BACK 0
-        #define LEVELING_M_X (LEVELING_M_BACK + 1)
-        #define LEVELING_M_Y (LEVELING_M_X + 1)
-        #define LEVELING_M_NEXT (LEVELING_M_Y + 1)
-        #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
-        #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
-        #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
-        #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
-        #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
-        #define LEVELING_M_TOTAL LEVELING_M_UNDEF
-
-        switch (item) {
-          case LEVELING_M_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else {
-              set_bed_leveling_enabled(level_state);
-              TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
-              Draw_Menu(Leveling, LEVELING_MANUAL);
-            }
-            break;
-          case LEVELING_M_X:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MoveX, GET_TEXT_F(MSG_MESH_X));
-              Draw_Float(mesh_conf.mesh_x, row, 0, 1);
-            }
-            else
-              Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
-            break;
-          case LEVELING_M_Y:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_MoveY, GET_TEXT_F(MSG_MESH_Y));
-              Draw_Float(mesh_conf.mesh_y, row, 0, 1);
-            }
-            else
-              Modify_Value(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
-            break;
-          case LEVELING_M_NEXT:
-            if (draw)
-              Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
-            else {
-              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
-                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && !(mesh_conf.mesh_y & 1)) || (!mesh_conf.mesh_x && (mesh_conf.mesh_y & 1)))
-                  mesh_conf.mesh_y++;
-                else if (mesh_conf.mesh_y & 1)
-                  mesh_conf.mesh_x--;
-                else
-                  mesh_conf.mesh_x++;
-                mesh_conf.manual_mesh_move();
-              }
-            }
-            break;
-          case LEVELING_M_OFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
-            }
-            else {
-              if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
-                bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
-            }
-            break;
-          case LEVELING_M_UP:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
-            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
-              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
-              gcode.process_subcommands_now(F("M290 Z0.01"));
-              planner.synchronize();
-              current_position.z += 0.01f;
-              sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
-            }
-            break;
-          case LEVELING_M_DOWN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
-            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
-              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
-              gcode.process_subcommands_now(F("M290 Z-0.01"));
-              planner.synchronize();
-              current_position.z -= 0.01f;
-              sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
-            }
-            break;
-          case LEVELING_M_GOTO_VALUE:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
-              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
-            }
-            else {
-              mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
-              current_position.z = 0;
-              mesh_conf.manual_mesh_move(true);
-              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
-            }
-            break;
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-          case LEVELING_M_UNDEF:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Clear Point Value"));
-            else {
-              mesh_conf.manual_value_update(true);
-              Redraw_Menu(false);
-            }
-            break;
-          #endif
-        }
-        break;
-    #endif // HAS_MESH
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:
-
-        #define UBL_M_BACK 0
-        #define UBL_M_NEXT (UBL_M_BACK + 1)
-        #define UBL_M_PREV (UBL_M_NEXT + 1)
-        #define UBL_M_OFFSET (UBL_M_PREV + 1)
-        #define UBL_M_UP (UBL_M_OFFSET + 1)
-        #define UBL_M_DOWN (UBL_M_UP + 1)
-        #define UBL_M_TOTAL UBL_M_DOWN
-
-        switch (item) {
-          case UBL_M_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-            else {
-              set_bed_leveling_enabled(level_state);
-              Draw_Menu(Leveling, LEVELING_GET_MESH);
-            }
-            break;
-          case UBL_M_NEXT:
-            if (draw) {
-              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
-                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
-              else
-                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_UBL_SAVE_MESH));
-            }
-            else {
-              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
-                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && !(mesh_conf.mesh_y & 1)) || (!mesh_conf.mesh_x && (mesh_conf.mesh_y & 1)))
-                  mesh_conf.mesh_y++;
-                else if (mesh_conf.mesh_y & 1)
-                  mesh_conf.mesh_x--;
-                else
-                  mesh_conf.mesh_x++;
-                mesh_conf.manual_mesh_move();
-              }
-              else {
-                gcode.process_subcommands_now(F("G29 S"));
-                planner.synchronize();
-                AudioFeedback(true);
-                Draw_Menu(Leveling, LEVELING_GET_MESH);
-              }
-            }
-            break;
-          case UBL_M_PREV:
-            if (draw)
-              Draw_Menu_Item(row, ICON_More, F("Previous Point"));
-            else {
-              if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
-                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && (mesh_conf.mesh_y & 1)) || (!mesh_conf.mesh_x && !(mesh_conf.mesh_y & 1)))
-                  mesh_conf.mesh_y--;
-                else if (mesh_conf.mesh_y & 1)
-                  mesh_conf.mesh_x++;
-                else
-                  mesh_conf.mesh_x--;
-                mesh_conf.manual_mesh_move();
-              }
-            }
-            break;
-          case UBL_M_OFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
-            }
-            else {
-              if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
-                bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
-            }
-            break;
-          case UBL_M_UP:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
-            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
-              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
-              gcode.process_subcommands_now(F("M290 Z0.01"));
-              planner.synchronize();
-              current_position.z += 0.01f;
-              sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
-            }
-            break;
-          case UBL_M_DOWN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Down"));
-            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
-              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
-              gcode.process_subcommands_now(F("M290 Z-0.01"));
-              planner.synchronize();
-              current_position.z -= 0.01f;
-              sync_plan_position();
-              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
-            }
-            break;
-        }
-        break;
-    #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
-
-    #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:
-
-        #define MMESH_BACK 0
-        #define MMESH_NEXT (MMESH_BACK + 1)
-        #define MMESH_OFFSET (MMESH_NEXT + 1)
-        #define MMESH_UP (MMESH_OFFSET + 1)
-        #define MMESH_DOWN (MMESH_UP + 1)
-        #define MMESH_OLD (MMESH_DOWN + 1)
-        #define MMESH_TOTAL MMESH_OLD
-
-        switch (item) {
-          case MMESH_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_CANCEL));
-            else {
-              gcode.process_subcommands_now(F("G29 A"));
-              planner.synchronize();
-              set_bed_leveling_enabled(level_state);
-              Draw_Menu(Leveling, LEVELING_GET_MESH);
-            }
-            break;
-          case MMESH_NEXT:
-            if (draw) {
-              if (temp_val.gridpoint < GRID_MAX_POINTS)
-                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
-              else
-                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_UBL_SAVE_MESH));
-            }
-            else if (temp_val.gridpoint < GRID_MAX_POINTS) {
-              Popup_Handler(MoveWait);
-              gcode.process_subcommands_now(F("G29"));
-              planner.synchronize();
-              temp_val.gridpoint++;
-              Redraw_Menu();
-            }
-            else {
-              gcode.process_subcommands_now(F("G29"));
-              planner.synchronize();
-              AudioFeedback(settings.save());
-              Draw_Menu(Leveling, LEVELING_GET_MESH);
-            }
-            break;
-          case MMESH_OFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
-              current_position.z = MANUAL_PROBE_START_Z;
-              Draw_Float(current_position.z, row, false, 100);
-            }
-            else
-              Modify_Value(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
-            break;
-          case MMESH_UP:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
-            else if (current_position.z < MAX_Z_OFFSET) {
-              gcode.process_subcommands_now(F("M290 Z0.01"));
-              planner.synchronize();
-              current_position.z += 0.01f;
-              sync_plan_position();
-              Draw_Float(current_position.z, row - 1, false, 100);
-            }
-            break;
-          case MMESH_DOWN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
-            else if (current_position.z > MIN_Z_OFFSET) {
-              gcode.process_subcommands_now(F("M290 Z-0.01"));
-              planner.synchronize();
-              current_position.z -= 0.01f;
-              sync_plan_position();
-              Draw_Float(current_position.z, row - 2, false, 100);
-            }
-            break;
-          case MMESH_OLD:
-            uint8_t mesh_x, mesh_y;
-            // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
-            mesh_y = (temp_val.gridpoint - 1) / (GRID_MAX_POINTS_Y);
-            mesh_x = (temp_val.gridpoint - 1) % (GRID_MAX_POINTS_X);
-
-            if (mesh_y & 1)
-              mesh_x = (GRID_MAX_POINTS_X) - mesh_x - 1;
-
-            const float currval = bedlevel.z_values[mesh_x][mesh_y];
-
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, GET_TEXT_F(MSG_MESH_EDIT_Z));
-              Draw_Float(currval, row, false, 100);
-            }
-            else if (!isnan(currval)) {
-              current_position.z = currval;
-              planner.synchronize();
-              planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
-              planner.synchronize();
-              Draw_Float(current_position.z, row - 3, false, 100);
-            }
-            break;
-        }
-        break;
-    #endif // PROBE_MANUALLY
-
-    case Tune:
-
-      #define TUNE_BACK 0
-      #define TUNE_SPEED (TUNE_BACK + 1)
-      #define TUNE_FLOW (TUNE_SPEED + ENABLED(HAS_HOTEND))
-      #define TUNE_HOTEND (TUNE_FLOW + ENABLED(HAS_HOTEND))
-      #define TUNE_BED (TUNE_HOTEND + ENABLED(HAS_HEATED_BED))
-      #define TUNE_FAN (TUNE_BED + ENABLED(HAS_FAN))
-      #define TUNE_ZOFFSET (TUNE_FAN + ENABLED(HAS_ZOFFSET_ITEM))
-      #define TUNE_ZUP (TUNE_ZOFFSET + ENABLED(HAS_ZOFFSET_ITEM))
-      #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
-      #define TUNE_FWRETRACT (TUNE_ZDOWN + ENABLED(FWRETRACT))
-      #define TUNE_HOSTACTIONS (TUNE_FWRETRACT + ENABLED(HAS_HOSTACTION_MENUS))
-      #define TUNE_CHANGEFIL (TUNE_HOSTACTIONS + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
-      #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
-      #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
-      #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
-      #define TUNE_CASELIGHT (TUNE_BACKLIGHT + ENABLED(CASE_LIGHT_MENU))
-      #define TUNE_LEDCONTROL (TUNE_CASELIGHT + (ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)))
-      #define TUNE_LOCKSCREEN (TUNE_LEDCONTROL + ENABLED(HAS_LOCKSCREEN))
-      #define TUNE_TOTAL TUNE_LOCKSCREEN
-
-      switch (item) {
-        case TUNE_BACK:
-          if (draw) Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
-          else Draw_Print_Screen();
-          break;
-        case TUNE_SPEED:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_Speed, GET_TEXT_F(MSG_SPEED));
-            Draw_Float(feedrate_percentage, row, false, 1);
-          }
-          else
-            Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
-          break;
-
-        #if HAS_HOTEND
-          case TUNE_FLOW:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
-              Draw_Float(planner.flow_percentage[0], row, false, 1);
-            }
-            else
-              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
-            break;
-          case TUNE_HOTEND:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
-            break;
-        #endif
-
-        #if HAS_HEATED_BED
-          case TUNE_BED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-            break;
-        #endif
-
-        #if HAS_FAN
-          case TUNE_FAN:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
-              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-            break;
-        #endif
-
-        #if HAS_ZOFFSET_ITEM
-          case TUNE_ZOFFSET:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Z-Offset"));
-              Draw_Float(temp_val.zoffsetvalue, row, false, 100);
-            }
-            else
-              Modify_Value(temp_val.zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
-            break;
-          case TUNE_ZUP:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Z-Offset Up"));
-            else if (temp_val.zoffsetvalue < MAX_Z_OFFSET) {
-              gcode.process_subcommands_now(F("M290 Z0.01"));
-              temp_val.zoffsetvalue += 0.01;
-              Draw_Float(temp_val.zoffsetvalue, row - 1, false, 100);
-            }
-            break;
-          case TUNE_ZDOWN:
-            if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Z-Offset Down"));
-            else if (temp_val.zoffsetvalue > MIN_Z_OFFSET) {
-              gcode.process_subcommands_now(F("M290 Z-0.01"));
-              temp_val.zoffsetvalue -= 0.01;
-              Draw_Float(temp_val.zoffsetvalue, row - 2, false, 100);
-            }
-            break;
-        #endif
-
-        #if ENABLED(FWRETRACT)
-          case TUNE_FWRETRACT:
-            if (draw)
-              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_AUTORETRACT), nullptr, true);
-            else {
-              temp_val.flag_tune = true;
-              last_pos_selection = selection;
-              Draw_Menu(FwRetraction);
-            }
-            break;
-        #endif
-
-        #if HAS_HOSTACTION_MENUS
-          case TUNE_HOSTACTIONS:
-            if (draw)
-              Draw_Menu_Item(row, ICON_SetHome, F("Host Actions"), nullptr, true);
-            else {
-              temp_val.flag_tune = true;
-              last_pos_selection = selection;
-              Draw_Menu(HostActions);
-            }
-            break;
-        #endif
-
-        #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-          case TUNE_CHANGEFIL:
-            if (draw) Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
-            else Popup_Handler(ConfFilChange);
-            break;
-        #endif
-
-        #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-          case TUNE_FILSENSORENABLED:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, GET_TEXT_F(MSG_RUNOUT_SENSOR));
-              Draw_Checkbox(row, runout.enabled);
-            }
-            else {
-              runout.enabled = !runout.enabled;
-              Draw_Checkbox(row, runout.enabled);
-            }
-            break;
-        #endif
-
-        case TUNE_BACKLIGHT_OFF:
-          if (draw) Draw_Menu_Item(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF));
-          else ui.set_brightness(0);
-          break;
-        case TUNE_BACKLIGHT:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness,  GET_TEXT_F(MSG_BRIGHTNESS));
-            Draw_Float(ui.brightness, row, false, 1);
-          }
-          else
-            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
-          break;
-        #if ENABLED(CASE_LIGHT_MENU)
-          case TUNE_CASELIGHT:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT));
-              Draw_Checkbox(row, caselight.on);
-            }
-            else {
-              caselight.on = !caselight.on;
-              caselight.update_enabled();
-              Draw_Checkbox(row, caselight.on);
-            }
-            break;
-        #endif
-        #if ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
-          case TUNE_LEDCONTROL:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LEDS));
-              Draw_Checkbox(row, leds.lights_on);
-            }
-            else {
-              leds.toggle();
-              Draw_Checkbox(row, leds.lights_on);
-            }
-            break;
-        #endif
-        #if HAS_LOCKSCREEN
-          case TUNE_LOCKSCREEN:
-            if (draw) Draw_Menu_Item(row, ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN));
-            else DWIN_LockScreen();
-            break;
-        #endif
-      }
-      break;
-
-    #if HAS_PREHEAT && HAS_HOTEND
-      case PreheatHotend:
-
-          #define PREHEATHOTEND_BACK 0
-          #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
-          #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
-          #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
-          #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
-          #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
-          #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
-          #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
-          #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
-
-          switch (item) {
-            case PREHEATHOTEND_BACK:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_CANCEL));
-              else {
-                thermalManager.setTargetHotend(0, 0);
-                thermalManager.set_fan_speed(0, 0);
-                Redraw_Menu(false, true, true);
-              }
-              break;
-            case PREHEATHOTEND_CONTINUE:
-              if (draw)
-                Draw_Menu_Item(row, ICON_SetEndTemp, GET_TEXT_F(MSG_BUTTON_CONTINUE));
-              else {
-                Popup_Handler(Heating);
-                thermalManager.wait_for_hotend(0);
-                switch (last_menu) {
-                  case Prepare:
-                    Popup_Handler(FilChange);
-                    sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                    gcode.process_subcommands_now(cmd);
-                    Draw_Menu(Prepare, PREPARE_CHANGEFIL);
-                    break;
-                  #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                    case ChangeFilament:
-                      switch (last_selection) {
-                        case CHANGEFIL_LOAD:
-                          Popup_Handler(FilLoad);
-                          Update_Status(GET_TEXT(MSG_FILAMENTLOAD));
-                          gcode.process_subcommands_now(F("M701"));
-                          planner.synchronize();
-                          Draw_Menu(ChangeFilament, CHANGEFIL_LOAD);
-                          break;
-                        case CHANGEFIL_UNLOAD:
-                          Popup_Handler(FilLoad, true);
-                          Update_Status(GET_TEXT(MSG_FILAMENTUNLOAD));
-                          gcode.process_subcommands_now(F("M702"));
-                          planner.synchronize();
-                          Draw_Menu(ChangeFilament, CHANGEFIL_UNLOAD);
-                          break;
-                        case CHANGEFIL_CHANGE:
-                          Popup_Handler(FilChange);
-                          Update_Status(GET_TEXT(MSG_FILAMENTCHANGE));
-                          sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                          gcode.process_subcommands_now(cmd);
-                          Draw_Menu(ChangeFilament, CHANGEFIL_CHANGE);
-                          break;
-                      }
-                      break;
-                  #endif
-                  default:
-                    Redraw_Menu(true, true, true);
-                    break;
-                }
-              }
-              break;
-
-            #define _PREHEAT_HOTEND_CASE(N) \
-              case PREHEATHOTEND_##N: \
-                if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
-                else ui.preheat_hotend_and_fan((N) - 1); \
-                break;
-
-            REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
-
-            case PREHEATHOTEND_CUSTOM:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_PREHEAT_CUSTOM));
-                Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
-              }
-              else
-                Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
-              break;
-          }
-        break;
-
-    #endif // HAS_PREHEAT && HAS_HOTEND
-  }
-}
-
-FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
-  switch (menu) {
-    case MainMenu:          return GET_TEXT_F(MSG_MAIN);
-    case Prepare:           return GET_TEXT_F(MSG_PREPARE);
-    case HomeMenu:          return GET_TEXT_F(MSG_HOMING);
-    case Move:              return GET_TEXT_F(MSG_MOVE_AXIS);
-    case ManualLevel:       return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
-    #if HAS_ZOFFSET_ITEM
-      case ZOffset:         return F("Z Offset");
-    #endif
-    #if HAS_PREHEAT
-      case Preheat:         return F("Preheat");
-    #endif
-    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return GET_TEXT_F(MSG_FILAMENTCHANGE);
-    #endif
-    #if HAS_HOSTACTION_MENUS
-      case HostActions:     return F("Host Actions");
-    #endif
-    #if HAS_CUSTOM_MENU
-      case MenuCustom:
-        #ifdef CUSTOM_MENU_CONFIG_TITLE
-          return F(CUSTOM_MENU_CONFIG_TITLE);
-        #else
-          return F("Custom Commands");
-        #endif
-    #endif
-    case Control:           return GET_TEXT_F(MSG_CONTROL);
-    case TempMenu:          return GET_TEXT_F(MSG_TEMPERATURE);
-    #if HAS_HOTEND || HAS_HEATED_BED
-      case PID:             return F("PID Menu");
-    #endif
-    #if HAS_HOTEND
-      case HotendPID:       return F("Hotend PID Settings");
-    #endif
-    #if HAS_HEATED_BED
-      case BedPID:          return F("Bed PID Settings");
-    #endif
-    #if HAS_PREHEAT
-      #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
-      REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
-    #endif
-    case Motion:            return F("Motion Settings");
-    #if ENABLED(FWRETRACT)
-      case FwRetraction:    return F("Firmware Retract");
-    #endif
-    case HomeOffsets:       return GET_TEXT_F(MSG_SET_HOME_OFFSETS);
-    case MaxSpeed:          return GET_TEXT_F(MSG_SPEED);
-    case MaxAcceleration:   return GET_TEXT_F(MSG_ACCELERATION);
-    #if HAS_CLASSIC_JERK
-      case MaxJerk:         return GET_TEXT_F(MSG_JERK);
-    #endif
-    #if HAS_JUNCTION_DEVIATION
-      case JDmenu:          return GET_TEXT_F(MSG_JUNCTION_DEVIATION);
-    #endif
-    case Steps:             return GET_TEXT_F(MSG_STEPS_PER_MM);
-    case Visual:            return F("Visual Settings");
-    #if HAS_HOSTACTION_MENUS
-      case HostSettings:    return F("Host Settings");
-      case ActionCommands:  return F("Host Actions");
-    #endif
-    case Advanced:          return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
-    #if HAS_BED_PROBE
-      case ProbeMenu:       return GET_TEXT_F(MSG_ZPROBE_SETTINGS);
-    #endif
-    case ColorSettings:     return F("UI Color Settings");
-    case Info:
-    case InfoMain:          return GET_TEXT_F(MSG_INFO_SCREEN);
-    #if HAS_MESH
-      case Leveling:        return GET_TEXT_F(MSG_BED_LEVELING);
-      case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
-      case LevelSettings:   return F("Leveling Settings");
-      case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
-      case LevelManual:     return GET_TEXT_F(MSG_UBL_FINE_TUNE_MESH);
-    #endif
-    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:         return GET_TEXT_F(MSG_UBL_LEVEL_BED);
-    #endif
-    #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return GET_TEXT_F(MSG_MESH_LEVELING);
-    #endif
-    case Tune:              return GET_TEXT_F(MSG_TUNE);
-    case PreheatHotend:     return F("Preheat Hotend");
-    #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
-      case Ledsmenu:        return F("Light Settings");
-      #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-        case CaseLightmenu: return GET_TEXT_F(MSG_CASE_LIGHT);
-      #endif
-      #if ENABLED(LED_CONTROL_MENU)
-        case LedControlmenu: return GET_TEXT_F(MSG_LED_CONTROL);
-        #if HAS_COLOR_LEDS
-          #if ENABLED(LED_COLOR_PRESETS)
-            case LedControlpresets: return GET_TEXT_F(MSG_LED_PRESETS);
-          #else
-            case LedControlcustom: return GET_TEXT_F(MSG_CUSTOM_LEDS);
-          #endif
-        #endif
-      #endif
-    #endif
-  }
-  return F("");
-}
-
-uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
-  switch (menu) {
-    case Prepare:           return PREPARE_TOTAL;
-    case HomeMenu:          return HOME_TOTAL;
-    case Move:              return MOVE_TOTAL;
-    case ManualLevel:       return MLEVEL_TOTAL;
-    #if HAS_ZOFFSET_ITEM
-      case ZOffset:         return ZOFFSET_TOTAL;
-    #endif
-    #if HAS_PREHEAT
-      case Preheat:         return PREHEAT_TOTAL;
-    #endif
-    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return CHANGEFIL_TOTAL;
-    #endif
-    #if HAS_HOSTACTION_MENUS
-      case HostActions:     return HOSTACTIONS_TOTAL;
-    #endif
-    #if HAS_CUSTOM_MENU
-      case MenuCustom:      return CUSTOM_MENU_TOTAL;
-    #endif
-    case Control:           return CONTROL_TOTAL;
-    case TempMenu:          return TEMP_TOTAL;
-    #if HAS_HOTEND || HAS_HEATED_BED
-      case PID:             return PID_TOTAL;
-    #endif
-    #if HAS_HOTEND
-      case HotendPID:       return HOTENDPID_TOTAL;
-    #endif
-    #if HAS_HEATED_BED
-      case BedPID:          return BEDPID_TOTAL;
-    #endif
-    #if HAS_PREHEAT
-      case Preheat1 ... CAT(Preheat, PREHEAT_COUNT):
-                            return PREHEAT_SUBMENU_TOTAL;
-    #endif
-    case Motion:            return MOTION_TOTAL;
-    #if ENABLED(FWRETRACT)
-      case FwRetraction:    return FWR_TOTAL;
-    #endif
-    case HomeOffsets:       return HOMEOFFSETS_TOTAL;
-    case MaxSpeed:          return SPEED_TOTAL;
-    case MaxAcceleration:   return ACCEL_TOTAL;
-    #if HAS_CLASSIC_JERK
-      case MaxJerk:         return JERK_TOTAL;
-    #endif
-    #if HAS_JUNCTION_DEVIATION
-      case JDmenu:          return JD_TOTAL;
-    #endif
-    case Steps:             return STEPS_TOTAL;
-    case Visual:            return VISUAL_TOTAL;
-    #if HAS_HOSTACTION_MENUS
-      case HostSettings:    return HOSTSETTINGS_TOTAL;
-      case ActionCommands:  return ACTIONCOMMANDS_TOTAL;
-    #endif
-    case Advanced:          return ADVANCED_TOTAL;
-    #if HAS_BED_PROBE
-      case ProbeMenu:       return PROBE_TOTAL;
-    #endif
-    case Info:              return INFO_TOTAL;
-    case InfoMain:          return INFO_TOTAL;
-    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:         return UBL_M_TOTAL;
-    #endif
-    #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return MMESH_TOTAL;
-    #endif
-    #if HAS_MESH
-      case Leveling:        return LEVELING_TOTAL;
-      case LevelView:       return LEVELING_VIEW_TOTAL;
-      case LevelSettings:   return LEVELING_SETTINGS_TOTAL;
-      case MeshViewer:      return MESHVIEW_TOTAL;
-      case LevelManual:     return LEVELING_M_TOTAL;
-    #endif
-    case Tune:              return TUNE_TOTAL;
-
-    #if HAS_PREHEAT && HAS_HOTEND
-      case PreheatHotend:   return PREHEATHOTEND_TOTAL;
-    #endif
-
-    case ColorSettings:     return COLORSETTINGS_TOTAL;
-    #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
-      case Ledsmenu:         return LEDS_TOTAL;
-      #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-        case CaseLightmenu: return CASE_LIGHT_TOTAL;
-      #endif
-      #if ENABLED(LED_CONTROL_MENU)
-        case LedControlmenu: return LEDCONTROL_TOTAL;
-        #if HAS_COLOR_LEDS
-          #if ENABLED(LED_COLOR_PRESETS)
-            case LedControlpresets: return LEDCONTROL_PRESETS_TOTAL;
-          #else
-            case LedControlcustom: return LEDCONTROL_CUSTOM_TOTAL;
-          #endif
-        #endif
-      #endif
-    #endif
-  }
-  return 0;
-}
-
-/* Popup Config */
-
-void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
-  popup = last_popup = popupid;
-  switch (popupid) {
-    case Pause:         Draw_Popup(GET_TEXT_F(MSG_PAUSE_PRINT), F(""), F(""), Popup); break;
-    case Stop:          Draw_Popup(GET_TEXT_F(MSG_STOP_PRINT), F(""), F(""), Popup); break;
-    case Resume:        Draw_Popup(GET_TEXT_F(MSG_RESUME_PRINT), F("Looks Like the last"), F("print was interrupted."), Popup); break;
-    case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
-    case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
-    case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
-    case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
-    case ETemp:         Draw_Popup(GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT), F(""), Popup); break;
-    case ManualProbing: Draw_Popup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
-    case Level:         Draw_Popup(F("Auto Bed Leveling"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_AutoLeveling); break;
-    case Home:          Draw_Popup(option ? GET_TEXT_F(MSG_PAUSE_PRINT_PARKING) : GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
-    case MoveWait:      Draw_Popup(GET_TEXT_F(MSG_MOVING), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
-    case Heating:       Draw_Popup(GET_TEXT_F(MSG_HEATING), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
-    case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
-    case FilChange:     Draw_Popup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
-    case TempWarn:      Draw_Popup(option ? GET_TEXT_F(MSG_HOTEND_TOO_COLD) : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
-    case Runout:        Draw_Popup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
-    #if !HAS_PIDPLOT
-      case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), GET_TEXT_F(MSG_PLEASE_WAIT), Wait, ICON_BLTouch); break;
-    #endif
-    case Resuming:      Draw_Popup(F("Resuming Print"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
-    #if HAS_CUSTOM_MENU
-      case Custom:        Draw_Popup(F("Running Custom GCode"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
-    #endif
-    case PrintConfirm: Draw_Popup(option ? F("") : F("Print file?"), F(""), F(""), Popup); break;
-    default: break;
-  }
-}
-
-void CrealityDWINClass::Confirm_Handler(PopupID popupid, bool option/*=false*/) {
-  popup = popupid;
-  switch (popupid) {
-    case FilInsert:   Draw_Popup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
-    case HeaterTime:  Draw_Popup(GET_TEXT_F(MSG_HEATER_TIMEOUT), GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), F(""), Confirm); break;
-    case UserInput:   Draw_Popup(option ? GET_TEXT_F(MSG_STOPPED) : F("Waiting for Input"), GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), F(""), Confirm); break;
-    case Level:       Draw_Popup(F("Bed Leveling"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Cancel, ICON_AutoLeveling); break;
-    case LevelError:  Draw_Popup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
-    case InvalidMesh: Draw_Popup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
-    default: break;
-  }
-}
-
-/* Navigation and Control */
-
-void CrealityDWINClass::Main_Menu_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {
-    selection++; // Select Down
-    Main_Menu_Icons();
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    selection--; // Select Up
-    Main_Menu_Icons();
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER)
-    switch (selection) {
-      case PAGE_PRINT: card.mount(); Draw_SD_List(); break;
-      case PAGE_PREPARE: Draw_Menu(Prepare); break;
-      case PAGE_CONTROL: Draw_Menu(Control); break;
-      case PAGE_INFO_LEVELING: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
-    }
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::Menu_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    selection++; // Select Down
-    if (selection > scrollpos+MROWS) {
-      scrollpos++;
-      DWIN_Frame_AreaMove(1, 2, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
-      Menu_Item_Handler(active_menu, selection);
-    }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    selection--; // Select Up
-    if (selection < scrollpos) {
-      scrollpos--;
-      DWIN_Frame_AreaMove(1, 3, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
-      Menu_Item_Handler(active_menu, selection);
-    }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER)
-    Menu_Item_Handler(active_menu, selection, false);
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::Value_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  float difvalue = 0;
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW) {
-    tempvalue += EncoderRate.encoderMoveValue;
-    difvalue = EncoderRate.encoderMoveValue;
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW) {
-    tempvalue -= EncoderRate.encoderMoveValue;
-    difvalue = - EncoderRate.encoderMoveValue;
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    process = Menu;
-    EncoderRate.enabled = false;
-    Draw_Float(tempvalue / valueunit, selection - scrollpos, false, valueunit);
-    DWIN_UpdateLCD();
-    if (active_menu == ZOffset && temp_val.zoffsetmode != 0) {
-      planner.synchronize();
-      if (temp_val.zoffsetmode == 1) {
-        current_position.z += (tempvalue / valueunit - temp_val.zoffsetvalue);
-        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
-      }
-      current_position.z = 0;
-      sync_plan_position();
-    }
-    else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
-      sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - temp_val.zoffsetvalue), 1, 3, str_1));
-      gcode.process_subcommands_now(cmd);
-    }
-    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
-      tempvalue = scalePID_i(tempvalue);
-    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
-      tempvalue = scalePID_d(tempvalue);
-    switch (valuetype) {
-      case 0: *(float*)valuepointer = tempvalue / valueunit; break;
-      case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
-      case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
-      case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
-      case 4: *(uint32_t*)valuepointer = tempvalue / valueunit; break;
-      case 5: *(int8_t*)valuepointer = tempvalue / valueunit; break;
-    }
-    switch (active_menu) {
-      case Move:
-        planner.synchronize();
-        planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
-        break;
-      #if HAS_MESH
-        #if ENABLED(PROBE_MANUALLY)
-          case ManualMesh:
-            planner.synchronize();
-            planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
-            planner.synchronize();
-            break;
-        #endif
-        #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-          case UBLMesh: mesh_conf.manual_mesh_move(true); break;
-        #endif
-        case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
-      #endif
-    }
-    if (valuepointer == &planner.flow_percentage[0])
-      planner.refresh_e_factor(0);
-    #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-      if (valuepointer == &caselight.brightness)
-        caselight.update_brightness();
-    #endif
-    #if HAS_COLOR_LEDS
-      if ((valuepointer == &leds.color.r) || (valuepointer == &leds.color.g) || (valuepointer == &leds.color.b))
-        ApplyLEDColor();
-        #if HAS_WHITE_LED
-          if (valuepointer == &leds.color.w) ApplyLEDColor();
-        #endif
-    #endif
-
-    if (funcpointer) funcpointer();
-    return;
-  }
-  NOLESS(tempvalue, (valuemin * valueunit));
-  NOMORE(tempvalue, (valuemax * valueunit));
-  Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
-  DWIN_UpdateLCD();
-
-  if (valuepointer == &ui.brightness) {
-    *(uint8_t*)valuepointer = tempvalue / valueunit;
-    ui.refresh_brightness();
-  }
-
-  switch (active_menu) {
-    case Move:
-      if (temp_val.livemove) {
-        *(float*)valuepointer = tempvalue / valueunit;
-        planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
-      }
-      break;
-    case ZOffset:
-      if (temp_val.zoffsetmode == 2) {
-        planner.synchronize();
-        sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((difvalue / valueunit), 1, 3, str_1));
-        gcode.process_subcommands_now(cmd);
-        planner.synchronize();
-      }
-      break;
-    case Tune:
-      if (selection == TUNE_ZOFFSET) {
-        planner.synchronize();
-        sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((difvalue / valueunit), 1, 3, str_1));
-        gcode.process_subcommands_now(cmd);
-        planner.synchronize();
-      }
-      break;
-    #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-      case CaseLightmenu:
-        *(uint8_t*)valuepointer = tempvalue / valueunit;
-        caselight.update_brightness();
-        break;
-    #endif
-    #if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
-      case LedControlmenu:
-        *(uint8_t*)valuepointer = tempvalue / valueunit;
-        leds.update();
-        break;
-    #endif
-    default : break;
-  }
-}
-
-void CrealityDWINClass::Option_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW)
-    tempvalue += EncoderRate.encoderMoveValue;
-  else if (encoder_diffState == ENCODER_DIFF_CCW)
-    tempvalue -= EncoderRate.encoderMoveValue;
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    process = Menu;
-    EncoderRate.enabled = false;
-    if (valuepointer == &color_names) {
-      switch (selection) {
-        case COLORSETTINGS_CURSOR: eeprom_settings.cursor_color = tempvalue; break;
-        case COLORSETTINGS_SPLIT_LINE: eeprom_settings.menu_split_line = tempvalue; break;
-        case COLORSETTINGS_MENU_TOP_BG: eeprom_settings.menu_top_bg = tempvalue; break;
-        case COLORSETTINGS_MENU_TOP_TXT: eeprom_settings.menu_top_txt = tempvalue; break;
-        case COLORSETTINGS_HIGHLIGHT_BORDER: eeprom_settings.highlight_box = tempvalue; break;
-        case COLORSETTINGS_PROGRESS_PERCENT: eeprom_settings.progress_percent = tempvalue; break;
-        case COLORSETTINGS_PROGRESS_TIME: eeprom_settings.progress_time = tempvalue; break;
-        case COLORSETTINGS_PROGRESS_STATUS_BAR: eeprom_settings.status_bar_text = tempvalue; break;
-        case COLORSETTINGS_PROGRESS_STATUS_AREA: eeprom_settings.status_area_text = tempvalue; break;
-        case COLORSETTINGS_PROGRESS_COORDINATES: eeprom_settings.coordinates_text = tempvalue; break;
-        case COLORSETTINGS_PROGRESS_COORDINATES_LINE: eeprom_settings.coordinates_split_line = tempvalue; break;
-      }
-      Redraw_Screen();
-    }
-    else if (valuepointer == &preheat_modes)
-      temp_val.preheatmode = tempvalue;
-    #if ENABLED(PREHEAT_BEFORE_LEVELING)
-      else if (valuepointer == &preheat_levmodes) {
-        temp_val.LevelingTempmode = tempvalue;
-        eeprom_settings.ena_hotend_levtemp = false;
-        eeprom_settings.ena_bed_levtemp = false;
-        if (temp_val.LevelingTempmode == 0 || temp_val.LevelingTempmode == 1) eeprom_settings.ena_hotend_levtemp = true;
-        if (temp_val.LevelingTempmode == 0 || temp_val.LevelingTempmode == 2) eeprom_settings.ena_bed_levtemp = true;
-      }
-    #endif
-    else if (valuepointer == &zoffset_modes) {
-      temp_val.zoffsetmode = tempvalue;
-      if (temp_val.zoffsetmode == 1 || temp_val.zoffsetmode == 2) {
-        if (axes_should_home()) {
-          Popup_Handler(Home);
-          gcode.home_all_axes(true);
-        }
-        Popup_Handler(MoveWait);
-        #if ENABLED(Z_SAFE_HOMING)
-          planner.synchronize();
-          sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-          gcode.process_subcommands_now(cmd);
-        #else
-          sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2));
-          gcode.process_subcommands_now(cmd);
-        #endif
-        gcode.process_subcommands_now(F("G0 F300 Z0"));
-        planner.synchronize();
-        Redraw_Menu();
-      }
-    }
-
-    Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
-    DWIN_UpdateLCD();
-    return;
-  }
-  NOLESS(tempvalue, valuemin);
-  NOMORE(tempvalue, valuemax);
-  Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::File_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  static uint8_t filescrl = 0;
-  if (encoder_diffState == ENCODER_DIFF_NO) {
-    if (selection > 0) {
-      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
-      char * const filename = card.longest_filename();
-      size_t len = strlen(filename);
-      int8_t pos = len;
-      if (!card.flag.filenameIsDir)
-        while (pos && filename[pos] != '.') pos--;
-      if (pos > MENU_CHAR_LIMIT) {
-        static millis_t time = 0;
-        if (PENDING(millis(), time)) return;
-        time = millis() + 200;
-        pos -= filescrl;
-        len = _MIN(pos, MENU_CHAR_LIMIT);
-        char name[len + 1];
-        if (pos >= 0) {
-          LOOP_L_N(i, len) name[i] = filename[i + filescrl];
-        }
-        else {
-          LOOP_L_N(i, MENU_CHAR_LIMIT + pos) name[i] = ' ';
-          LOOP_S_L_N(i, MENU_CHAR_LIMIT + pos, MENU_CHAR_LIMIT) name[i] = filename[i - (MENU_CHAR_LIMIT + pos)];
-        }
-        name[len] = '\0';
-        DWIN_Draw_Rectangle(1, Def_Background_Color, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
-        Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
-        if (-pos >= MENU_CHAR_LIMIT) filescrl = 0;
-        filescrl++;
-        DWIN_UpdateLCD();
-      }
-    }
-    return;
-  }
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_Files()) {
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    if (selection > 0) {
-      DWIN_Draw_Rectangle(1, Def_Background_Color, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
-      Draw_SD_Item(selection, selection - scrollpos);
-    }
-    filescrl = 0;
-    selection++; // Select Down
-    if (selection > scrollpos + MROWS) {
-      scrollpos++;
-      DWIN_Frame_AreaMove(1, 2, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
-      Draw_SD_Item(selection, selection - scrollpos);
-    }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    DWIN_Draw_Rectangle(1, Def_Background_Color, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
-    Draw_SD_Item(selection, selection - scrollpos);
-    filescrl = 0;
-    selection--; // Select Up
-    if (selection < scrollpos) {
-      scrollpos--;
-      DWIN_Frame_AreaMove(1, 3, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
-      Draw_SD_Item(selection, selection - scrollpos);
-    }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    if (selection == 0) {
-      if (card.flag.workDirIsRoot) {
-        process = Main;
-        Draw_Main_Menu();
-      }
-      else {
-        card.cdup();
-        Draw_SD_List();
-      }
-    }
-    else {
-      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
-      if (card.flag.filenameIsDir) {
-        card.cd(card.filename);
-        Draw_SD_List();
-      }
-      else {
-        #if HAS_GCODE_PREVIEW
-          Preview_DrawFromSD();
-        #else
-          card.openAndPrintFile(card.filename);
-        #endif
-      }
-    }
-  }
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::Print_Screen_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
-    selection++; // Select Down
-    Print_Screen_Icons();
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    selection--; // Select Up
-    Print_Screen_Icons();
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    switch (selection) {
-      case PRINT_SETUP:
-        Draw_Menu(Tune);
-        Update_Status_Bar(true);
-        break;
-      case PRINT_PAUSE_RESUME:
-        if (temp_val.paused) {
-          if (temp_val.sdprint) {
-            wait_for_user = false;
-            #if ENABLED(PARK_HEAD_ON_PAUSE)
-              card.startOrResumeFilePrinting();
-              TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-            #else
-              char cmd[20];
-              #if HAS_HEATED_BED
-                sprintf_P(cmd, PSTR("M140 S%i"), temp_val.pausebed);
-                gcode.process_subcommands_now(cmd);
-              #endif
-              #if HAS_EXTRUDERS
-                sprintf_P(cmd, PSTR("M109 S%i"), temp_val.pausetemp);
-                gcode.process_subcommands_now(cmd);
-              #endif
-              TERN_(HAS_FAN, thermalManager.fan_speed[0] = temp_val.pausefan);
-              planner.synchronize();
-              TERN_(SDSUPPORT, queue.inject(F("M24")));
-            #endif
-          }
-          else {
-            TERN_(HOST_ACTION_COMMANDS, hostui.resume());
-          }
-          Draw_Print_Screen();
-        }
-        else
-          Popup_Handler(Pause);
-        break;
-      case PRINT_STOP: Popup_Handler(Stop); break;
-    }
-  }
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::Popup_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
-    selection++;
-    Popup_Select();
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    selection--;
-    Popup_Select();
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    switch (popup) {
-      case Pause:
-        if (selection == 0) {
-          if (temp_val.sdprint) {
-            #if ENABLED(POWER_LOSS_RECOVERY)
-              if (recovery.enabled) recovery.save(true);
-            #endif
-            #if ENABLED(PARK_HEAD_ON_PAUSE)
-              Popup_Handler(Home, true);
-              #if ENABLED(SDSUPPORT)
-                if (IS_SD_PRINTING()) card.pauseSDPrint();
-              #endif
-              planner.synchronize();
-              queue.inject(F("M125"));
-              planner.synchronize();
-            #else
-              queue.inject(F("M25"));
-              TERN_(HAS_HOTEND, temp_val.pausetemp = thermalManager.temp_hotend[0].target);
-              TERN_(HAS_HEATED_BED, temp_val.pausebed = thermalManager.temp_bed.target);
-              TERN_(HAS_FAN, temp_val.pausefan = thermalManager.fan_speed[0]);
-              thermalManager.cooldown();
-            #endif
-          }
-          else {
-            TERN_(HOST_ACTION_COMMANDS, hostui.pause());
-          }
-        }
-        Draw_Print_Screen();
-        break;
-      case Stop:
-        if (selection == 0) {
-          if (temp_val.sdprint) {
-            ui.abort_print();
-            thermalManager.cooldown();
-          }
-          else {
-            TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
-          }
-        }
-        else
-          Draw_Print_Screen();
-        break;
-      case Resume:
-        if (selection == 0)
-          queue.inject(F("M1000"));
-        else {
-          queue.inject(F("M1000 C"));
-          Draw_Main_Menu();
-        }
-        break;
-
-      #if HAS_HOTEND
-        case ETemp:
-          if (selection == 0) {
-            thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
-            thermalManager.set_fan_speed(0, MAX_FAN_SPEED);
-            Draw_Menu(PreheatHotend);
-          }
-          else
-            Redraw_Menu(true, true, false);
-          break;
-      #endif
-
-      #if HAS_BED_PROBE
-        case ManualProbing:
-          if (selection == 0) {
-            char buf[80];
-            const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - temp_val.corner_avg;
-            sprintf_P(buf, dif > 0 ? PSTR("Corner is %smm high") : PSTR("Corner is %smm low"), dtostrf(abs(dif), 1, 3, str_1));
-            Update_Status(buf);
-          }
-          else {
-            Redraw_Menu(true, true, false);
-            Update_Status("");
-          }
-          break;
-      #endif
-
-      #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        case ConfFilChange:
-          if (selection == 0) {
-            if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
-              Popup_Handler(ETemp);
-            else {
-              if (thermalManager.temp_hotend[0].is_below_target(-2)) {
-                Popup_Handler(Heating);
-                thermalManager.wait_for_hotend(0);
-              }
-              Popup_Handler(FilChange);
-              sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-              gcode.process_subcommands_now(cmd);
-            }
-          }
-          else
-            Redraw_Menu(true, true, false);
-          break;
-        case PurgeMore:
-          if (selection == 0) {
-            pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
-            Popup_Handler(FilChange);
-          }
-          else {
-            pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
-            if (temp_val.printing) Popup_Handler(Resuming);
-            else Redraw_Menu(true, true, (active_menu==PreheatHotend));
-          }
-          break;
-      #endif // ADVANCED_PAUSE_FEATURE
-
-      case PrintConfirm:
-        if (selection==0) {
-          card.openAndPrintFile(card.filename);}
-        else{
-          Redraw_Menu(true, true, true);
-          gcode.process_subcommands_now(F("M117"));}
-        break;
-
-      #if HAS_MESH
-        case SaveLevel:
-          if (selection == 0) {
-            #if ENABLED(AUTO_BED_LEVELING_UBL)
-              gcode.process_subcommands_now(F("G29 S"));
-              planner.synchronize();
-              AudioFeedback(true);
-            #else
-              AudioFeedback(settings.save());
-            #endif
-          }
-          Draw_Menu(Leveling, LEVELING_GET_MESH);
-          break;
-      #endif
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        case MeshSlot:
-          if (selection == 0) bedlevel.storage_slot = 0;
-          Redraw_Menu(true, true);
-          break;
-      #endif
-      default: break;
-    }
-  }
-  DWIN_UpdateLCD();
-}
-
-void CrealityDWINClass::Confirm_Control() {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    switch (popup) {
-      case Complete:
-        Draw_Main_Menu();
-        break;
-      case FilInsert:
-        Popup_Handler(FilChange);
-        wait_for_user = false;
-        break;
-      case HeaterTime:
-        Popup_Handler(Heating);
-        Update_Status(GET_TEXT_F(MSG_HEATING));
-        wait_for_user = false;
-        break;
-      #if HAS_ESDIAG
-        case ESDiagPopup:
-          wait_for_user = false;
-          Redraw_Menu(true, true, false);
-          break;
-      #endif
-      default:
-        Redraw_Menu(true, true, false);
-        wait_for_user = false;
-        break;
-    }
-  }
-  DWIN_UpdateLCD();
-}
-
-#if HAS_HOSTACTION_MENUS
-
-  void CrealityDWINClass::Keyboard_Control() {
-    const uint8_t keyboard_size = 34;
-    static uint8_t key_selection = 0, cursor = 0;
-    static char string[31];
-    static bool uppercase = false, locked = false;
-    if (reset_keyboard) {
-      if (strcmp(stringpointer, "-") == 0) stringpointer[0] = '\0';
-      key_selection = 0, cursor = strlen(stringpointer);
-      uppercase = false, locked = false;
-      reset_keyboard = false;
-      strcpy(string, stringpointer);
-    }
-    EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-    if (encoder_diffState == ENCODER_DIFF_NO) return;
-    if (encoder_diffState == ENCODER_DIFF_CW && key_selection < keyboard_size) {
-      Draw_Keys(key_selection, false, uppercase, locked);
-      key_selection++;
-      Draw_Keys(key_selection, true, uppercase, locked);
-    }
-    else if (encoder_diffState == ENCODER_DIFF_CCW && key_selection > 0) {
-      Draw_Keys(key_selection, false, uppercase, locked);
-      key_selection--;
-      Draw_Keys(key_selection, true, uppercase, locked);
-    }
-    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-      if (key_selection < 28) {
-        if (key_selection == 19) {
-          if (!numeric_keyboard) {
-            if (locked) {
-              uppercase = false, locked = false;
-              Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
-            } else if (uppercase) {
-              locked = true;
-              Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
-            }
-            else {
-              uppercase = true;
-              Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
-            }
-          }
-        }
-        else if (key_selection == 27) {
-          cursor--;
-          string[cursor] = '\0';
-        }
-        else {
-          uint8_t index = key_selection;
-          if (index > 19) index--;
-          if (index > 27) index--;
-          const char *keys;
-          if (numeric_keyboard) keys = "1234567890&<>() {}[]*\"\':;!?";
-          else keys = (uppercase) ? "QWERTYUIOPASDFGHJKLZXCVBNM" : "qwertyuiopasdfghjklzxcvbnm";
-          if (!(keyboard_restrict && numeric_keyboard && index > 9)) {
-            string[cursor] = keys[index];
-            cursor++;
-            string[cursor] = '\0';
-          }
-          if (!locked && uppercase) {
-            uppercase = false;
-            Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
-          }
-        }
-      }
-      else {
-        switch (key_selection) {
-          case 28:
-            if (!numeric_keyboard) uppercase = false, locked = false;
-            Draw_Keyboard(keyboard_restrict, !numeric_keyboard, key_selection, uppercase, locked);
-            break;
-          case 29:
-            string[cursor] = '-';
-            cursor++;
-            string[cursor] = '\0';
-            break;
-          case 30:
-            string[cursor] = '_';
-            cursor++;
-            string[cursor] = '\0';
-            break;
-          case 31:
-            if (!keyboard_restrict) {
-              string[cursor] = ' ';
-              cursor++;
-              string[cursor] = '\0';
-            }
-            break;
-          case 32:
-            if (!keyboard_restrict) {
-              string[cursor] = '.';
-              cursor++;
-              string[cursor] = '\0';
-            }
-            break;
-          case 33:
-            if (!keyboard_restrict) {
-              string[cursor] = '/';
-              cursor++;
-              string[cursor] = '\0';
-            }
-            break;
-          case 34:
-            if (string[0] == '\0') strcpy(string, "-");
-            strcpy(stringpointer, string);
-            process = Menu;
-            DWIN_Draw_Rectangle(1, Def_Background_Color, 0, KEY_Y_START, DWIN_WIDTH-2, DWIN_HEIGHT-2);
-            Draw_Status_Area(true);
-            Update_Status_Bar(true);
-            break;
-        }
-      }
-      if (strlen(string) > maxstringlen) string[maxstringlen] = '\0', cursor = maxstringlen;
-      Draw_String(string, selection, (process==Keyboard), (maxstringlen > 10));
-    }
-    DWIN_UpdateLCD();
-  }
-
-#endif // HAS_HOSTACTION_MENUS
-
-/* In-Menu Value Modification */
-
-void CrealityDWINClass::Setup_Value(float value, float min, float max, float unit, uint8_t type) {
-  if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
-    tempvalue = unscalePID_i(value) * unit;
-  else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
-    tempvalue = unscalePID_d(value) * unit;
-  else
-    tempvalue = value * unit;
-  valuemin = min;
-  valuemax = max;
-  valueunit = unit;
-  valuetype = type;
-  process = Value;
-  EncoderRate.enabled = true;
-  Draw_Float(tempvalue / unit, selection - scrollpos, true, valueunit);
-}
-
-void CrealityDWINClass::Modify_Value(float &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
-  valuepointer = &value;
-  funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 0);
-}
-void CrealityDWINClass::Modify_Value(uint8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
-  valuepointer = &value;
-  funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 1);
-}
-void CrealityDWINClass::Modify_Value(uint16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
-  valuepointer = &value;
-  funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 2);
-}
-void CrealityDWINClass::Modify_Value(int16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
-  valuepointer = &value;
-  funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 3);
-}
-void CrealityDWINClass::Modify_Value(uint32_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
-  valuepointer = &value;
-  funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 4);
-}
-void CrealityDWINClass::Modify_Value(int8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
-  valuepointer = &value;
-  funcpointer = f;
-  Setup_Value((float)value, min, max, unit, 5);
-}
-
-void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * options, uint8_t max) {
-  tempvalue = value;
-  valuepointer = const_cast<const char * *>(options);
-  valuemin = 0;
-  valuemax = max;
-  process = Option;
-  EncoderRate.enabled = true;
-  Draw_Option(value, options, selection - scrollpos, true);
-}
-
-#if HAS_HOSTACTION_MENUS
-  void CrealityDWINClass::Modify_String(char * string, uint8_t maxlength, bool restrict) {
-    stringpointer = string;
-    maxstringlen = maxlength;
-    reset_keyboard = true;
-    Draw_Keyboard(restrict, false);
-    Draw_String(string, selection, true, (maxstringlen > 10));
-  }
-#endif
-
-/* Main Functions */
-
-void CrealityDWINClass::Update_Print_Filename(const char * const text) {
-  LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i];
-  filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
-  Draw_Print_Filename(true);
-}
-
-void CrealityDWINClass::Update_Status(const char * const text) {
-  LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
-  statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
-}
-
-void CrealityDWINClass::Update_Status(FSTR_P text) {
-  Update_Status(FTOP(text));
-}
-
-void CrealityDWINClass::Start_Print(bool sd) {
-  temp_val.sdprint = sd;
-  if (!temp_val.printing) {
-    temp_val.printing = true;
-    statusmsg[0] = '\0';
-    if (sd) {
-      #if ENABLED(POWER_LOSS_RECOVERY)
-        if (recovery.valid()) {
-          SdFile *diveDir = nullptr;
-          const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
-          card.selectFileByName(fname);
-        }
-      #endif
-      strcpy(filename, card.longest_filename());
-    }
-    TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
-    TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
-    Draw_Print_Screen();
-  }
-}
-
-void CrealityDWINClass::Stop_Print() {
-  temp_val.printing = false;
-  temp_val.sdprint = false;
-  thermalManager.cooldown();
-  TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(100 * (PROGRESS_SCALE)));
-  TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
-  Draw_PrintDone_confirm();
-  filename[0] = '\0';
-}
-
-void CrealityDWINClass::Update() {
-  State_Update();
-  Screen_Update();
-  switch (process) {
-    case Main:    Main_Menu_Control();    break;
-    case Menu:    Menu_Control();         break;
-    case Value:   Value_Control();        break;
-    case Option:  Option_Control();       break;
-    case File:    File_Control();         break;
-    case Print:   Print_Screen_Control(); break;
-    case Popup:   Popup_Control();        break;
-    case Confirm: Confirm_Control();      break;
-    #if HAS_HOSTACTION_MENUS
-      case Keyboard: Keyboard_Control();  break;
-    #endif
-    case Cancel:  Confirm_Control();      break;
-    #if HAS_LOCKSCREEN
-      case Locked: HMI_LockScreen();      break;
-    #endif
-  }
-}
-
-void MarlinUI::update() { CrealityDWIN.Update(); }
-
-#if HAS_LCD_BRIGHTNESS
-  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
-#endif
-
-void CrealityDWINClass::State_Update() {
-  if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != temp_val.printing) {
-    if (!temp_val.printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
-    else Stop_Print();
-  }
-  if (print_job_timer.isPaused() != temp_val.paused) {
-    temp_val.paused = print_job_timer.isPaused();
-    if (process == Print) Print_Screen_Icons();
-    if (process == Wait && !temp_val.paused) Redraw_Menu(true, true);
-  }
-  if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
-    Confirm_Handler(UserInput);
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    if (process == Popup && popup == PurgeMore) {
-      if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
-        Popup_Handler(FilChange);
-      else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
-        if (temp_val.printing) Popup_Handler(Resuming);
-        else Redraw_Menu(true, true, (active_menu==PreheatHotend));
-      }
-    }
-  #endif
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    static bool ranout = false;
-    if (runout.filament_ran_out != ranout) {
-      ranout = runout.filament_ran_out;
-      if (ranout) Popup_Handler(Runout);
-    }
-  #endif
-}
-
-void CrealityDWINClass::Screen_Update() {
-  const millis_t ms = millis();
-  static millis_t scrltime = 0;
-  if (ELAPSED(ms, scrltime)) {
-    scrltime = ms + 200;
-    if (process != Keyboard) Update_Status_Bar();
-    if (process == Print) Draw_Print_Filename();
-  }
-
-  static millis_t statustime = 0;
-  if (ELAPSED(ms, statustime) && process != Keyboard) {
-    statustime = ms + 500;
-    Draw_Status_Area();
-    #if HAS_ESDIAG
-      if (process == Confirm && popup == ESDiagPopup) ESDiag.Update();
-    #endif
-    #if HAS_PIDPLOT
-      if (process == Wait && (popup == PIDWaitH || popup == PIDWaitB)) Plot.Update((popup == PIDWaitH) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
-    #endif
-  }
-
-  static millis_t printtime = 0;
-  if (ELAPSED(ms, printtime)) {
-    printtime = ms + 1000;
-    if (process == Print) {
-      Draw_Print_ProgressBar();
-      Draw_Print_ProgressElapsed();
-      TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
-    }
-  }
-
-  static bool mounted = card.isMounted();
-  if (mounted != card.isMounted()) {
-    mounted = card.isMounted();
-    if (process == File)
-      Draw_SD_List();
-  }
-
-  #if HAS_HOTEND
-    static int16_t hotendtarget = -1;
-  #endif
-  #if HAS_HEATED_BED
-    static int16_t bedtarget = -1;
-  #endif
-  #if HAS_FAN
-    static int16_t fanspeed = -1;
-  #endif
-
-  #if HAS_ZOFFSET_ITEM
-    static float lastzoffset = temp_val.zoffsetvalue;
-    if (temp_val.zoffsetvalue != lastzoffset) {
-      lastzoffset = temp_val.zoffsetvalue;
-      #if HAS_BED_PROBE
-        probe.offset.z = temp_val.zoffsetvalue;
-      #else
-        set_home_offset(Z_AXIS, -temp_val.zoffsetvalue);
-      #endif
-    }
-
-    #if HAS_BED_PROBE
-      if (probe.offset.z != lastzoffset)
-        temp_val.zoffsetvalue = lastzoffset = probe.offset.z;
-    #else
-      if (-home_offset.z != lastzoffset)
-        temp_val.zoffsetvalue = lastzoffset = -home_offset.z;
-    #endif
-  #endif // HAS_ZOFFSET_ITEM
-
-  if (process == Menu || process == Value) {
-    switch (active_menu) {
-      case TempMenu:
-        #if HAS_HOTEND
-          if (thermalManager.temp_hotend[0].target != hotendtarget) {
-            hotendtarget = thermalManager.temp_hotend[0].target;
-            if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
-            }
-          }
-        #endif
-        #if HAS_HEATED_BED
-          if (thermalManager.temp_bed.target != bedtarget) {
-            bedtarget = thermalManager.temp_bed.target;
-            if (scrollpos <= TEMP_BED && TEMP_BED <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
-            }
-          }
-        #endif
-        #if HAS_FAN
-          if (thermalManager.fan_speed[0] != fanspeed) {
-            fanspeed = thermalManager.fan_speed[0];
-            if (scrollpos <= TEMP_FAN && TEMP_FAN <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
-            }
-          }
-        #endif
-        break;
-      case Tune:
-        #if HAS_HOTEND
-          if (thermalManager.temp_hotend[0].target != hotendtarget) {
-            hotendtarget = thermalManager.temp_hotend[0].target;
-            if (scrollpos <= TUNE_HOTEND && TUNE_HOTEND <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
-            }
-          }
-        #endif
-        #if HAS_HEATED_BED
-          if (thermalManager.temp_bed.target != bedtarget) {
-            bedtarget = thermalManager.temp_bed.target;
-            if (scrollpos <= TUNE_BED && TUNE_BED <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
-            }
-          }
-        #endif
-        #if HAS_FAN
-          if (thermalManager.fan_speed[0] != fanspeed) {
-            fanspeed = thermalManager.fan_speed[0];
-            if (scrollpos <= TUNE_FAN && TUNE_FAN <= scrollpos + MROWS) {
-              if (process != Value || selection != TEMP_HOTEND - scrollpos)
-                Draw_Float(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
-            }
-          }
-        #endif
-        break;
-    }
-  }
-}
-
-void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
-  if (ui.sound_on)
-    DONE_BUZZ(success);
-  else
-    Update_Status(success ? "Success" : "Failed");
-}
-
-void CrealityDWINClass::Save_Settings(char *buff) {
-  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("Save_Settings"));
-  TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
-  eeprom_settings.corner_pos = temp_val.corner_pos * 10;
-  #if HAS_HOSTACTION_MENUS
-    eeprom_settings.host_action_label_1 = Encode_String(action1);
-    eeprom_settings.host_action_label_2 = Encode_String(action2);
-    eeprom_settings.host_action_label_3 = Encode_String(action3);
-  #endif
-  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("eeprom_settings size: ", sizeof(eeprom_settings_t)));
-  memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
-}
-
-void CrealityDWINClass::Load_Settings(const char *buff) {
-  memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
-  TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
-  if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
-  temp_val.corner_pos = eeprom_settings.corner_pos / 10.0f;
-  #if ENABLED(BAUD_RATE_GCODE)
-    if (eeprom_settings.Baud115k) queue.inject(F("M575 P0 B115200"));
-  #endif
-  #if ENABLED(FWRETRACT)
-    temp_val.auto_fw_retract = fwretract.autoretract_enabled;
-  #endif
-  #if ENABLED(PREHEAT_BEFORE_LEVELING)
-    temp_val.LevelingTempmode = 2 * !eeprom_settings.ena_hotend_levtemp + !eeprom_settings.ena_bed_levtemp;
-  #endif
-  #if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
-    leds.set_color(
-    (temp_val.LED_Color >> 16) & 0xFF,
-    (temp_val.LED_Color >>  8) & 0xFF,
-    (temp_val.LED_Color >>  0) & 0xFF
-    OPTARG(HAS_WHITE_LED, (temp_val.LED_Color >> 24) & 0xFF)
-    );
-  #endif
-  #if HAS_HOSTACTION_MENUS
-    Decode_String(eeprom_settings.host_action_label_1, action1);
-    Decode_String(eeprom_settings.host_action_label_2, action2);
-    Decode_String(eeprom_settings.host_action_label_3, action3);
-  #endif
-  Redraw_Screen();
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    static bool init = true;
-    if (init) {
-      init = false;
-      queue.inject(F("M1000 S"));
-    }
-  #endif
-}
-
-void CrealityDWINClass::Reset_Settings() {
-  eeprom_settings.time_format_textual = false;
-  TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
-  eeprom_settings.corner_pos = 325;
-  eeprom_settings.cursor_color = 0;
-  eeprom_settings.menu_split_line = 0;
-  eeprom_settings.menu_top_bg = 0;
-  eeprom_settings.menu_top_txt = 0;
-  eeprom_settings.highlight_box = 0;
-  eeprom_settings.progress_percent = 0;
-  eeprom_settings.progress_time = 0;
-  eeprom_settings.status_bar_text = 0;
-  eeprom_settings.status_area_text = 0;
-  eeprom_settings.coordinates_text = 0;
-  eeprom_settings.coordinates_split_line = 0;
-  TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
-  temp_val.corner_pos = eeprom_settings.corner_pos / 10.0f;
-  TERN_(SOUND_MENU_ITEM, ui.sound_on = ENABLED(SOUND_ON_DEFAULT));
-  TERN_(BAUD_RATE_GCODE, eeprom_settings.Baud115k = false);
-  TERN_(FWRETRACT, temp_val.auto_fw_retract = fwretract.autoretract_enabled);
-  #if ENABLED(PREHEAT_BEFORE_LEVELING)
-    eeprom_settings.ena_hotend_levtemp = true;
-    eeprom_settings.ena_bed_levtemp = true;
-    eeprom_settings.hotend_levtemp = LEVELING_NOZZLE_TEMP;
-    eeprom_settings.bed_levtemp = LEVELING_BED_TEMP;
-  #endif
-  #if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
-    leds.setup();
-    #if ENABLED(LED_COLOR_PRESETS)
-      leds.set_default();
-    #endif
-      temp_val.LED_Color = Def_Leds_Color;
-      leds.set_color(
-      (temp_val.LED_Color >> 16) & 0xFF,
-      (temp_val.LED_Color >>  8) & 0xFF,
-      (temp_val.LED_Color >>  0) & 0xFF
-      OPTARG(HAS_WHITE_LED, (temp_val.LED_Color >> 24) & 0xFF)
-      );
-  #endif
-  #if HAS_HOSTACTION_MENUS
-    eeprom_settings.host_action_label_1 = 0;
-    eeprom_settings.host_action_label_2 = 0;
-    eeprom_settings.host_action_label_3 = 0;
-    action1[0] = action2[0] = action3[0] = '-';
-  #endif
-  Redraw_Screen();
-}
-
-void CrealityDWINClass::PreheatBefore() {
-  #if ENABLED(PREHEAT_BEFORE_LEVELING)
-    Popup_Handler(Heating);
-    #if HAS_BED_PROBE
-      probe.preheat_for_probing(eeprom_settings.ena_hotend_levtemp, eeprom_settings.ena_bed_levtemp);
-    #else
-      #if HAS_HOTEND
-        if (thermalManager.degTargetHotend(0) < eeprom_settings.hotend_levtemp && (eeprom_settings.ena_hotend_levtemp))
-          thermalManager.setTargetHotend(eeprom_settings.hotend_levtemp, 0);
-      #endif
-      #if HAS_HEATED_BED
-        if (thermalManager.degTargetBed() < eeprom_settings.bed_levtemp && (eeprom_settings.ena_bed_levtemp))
-          thermalManager.setTargetBed(eeprom_settings.bed_levtemp);
-      #endif
-      TERN_(HAS_HOTEND, if (eeprom_settings.ena_hotend_levtemp) thermalManager.wait_for_hotend(0));
-      TERN_(HAS_HEATED_BED, if (eeprom_settings.ena_bed_levtemp) thermalManager.wait_for_bed_heating());
-    #endif
-    Update_Status("");
-  #endif
-}
-
-void MarlinUI::init_lcd() {
-  DWINUI::init();
-  Encoder_Configuration();
-  DWIN_JPG_ShowAndCache(0);
-  for (uint16_t t = 0; t <= 100; t += 2) {
-    DWINUI::DRAW_IconWB(ICON, ICON_Bar, 15, 260);
-    DWIN_Draw_Rectangle(1, Def_Background_Color, 15 + t * 242 / 100, 260, 257, 280);
-    DWIN_UpdateLCD();
-    delay(20);
-  }
-  DWIN_JPG_CacheTo1(Language_English);
-  CrealityDWIN.Redraw_Screen();
-}
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
-    switch (message) {
-      case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
-      case PAUSE_MESSAGE_PURGE:   break;
-      case PAUSE_MESSAGE_OPTION:  pause_menu_response = PAUSE_RESPONSE_WAIT_FOR; CrealityDWIN.Popup_Handler(PurgeMore); break;
-      case PAUSE_MESSAGE_HEAT:    CrealityDWIN.Confirm_Handler(HeaterTime); break;
-      case PAUSE_MESSAGE_WAITING: CrealityDWIN.Draw_Print_Screen();         break;
-      default: break;
-    }
-  }
-#endif
-
-// End-stops diagnostic from DWIN PROUI
-#if HAS_ESDIAG
-  void CrealityDWINClass::DWIN_EndstopsDiag() {
-    last_process = process;
-    last_selection = selection;
-    process = Confirm;
-    popup = ESDiagPopup;
-    ESDiag.Draw();
-  }
-#endif
-
-// Lock screen from DWIN PROUI
-#if HAS_LOCKSCREEN
-  void CrealityDWINClass::DWIN_LockScreen() {
-    if (process != Locked) {
-      lockScreen.rprocess = process;
-      process = Locked;
-      lockScreen.init();
-    }
-  }
-
-  void CrealityDWINClass::DWIN_UnLockScreen() {
-    if (process == Locked) {
-      process = lockScreen.rprocess;
-      if (!temp_val.printing) Draw_Main_Menu(); else Draw_Print_Screen();
-    }
-  }
-
-  void CrealityDWINClass::HMI_LockScreen() {
-    EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-    if (encoder_diffState == ENCODER_DIFF_NO) return;
-    lockScreen.onEncoder(encoder_diffState);
-    if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
-  }
-#endif
-
-// Reboot screen from DWIN PROUI
-void CrealityDWINClass::DWIN_RebootScreen() {
-  DWIN_Frame_Clear(Def_Background_Color);
-  DWIN_JPG_ShowAndCache(0);
-  DWINUI::Draw_CenteredString(Def_Text_Color, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
-  DWIN_UpdateLCD();
-  delay(500);
-}
-
-// Reboot Printer from DWIN PROUI
-void CrealityDWINClass::RebootPrinter() {
-  wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
-  thermalManager.disable_all_heaters();
-  planner.finish_and_disable();
-  DWIN_RebootScreen();
-  hal.reboot();
-}
-
-#if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
-  void CrealityDWINClass::ApplyLEDColor() {
-    temp_val.LED_Color = TERN0(HAS_WHITE_LED,(leds.color.w << 24)) | (leds.color.r << 16) | (leds.color.g << 8) | (leds.color.b);
-  }
-#endif
-
-#if HAS_PIDPLOT
-  void CrealityDWINClass::DWIN_Draw_PIDPopup(const pidresult_t pidresult) {
-    frame_rect_t gfrm = {40, 160, DWIN_WIDTH - 80, 150};
-    DWINUI::ClearMainArea();
-    DWIN_Draw_Rectangle(1, Def_PopupBg_color, 14, 60, 258, 330);
-    DWIN_Draw_Rectangle(0, Def_Highlight_Color, 14, 60, 258, 330);
-    DWINUI::Draw_CenteredString(Def_PopupTxt_Color, 80, GET_TEXT_F(MSG_PID_AUTOTUNE));
-    DWINUI::Draw_String(Def_PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
-    switch (pidresult) {
-      case PID_EXTR_START:
-        DWINUI::Draw_CenteredString(Def_PopupTxt_Color, 100, F("for Nozzle is running."));
-        Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], temp_val.PID_e_temp);
-        DWINUI::Draw_Int(Def_PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, temp_val.PID_e_temp);
-        break;
-      case PID_BED_START:
-        DWINUI::Draw_CenteredString(Def_PopupTxt_Color, 100, F("for BED is running."));
-        Plot.Draw(gfrm, BED_MAXTEMP, temp_val.PID_bed_temp);
-        DWINUI::Draw_Int(Def_PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, temp_val.PID_bed_temp);
-        break;
-      default:
-        break;
-    }
-  }
-#endif
-
-#if HAS_PID_HEATING
-  void CrealityDWINClass::DWIN_PidTuning(const pidresult_t pidresult) {
-    switch (pidresult) {
-      case PID_STARTED:  break;
-      #if HAS_PIDPLOT
-        case PID_EXTR_START:  last_process = process; last_selection = selection; process = Wait; popup = PIDWaitH; DWIN_Draw_PIDPopup(pidresult); break;
-        case PID_BED_START:  last_process = process; last_selection = selection; process = Wait; popup = PIDWaitB; DWIN_Draw_PIDPopup(pidresult); break;
-      #else
-        case PID_EXTR_START:  Popup_Handler(PIDWait); break;
-        case PID_BED_START:  Popup_Handler(PIDWait, true); break;
-      #endif
-      case PID_BAD_EXTRUDER_NUM:  Confirm_Handler(BadextruderNumber);  break;
-      case PID_TEMP_TOO_HIGH:  Confirm_Handler(TempTooHigh);  break;
-      case PID_TUNING_TIMEOUT:  Confirm_Handler(PIDTimeout);  break;
-      case PID_DONE: Confirm_Handler(PIDDone);  break;
-      default: break;
-    }
-  }
-#endif
-
-#endif // DWIN_CREALITY_LCD_JYERSUI

commit 509dfe92d0c2227ddece025fb97875582ca47aed
Author: Meilleur Gars <98503100+LCh-77@users.noreply.github.com>
Date:   Wed Jul 6 13:46:11 2022 -0700

    🚸 JyersUI updates (#24451)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 285013d750..e62bb04a43 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -15,37 +15,44 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * lcd/e3v2/jyersui/dwin.cpp
+ * JYERSUI Author: Jacob Myers
+ *
+ * JYERSUI Enhanced by LCH-77
+ * Version: 1.9
+ * Date: Jun 16, 2022
  */
 
 #include "../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
 
+#include "dwin_defines.h"
 #include "dwin.h"
+#include "dwinui.h"
 
 #include "../../marlinui.h"
 #include "../../../MarlinCore.h"
-
 #include "../../../gcode/gcode.h"
 #include "../../../module/temperature.h"
 #include "../../../module/planner.h"
 #include "../../../module/settings.h"
 #include "../../../libs/buzzer.h"
 #include "../../../inc/Conditionals_post.h"
+#include "../common/encoder.h"
 
 //#define DEBUG_OUT 1
 #include "../../../core/debug_out.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../../../feature/pause.h"
 #endif
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   #include "../../../feature/runout.h"
@@ -60,72 +67,100 @@
 #endif
 
 #ifndef strcasecmp_P
   #define strcasecmp_P(a, b) strcasecmp((a), (b))
 #endif
 
 #if HAS_LEVELING
   #include "../../../feature/bedlevel/bedlevel.h"
 #endif
 
+#ifdef BLTOUCH_HS_MODE
+  #include "../../../feature/bltouch.h"
+#endif
+
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../../libs/least_squares_fit.h"
   #include "../../../libs/vector_3.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
-#define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
+#if HAS_ESDIAG
+  #include "endstop_diag.h"
+#endif
+
+#if HAS_LOCKSCREEN
+  #include "lockscreen.h"
+#endif
 
-#define DWIN_FONT_MENU font8x16
-#define DWIN_FONT_STAT font10x20
-#define DWIN_FONT_HEAD font10x20
+#if ENABLED(CASE_LIGHT_MENU)
+  #include "../../../feature/caselight.h"
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+  #include "../../../feature/leds/leds.h"
+#endif
+
+#if HAS_PIDPLOT
+  #include "plot.h"
+#endif
+#if HAS_GCODE_PREVIEW
+  #include "gcode_preview.h"
+#endif
+
+#define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 
-#define MENU_CHAR_LIMIT  24
-#define STATUS_Y 352
+#define MENU_CHAR_LIMIT 24
+#define STATUS_CHAR_LIMIT 30
 
-#define MAX_PRINT_SPEED   500
-#define MIN_PRINT_SPEED   10
+#define MAX_PRINT_SPEED 500
+#define MIN_PRINT_SPEED 10
 
 #if HAS_FAN
-  #define MAX_FAN_SPEED     255
-  #define MIN_FAN_SPEED     0
+  #define MAX_FAN_SPEED 255
+  #define MIN_FAN_SPEED 0
 #endif
 
 #define MAX_XY_OFFSET 100
 
 #if HAS_ZOFFSET_ITEM
   #define MAX_Z_OFFSET 9.99
   #if HAS_BED_PROBE
     #define MIN_Z_OFFSET -9.99
   #else
     #define MIN_Z_OFFSET -1
   #endif
 #endif
 
 #if HAS_HOTEND
-  #define MAX_FLOW_RATE   200
-  #define MIN_FLOW_RATE   10
+  #define MAX_FLOW_RATE 200
+  #define MIN_FLOW_RATE 10
 
-  #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
-  #define MIN_E_TEMP    0
+  #define MAX_E_TEMP (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+  #define MIN_E_TEMP 0
 #endif
 
 #if HAS_HEATED_BED
-  #define MAX_BED_TEMP  BED_MAXTEMP
-  #define MIN_BED_TEMP  0
+  #define MAX_BED_TEMP BED_MAXTEMP
+  #define MIN_BED_TEMP 0
+#endif
+
+#if HAS_JUNCTION_DEVIATION
+  #define MIN_JD_MM 0.01
+  #define MAX_JD_MM 0.3
 #endif
 
 /**
  * Custom menu items with jyersLCD
  */
 #if ENABLED(CUSTOM_MENU_CONFIG)
   #ifdef CONFIG_MENU_ITEM_5_DESC
     #define CUSTOM_MENU_COUNT 5
   #elif defined(CONFIG_MENU_ITEM_4_DESC)
     #define CUSTOM_MENU_COUNT 4
@@ -134,94 +169,87 @@
   #elif defined(CONFIG_MENU_ITEM_2_DESC)
     #define CUSTOM_MENU_COUNT 2
   #elif defined(CONFIG_MENU_ITEM_1_DESC)
     #define CUSTOM_MENU_COUNT 1
   #endif
   #if CUSTOM_MENU_COUNT
     #define HAS_CUSTOM_MENU 1
   #endif
 #endif
 
-constexpr uint16_t TROWS = 6, MROWS = TROWS - 1,
-                   TITLE_HEIGHT = 30,
-                   MLINE = 53,
-                   LBLX = 60,
-                   MENU_CHR_W = 8, MENU_CHR_H = 16, STAT_CHR_W = 10;
-
-#define MBASE(L) (49 + MLINE * (L))
-
-constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
-constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
-constexpr float default_steps[]               = DEFAULT_AXIS_STEPS_PER_UNIT;
+constexpr float default_max_feedrate[]     = DEFAULT_MAX_FEEDRATE;
+constexpr float default_max_acceleration[] = DEFAULT_MAX_ACCELERATION;
+constexpr float default_steps[]            = DEFAULT_AXIS_STEPS_PER_UNIT;
 #if HAS_CLASSIC_JERK
-  constexpr float default_max_jerk[]            = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+  constexpr float default_max_jerk[]       = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
 #endif
 
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
   PAGE_INFO_LEVELING,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
   PRINT_PAUSE_RESUME,
   PRINT_STOP,
   PRINT_COUNT
 };
 
+eeprom_settings_t eeprom_settings = {0};
+temp_val_t temp_val = {0};
 uint8_t active_menu = MainMenu, last_menu = MainMenu;
-uint8_t selection = 0, last_selection = 0;
+uint8_t selection = 0, last_selection = 0, last_pos_selection = 0;
 uint8_t scrollpos = 0;
 uint8_t process = Main, last_process = Main;
 PopupID popup, last_popup;
 
 void (*funcpointer)() = nullptr;
 void *valuepointer = nullptr;
 float tempvalue;
 float valuemin;
 float valuemax;
 uint8_t valueunit;
 uint8_t valuetype;
 
-char cmd[MAX_CMD_SIZE+16], str_1[16], str_2[16], str_3[16];
+char cmd[MAX_CMD_SIZE + 16], str_1[16], str_2[16], str_3[16];
 char statusmsg[64];
 char filename[LONG_FILENAME_LENGTH];
-bool printing = false;
-bool paused = false;
-bool sdprint = false;
 
-int16_t pausetemp, pausebed, pausefan;
-
-bool livemove = false;
-bool liveadjust = false;
-uint8_t preheatmode = 0;
-float zoffsetvalue = 0;
-uint8_t gridpoint;
-float corner_avg;
-float corner_pos;
-
-bool probe_deployed = false;
+#if HAS_HOSTACTION_MENUS
+  #define KEY_WIDTH 26
+  #define KEY_HEIGHT 30
+  #define KEY_INSET 5
+  #define KEY_PADDING 3
+  #define KEY_Y_START DWIN_HEIGHT - (4 * (KEY_HEIGHT) + 2 * (KEY_INSET + 1))
+
+  bool keyboard_restrict, reset_keyboard, numeric_keyboard = false;
+  uint8_t maxstringlen;
+  char *stringpointer = nullptr;
+  char action1[9], action2[9], action3[9];
+#endif
 
 CrealityDWINClass CrealityDWIN;
 
 #if HAS_MESH
 
   struct Mesh_Settings {
     bool viewer_asymmetric_range = false;
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
+
       uint8_t tilt_grid = 1;
 
       void manual_value_update(bool undefined=false) {
         sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
         gcode.process_subcommands_now(cmd);
         planner.synchronize();
       }
 
       bool create_plane_from_mesh() {
         struct linear_fit_data lsf_results;
@@ -323,27 +351,27 @@ CrealityDWINClass CrealityDWIN;
     }
 
     void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
                      cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
                      cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
       const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
+      DWIN_Draw_Rectangle(1, Def_Background_Color, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / (GRID_MAX_POINTS_X);
         const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
-        DWIN_Draw_Rectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
+        DWIN_Draw_Rectangle(1, Def_Highlight_Color, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       char buf[8];
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
         DWIN_Draw_Rectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
@@ -355,31 +383,31 @@ CrealityDWINClass CrealityDWIN;
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
           if (isnan(bedlevel.z_values[x][y])) {  // undefined
-            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+            DWINUI::Draw_String(font6x12, Def_Text_Color, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             if (GRID_MAX_POINTS_X < 10)
               sprintf_P(buf, PSTR("%s"), dtostrf(abs(bedlevel.z_values[x][y]), 1, 2, str_1));
             else
               sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(bedlevel.z_values[x][y] - (int16_t)bedlevel.z_values[x][y]) * 100));
             offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
             if (!(GRID_MAX_POINTS_X < 10))
-              DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
+              DWINUI::Draw_String(font6x12, Def_Text_Color, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            DWINUI::Draw_String(font6x12, Def_Text_Color, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
       float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
       if (v_min > 3e+10F) v_min = 0.0000001;
@@ -398,132 +426,155 @@ CrealityDWINClass CrealityDWIN;
       CrealityDWIN.Update_Status(msg);
       drawing_mesh = false;
     }
 
   };
   Mesh_Settings mesh_conf;
 
 #endif // HAS_MESH
 
 /* General Display Functions */
-
-struct CrealityDWINClass::EEPROM_Settings CrealityDWINClass::eeprom_settings{0};
 constexpr const char * const CrealityDWINClass::color_names[11];
 constexpr const char * const CrealityDWINClass::preheat_modes[3];
+constexpr const char * const CrealityDWINClass::zoffset_modes[3];
+#if ENABLED(PREHEAT_BEFORE_LEVELING)
+  constexpr const char * const CrealityDWINClass::preheat_levmodes[4];
+#endif
 
 // Clear a part of the screen
 //  4=Entire screen
 //  3=Title bar and Menu area (default)
 //  2=Menu area
 //  1=Title bar
 void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
-  if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
-  if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
-  if (e == 4) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
+  if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Def_TitleBg_color, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
+  if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Def_Background_Color, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
+  if (e == 4) DWIN_Draw_Rectangle(1, Def_Background_Color, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
 }
 
 void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
-  const uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
+  const uint16_t bColor = (selected) ? Def_Selected_Color : Def_Background_Color;
   const uint16_t xpos = 240 - (digits * 8);
-  DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
+  DWIN_Draw_Rectangle(1, Def_Background_Color, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
-    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
+    DWINUI::Draw_String(Def_Text_Color, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
-    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
-    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
+    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Def_Text_Color, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
+    DWINUI::Draw_String(Def_Text_Color, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
 void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
-  uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black,
-           tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
+  uint16_t bColor = (selected) ? Def_Selected_Color : Def_Background_Color,
+           tColor = (color) ? GetColor(value, Def_Text_Color, false) : Def_Text_Color;
   DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
-  DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
+  DWINUI::Draw_String(tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
+#if HAS_HOSTACTION_MENUS
+
+  void CrealityDWINClass::Draw_String(char * string, uint8_t row, bool selected/*=false*/, bool below/*=false*/) {
+    if (!string) string[0] = '\0';
+    const uint8_t offset_x = DWIN_WIDTH - strlen(string) * 8 - 20;
+    const uint8_t offset_y = (below) ? MENU_CHR_H * 3 / 5 : 0;
+    DWIN_Draw_Rectangle(1, Def_Background_Color, offset_x - 10, MBASE(row) + offset_y - 1, offset_x, MBASE(row) + 16 + offset_y);
+    DWINUI::Draw_String(Def_Text_Color, (selected) ? Def_Selected_Color : Def_Background_Color, offset_x, MBASE(row) - 1 + offset_y, string);
+  }
+
+  const uint64_t CrealityDWINClass::Encode_String(const char * string) {
+    const char table[65] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
+    uint64_t output = 0;
+    LOOP_L_N(i, strlen(string)) {
+      uint8_t upper_bound = 63, lower_bound = 0;
+      uint8_t midpoint;
+      LOOP_L_N(x, 6) {
+        midpoint = (uint8_t)(0.5 * (upper_bound + lower_bound));
+        if (string[i] == table[midpoint]) break;
+        if (string[i] > table[midpoint])
+          lower_bound = midpoint;
+        else
+          upper_bound = midpoint;
+      }
+      output += midpoint * pow(64, i);
+    }
+    return output;
+  }
+
+  void CrealityDWINClass::Decode_String(uint64_t num, char * string) {
+    const char table[65] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
+    LOOP_L_N(i, 30) {
+      string[i] = table[num % 64];
+      num /= 64;
+      if (num == 0) {
+        string[i + 1] = '\0';
+        break;
+      }
+    }
+  }
+
+#endif // HAS_HOSTACTION_MENUS
+
 uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
   switch (color) {
-    case Default:
-      return original;
-      break;
-    case White:
-      return (light) ? Color_Light_White : Color_White;
-      break;
-    case Green:
-      return (light) ? Color_Light_Green : Color_Green;
-      break;
-    case Cyan:
-      return (light) ? Color_Light_Cyan : Color_Cyan;
-      break;
-    case Blue:
-      return (light) ? Color_Light_Blue : Color_Blue;
-      break;
-    case Magenta:
-      return (light) ? Color_Light_Magenta : Color_Magenta;
-      break;
-    case Red:
-      return (light) ? Color_Light_Red : Color_Red;
-      break;
-    case Orange:
-      return (light) ? Color_Light_Orange : Color_Orange;
-      break;
-    case Yellow:
-      return (light) ? Color_Light_Yellow : Color_Yellow;
-      break;
-    case Brown:
-      return (light) ? Color_Light_Brown : Color_Brown;
-      break;
-    case Black:
-      return Color_Black;
-      break;
+    case Default: return original;
+    case White:   return (light) ? Color_Light_White   : Color_White;
+    case Green:   return (light) ? Color_Light_Green   : Color_Green;
+    case Cyan:    return (light) ? Color_Light_Cyan    : Color_Cyan;
+    case Blue:    return (light) ? Color_Light_Blue    : Color_Blue;
+    case Magenta: return (light) ? Color_Light_Magenta : Color_Magenta;
+    case Red:     return (light) ? Color_Light_Red     : Color_Red;
+    case Orange:  return (light) ? Color_Light_Orange  : Color_Orange;
+    case Yellow:  return (light) ? Color_Light_Yellow  : Color_Yellow;
+    case Brown:   return (light) ? Color_Light_Brown   : Color_Brown;
+    case Black:   return Color_Black;
   }
   return Color_White;
 }
 
 void CrealityDWINClass::Draw_Title(const char * ctitle) {
-  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
+  DWINUI::Draw_CenteredString((uint8_t)DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Def_TitleTxt_color, false), 5, ctitle);
 }
 void CrealityDWINClass::Draw_Title(FSTR_P const ftitle) {
-  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
+   DWINUI::Draw_CenteredString((uint8_t)DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Def_TitleTxt_color, false), 5, ftitle);
 }
 
 void _Decorate_Menu_Item(uint8_t row, uint8_t icon, bool more) {
   if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
   if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
-  DWIN_Draw_Line(CrealityDWIN.GetColor(CrealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+  DWIN_Draw_HLine(CrealityDWIN.GetColor(eeprom_settings.menu_split_line, Def_SplitLine_Color, true), 16, MBASE(row) + 33, 240); // Draw Menu Line
 }
 
 void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
-  const uint8_t label_offset_y = (label1 || label2) ? MENU_CHR_H * 3 / 5 : 0,
-                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
-                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
-  if (label1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
-  if (label2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
+  const uint8_t label_offset_y = (label1 && label2) ? MENU_CHR_H * 3 / 5 : 0,
+                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
+                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
+  if (label1) DWINUI::Draw_String(label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
+  if (label2) DWINUI::Draw_String(label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
   _Decorate_Menu_Item(row, icon, more);
 }
 
 void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, bool more/*=false*/, bool centered/*=false*/) {
-  const uint8_t label_offset_y = (flabel1 || flabel2) ? MENU_CHR_H * 3 / 5 : 0,
-                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
-                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
-  if (flabel1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
-  if (flabel2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
+  const uint8_t label_offset_y = (flabel1 && flabel2) ? MENU_CHR_H * 3 / 5 : 0,
+                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
+                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1/5U, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
+  if (flabel1) DWINUI::Draw_String(label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
+  if (flabel2) DWINUI::Draw_String(label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
   _Decorate_Menu_Item(row, icon, more);
 }
 
 void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
     DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
-    DWIN_Draw_Rectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    DWIN_Draw_Rectangle(0, Def_Text_Color, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     if (value) {
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
     }
   #endif
 }
@@ -535,526 +586,662 @@ void CrealityDWINClass::Draw_Menu(uint8_t menu, uint8_t select/*=0*/, uint8_t sc
   }
   selection = _MIN(select, Get_Menu_Size(menu));
   scrollpos = scroll;
   if (selection - scrollpos > MROWS)
     scrollpos = selection - MROWS;
   process = Menu;
   active_menu = menu;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(menu));
   LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
-  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
 
 void CrealityDWINClass::Redraw_Menu(bool lastprocess/*=true*/, bool lastselection/*=false*/, bool lastmenu/*=false*/) {
   switch ((lastprocess) ? last_process : process) {
     case Menu:
       Draw_Menu((lastmenu) ? last_menu : active_menu, (lastselection) ? last_selection : selection, (lastmenu) ? 0 : scrollpos);
       break;
     case Main:  Draw_Main_Menu((lastselection) ? last_selection : selection); break;
     case Print: Draw_Print_Screen(); break;
     case File:  Draw_SD_List(); break;
     default: break;
   }
 }
 
 void CrealityDWINClass::Redraw_Screen() {
-  Redraw_Menu(false);
+  if (printingIsActive()) Draw_Print_Screen();
+  else Redraw_Menu(false);
   Draw_Status_Area(true);
   Update_Status_Bar(true);
 }
 
 /* Primary Menus and Screen Elements */
 
 void CrealityDWINClass::Main_Menu_Icons() {
+
   if (selection == 0) {
-    DWIN_ICON_Show(ICON, ICON_Print_1, 17, 130);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
-  }
-  else {
-    DWIN_ICON_Show(ICON, ICON_Print_0, 17, 130);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    DWINUI::DRAW_IconWB(ICON, ICON_Print_1, 17, 110);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 17, 110, 126, 209);
   }
+  else
+    DWINUI::DRAW_IconWB(ICON, ICON_Print_0, 17, 110);
+
+  DWINUI::Draw_String(52, 180, GET_TEXT_F(MSG_BUTTON_PRINT));
+
   if (selection == 1) {
-    DWIN_ICON_Show(ICON, ICON_Prepare_1, 145, 130);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
-  }
-  else {
-    DWIN_ICON_Show(ICON, ICON_Prepare_0, 145, 130);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    DWINUI::DRAW_IconWB(ICON, ICON_Prepare_1, 145, 110);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 145, 110, 254, 209);
   }
+  else
+    DWINUI::DRAW_IconWB(ICON, ICON_Prepare_0, 145, 110);
+
+  DWINUI::Draw_String(170, 180, GET_TEXT_F(MSG_PREPARE));
+
   if (selection == 2) {
-    DWIN_ICON_Show(ICON, ICON_Control_1, 17, 246);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
-  }
-  else {
-    DWIN_ICON_Show(ICON, ICON_Control_0, 17, 246);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    DWINUI::DRAW_IconWB(ICON, ICON_Control_1, 17, 226);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 17, 226, 126, 325);
   }
+  else
+    DWINUI::DRAW_IconWB(ICON, ICON_Control_0, 17, 226);
+
+  DWINUI::Draw_String(43, 297, GET_TEXT_F(MSG_CONTROL));
+
   #if HAS_ABL_OR_UBL
+
     if (selection == 3) {
-      DWIN_ICON_Show(ICON, ICON_Leveling_1, 145, 246);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
-    }
-    else {
-      DWIN_ICON_Show(ICON, ICON_Leveling_0, 145, 246);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      DWINUI::DRAW_IconWB(ICON, ICON_Leveling_1, 145, 226);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 145, 226, 254, 325);
     }
+    else
+      DWINUI::DRAW_IconWB(ICON, ICON_Leveling_0, 145, 226);
+
+    DWINUI::Draw_String(179, 297, GET_TEXT_F(MSG_BUTTON_LEVEL));
+
   #else
+
     if (selection == 3) {
-      DWIN_ICON_Show(ICON, ICON_Info_1, 145, 246);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
-    }
-    else {
-      DWIN_ICON_Show(ICON, ICON_Info_0, 145, 246);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      DWINUI::DRAW_IconWB(ICON, ICON_Info_1, 145, 226);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 145, 226, 254, 325);
     }
+    else
+      DWINUI::DRAW_IconWB(ICON, ICON_Info_0, 145, 226);
+
+    DWINUI::Draw_String(181, 297, GET_TEXT_F(MSG_BUTTON_INFO));
+
   #endif
 }
 
 void CrealityDWINClass::Draw_Main_Menu(uint8_t select/*=0*/) {
   process = Main;
   active_menu = MainMenu;
   selection = select;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
-  DWIN_ICON_Show(ICON, ICON_LOGO, 71, 72);
+  DWIN_ICON_Show(ICON, ICON_LOGO, 71, 62);
   Main_Menu_Icons();
 }
 
 void CrealityDWINClass::Print_Screen_Icons() {
   if (selection == 0) {
-    DWIN_ICON_Show(ICON, ICON_Setup_1, 8, 252);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
-  }
-  else {
-    DWIN_ICON_Show(ICON, ICON_Setup_0, 8, 252);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    DWINUI::DRAW_IconWB(ICON, ICON_Setup_1, 8, 252);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 8, 252, 87, 351);
   }
+  else
+    DWINUI::DRAW_IconWB(ICON, ICON_Setup_0, 8, 252);
+
+  DWINUI::Draw_String(30, 322, GET_TEXT_F(MSG_TUNE));
+
   if (selection == 2) {
-    DWIN_ICON_Show(ICON, ICON_Stop_1, 184, 252);
-    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    DWINUI::DRAW_IconWB(ICON, ICON_Stop_1, 184, 252);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 184, 252, 263, 351);
   }
-  else {
-    DWIN_ICON_Show(ICON, ICON_Stop_0, 184, 252);
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
-  }
-  if (paused) {
+  else
+    DWINUI::DRAW_IconWB(ICON, ICON_Stop_0, 184, 252);
+
+  DWINUI::Draw_String(205, 322, GET_TEXT_F(MSG_BUTTON_STOP));
+
+  if (temp_val.paused) {
     if (selection == 1) {
-      DWIN_ICON_Show(ICON, ICON_Continue_1, 96, 252);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
-    }
-    else {
-      DWIN_ICON_Show(ICON, ICON_Continue_0, 96, 252);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      DWINUI::DRAW_IconWB(ICON, ICON_Continue_1, 96, 252);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 96, 252, 175, 351);
     }
+    else
+      DWINUI::DRAW_IconWB(ICON, ICON_Continue_0, 96, 252);
+
+    DWINUI::Draw_String(114, 322, GET_TEXT_F(MSG_BUTTON_RESUME));
   }
   else {
     if (selection == 1) {
-      DWIN_ICON_Show(ICON, ICON_Pause_1, 96, 252);
-      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
-    }
-    else {
-      DWIN_ICON_Show(ICON, ICON_Pause_0, 96, 252);
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      DWINUI::DRAW_IconWB(ICON, ICON_Pause_1, 96, 252);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 96, 252, 175, 351);
     }
+    else
+      DWINUI::DRAW_IconWB(ICON, ICON_Pause_0, 96, 252);
+
+    DWINUI::Draw_String(114, 322, GET_TEXT_F(MSG_BUTTON_PAUSE));
   }
 }
 
 void CrealityDWINClass::Draw_Print_Screen() {
   process = Print;
   selection = 0;
   Clear_Screen();
-  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
-  Draw_Title("Printing...");
+  DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 352, DWIN_WIDTH - 8, 376);
+  Draw_Title(GET_TEXT(MSG_PRINTING));
   Print_Screen_Icons();
   DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
   DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
-  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
-  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
+  DWINUI::Draw_String(Def_PercentTxt_Color, 41, 163, GET_TEXT_F(MSG_INFO_PRINT_TIME));
+  DWINUI::Draw_String(Def_PercentTxt_Color, 176, 163, GET_TEXT_F(MSG_REMAINING_TIME));
   Update_Status_Bar(true);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
   Draw_Print_Filename(true);
 }
 
 void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
   static uint8_t namescrl = 0;
   if (reset) namescrl = 0;
   if (process == Print) {
-    constexpr int8_t maxlen = 30;
-    char *outstr = filename;
-    size_t slen = strlen(filename);
-    int8_t outlen = slen;
-    if (slen > maxlen) {
-      char dispname[maxlen + 1];
-      int8_t pos = slen - namescrl, len = maxlen;
+    size_t len = strlen(filename);
+    int8_t pos = len;
+    if (pos > STATUS_CHAR_LIMIT) {
+      pos -= namescrl;
+      len = _MIN((size_t)pos, (size_t)STATUS_CHAR_LIMIT);
+      char dispname[len + 1];
       if (pos >= 0) {
-        NOMORE(len, pos);
         LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
       }
       else {
-        const int8_t mp = maxlen + pos;
-        LOOP_L_N(i, mp) dispname[i] = ' ';
-        LOOP_S_L_N(i, mp, maxlen) dispname[i] = filename[i - mp];
-        if (mp <= 0) namescrl = 0;
+        LOOP_L_N(i, STATUS_CHAR_LIMIT + pos) dispname[i] = ' ';
+        LOOP_S_L_N(i, STATUS_CHAR_LIMIT + pos, STATUS_CHAR_LIMIT) dispname[i] = filename[i - (STATUS_CHAR_LIMIT + pos)];
       }
       dispname[len] = '\0';
-      outstr = dispname;
-      outlen = maxlen;
+      DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 50, DWIN_WIDTH - 8, 80);
+      const int8_t npos = (DWIN_WIDTH - STATUS_CHAR_LIMIT * MENU_CHR_W) / 2;
+      DWINUI::Draw_String(npos, 60, dispname);
+      if (-pos >= STATUS_CHAR_LIMIT) namescrl = 0;
       namescrl++;
     }
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
-    const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
-    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
+    else {
+      DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 50, DWIN_WIDTH - 8, 80);
+      const int8_t npos = (DWIN_WIDTH - strlen(filename) * MENU_CHR_W) / 2;
+      DWINUI::Draw_String(npos, 60, filename);
+    }
   }
 }
 
 void CrealityDWINClass::Draw_Print_ProgressBar() {
-  uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
-  DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
-  DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
-  DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
-  DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
+  uint8_t printpercent = temp_val.sdprint ? card.percentDone() : (ui._get_progress() / 100);
+  DWINUI::DRAW_IconWB(ICON, ICON_Bar, 15, 93);
+  DWIN_Draw_Rectangle(1, Def_Barfill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
+  DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Def_PercentTxt_Color), Def_Background_Color, 3, 109, 133, printpercent);
+  DWINUI::Draw_String(GetColor(eeprom_settings.progress_percent, Def_PercentTxt_Color), Def_Background_Color, 134, 133, F("%"));
 }
 
 #if ENABLED(USE_M73_REMAINING_TIME)
 
   void CrealityDWINClass::Draw_Print_ProgressRemain() {
     uint16_t remainingtime = ui.get_remaining_time();
-    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
-    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
+    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 176, 187, remainingtime / 3600);
+    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 201, 187, (remainingtime % 3600) / 60);
     if (eeprom_settings.time_format_textual) {
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
+      DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 193, 187, F("h"));
+      DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 217, 187, F("m"));
     }
     else
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
+      DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 193, 187, F(":"));
   }
 
 #endif
 
 void CrealityDWINClass::Draw_Print_ProgressElapsed() {
   duration_t elapsed = print_job_timer.duration();
-  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
-  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
+  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 42, 187, elapsed.value / 3600);
+  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 2, 67, 187, (elapsed.value % 3600) / 60);
   if (eeprom_settings.time_format_textual) {
-    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
-    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
+    DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 59, 187, F("h"));
+    DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 83, 187, F("m"));
   }
   else
-    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
+    DWINUI::Draw_String(GetColor(eeprom_settings.progress_time, Def_PercentTxt_Color), Def_Background_Color, 59, 187, F(":"));
 }
 
-void CrealityDWINClass::Draw_Print_confirm() {
-  Draw_Print_Screen();
+void CrealityDWINClass::Draw_PrintDone_confirm() {
   process = Confirm;
   popup = Complete;
-  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
-  DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
-  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
-  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
+  if (TERN0(HAS_GCODE_PREVIEW, Preview_Valid())) {
+    Clear_Screen();
+    Draw_Title(GET_TEXT(MSG_PRINT_DONE));
+    DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
+    DWINUI::Draw_Button(BTN_Continue, 87, 300);
+  }
+  else {
+    Draw_Print_Screen();
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 8, 252, 263, 351);
+    DWINUI::Draw_Button(BTN_Continue, 87, 283);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 86, 282, 187, 321);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Def_Highlight_Color), 85, 281, 188, 322);
+  }
 }
 
 void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
   if (item == 0)
-    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
+    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? GET_TEXT_F(MSG_BACK) : F(".."));
   else {
     card.getfilename_sorted(SD_ORDER(item - 1, card.get_num_Files()));
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
-    if (len > max) len = max;
+    NOMORE(len, max);
     char name[len + 1];
-    LOOP_L_N(i, len) name[i] = filename[i];
-    if (pos > max)
-      LOOP_S_L_N(i, len - 3, len) name[i] = '.';
+    memcpy(name, filename, len);
+    if (pos > max) LOOP_S_L_N(i, len - 3, len) name[i] = '.';
     name[len] = '\0';
     Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
   }
 }
 
 void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
   Clear_Screen();
   Draw_Title("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
     LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
       Draw_SD_Item(i, i);
   }
   else {
-    Draw_Menu_Item(0, ICON_Back, F("Back"));
-    DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
+    Draw_Menu_Item(0, ICON_Back, GET_TEXT_F(MSG_BACK));
+    DWIN_Draw_Rectangle(1, Def_AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    DWINUI::Draw_String(font16x32, Def_AlertTxt_Color, Def_AlertBg_Color, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), GET_TEXT_F(MSG_NO_MEDIA));
   }
-  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
+  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
 void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
 
-  if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
+  if (icons) DWIN_Draw_Rectangle(1, Def_Background_Color, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
       DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
-      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+      DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     }
     if (thermalManager.temp_hotend[0].celsius != hotend) {
       hotend = thermalManager.temp_hotend[0].celsius;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 3 * STAT_CHR_W + 5, 386);
     }
     if (thermalManager.temp_hotend[0].target != hotendtarget) {
       hotendtarget = thermalManager.temp_hotend[0].target;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 4 * STAT_CHR_W + 39, 386);
     }
     if (icons) {
       flow = -1;
       DWIN_ICON_Show(ICON, ICON_StepE, 112, 417);
-      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+      DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
     }
     if (planner.flow_percentage[0] != flow) {
       flow = planner.flow_percentage[0];
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     }
   #endif
 
   #if HAS_HEATED_BED
     static float bed = -1;
     static int16_t bedtarget = -1;
     if (icons) {
       bed = -1;
       bedtarget = -1;
       DWIN_ICON_Show(ICON, ICON_BedTemp, 10, 416);
-      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+      DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     }
     if (thermalManager.temp_bed.celsius != bed) {
       bed = thermalManager.temp_bed.celsius;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 28, 417, thermalManager.temp_bed.celsius);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 3 * STAT_CHR_W + 5, 419);
     }
     if (thermalManager.temp_bed.target != bedtarget) {
       bedtarget = thermalManager.temp_bed.target;
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
-      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), 25 + 4 * STAT_CHR_W + 39, 419);
     }
   #endif
 
   #if HAS_FAN
     static uint8_t fan = -1;
     if (icons) {
       fan = -1;
       DWIN_ICON_Show(ICON, ICON_FanSpeed, 187, 383);
     }
     if (thermalManager.fan_speed[0] != fan) {
       fan = thermalManager.fan_speed[0];
-      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
     }
   #endif
 
   #if HAS_ZOFFSET_ITEM
     static float offset = -1;
 
-    if (icons) {
-      offset = -1;
+    #if HAS_MESH
+      static bool _leveling_active = false,
+                  _printing_leveling_active = false;
+      if (printingIsActive()) {
+        _printing_leveling_active = ((planner.leveling_active && planner.leveling_active_at_z(current_position.z)) || _printing_leveling_active );
+        if ((_printing_leveling_active = (planner.leveling_active && planner.leveling_active_at_z(current_position.z)) && ui.get_blink()))
+          DWIN_Draw_Rectangle(1, Def_SplitLine_Color, 186, 415, 205, 436);
+        else
+          DWIN_Draw_Rectangle(1, Def_Background_Color, 186, 415, 205, 436);
+      }
+      else {
+        _leveling_active = (planner.leveling_active || _leveling_active);
+        if ((_leveling_active = planner.leveling_active && ui.get_blink()))
+          DWIN_Draw_Rectangle(1, Def_SplitLine_Color, 186, 415, 205, 436);
+        else
+          DWIN_Draw_Rectangle(1, Def_Background_Color, 186, 415, 205, 436);
+      }
       DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
-    }
-    if (zoffsetvalue != offset) {
-      offset = zoffsetvalue;
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
+    #else
+      if (icons) DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
+    #endif
+    if (temp_val.zoffsetvalue != offset || icons) {
+      offset = temp_val.zoffsetvalue;
+      DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color),Def_Background_Color, 1, 2, 202, 417, temp_val.zoffsetvalue);
     }
   #endif
 
   static int16_t feedrate = -1;
   if (icons) {
     feedrate = -1;
     DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
-    DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+    DWINUI::Draw_String(DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
   }
   if (feedrate_percentage != feedrate) {
     feedrate = feedrate_percentage;
-    DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+    DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Def_Indicator_Color), Def_Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   }
 
   static float x = -1, y = -1, z = -1;
   static bool update_x = false, update_y = false, update_z = false;
   update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
   update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
   update_z = (current_position.z != z || axis_should_home(Z_AXIS) || update_z);
   if (icons) {
     x = y = z = -1;
-    DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
+    DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Def_SplitLine_Color, true), 16, 450, 256, 450);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
   }
   if (update_x) {
     x = current_position.x;
     if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
+      DWINUI::Draw_String(GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 39, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x);
+      DWINUI::Draw_Signed_Float(DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 3, 1, 31, 459, current_position.x);
   }
   if (update_y) {
     y = current_position.y;
     if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
+      DWINUI::Draw_String(GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 124, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
+      DWINUI::Draw_Signed_Float(DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 3, 1, 116, 459, current_position.y);
   }
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
+      DWINUI::Draw_String(GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 205, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z : 0);
+      DWINUI::Draw_Signed_Float(DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Def_Coordinate_Color), Def_Background_Color, 3, 2, 197, 459, current_position.z);
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
-  if (process != Confirm && process != Popup && process != Wait) last_process = process;
+  if (process != Confirm && process != Popup && process != Wait && process != Cancel) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
-  Clear_Screen();
-  DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
-  DWIN_Draw_Rectangle(1, Color_Bg_Window, 14, 60, 258, 350);
-  const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
+  if (popup != PrintConfirm) {
+    Clear_Screen();
+    DWIN_Draw_Rectangle(0, Def_Highlight_Color, 13, 59, 259, 346);
+    DWIN_Draw_Rectangle(1, Def_PopupBg_color, 14, 60, 258, 345);
+  }
+  else DWIN_Draw_Rectangle(1, Def_Background_Color, 0, 0, DWIN_WIDTH, STATUS_Y - 1);
+  const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : (mode == Cancel) ? 200 : 230;
   if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
+  if (line1) DWINUI::Draw_String(Def_PopupTxt_Color, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
+  if (line2) DWINUI::Draw_String(Def_PopupTxt_Color, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
+  if (line3) DWINUI::Draw_String(Def_PopupTxt_Color, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
   if (mode == Popup) {
     selection = 0;
-    DWIN_Draw_Rectangle(1, Confirm_Color, 26, 280, 125, 317);
-    DWIN_Draw_Rectangle(1, Cancel_Color, 146, 280, 245, 317);
-    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
-    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
+    DWINUI::Draw_Button(BTN_Confirm, 26, 280);
+    DWINUI::Draw_Button(BTN_Cancel, 146, 280);
     Popup_Select();
   }
-  else if (mode == Confirm) {
-    DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
-    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
-  }
+  else if (mode == Confirm) DWINUI::Draw_Button(BTN_Continue, 87, 280);
+  else if (mode == Cancel) DWINUI::Draw_Button(BTN_Cancel, 87, 280);
 }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
-  CrealityDWIN.Draw_Popup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
+  CrealityDWIN.Draw_Popup(GET_TEXT_F(MSG_KILLED), error, GET_TEXT_F(MSG_SWITCH_PS_OFF), Wait, ICON_BLTouch);
 }
 
 void CrealityDWINClass::Popup_Select() {
-  const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
-                 c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
+  const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Def_Highlight_Color) : Def_Background_Color,
+                 c2 = (selection == 0) ? Def_Background_Color : GetColor(eeprom_settings.highlight_box, Def_Highlight_Color);
   DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
   DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
   DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
   DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
 }
 
 void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
   static bool new_msg;
   static uint8_t msgscrl = 0;
-  static char lastmsg[64];
+  static char lastmsg[128];
   if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
     strcpy(lastmsg, statusmsg);
     msgscrl = 0;
     new_msg = true;
   }
   size_t len = strlen(statusmsg);
   int8_t pos = len;
-  if (pos > 30) {
+  if (pos > STATUS_CHAR_LIMIT) {
     pos -= msgscrl;
-    len = pos;
-    if (len > 30)
-      len = 30;
+    len = _MIN((size_t)pos, (size_t)STATUS_CHAR_LIMIT);
     char dispmsg[len + 1];
     if (pos >= 0) {
       LOOP_L_N(i, len) dispmsg[i] = statusmsg[i + msgscrl];
     }
     else {
-      LOOP_L_N(i, 30 + pos) dispmsg[i] = ' ';
-      LOOP_S_L_N(i, 30 + pos, 30) dispmsg[i] = statusmsg[i - (30 + pos)];
+      LOOP_L_N(i, STATUS_CHAR_LIMIT + pos) dispmsg[i] = ' ';
+      LOOP_S_L_N(i, STATUS_CHAR_LIMIT + pos, STATUS_CHAR_LIMIT) dispmsg[i] = statusmsg[i - (STATUS_CHAR_LIMIT + pos)];
     }
     dispmsg[len] = '\0';
     if (process == Print) {
-      DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
-      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
+      DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 214, DWIN_WIDTH - 8, 238);
+      const int8_t npos = (DWIN_WIDTH - STATUS_CHAR_LIMIT * MENU_CHR_W) / 2;
+      DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 219, dispmsg);
     }
     else {
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
-      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
+      DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 352, DWIN_WIDTH - 8, 376);
+      const int8_t npos = (DWIN_WIDTH - STATUS_CHAR_LIMIT * MENU_CHR_W) / 2;
+      DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 357, dispmsg);
     }
-    if (-pos >= 30) msgscrl = 0;
+    if (-pos >= STATUS_CHAR_LIMIT) msgscrl = 0;
     msgscrl++;
   }
   else {
     if (new_msg) {
       new_msg = false;
       if (process == Print) {
-        DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+        DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 214, DWIN_WIDTH - 8, 238);
         const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, statusmsg);
+        DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 219, statusmsg);
       }
       else {
-        DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+        DWIN_Draw_Rectangle(1, Def_StatusBg_Color, 8, 352, DWIN_WIDTH - 8, 376);
         const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
+        DWINUI::Draw_String(GetColor(eeprom_settings.status_bar_text, Def_StatusTxt_Color), Def_StatusBg_Color, npos, 357, statusmsg);
       }
     }
   }
 }
 
+#if HAS_HOSTACTION_MENUS
+
+  void CrealityDWINClass::Draw_Keyboard(bool restrict, bool numeric, uint8_t selected, bool uppercase/*=false*/, bool lock/*=false*/) {
+    process = Keyboard;
+    keyboard_restrict = restrict;
+    numeric_keyboard = numeric;
+    DWIN_Draw_Rectangle(0, Def_SplitLine_Color, 0, KEY_Y_START, DWIN_WIDTH-2, DWIN_HEIGHT-2);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 1, KEY_Y_START+1, DWIN_WIDTH-3, DWIN_HEIGHT-3);
+    LOOP_L_N(i, 36) Draw_Keys(i, (i == selected), uppercase, lock);
+  }
+
+  void CrealityDWINClass::Draw_Keys(uint8_t index, bool selected, bool uppercase/*=false*/, bool lock/*=false*/) {
+    const char *keys;
+    if (numeric_keyboard) keys = "1234567890&<>() {}[]*\"\':;!?";
+    else keys = (uppercase) ? "QWERTYUIOPASDFGHJKLZXCVBNM" : "qwertyuiopasdfghjklzxcvbnm";
+    #define KEY_X1(x) x*KEY_WIDTH+KEY_INSET+KEY_PADDING
+    #define KEY_X2(x) (x+1) * KEY_WIDTH+KEY_INSET-KEY_PADDING
+    #define KEY_Y1(y) KEY_Y_START+KEY_INSET+KEY_PADDING+y*KEY_HEIGHT
+    #define KEY_Y2(y) KEY_Y_START+KEY_INSET-KEY_PADDING+(y+1) * KEY_HEIGHT
+
+    const uint8_t rowCount[3] = { 10, 9, 7 };
+    const float xOffset[3] = { 0, 0.5f * KEY_WIDTH, 1.5f * KEY_WIDTH };
+
+    if (index < 28) {
+      if (index == 19) {
+        DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(0), KEY_Y1(2), KEY_X2(0) + xOffset[1], KEY_Y2(2));
+        DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(0) + 1, KEY_Y1(2) + 1, KEY_X2(0) + xOffset[1] - 1, KEY_Y2(2) - 1);
+        if (!numeric_keyboard) {
+          if (lock) {
+            DWIN_Draw_Line(Def_Selected_Color, KEY_X1(0) + 17, KEY_Y1(2) + 16, KEY_X1(0) + 25, KEY_Y1(2) + 8);
+            DWIN_Draw_Line(Def_Selected_Color, KEY_X1(0) + 17, KEY_Y1(2) + 16, KEY_X1(0) + 9, KEY_Y1(2) + 8);
+          }
+          else {
+            DWIN_Draw_Line((uppercase) ? Def_Selected_Color : Def_Text_Color, KEY_X1(0) + 17, KEY_Y1(2) + 8, KEY_X1(0) + 25, KEY_Y1(2) + 16);
+            DWIN_Draw_Line((uppercase) ? Def_Selected_Color : Def_Text_Color, KEY_X1(0) + 17, KEY_Y1(2) + 8, KEY_X1(0) + 9, KEY_Y1(2) + 16);
+          }
+        }
+      }
+      else if (index == 27) {
+        DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(7) + xOffset[2], KEY_Y1(2), KEY_X2(9), KEY_Y2(2));
+        DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(7) + xOffset[2] + 1, KEY_Y1(2) + 1, KEY_X2(9) - 1, KEY_Y2(2) - 1);
+        DWINUI::Draw_String(Color_Red, KEY_X1(7) + xOffset[2] + 3, KEY_Y1(2) + 5, F("<--"));
+      }
+      else {
+        if (index > 19) index--;
+        if (index > 27) index--;
+        uint8_t y, x;
+        if (index < rowCount[0]) y = 0, x = index;
+        else if (index < (rowCount[0] + rowCount[1])) y = 1, x = index-rowCount[0];
+        else y = 2, x = index-(rowCount[0] + rowCount[1]);
+        const char keyStr[2] = {keys[(y > 0) * rowCount[0] + (y > 1) * rowCount[1] + x], '\0'};
+        DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(x) + xOffset[y], KEY_Y1(y), KEY_X2(x) + xOffset[y], KEY_Y2(y));
+        DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(x) + xOffset[y] + 1, KEY_Y1(y) + 1, KEY_X2(x) + xOffset[y] - 1, KEY_Y2(y) - 1);
+        DWINUI::Draw_String(KEY_X1(x) + xOffset[y] + 5, KEY_Y1(y) + 5, keyStr);
+        if (keyboard_restrict && numeric_keyboard && index > 9) {
+          DWIN_Draw_Line(Color_Light_Red, KEY_X1(x) + xOffset[y] + 1, KEY_Y1(y) + 1, KEY_X2(x) + xOffset[y] - 1, KEY_Y2(y) - 1);
+          DWIN_Draw_Line(Color_Light_Red, KEY_X1(x) + xOffset[y] + 1, KEY_Y2(y) - 1, KEY_X2(x) + xOffset[y] - 1, KEY_Y1(y) + 1);
+        }
+      }
+    }
+    else {
+      switch (index) {
+        case 28:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(0), KEY_Y1(3), KEY_X2(0) + xOffset[1], KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(0) + 1, KEY_Y1(3) + 1, KEY_X2(0) + xOffset[1] - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(KEY_X1(0) - 1, KEY_Y1(3) + 5, F("?123"));
+          break;
+        case 29:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(1) + xOffset[1], KEY_Y1(3), KEY_X2(1) + xOffset[1], KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(1) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(1) + xOffset[1] - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(KEY_X1(1) + xOffset[1] + 5, KEY_Y1(3) + 5, F("-"));
+          break;
+        case 30:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(2) + xOffset[1], KEY_Y1(3), KEY_X2(2) + xOffset[1], KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(2) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(2) + xOffset[1] - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(KEY_X1(2) + xOffset[1] + 5, KEY_Y1(3) + 5, F("_"));
+          break;
+        case 31:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(3) + xOffset[1], KEY_Y1(3), KEY_X2(5) + xOffset[1], KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(3) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(5) + xOffset[1] - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(KEY_X1(3) + xOffset[1] + 14, KEY_Y1(3) + 5, F("Space"));
+          if (keyboard_restrict) {
+            DWIN_Draw_Line(Color_Light_Red, KEY_X1(3) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(5) + xOffset[1] - 1, KEY_Y2(3) - 1);
+            DWIN_Draw_Line(Color_Light_Red, KEY_X1(3) + xOffset[1] + 1, KEY_Y2(3) - 1, KEY_X2(5) + xOffset[1] - 1, KEY_Y1(3) + 1);
+          }
+          break;
+        case 32:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(6) + xOffset[1], KEY_Y1(3), KEY_X2(6) + xOffset[1], KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(6) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(6) + xOffset[1] - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(KEY_X1(6) + xOffset[1] + 7, KEY_Y1(3) + 5, F("."));
+          if (keyboard_restrict) {
+            DWIN_Draw_Line(Color_Light_Red, KEY_X1(6) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(6) + xOffset[1] - 1, KEY_Y2(3) - 1);
+            DWIN_Draw_Line(Color_Light_Red, KEY_X1(6) + xOffset[1] + 1, KEY_Y2(3) - 1, KEY_X2(6) + xOffset[1] - 1, KEY_Y1(3) + 1);
+          }
+          break;
+        case 33:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(7) + xOffset[1], KEY_Y1(3), KEY_X2(7) + xOffset[1], KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(7) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(7) + xOffset[1] - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(KEY_X1(7) + xOffset[1] + 4, KEY_Y1(3) + 5, F("/"));
+          if (keyboard_restrict) {
+            DWIN_Draw_Line(Color_Light_Red, KEY_X1(7) + xOffset[1] + 1, KEY_Y1(3) + 1, KEY_X2(7) + xOffset[1] - 1, KEY_Y2(3) - 1);
+            DWIN_Draw_Line(Color_Light_Red, KEY_X1(7) + xOffset[1] + 1, KEY_Y2(3) - 1, KEY_X2(7) + xOffset[1] - 1, KEY_Y1(3) + 1);
+          }
+          break;
+        case 34:
+          DWIN_Draw_Rectangle(0, Color_Light_Blue, KEY_X1(7) + xOffset[2], KEY_Y1(3), KEY_X2(9), KEY_Y2(3));
+          DWIN_Draw_Rectangle(0, (selected) ? Def_Selected_Color : Def_Background_Color, KEY_X1(7) + xOffset[2] + 1, KEY_Y1(3) + 1, KEY_X2(9) - 1, KEY_Y2(3) - 1);
+          DWINUI::Draw_String(Color_Cyan, KEY_X1(7) + xOffset[2] + 3, KEY_Y1(3) + 5, F("-->"));
+          break;
+      }
+    }
+  }
+#endif // HAS_HOSTACTION_MENUS
+
 /* Menu Item Config */
 
 void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
   const uint8_t row = item - scrollpos;
   #if HAS_LEVELING
     static bool level_state;
   #endif
 
   #if HAS_PREHEAT
 
     #define PREHEAT_BACK 0
     #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
     #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
     #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
     #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
 
     auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
       switch (item) {
         case PREHEAT_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(TempMenu, sel);
           break;
         #if HAS_HOTEND
           case PREHEAT_SUBMENU_HOTEND:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
               Draw_Float(ui.material_preset[index].hotend_temp, row, false, 1);
             }
             else
@@ -1067,21 +1254,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
               Draw_Float(ui.material_preset[index].bed_temp, row, false, 1);
             }
             else
               Modify_Value(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case PREHEAT_SUBMENU_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
               Draw_Float(ui.material_preset[index].fan_speed, row, false, 1);
             }
             else
               Modify_Value(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
       }
     };
 
   #endif
@@ -1091,51 +1278,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
       #define PREPARE_COOLDOWN (PREPARE_PREHEAT + EITHER(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
-      #define PREPARE_CUSTOM_MENU (PREPARE_CHANGEFIL + ENABLED(HAS_CUSTOM_MENU))
-      #define PREPARE_TOTAL PREPARE_CUSTOM_MENU
+      #define PREPARE_ACTIONCOMMANDS (PREPARE_CHANGEFIL + ENABLED(HAS_HOSTACTION_MENUS))
+      #define PREPARE_CUSTOM_MENU (PREPARE_ACTIONCOMMANDS + ENABLED(HAS_CUSTOM_MENU))
+      #define PREPARE_TOTAL PREPARE_ACTIONCOMMANDS
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Main_Menu(1);
           break;
         case PREPARE_MOVE:
           if (draw)
-            Draw_Menu_Item(row, ICON_Axis, F("Move"), nullptr, true);
+            Draw_Menu_Item(row, ICON_Axis, GET_TEXT_F(MSG_MOVE_AXIS), nullptr, true);
           else
             Draw_Menu(Move);
           break;
         case PREPARE_DISABLE:
           if (draw)
-            Draw_Menu_Item(row, ICON_CloseMotor, F("Disable Stepper"));
+            Draw_Menu_Item(row, ICON_CloseMotor, GET_TEXT_F(MSG_DISABLE_STEPPERS));
           else
             queue.inject(F("M84"));
           break;
         case PREPARE_HOME:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Homing"), nullptr, true);
+            Draw_Menu_Item(row, ICON_SetHome, GET_TEXT_F(MSG_HOMING), nullptr, true);
           else
             Draw_Menu(HomeMenu);
           break;
         case PREPARE_MANUALLEVEL:
           if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
+            Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_BED_TRAMMING_MANUAL), nullptr, true);
           else {
             if (axes_should_home()) {
               Popup_Handler(Home);
               gcode.home_all_axes(true);
             }
             #if HAS_LEVELING
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
             #endif
             Draw_Menu(ManualLevel);
@@ -1161,42 +1349,53 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             if (draw)
               Draw_Menu_Item(row, ICON_Temperature, F("Preheat"), nullptr, true);
             else
               Draw_Menu(Preheat);
             break;
         #endif
 
         #if HAS_HOTEND || HAS_HEATED_BED
           case PREPARE_COOLDOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_Cool, F("Cooldown"));
-            else
+              Draw_Menu_Item(row, ICON_Cool, GET_TEXT_F(MSG_COOLDOWN));
+            else {
               thermalManager.cooldown();
+              Update_Status(GET_TEXT(MSG_COOLDOWN));
+            }
             break;
         #endif
 
+        #if HAS_HOSTACTION_MENUS
+          case PREPARE_ACTIONCOMMANDS:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, F("Host Actions"), nullptr, true);
+          else
+            Draw_Menu(HostActions);
+          break;
+        #endif
+
         #if HAS_CUSTOM_MENU
           case PREPARE_CUSTOM_MENU:
             #ifndef CUSTOM_MENU_CONFIG_TITLE
               #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
             #endif
             if (draw)
               Draw_Menu_Item(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
             else
               Draw_Menu(MenuCustom);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament")
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE)
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 Draw_Menu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
@@ -1223,66 +1422,66 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define HOME_ALL   (HOME_BACK + 1)
       #define HOME_X     (HOME_ALL + 1)
       #define HOME_Y     (HOME_X + 1)
       #define HOME_Z     (HOME_Y + 1)
       #define HOME_SET   (HOME_Z + 1)
       #define HOME_TOTAL HOME_SET
 
       switch (item) {
         case HOME_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Prepare, PREPARE_HOME);
           break;
         case HOME_ALL:
           if (draw)
-            Draw_Menu_Item(row, ICON_Homing, F("Home All"));
+            Draw_Menu_Item(row, ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME));
           else {
             Popup_Handler(Home);
             gcode.home_all_axes(true);
             Redraw_Menu();
           }
           break;
         case HOME_X:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveX, F("Home X"));
+            Draw_Menu_Item(row, ICON_MoveX, GET_TEXT_F(MSG_AUTO_HOME_X));
           else {
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 X"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_Y:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveY, F("Home Y"));
+            Draw_Menu_Item(row, ICON_MoveY, GET_TEXT_F(MSG_AUTO_HOME_Y));
           else {
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 Y"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_Z:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveZ, F("Home Z"));
+            Draw_Menu_Item(row, ICON_MoveZ, GET_TEXT_F(MSG_AUTO_HOME_Z));
           else {
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 Z"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_SET:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Set Home Position"));
+            Draw_Menu_Item(row, ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS));
           else {
             gcode.process_subcommands_now(F("G92X0Y0Z0"));
             AudioFeedback();
           }
           break;
       }
       break;
 
     case Move:
 
@@ -1291,264 +1490,285 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define MOVE_Y (MOVE_X + 1)
       #define MOVE_Z (MOVE_Y + 1)
       #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
       #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
       #define MOVE_LIVE (MOVE_P + 1)
       #define MOVE_TOTAL MOVE_LIVE
 
       switch (item) {
         case MOVE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else {
             #if HAS_BED_PROBE
-              probe_deployed = false;
-              probe.set_deployed(probe_deployed);
+              temp_val.probe_deployed = false;
+              probe.set_deployed(temp_val.probe_deployed);
             #endif
             Draw_Menu(Prepare, PREPARE_MOVE);
           }
           break;
         case MOVE_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveX, F("Move X"));
+            Draw_Menu_Item(row, ICON_MoveX, GET_TEXT_F(MSG_MOVE_X));
             Draw_Float(current_position.x, row, false);
           }
           else
             Modify_Value(current_position.x, X_MIN_POS, X_MAX_POS, 10);
           break;
         case MOVE_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveY, F("Move Y"));
+            Draw_Menu_Item(row, ICON_MoveY, GET_TEXT_F(MSG_MOVE_Y));
             Draw_Float(current_position.y, row);
           }
           else
             Modify_Value(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
           break;
         case MOVE_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveZ, F("Move Z"));
+            Draw_Menu_Item(row, ICON_MoveZ, GET_TEXT_F(MSG_MOVE_Z));
             Draw_Float(current_position.z, row);
           }
           else
             Modify_Value(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
           break;
 
         #if HAS_HOTEND
           case MOVE_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, F("Extruder"));
+              Draw_Menu_Item(row, ICON_Extruder, GET_TEXT_F(MSG_MOVE_E));
               current_position.e = 0;
               sync_plan_position();
               Draw_Float(current_position.e, row);
             }
             else {
-              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
-              }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                   Redraw_Menu();
                 }
                 current_position.e = 0;
                 sync_plan_position();
                 Modify_Value(current_position.e, -500, 500, 10);
               }
             }
           break;
         #endif // HAS_HOTEND
 
         #if HAS_BED_PROBE
           case MOVE_P:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, F("Probe"));
-              Draw_Checkbox(row, probe_deployed);
+              Draw_Menu_Item(row, ICON_ProbeDeploy, GET_TEXT_F(MSG_MANUAL_DEPLOY));
+              Draw_Checkbox(row, temp_val.probe_deployed);
             }
             else {
-              probe_deployed = !probe_deployed;
-              probe.set_deployed(probe_deployed);
-              Draw_Checkbox(row, probe_deployed);
+              temp_val.probe_deployed = !temp_val.probe_deployed;
+              probe.set_deployed(temp_val.probe_deployed);
+              Draw_Checkbox(row, temp_val.probe_deployed);
             }
             break;
         #endif
 
         case MOVE_LIVE:
           if (draw) {
             Draw_Menu_Item(row, ICON_Axis, F("Live Movement"));
-            Draw_Checkbox(row, livemove);
+            Draw_Checkbox(row, temp_val.livemove);
           }
           else {
-            livemove = !livemove;
-            Draw_Checkbox(row, livemove);
+            temp_val.livemove = !temp_val.livemove;
+            Draw_Checkbox(row, temp_val.livemove);
           }
           break;
       }
       break;
     case ManualLevel:
 
       #define MLEVEL_BACK 0
       #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
-      #define MLEVEL_BL (MLEVEL_PROBE + 1)
-      #define MLEVEL_TL (MLEVEL_BL + 1)
-      #define MLEVEL_TR (MLEVEL_TL + 1)
-      #define MLEVEL_BR (MLEVEL_TR + 1)
-      #define MLEVEL_C (MLEVEL_BR + 1)
+      #define MLEVEL_FL (MLEVEL_PROBE + 1)
+      #define MLEVEL_BL (MLEVEL_FL + 1)
+      #define MLEVEL_BR (MLEVEL_BL + 1)
+      #define MLEVEL_FR (MLEVEL_BR + 1)
+      #define MLEVEL_C (MLEVEL_FR + 1)
       #define MLEVEL_ZPOS (MLEVEL_C + 1)
       #define MLEVEL_TOTAL MLEVEL_ZPOS
 
       static float mlev_z_pos = 0;
       static bool use_probe = false;
 
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
             Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
           }
           break;
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
               Draw_Checkbox(row, use_probe);
             }
             else {
               use_probe = !use_probe;
               Draw_Checkbox(row, use_probe);
               if (use_probe) {
                 Popup_Handler(Level);
-                corner_avg = 0;
-                #define PROBE_X_MIN _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x
-                #define PROBE_X_MAX _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x
-                #define PROBE_Y_MIN _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y
-                #define PROBE_Y_MAX _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y
-                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MIN, PROBE_PT_RAISE, 0, false);
-                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
-                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
-                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
-                corner_avg /= 4;
+                do_z_clearance(Z_HOMING_HEIGHT);
+                temp_val.corner_avg = 0;
+                #define PROBE_X_MIN _MAX(temp_val.corner_pos, PROBING_MARGIN, MESH_MIN_X) - probe.offset.x
+                #define PROBE_X_MAX _MIN(X_BED_SIZE - temp_val.corner_pos, X_BED_SIZE - PROBING_MARGIN, MESH_MAX_X) - probe.offset.x
+                #define PROBE_Y_MIN _MAX(temp_val.corner_pos, PROBING_MARGIN, MESH_MIN_Y) - probe.offset.y
+                #define PROBE_Y_MAX _MIN(Y_BED_SIZE - temp_val.corner_pos, Y_BED_SIZE - PROBING_MARGIN, MESH_MAX_Y) - probe.offset.y
+                temp_val.zval = probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MIN, PROBE_PT_RAISE, 0, false);
+                const char * MSG_UNREACHABLE = "Position unreachable. Check Probe Offsets and Bed Screw Inset.";
+                if (isnan(temp_val.zval)) {
+                  Update_Status(MSG_UNREACHABLE);
+                  Redraw_Menu();
+                }
+                temp_val.corner_avg += temp_val.zval;
+                temp_val.zval = probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
+                if (isnan(temp_val.zval)) {
+                  Update_Status(MSG_UNREACHABLE);
+                  Redraw_Menu();
+                }
+                temp_val.corner_avg += temp_val.zval;
+                temp_val.zval = probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
+                if (isnan(temp_val.zval)) {
+                  Update_Status(MSG_UNREACHABLE);
+                  Redraw_Menu();
+                }
+                temp_val.corner_avg += temp_val.zval;
+                temp_val.zval = probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
+                if (isnan(temp_val.zval)) {
+                  Update_Status(MSG_UNREACHABLE);
+                  Redraw_Menu();
+                }
+                temp_val.corner_avg += temp_val.zval;
+                temp_val.corner_avg /= 4;
                 Redraw_Menu();
               }
             }
             break;
         #endif
-        case MLEVEL_BL:
+        case MLEVEL_FL:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisBL, F("Bottom Left"));
+            Draw_Menu_Item(row, ICON_AxisBL, GET_TEXT_F(MSG_LEVBED_FL));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(temp_val.corner_pos, 1, 3, str_1), dtostrf(temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
-        case MLEVEL_TL:
+        case MLEVEL_BL:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisTL, F("Top Left"));
+            Draw_Menu_Item(row, ICON_AxisTL, GET_TEXT_F(MSG_LEVBED_BL));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(temp_val.corner_pos, 1, 3, str_1), dtostrf(Y_BED_SIZE - temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
-        case MLEVEL_TR:
+        case MLEVEL_BR:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisTR, F("Top Right"));
+            Draw_Menu_Item(row, ICON_AxisTR, GET_TEXT_F(MSG_LEVBED_BR));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(X_BED_SIZE - temp_val.corner_pos, 1, 3, str_1), dtostrf(Y_BED_SIZE - temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
-        case MLEVEL_BR:
+        case MLEVEL_FR:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisBR, F("Bottom Right"));
+            Draw_Menu_Item(row, ICON_AxisBR, GET_TEXT_F(MSG_LEVBED_FR));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(X_BED_SIZE - temp_val.corner_pos, 1, 3, str_1), dtostrf(temp_val.corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisC, F("Center"));
+            Draw_Menu_Item(row, ICON_AxisC, GET_TEXT_F(MSG_LEVBED_C));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
-                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf((PROBE_X_MIN + PROBE_X_MAX) / 2.0f, 1, 3, str_1), dtostrf((PROBE_Y_MIN + PROBE_Y_MAX) / 2.0f, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
-              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(X_BED_SIZE / 2.0f, 1, 3, str_1), dtostrf(Y_BED_SIZE / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_ZPOS:
           if (draw) {
-            Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
+            Draw_Menu_Item(row, ICON_SetZOffset, GET_TEXT_F(MSG_MOVE_Z));
             Draw_Float(mlev_z_pos, row, false, 100);
           }
           else
             Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
           break;
       }
       break;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:
 
@@ -1557,239 +1777,275 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
         #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
         #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
         #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
         #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
         #define ZOFFSET_TOTAL ZOFFSET_SAVE
 
         switch (item) {
           case ZOFFSET_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else {
-              liveadjust = false;
+              temp_val.zoffsetmode = 0;
+              #if !HAS_BED_PROBE
+                gcode.process_subcommands_now(F("M211 S1"));  // Soft end-stops
+              #endif
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
               Draw_Menu(Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
-              Draw_Menu_Item(row, ICON_Homing, F("Home Z Axis"));
+              Draw_Menu_Item(row, ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME_Z));
             else {
               Popup_Handler(Home);
               gcode.process_subcommands_now(F("G28 Z"));
               Popup_Handler(MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
               #else
-                gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
+                sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2));
+                gcode.process_subcommands_now(cmd);
               #endif
               gcode.process_subcommands_now(F("G0 F300 Z0"));
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case ZOFFSET_MODE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, F("Live Adjustment"));
-              Draw_Checkbox(row, liveadjust);
-            }
-            else {
-              if (!liveadjust) {
-                if (axes_should_home()) {
-                  Popup_Handler(Home);
-                  gcode.home_all_axes(true);
-                }
-                Popup_Handler(MoveWait);
-                #if ENABLED(Z_SAFE_HOMING)
-                  planner.synchronize();
-                  sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-                  gcode.process_subcommands_now(cmd);
-                #else
-                  gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
-                #endif
-                gcode.process_subcommands_now(F("G0 F300 Z0"));
-                planner.synchronize();
-                Redraw_Menu();
-              }
-              liveadjust = !liveadjust;
-              Draw_Checkbox(row, liveadjust);
+              Draw_Option(temp_val.zoffsetmode, zoffset_modes, row);
             }
+            else
+              Modify_Option(temp_val.zoffsetmode, zoffset_modes, 2);
             break;
           case ZOFFSET_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Z Offset"));
-              Draw_Float(zoffsetvalue, row, false, 100);
+              Draw_Float(temp_val.zoffsetvalue, row, false, 100);
             }
             else
-              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              Modify_Value(temp_val.zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case ZOFFSET_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
             else {
-              if (zoffsetvalue < MAX_Z_OFFSET) {
-                if (liveadjust) {
+              if (temp_val.zoffsetvalue < MAX_Z_OFFSET) {
+                if (temp_val.zoffsetmode != 0) {
                   gcode.process_subcommands_now(F("M290 Z0.01"));
                   planner.synchronize();
                 }
-                zoffsetvalue += 0.01;
-                Draw_Float(zoffsetvalue, row - 1, false, 100);
+                temp_val.zoffsetvalue += 0.01;
+                Draw_Float(temp_val.zoffsetvalue, row - 1, false, 100);
               }
             }
             break;
           case ZOFFSET_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
             else {
-              if (zoffsetvalue > MIN_Z_OFFSET) {
-                if (liveadjust) {
+              if (temp_val.zoffsetvalue > MIN_Z_OFFSET) {
+                if (temp_val.zoffsetmode != 0) {
                   gcode.process_subcommands_now(F("M290 Z-0.01"));
                   planner.synchronize();
                 }
-                zoffsetvalue -= 0.01;
-                Draw_Float(zoffsetvalue, row - 2, false, 100);
+                temp_val.zoffsetvalue -= 0.01;
+                Draw_Float(temp_val.zoffsetvalue, row - 2, false, 100);
               }
             }
             break;
           #if ENABLED(EEPROM_SETTINGS)
             case ZOFFSET_SAVE:
               if (draw)
-                Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save"));
+                Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_BUTTON_SAVE));
               else
                 AudioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
 
     #if HAS_PREHEAT
       case Preheat: {
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
         #define PREHEAT_1 (PREHEAT_MODE + 1)
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
         auto do_preheat = [](const uint8_t m) {
           thermalManager.cooldown();
-          if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
-          if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
+          if (temp_val.preheatmode == 0 || temp_val.preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
+          if (temp_val.preheatmode == 0 || temp_val.preheatmode == 2) ui.preheat_bed(m);
         };
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(Prepare, PREPARE_PREHEAT);
             break;
 
           case PREHEAT_MODE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
-              Draw_Option(preheatmode, preheat_modes, row);
+              Draw_Menu_Item(row, ICON_Homing, GET_TEXT_F(MSG_CONFIGURATION));
+              Draw_Option(temp_val.preheatmode, preheat_modes, row);
             }
             else
-              Modify_Option(preheatmode, preheat_modes, 2);
+              Modify_Option(temp_val.preheatmode, preheat_modes, 2);
             break;
 
           #define _PREHEAT_CASE(N) \
             case PREHEAT_##N: { \
               if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
               else do_preheat(N - 1); \
             } break;
 
           REPEAT_1(PREHEAT_COUNT, _PREHEAT_CASE)
         }
       } break;
     #endif // HAS_PREHEAT
 
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:
 
         #define CHANGEFIL_BACK 0
-        #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
+        #define CHANGEFIL_PARKHEAD (CHANGEFIL_BACK + 1)
+        #define CHANGEFIL_LOAD (CHANGEFIL_PARKHEAD + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
         #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
         #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
 
         switch (item) {
           case CHANGEFIL_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(Prepare, PREPARE_CHANGEFIL);
             break;
+          case CHANGEFIL_PARKHEAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Park, GET_TEXT_F(MSG_FILAMENT_PARK_ENABLED));
+            else {
+              #if ENABLED(NOZZLE_PARK_FEATURE)
+                queue.inject(F("G28O\nG27 P2"));
+              #else
+                sprintf_P(cmd, PSTR("G28O\nG0 F4000 X%i Y%i\nG0 F3000 Z%i"), 0 , 0, 20);
+                queue.inject(cmd);
+              #endif
+            }
+            break;
           case CHANGEFIL_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Filament"));
+              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENTLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Filament"));
+              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENTUNLOAD));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                 gcode.process_subcommands_now(cmd);
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
+    #if HAS_HOSTACTION_MENUS
+      case HostActions:
+
+        #define HOSTACTIONS_BACK 0
+        #define HOSTACTIONS_1 (HOSTACTIONS_BACK + 1)
+        #define HOSTACTIONS_2 (HOSTACTIONS_1 + 1)
+        #define HOSTACTIONS_3 (HOSTACTIONS_2 + 1)
+        #define HOSTACTIONS_TOTAL HOSTACTIONS_3
+
+        switch (item) {
+          case HOSTACTIONS_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+            else {
+              if (temp_val.flag_tune) {
+                temp_val.flag_tune = false;
+                Redraw_Menu(false, true, true);
+              }
+              else
+                Draw_Menu(Prepare, PREPARE_ACTIONCOMMANDS);
+            }
+            break;
+          case HOSTACTIONS_1:
+            if (draw) Draw_Menu_Item(row, ICON_File, action1);
+            else if (!strcmp(action1, "-") == 0) hostui.action(F(action1));
+            break;
+          case HOSTACTIONS_2:
+            if (draw) Draw_Menu_Item(row, ICON_File, action2);
+            else if (!strcmp(action2, "-") == 0) hostui.action(F(action2));
+            break;
+          case HOSTACTIONS_3:
+            if (draw) Draw_Menu_Item(row, ICON_File, action3);
+            else if (!strcmp(action3, "-") == 0) hostui.action(F(action3));
+            break;
+        }
+        break;
+    #endif
+
     #if HAS_CUSTOM_MENU
 
       case MenuCustom:
 
         #define CUSTOM_MENU_BACK 0
         #define CUSTOM_MENU_1 1
         #define CUSTOM_MENU_2 2
         #define CUSTOM_MENU_3 3
         #define CUSTOM_MENU_4 4
         #define CUSTOM_MENU_5 5
@@ -1901,84 +2157,118 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         }
         break;
 
     #endif // HAS_CUSTOM_MENU
 
     case Control:
 
       #define CONTROL_BACK 0
       #define CONTROL_TEMP (CONTROL_BACK + 1)
       #define CONTROL_MOTION (CONTROL_TEMP + 1)
-      #define CONTROL_VISUAL (CONTROL_MOTION + 1)
-      #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
+      #define CONTROL_FWRETRACT (CONTROL_MOTION + ENABLED(FWRETRACT))
+      #define CONTROL_LEDS (CONTROL_FWRETRACT + ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU))
+      #define CONTROL_VISUAL (CONTROL_LEDS + 1)
+      #define CONTROL_HOSTSETTINGS (CONTROL_VISUAL + ENABLED(HAS_HOSTACTION_MENUS))
+      #define CONTROL_ADVANCED (CONTROL_HOSTSETTINGS + 1)
       #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
-      #define CONTROL_INFO (CONTROL_RESET + 1)
+      #define CONTROL_REBOOT (CONTROL_RESET + 1)
+      #define CONTROL_INFO (CONTROL_REBOOT + 1)
       #define CONTROL_TOTAL CONTROL_INFO
 
       switch (item) {
         case CONTROL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Main_Menu(2);
           break;
         case CONTROL_TEMP:
           if (draw)
-            Draw_Menu_Item(row, ICON_Temperature, F("Temperature"), nullptr, true);
+            Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), nullptr, true);
           else
             Draw_Menu(TempMenu);
           break;
         case CONTROL_MOTION:
           if (draw)
-            Draw_Menu_Item(row, ICON_Motion, F("Motion"), nullptr, true);
+            Draw_Menu_Item(row, ICON_Motion, GET_TEXT_F(MSG_MOTION), nullptr, true);
           else
             Draw_Menu(Motion);
           break;
+        #if ENABLED(FWRETRACT)
+          case CONTROL_FWRETRACT:
+          if (draw)
+            Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_AUTORETRACT), nullptr, true);
+          else
+            Draw_Menu(FwRetraction);
+          break;
+        #endif
+        #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
+          case CONTROL_LEDS:
+            if (draw)
+              Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LEDS), nullptr, true);
+            else
+              Draw_Menu(Ledsmenu);
+            break;
+        #endif
         case CONTROL_VISUAL:
           if (draw)
             Draw_Menu_Item(row, ICON_PrintSize, F("Visual"), nullptr, true);
           else
             Draw_Menu(Visual);
           break;
+        #if HAS_HOSTACTION_MENUS
+          case CONTROL_HOSTSETTINGS:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Contact, F("Host Settings"), nullptr, true);
+            else
+              Draw_Menu(HostSettings);
+            break;
+        #endif
         case CONTROL_ADVANCED:
           if (draw)
-            Draw_Menu_Item(row, ICON_Version, F("Advanced"), nullptr, true);
+            Draw_Menu_Item(row, ICON_Version, GET_TEXT_F(MSG_ADVANCED_SETTINGS), nullptr, true);
           else
             Draw_Menu(Advanced);
           break;
         #if ENABLED(EEPROM_SETTINGS)
           case CONTROL_SAVE:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Store Settings"));
+              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM));
             else
               AudioFeedback(settings.save());
             break;
           case CONTROL_RESTORE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Restore Settings"));
+              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM));
             else
               AudioFeedback(settings.load());
             break;
           case CONTROL_RESET:
             if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, F("Reset to Defaults"));
+              Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_RESTORE_DEFAULTS));
             else {
               settings.reset();
               AudioFeedback();
             }
             break;
         #endif
+        case CONTROL_REBOOT:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Reboot, GET_TEXT_F(MSG_RESET_PRINTER));
+          else
+            RebootPrinter();
+          break;
         case CONTROL_INFO:
           if (draw)
-            Draw_Menu_Item(row, ICON_Info, F("Info"));
+            Draw_Menu_Item(row, ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN));
           else
             Draw_Menu(Info);
           break;
       }
       break;
 
     case TempMenu:
 
       #define TEMP_BACK 0
       #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
@@ -1988,21 +2278,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
       #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
       #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
       #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
       #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
       #define TEMP_TOTAL TEMP_PREHEAT5
 
       switch (item) {
         case TEMP_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Control, CONTROL_TEMP);
           break;
         #if HAS_HOTEND
           case TEMP_HOTEND:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
@@ -2015,21 +2305,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
               Draw_Float(thermalManager.temp_bed.target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case TEMP_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
               Draw_Float(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
         #if HAS_HOTEND || HAS_HEATED_BED
           case TEMP_PID:
             if (draw)
               Draw_Menu_Item(row, ICON_Step, F("PID"), nullptr, true);
@@ -2055,90 +2345,88 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
         #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
         switch (item) {
           case PID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(TempMenu, TEMP_PID);
             break;
           #if HAS_HOTEND
             case PID_HOTEND:
               if (draw)
-                Draw_Menu_Item(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
+                Draw_Menu_Item(row, ICON_HotendTemp, F(STR_HOTEND_PID), nullptr, true);
               else
                 Draw_Menu(HotendPID);
               break;
           #endif
           #if HAS_HEATED_BED
             case PID_BED:
               if (draw)
-                Draw_Menu_Item(row, ICON_BedTemp, F("Bed"), nullptr, true);
+                Draw_Menu_Item(row, ICON_BedTemp, F(STR_BED_PID), nullptr, true);
               else
                 Draw_Menu(BedPID);
               break;
           #endif
           case PID_CYCLES:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Cycles"));
+              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_PID_CYCLE));
               Draw_Float(PID_cycles, row, false, 1);
             }
             else
               Modify_Value(PID_cycles, 3, 50, 1);
             break;
         }
         break;
     #endif // HAS_HOTEND || HAS_HEATED_BED
 
     #if HAS_HOTEND
       case HotendPID:
 
         #define HOTENDPID_BACK 0
         #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
         #define HOTENDPID_TEMP (HOTENDPID_TUNE + 1)
         #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
         #define HOTENDPID_KI (HOTENDPID_KP + 1)
         #define HOTENDPID_KD (HOTENDPID_KI + 1)
         #define HOTENDPID_TOTAL HOTENDPID_KD
 
-        static uint16_t PID_e_temp = 180;
-
         switch (item) {
           case HOTENDPID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
+              Draw_Menu_Item(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
             else {
               Popup_Handler(PIDWait);
-              sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
+              sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, temp_val.PID_e_temp);
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
-              Draw_Float(PID_e_temp, row, false, 1);
+              Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE));
+              Draw_Float(temp_val.PID_e_temp, row, false, 1);
             }
             else
-              Modify_Value(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              Modify_Value(temp_val.PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
           case HOTENDPID_KP:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
               Draw_Float(thermalManager.temp_hotend[0].pid.Kp, row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KI:
@@ -2165,56 +2453,53 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       case BedPID:
 
         #define BEDPID_BACK 0
         #define BEDPID_TUNE (BEDPID_BACK + 1)
         #define BEDPID_TEMP (BEDPID_TUNE + 1)
         #define BEDPID_KP (BEDPID_TEMP + 1)
         #define BEDPID_KI (BEDPID_KP + 1)
         #define BEDPID_KD (BEDPID_KI + 1)
         #define BEDPID_TOTAL BEDPID_KD
 
-        static uint16_t PID_bed_temp = 60;
-
         switch (item) {
           case BEDPID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
+              Draw_Menu_Item(row, ICON_HotendTemp, GET_TEXT_F(MSG_PID_AUTOTUNE));
             else {
               Popup_Handler(PIDWait);
-              sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
+              sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, temp_val.PID_bed_temp);
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
-              Draw_Float(PID_bed_temp, row, false, 1);
+              Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE));
+              Draw_Float(temp_val.PID_bed_temp, row, false, 1);
             }
             else
-              Modify_Value(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              Modify_Value(temp_val.PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
           case BEDPID_KP:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
               Draw_Float(thermalManager.temp_bed.pid.Kp, row, false, 100);
             }
-            else {
+            else
               Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
-            }
             break;
           case BEDPID_KI:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
               Draw_Float(unscalePID_i(thermalManager.temp_bed.pid.Ki), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case BEDPID_KD:
@@ -2234,159 +2519,261 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
     case Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
-      #define MOTION_STEPS (MOTION_JERK + 1)
+      #define MOTION_JD (MOTION_JERK + ENABLED(HAS_JUNCTION_DEVIATION))
+      #define MOTION_STEPS (MOTION_JD + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
       #define MOTION_TOTAL MOTION_FLOW
 
       switch (item) {
         case MOTION_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Control, CONTROL_MOTION);
           break;
         case MOTION_HOMEOFFSETS:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
+            Draw_Menu_Item(row, ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS), nullptr, true);
           else
             Draw_Menu(HomeOffsets);
           break;
         case MOTION_SPEED:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
+            Draw_Menu_Item(row, ICON_MaxSpeed, GET_TEXT_F(MSG_MAX_SPEED), nullptr, true);
           else
             Draw_Menu(MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
+            Draw_Menu_Item(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_AMAX_EN), nullptr, true);
           else
             Draw_Menu(MaxAcceleration);
           break;
         #if HAS_CLASSIC_JERK
           case MOTION_JERK:
             if (draw)
-              Draw_Menu_Item(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
+              Draw_Menu_Item(row, ICON_MaxJerk, GET_TEXT_F(MSG_JERK), nullptr, true);
             else
               Draw_Menu(MaxJerk);
             break;
         #endif
+        #if HAS_JUNCTION_DEVIATION
+          case MOTION_JD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_MaxJerk, GET_TEXT_F(MSG_JUNCTION_DEVIATION), nullptr, true);
+            else
+              Draw_Menu(JDmenu);
+            break;
+        #endif
         case MOTION_STEPS:
           if (draw)
-            Draw_Menu_Item(row, ICON_Step, F("Steps/mm"), nullptr, true);
+            Draw_Menu_Item(row, ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), nullptr, true);
           else
             Draw_Menu(Steps);
           break;
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
+              Draw_Menu_Item(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
               Draw_Float(planner.flow_percentage[0], row, false, 1);
             }
             else
               Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
             break;
         #endif
       }
       break;
 
-    case HomeOffsets:
+    #if ENABLED(FWRETRACT)
+      case FwRetraction:
 
-      #define HOMEOFFSETS_BACK 0
-      #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
-      #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
-      #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
+        #define FWR_BACK 0
+        #define FWR_RET_AUTO (FWR_BACK + 1)
+        #define FWR_RET_LENGTH (FWR_RET_AUTO + 1)
+        #define FWR_RET_SPEED (FWR_RET_LENGTH + 1)
+        #define FWR_ZLIFT (FWR_RET_SPEED + 1)
+        #define FWR_REC_EXT_LENGTH (FWR_ZLIFT + 1)
+        #define FWR_REC_SPEED (FWR_REC_EXT_LENGTH + 1)
+        #define FWR_RESET (FWR_REC_SPEED + 1)
+        #define FWR_TOTAL FWR_RESET
 
-      switch (item) {
-        case HOMEOFFSETS_BACK:
+        switch (item) {
+
+          case FWR_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
-          else
-            Draw_Menu(Motion, MOTION_HOMEOFFSETS);
-          break;
-        case HOMEOFFSETS_XOFFSET:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, F("X Offset"));
-            Draw_Float(home_offset.x, row, false, 100);
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+          else {
+            if (temp_val.flag_tune) {
+              temp_val.flag_tune = false;
+              Redraw_Menu(false, true, true);
+            }
+            else
+              Draw_Menu(Control, CONTROL_FWRETRACT);
           }
-          else
-            Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+          break;
+          case FWR_RET_AUTO:
+            if (draw) {
+              temp_val.auto_fw_retract = fwretract.autoretract_enabled;
+              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_AUTORETRACT));
+              Draw_Checkbox(row, temp_val.auto_fw_retract);
+            }
+            else {
+              if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
+                temp_val.auto_fw_retract = !temp_val.auto_fw_retract;
+                fwretract.enable_autoretract(temp_val.auto_fw_retract);
+                Draw_Checkbox(row, temp_val.auto_fw_retract);
+              }
+            }
+            break;
+          case FWR_RET_LENGTH:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT));
+              Draw_Float(fwretract.settings.retract_length, row, false, 10);
+            }
+            else
+              Modify_Value(fwretract.settings.retract_length, 0, 10, 10);
+            break;
+          case FWR_RET_SPEED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED));
+              Draw_Float(fwretract.settings.retract_feedrate_mm_s, row, false, 10);
+            }
+            else
+              Modify_Value(fwretract.settings.retract_feedrate_mm_s, 1, 90, 10);
+            break;
+          case FWR_ZLIFT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP));
+              Draw_Float(fwretract.settings.retract_zraise, row, false, 100);
+            }
+            else
+              Modify_Value(fwretract.settings.retract_zraise, 0, 10, 100);
+            break;
+          case FWR_REC_EXT_LENGTH:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FWRecExtLength, GET_TEXT_F(MSG_CONTROL_RETRACT_RECOVER));
+              Draw_Float(fwretract.settings.retract_recover_extra, row, false, 10);
+            }
+            else
+              Modify_Value(fwretract.settings.retract_recover_extra, -10, 10, 10);
+            break;
+          case FWR_REC_SPEED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED));
+              Draw_Float(fwretract.settings.retract_recover_feedrate_mm_s, row, false, 10);
+            }
+            else
+              Modify_Value(fwretract.settings.retract_recover_feedrate_mm_s, 1, 90, 10);
+            break;
+          case FWR_RESET:
+            if (draw)
+              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_BUTTON_RESET));
+            else {
+              fwretract.reset();
+              Draw_Menu(FwRetraction);
+            }
+            break;
+        }
+        break;
+    #endif
+
+    case HomeOffsets:
+
+      #define HOMEOFFSETS_BACK 0
+      #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
+      #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
+      #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
+
+      switch (item) {
+        case HOMEOFFSETS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+          else
+            Draw_Menu(Motion, MOTION_HOMEOFFSETS);
+          break;
+        case HOMEOFFSETS_XOFFSET:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepX, GET_TEXT_F(MSG_HOME_OFFSET_X));
+            Draw_Float(home_offset.x, row, false, 100);
+          }
+          else
+            Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
         case HOMEOFFSETS_YOFFSET:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, F("Y Offset"));
+            Draw_Menu_Item(row, ICON_StepY, GET_TEXT_F(MSG_HOME_OFFSET_Y));
             Draw_Float(home_offset.y, row, false, 100);
           }
           else
             Modify_Value(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
       }
       break;
     case MaxSpeed:
 
       #define SPEED_BACK 0
       #define SPEED_X (SPEED_BACK + 1)
       #define SPEED_Y (SPEED_X + 1)
       #define SPEED_Z (SPEED_Y + 1)
       #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
       #define SPEED_TOTAL SPEED_E
 
       switch (item) {
         case SPEED_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Motion, MOTION_SPEED);
           break;
         case SPEED_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
+            Draw_Menu_Item(row, ICON_MaxSpeedX, GET_TEXT_F(MSG_VMAX_A));
             Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
           break;
 
         #if HAS_Y_AXIS
           case SPEED_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedY, F("Y Axis"));
+              Draw_Menu_Item(row, ICON_MaxSpeedY, GET_TEXT_F(MSG_VMAX_B));
               Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
             break;
         #endif
 
         #if HAS_Z_AXIS
           case SPEED_Z:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedZ, F("Z Axis"));
+              Draw_Menu_Item(row, ICON_MaxSpeedZ, GET_TEXT_F(MSG_VMAX_C));
               Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], 0, default_max_feedrate[Z_AXIS] * 2, 1);
             break;
         #endif
 
         #if HAS_HOTEND
           case SPEED_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedE, F("Extruder"));
+              Draw_Menu_Item(row, ICON_MaxSpeedE, GET_TEXT_F(MSG_VMAX_E));
               Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], 0, default_max_feedrate[E_AXIS] * 2, 1);
             break;
         #endif
       }
       break;
 
     case MaxAcceleration:
@@ -2394,52 +2781,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define ACCEL_BACK 0
       #define ACCEL_X (ACCEL_BACK + 1)
       #define ACCEL_Y (ACCEL_X + 1)
       #define ACCEL_Z (ACCEL_Y + 1)
       #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
       #define ACCEL_TOTAL ACCEL_E
 
       switch (item) {
         case ACCEL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Motion, MOTION_ACCEL);
           break;
         case ACCEL_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccX, F("X Axis"));
+            Draw_Menu_Item(row, ICON_MaxAccX, GET_TEXT_F(MSG_AMAX_A));
             Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], 0, default_max_acceleration[X_AXIS] * 2, 1);
           break;
         case ACCEL_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccY, F("Y Axis"));
+            Draw_Menu_Item(row, ICON_MaxAccY, GET_TEXT_F(MSG_AMAX_B));
             Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], 0, default_max_acceleration[Y_AXIS] * 2, 1);
           break;
         case ACCEL_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccZ, F("Z Axis"));
+            Draw_Menu_Item(row, ICON_MaxAccZ, GET_TEXT_F(MSG_AMAX_C));
             Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], 0, default_max_acceleration[Z_AXIS] * 2, 1);
           break;
         #if HAS_HOTEND
           case ACCEL_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccE, F("Extruder"));
+              Draw_Menu_Item(row, ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E));
               Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], 0, default_max_acceleration[E_AXIS] * 2, 1);
             break;
         #endif
       }
       break;
     #if HAS_CLASSIC_JERK
       case MaxJerk:
@@ -2447,157 +2834,413 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define JERK_BACK 0
         #define JERK_X (JERK_BACK + 1)
         #define JERK_Y (JERK_X + 1)
         #define JERK_Z (JERK_Y + 1)
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
           case JERK_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(Motion, MOTION_JERK);
             break;
           case JERK_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkX,  GET_TEXT_F(MSG_VA_JERK));
               Draw_Float(planner.max_jerk[X_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.max_jerk[X_AXIS], 0, default_max_jerk[X_AXIS] * 2, 10);
             break;
           case JERK_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, GET_TEXT_F(MSG_VB_JERK));
               Draw_Float(planner.max_jerk[Y_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.max_jerk[Y_AXIS], 0, default_max_jerk[Y_AXIS] * 2, 10);
             break;
           case JERK_Z:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, GET_TEXT_F(MSG_VC_JERK));
               Draw_Float(planner.max_jerk[Z_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.max_jerk[Z_AXIS], 0, default_max_jerk[Z_AXIS] * 2, 10);
             break;
           #if HAS_HOTEND
             case JERK_E:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, F("Extruder"));
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK));
                 Draw_Float(planner.max_jerk[E_AXIS], row, false, 10);
               }
               else
                 Modify_Value(planner.max_jerk[E_AXIS], 0, default_max_jerk[E_AXIS] * 2, 10);
               break;
           #endif
         }
         break;
     #endif
+    #if HAS_JUNCTION_DEVIATION
+      case JDmenu:
+
+        #define JD_BACK 0
+        #define JD_SETTING_JD_MM (JD_BACK + ENABLED(HAS_HOTEND))
+        #define JD_TOTAL JD_SETTING_JD_MM
+
+        switch (item) {
+          case JD_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+            else
+              Draw_Menu(Motion, MOTION_JD);
+            break;
+          #if HAS_HOTEND
+            case JD_SETTING_JD_MM:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxJerk, GET_TEXT_F(MSG_JUNCTION_DEVIATION));
+                Draw_Float(planner.junction_deviation_mm, row, false, 100);
+              }
+              else
+                Modify_Value(planner.junction_deviation_mm, MIN_JD_MM, MAX_JD_MM, 100);
+              break;
+            #endif
+        }
+        break;
+    #endif
     case Steps:
 
       #define STEPS_BACK 0
       #define STEPS_X (STEPS_BACK + 1)
       #define STEPS_Y (STEPS_X + 1)
       #define STEPS_Z (STEPS_Y + 1)
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Motion, MOTION_STEPS);
           break;
         case STEPS_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
+            Draw_Menu_Item(row, ICON_StepX, GET_TEXT_F(MSG_A_STEPS));
             Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, 10);
           }
           else
             Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], 0, default_steps[X_AXIS] * 2, 10);
           break;
         case STEPS_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, F("Y Axis"));
+            Draw_Menu_Item(row, ICON_StepY, GET_TEXT_F(MSG_B_STEPS));
             Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, 10);
           }
           else
             Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], 0, default_steps[Y_AXIS] * 2, 10);
           break;
         case STEPS_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepZ, F("Z Axis"));
+            Draw_Menu_Item(row, ICON_StepZ, GET_TEXT_F(MSG_C_STEPS));
             Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, 10);
           }
           else
             Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], 0, default_steps[Z_AXIS] * 2, 10);
           break;
         #if HAS_HOTEND
           case STEPS_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StepE, F("Extruder"));
+              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_E_STEPS));
               Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], 0, 1000, 10);
             break;
         #endif
       }
       break;
 
+    #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
+      case Ledsmenu:
+
+        #define LEDS_BACK 0
+        #define LEDS_CASELIGHT (LEDS_BACK + ENABLED(CASE_LIGHT_MENU))
+        #define LEDS_LED_CONTROL_MENU (LEDS_CASELIGHT + ENABLED(LED_CONTROL_MENU))
+        #define LEDS_TOTAL LEDS_LED_CONTROL_MENU
+
+        switch (item) {
+
+        case LEDS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+          else
+            Draw_Menu(Control, CONTROL_LEDS);
+          break;
+        #if ENABLED(CASE_LIGHT_MENU)
+          case LEDS_CASELIGHT:
+            if (draw) {
+              #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+                Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), nullptr, true);
+              #else
+                Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT));
+                Draw_Checkbox(row, caselight.on);
+              #endif
+            }
+            else {
+              #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+                Draw_Menu(CaseLightmenu);
+              #else
+                caselight.on = !caselight.on;
+                caselight.update_enabled();
+                Draw_Checkbox(row, caselight.on);
+                DWIN_UpdateLCD();
+              #endif
+            }
+            break;
+        #endif
+        #if ENABLED(LED_CONTROL_MENU)
+          case LEDS_LED_CONTROL_MENU:
+            if (draw)
+              Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LED_CONTROL), nullptr, true);
+            else
+              Draw_Menu(LedControlmenu);
+            break;
+        #endif
+        }
+      break;
+    #endif
+
+    #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+      case CaseLightmenu:
+
+        #define CASE_LIGHT_BACK 0
+        #define CASE_LIGHT_ON (CASE_LIGHT_BACK + 1)
+        #define CASE_LIGHT_USES_BRIGHT (CASE_LIGHT_ON + 1)
+        #define CASE_LIGHT_TOTAL CASE_LIGHT_USES_BRIGHT
+
+        switch (item) {
+
+          case CASE_LIGHT_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+            else
+              Draw_Menu(Ledsmenu, LEDS_CASELIGHT);
+            break;
+          case CASE_LIGHT_ON:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT));
+              Draw_Checkbox(row, caselight.on);
+            }
+            else {
+              caselight.on = !caselight.on;
+              caselight.update_enabled();
+              Draw_Checkbox(row, caselight.on);
+              DWIN_UpdateLCD();
+            }
+            break;
+          case CASE_LIGHT_USES_BRIGHT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Brightness, GET_TEXT_F(MSG_CASE_LIGHT_BRIGHTNESS));
+              Draw_Float(caselight.brightness, row);
+            }
+            else
+              Modify_Value(caselight.brightness, 0, 255, 1);
+            break;
+        }
+      break;
+    #endif
+
+    #if ENABLED(LED_CONTROL_MENU)
+      case LedControlmenu:
+
+        #define LEDCONTROL_BACK 0
+        #define LEDCONTROL_LIGHTON (LEDCONTROL_BACK + !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL))
+        #define LEDCONTROL_PRESETS_MENU (LEDCONTROL_LIGHTON + BOTH(HAS_COLOR_LEDS, LED_COLOR_PRESETS))
+        #define LEDCONTROL_CUSTOM_MENU (LEDCONTROL_PRESETS_MENU + ENABLED(HAS_COLOR_LEDS) - DISABLED(LED_COLOR_PRESETS))
+        #define LEDCONTROL_TOTAL LEDCONTROL_CUSTOM_MENU
+
+        switch (item) {
+          case LEDCONTROL_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+            else
+              Draw_Menu(Ledsmenu, LEDS_LED_CONTROL_MENU);
+            break;
+          #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+            case LEDCONTROL_LIGHTON:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LEDS));
+                Draw_Checkbox(row, leds.lights_on);
+              }
+              else {
+                leds.toggle();
+                Draw_Checkbox(row, leds.lights_on);
+                DWIN_UpdateLCD();
+              }
+              break;
+          #endif
+          #if HAS_COLOR_LEDS
+            #if ENABLED(LED_COLOR_PRESETS)
+              case LEDCONTROL_PRESETS_MENU:
+                  if (draw)
+                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LED_PRESETS));
+                  else
+                    Draw_Menu(LedControlpresets);
+                break;
+            #else
+              case LEDCONTROL_CUSTOM_MENU:
+                if (draw)
+                  Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_CUSTOM_LEDS));
+                else
+                  Draw_Menu(LedControlcustom);
+                break;
+            #endif
+          #endif
+        }
+        break;
+
+        #if HAS_COLOR_LEDS
+          #if ENABLED(LED_COLOR_PRESETS)
+            case LedControlpresets:
+
+              #define LEDCONTROL_PRESETS_BACK 0
+              #define LEDCONTROL_PRESETS_WHITE (LEDCONTROL_PRESETS_BACK + 1)
+              #define LEDCONTROL_PRESETS_RED (LEDCONTROL_PRESETS_WHITE + 1)
+              #define LEDCONTROL_PRESETS_ORANGE (LEDCONTROL_PRESETS_RED + 1)
+              #define LEDCONTROL_PRESETS_YELLOW (LEDCONTROL_PRESETS_ORANGE + 1)
+              #define LEDCONTROL_PRESETS_GREEN (LEDCONTROL_PRESETS_YELLOW + 1)
+              #define LEDCONTROL_PRESETS_BLUE (LEDCONTROL_PRESETS_GREEN + 1)
+              #define LEDCONTROL_PRESETS_INDIGO (LEDCONTROL_PRESETS_BLUE + 1)
+              #define LEDCONTROL_PRESETS_VIOLET (LEDCONTROL_PRESETS_INDIGO + 1)
+              #define LEDCONTROL_PRESETS_TOTAL LEDCONTROL_PRESETS_VIOLET
+
+              #define LEDCOLORITEM(MSG,FUNC) if (draw) Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG)); else FUNC; break;
+
+              switch (item) {
+                case LEDCONTROL_PRESETS_BACK:
+                  if (draw)
+                    Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+                  else
+                    Draw_Menu(LedControlmenu, LEDCONTROL_PRESETS_MENU);
+                  break;
+                case LEDCONTROL_PRESETS_WHITE:  LEDCOLORITEM(MSG_SET_LEDS_WHITE, leds.set_white());
+                case LEDCONTROL_PRESETS_RED:    LEDCOLORITEM(MSG_SET_LEDS_RED, leds.set_red());
+                case LEDCONTROL_PRESETS_ORANGE: LEDCOLORITEM(MSG_SET_LEDS_ORANGE, leds.set_orange());
+                case LEDCONTROL_PRESETS_YELLOW: LEDCOLORITEM(MSG_SET_LEDS_YELLOW, leds.set_yellow());
+                case LEDCONTROL_PRESETS_GREEN:  LEDCOLORITEM(MSG_SET_LEDS_GREEN, leds.set_green());
+                case LEDCONTROL_PRESETS_BLUE:   LEDCOLORITEM(MSG_SET_LEDS_BLUE, leds.set_blue());
+                case LEDCONTROL_PRESETS_INDIGO: LEDCOLORITEM(MSG_SET_LEDS_INDIGO, leds.set_indigo());
+                case LEDCONTROL_PRESETS_VIOLET: LEDCOLORITEM(MSG_SET_LEDS_VIOLET, leds.set_violet());
+              }
+              break;
+          #else
+            case LedControlcustom:
+
+              #define LEDCONTROL_CUSTOM_BACK 0
+              #define LEDCONTROL_CUSTOM_RED (LEDCONTROL_CUSTOM_BACK + 1)
+              #define LEDCONTROL_CUSTOM_GREEN (LEDCONTROL_CUSTOM_RED + 1)
+              #define LEDCONTROL_CUSTOM_BLUE (LEDCONTROL_CUSTOM_GREEN + 1)
+              #define LEDCONTROL_CUSTOM_WHITE (LEDCONTROL_CUSTOM_BLUE + ENABLED(HAS_WHITE_LED))
+              #define LEDCONTROL_CUSTOM_TOTAL LEDCONTROL_CUSTOM_WHITE
+
+              switch (item) {
+                case LEDCONTROL_PRESETS_BACK:
+                  Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+                  else
+                    Draw_Menu(LedControlmenu, LEDCONTROL_CUSTOM_MENU);
+                  break;
+                case LEDCONTROL_CUSTOM_RED:
+                  if (draw) {
+                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_R));
+                    Draw_Float(leds.color.r, row);
+                  }
+                  else
+                    Modify_Value(leds.color.r, 0, 255, 1);
+                  break;
+                case LEDCONTROL_CUSTOM_GREEN:
+                  if (draw) {
+                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_G));
+                    Draw_Float(leds.color.g, row);
+                  }
+                  else
+                    Modify_Value(leds.color.g, 0, 255, 1);
+                  break;
+                case LEDCONTROL_CUSTOM_BLUE:
+                  if (draw) {
+                    Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_B));
+                    Draw_Float(leds.color.b, row);
+                  }
+                  else
+                    Modify_Value(leds.color.b, 0, 255, 1);
+                  break;
+                #if HAS_WHITE_LED
+                  case case LEDCONTROL_CUSTOM_WHITE:
+                    if (draw) {
+                      Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_INTENSITY_W));
+                      Draw_Float(leds.color.w, row);
+                    }
+                    else
+                      Modify_Value(leds.color.w, 0, 255, 1);
+                    break;
+                #endif
+              }
+              break;
+          #endif
+        #endif
+    #endif
+
     case Visual:
 
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
       #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
       #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
       #define VISUAL_TOTAL VISUAL_COLOR_THEMES
 
       switch (item) {
         case VISUAL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Control, CONTROL_VISUAL);
           break;
         case VISUAL_BACKLIGHT:
           if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
+            Draw_Menu_Item(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF));
           else
             ui.set_brightness(0);
           break;
         case VISUAL_BRIGHTNESS:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
+            Draw_Menu_Item(row, ICON_Brightness,  GET_TEXT_F(MSG_BRIGHTNESS));
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
             Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
         case VISUAL_TIME_FORMAT:
           if (draw) {
             Draw_Menu_Item(row, ICON_PrintTime, F("Progress as __h__m"));
             Draw_Checkbox(row, eeprom_settings.time_format_textual);
           }
           else {
             eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
             Draw_Checkbox(row, eeprom_settings.time_format_textual);
           }
           break;
         case VISUAL_COLOR_THEMES:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
+            Draw_Menu_Item(row, ICON_MaxSpeed, GET_TEXT_F(MSG_COLORS_SELECT), nullptr, true);
           else
             Draw_Menu(ColorSettings);
         break;
       }
       break;
 
     case ColorSettings:
 
       #define COLORSETTINGS_BACK 0
       #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
@@ -2609,21 +3252,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
       #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
 
       switch (item) {
         case COLORSETTINGS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Visual, VISUAL_COLOR_THEMES);
           break;
         case COLORSETTINGS_CURSOR:
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxSpeed, F("Cursor"));
             Draw_Option(eeprom_settings.cursor_color, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.cursor_color, color_names, Custom_Colors);
@@ -2704,97 +3347,164 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Line"));
             Draw_Option(eeprom_settings.coordinates_split_line, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
           break;
       } // switch (item)
       break;
 
+    #if HAS_HOSTACTION_MENUS
+      case HostSettings:
+
+        #define HOSTSETTINGS_BACK 0
+        #define HOSTSETTINGS_ACTIONCOMMANDS (HOSTSETTINGS_BACK + 1)
+        #define HOSTSETTINGS_TOTAL HOSTSETTINGS_ACTIONCOMMANDS
+
+        switch (item) {
+          case HOSTSETTINGS_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+            else
+              Draw_Menu(Control, CONTROL_HOSTSETTINGS);
+            break;
+            case HOSTSETTINGS_ACTIONCOMMANDS:
+              if (draw) Draw_Menu_Item(row, ICON_File, F("Host Actions"));
+              else Draw_Menu(ActionCommands);
+              break;
+        }
+        break;
+
+      case ActionCommands:
+
+        #define ACTIONCOMMANDS_BACK 0
+        #define ACTIONCOMMANDS_1 (ACTIONCOMMANDS_BACK + 1)
+        #define ACTIONCOMMANDS_2 (ACTIONCOMMANDS_1 + 1)
+        #define ACTIONCOMMANDS_3 (ACTIONCOMMANDS_2 + 1)
+        #define ACTIONCOMMANDS_TOTAL ACTIONCOMMANDS_3
+
+        switch (item) {
+          case ACTIONCOMMANDS_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+            else
+              Draw_Menu(HostSettings, HOSTSETTINGS_ACTIONCOMMANDS);
+            break;
+          case ACTIONCOMMANDS_1:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_File, F("Action #1"));
+              Draw_String(action1, row);
+            }
+            else
+              Modify_String(action1, 8, true);
+            break;
+          case ACTIONCOMMANDS_2:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_File, F("Action #2"));
+              Draw_String(action2, row);
+            }
+            else
+              Modify_String(action2, 8, true);
+            break;
+          case ACTIONCOMMANDS_3:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_File, F("Action #3"));
+              Draw_String(action3, row);
+            }
+            else
+              Modify_String(action3, 8, true);
+            break;
+        }
+        break;
+    #endif
+
     case Advanced:
 
       #define ADVANCED_BACK 0
       #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
       #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
       #define ADVANCED_CORNER (ADVANCED_PROBE + 1)
       #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
       #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
-      #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
+      #define ADVANCED_BAUDRATE_MODE (ADVANCED_POWER_LOSS + ENABLED(BAUD_RATE_GCODE))
+      #define ADVANCED_ESDIAG (ADVANCED_BAUDRATE_MODE + ENABLED(HAS_ESDIAG))
+      #define ADVANCED_LOCKSCREEN (ADVANCED_ESDIAG + ENABLED(HAS_LOCKSCREEN))
+      #define ADVANCED_TOTAL ADVANCED_LOCKSCREEN
 
       switch (item) {
         case ADVANCED_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
           else
             Draw_Menu(Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, F("LCD Beeper"));
+              Draw_Menu_Item(row, ICON_Sound, GET_TEXT_F(MSG_SOUND_ENABLE));
               Draw_Checkbox(row, ui.sound_on);
             }
             else {
               ui.sound_on = !ui.sound_on;
               Draw_Checkbox(row, ui.sound_on);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
-              Draw_Menu_Item(row, ICON_StepX, F("Probe"), nullptr, true);
+              Draw_Menu_Item(row, ICON_ProbeSet, GET_TEXT_F(MSG_ZPROBE_SETTINGS), nullptr, true);
             else
               Draw_Menu(ProbeMenu);
             break;
         #endif
 
         case ADVANCED_CORNER:
           if (draw) {
             Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
-            Draw_Float(corner_pos, row, false, 10);
+            Draw_Float(temp_val.corner_pos, row, false, 10);
           }
           else
-            Modify_Value(corner_pos, 1, 100, 10);
+            Modify_Value(temp_val.corner_pos, 1, 100, 10);
           break;
 
         #if ENABLED(LIN_ADVANCE)
           case ADVANCED_LA:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccelerated, F("Lin Advance Kp"));
+              Draw_Menu_Item(row, ICON_MaxAccelerated, GET_TEXT_F(MSG_ADVANCE_K_E));
               Draw_Float(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case ADVANCED_LOAD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Length"));
+              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_FILAMENT_LOAD));
               Draw_Float(fc_settings[0].load_length, row, false, 1);
             }
             else
               Modify_Value(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
           case ADVANCED_UNLOAD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Length"));
+              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_FILAMENT_UNLOAD));
               Draw_Float(fc_settings[0].unload_length, row, false, 1);
             }
             else
               Modify_Value(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
         #endif // ADVANCED_PAUSE_FEATURE
 
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           case ADVANCED_COLD_EXTRUDE:
             if (draw) {
@@ -2804,127 +3514,208 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             else {
               Modify_Value(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
               thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case ADVANCED_FILSENSORENABLED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
+              Draw_Menu_Item(row, ICON_Extruder, GET_TEXT_F(MSG_RUNOUT_ENABLE));
               Draw_Checkbox(row, runout.enabled);
             }
             else {
               runout.enabled = !runout.enabled;
               Draw_Checkbox(row, runout.enabled);
             }
             break;
 
           #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
             case ADVANCED_FILSENSORDISTANCE:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxAccE, F("Runout Distance"));
+                Draw_Menu_Item(row, ICON_MaxAccE, GET_TEXT_F(MSG_RUNOUT_DISTANCE_MM));
                 Draw_Float(runout.runout_distance(), row, false, 10);
               }
               else
                 Modify_Value(runout.runout_distance(), 0, 999, 10);
               break;
           #endif
         #endif // FILAMENT_RUNOUT_SENSOR
 
         #if ENABLED(POWER_LOSS_RECOVERY)
           case ADVANCED_POWER_LOSS:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Motion, F("Power-loss recovery"));
+              Draw_Menu_Item(row, ICON_Motion, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
               Draw_Checkbox(row, recovery.enabled);
             }
             else {
               recovery.enable(!recovery.enabled);
               Draw_Checkbox(row, recovery.enabled);
             }
             break;
         #endif
+        #if ENABLED(BAUD_RATE_GCODE)
+          case ADVANCED_BAUDRATE_MODE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Setspeed, F("115k Baud"));
+              Draw_Checkbox(row, eeprom_settings.Baud115k);
+            }
+            else {
+              eeprom_settings.Baud115k = !eeprom_settings.Baud115k;
+              queue.inject(eeprom_settings.Baud115k ? F("M575 P0 B115200") : F("M575 P0 B250000"));
+            }
+            break;
+        #endif
+        #if HAS_ESDIAG
+          case ADVANCED_ESDIAG:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ESDiag, F("End-stops diagnostic"));
+            else
+              DWIN_EndstopsDiag();
+            break;
+        #endif
+        #if HAS_LOCKSCREEN
+          case ADVANCED_LOCKSCREEN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN));
+            else
+              DWIN_LockScreen();
+            break;
+        #endif
       }
       break;
 
     #if HAS_BED_PROBE
       case ProbeMenu:
 
         #define PROBE_BACK 0
         #define PROBE_XOFFSET (PROBE_BACK + 1)
         #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
-        #define PROBE_TEST (PROBE_YOFFSET + 1)
+        #define PROBE_ZOFFSET (PROBE_YOFFSET + 1)
+        #define PROBE_HSMODE (PROBE_ZOFFSET + ENABLED(BLTOUCH))
+        #define PROBE_ALARMR (PROBE_HSMODE + ENABLED(BLTOUCH))
+        #define PROBE_SELFTEST (PROBE_ALARMR + ENABLED(BLTOUCH))
+        #define PROBE_MOVEP (PROBE_SELFTEST + ENABLED(BLTOUCH))
+        #define PROBE_TEST (PROBE_MOVEP + 1)
         #define PROBE_TEST_COUNT (PROBE_TEST + 1)
         #define PROBE_TOTAL PROBE_TEST_COUNT
 
         static uint8_t testcount = 4;
 
         switch (item) {
           case PROBE_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(Advanced, ADVANCED_PROBE);
             break;
-
-            case PROBE_XOFFSET:
+          case PROBE_XOFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepX, GET_TEXT_F(MSG_ZPROBE_XOFFSET));
+              Draw_Float(probe.offset.x, row, false, 10);
+            }
+            else
+              Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+            break;
+          case PROBE_YOFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepY, GET_TEXT_F(MSG_ZPROBE_YOFFSET));
+              Draw_Float(probe.offset.y, row, false, 10);
+            }
+            else
+              Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+            break;
+          case PROBE_ZOFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepZ, GET_TEXT_F(MSG_ZPROBE_ZOFFSET));
+              Draw_Float(probe.offset.z, row, false, 100);
+            }
+            else
+              Modify_Value(probe.offset.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          #if ENABLED(BLTOUCH)
+            case PROBE_HSMODE:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepX, F("Probe X Offset"));
-                Draw_Float(probe.offset.x, row, false, 10);
+                Draw_Menu_Item(row, ICON_HSMode, GET_TEXT(MSG_BLTOUCH_SPEED_MODE));
+                Draw_Checkbox(row, bltouch.high_speed_mode);
+              }
+              else {
+                bltouch.high_speed_mode = !bltouch.high_speed_mode;
+                Draw_Checkbox(row, bltouch.high_speed_mode);
               }
-              else
-                Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
-            case PROBE_YOFFSET:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, F("Probe Y Offset"));
-                Draw_Float(probe.offset.y, row, false, 10);
+            case PROBE_ALARMR:
+              if (draw)
+                Draw_Menu_Item(row, ICON_ProbeAlarm, GET_TEXT_F(MSG_BLTOUCH_RESET));
+              else {
+                gcode.process_subcommands_now(F("M280 P0 S160"));
+                AudioFeedback();
               }
-              else
-                Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
-            case PROBE_TEST:
+            case PROBE_SELFTEST:
               if (draw)
-                Draw_Menu_Item(row, ICON_StepY, F("M48 Probe Test"));
+                Draw_Menu_Item(row, ICON_ProbeSelfTest, GET_TEXT_F(MSG_BLTOUCH_SELFTEST));
               else {
-                sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
-                gcode.process_subcommands_now(cmd);
+                gcode.process_subcommands_now(F("M280 P0 S120\nG4 P1000\nM280 P0 S160"));
+                planner.synchronize();
+                AudioFeedback();
               }
               break;
-            case PROBE_TEST_COUNT:
+            case PROBE_MOVEP:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, F("Probe Test Count"));
-                Draw_Float(testcount, row, false, 1);
+                Draw_Menu_Item(row, ICON_ProbeDeploy, GET_TEXT_F(MSG_BLTOUCH_DEPLOY));
+                Draw_Checkbox(row, temp_val.probe_deployed);
+              }
+              else {
+                temp_val.probe_deployed = !temp_val.probe_deployed;
+                if (temp_val.probe_deployed == true)  gcode.process_subcommands_now(F("M280 P0 S10"));
+                else  gcode.process_subcommands_now(F("M280 P0 S90"));
+                Draw_Checkbox(row, temp_val.probe_deployed);
               }
-              else
-                Modify_Value(testcount, 4, 50, 1);
               break;
+          #endif
+          case PROBE_TEST:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ProbeTest, GET_TEXT_F(MSG_M48_TEST));
+            else {
+              sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
+              gcode.process_subcommands_now(cmd);
+            }
+            break;
+          case PROBE_TEST_COUNT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_ProbeTestCount, F("Probe Test Count"));
+              Draw_Float(testcount, row, false, 1);
+            }
+            else
+              Modify_Value(testcount, 4, 50, 1);
+            break;
         }
         break;
     #endif
 
     case InfoMain:
     case Info:
 
       #define INFO_BACK 0
       #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
       #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
       #define INFO_SIZE (INFO_PRINTTIME + 1)
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
       #define INFO_TOTAL INFO_BACK
 
       switch (item) {
         case INFO_BACK:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
+            Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
 
             #if ENABLED(PRINTCOUNTER)
               char row1[50], row2[50], buf[32];
               printStatistics ps = print_job_timer.getStats();
 
               sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
               sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
               Draw_Menu_Item(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
 
               duration_t(print_job_timer.getStats().printTime).toString(buf);
@@ -2959,219 +3750,186 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_VIEW (LEVELING_MANUAL + 1)
         #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
         #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_TOTAL LEVELING_SAVE
 
         switch (item) {
           case LEVELING_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Main_Menu(3);
             break;
           case LEVELING_ACTIVE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, F("Leveling Active"));
+              Draw_Menu_Item(row, ICON_MeshActive, GET_TEXT_F(MSG_MESH_LEVELING));
               Draw_Checkbox(row, planner.leveling_active);
             }
             else {
               if (!planner.leveling_active) {
                 set_bed_leveling_enabled(!planner.leveling_active);
-                if (!planner.leveling_active) {
-                  Confirm_Handler(LevelError);
-                  break;
-                }
+                if (!planner.leveling_active) { Confirm_Handler(LevelError); break; }
               }
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
               Draw_Checkbox(row, planner.leveling_active);
             }
             break;
           #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
                 Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
-                if (bedlevel.storage_slot < 0) {
-                  Popup_Handler(MeshSlot);
-                  break;
-                }
+                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
+                PreheatBefore();
                 Popup_Handler(Home);
                 gcode.home_all_axes(true);
                 Popup_Handler(Level);
                 if (mesh_conf.tilt_grid > 1) {
                   sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
                   gcode.process_subcommands_now(cmd);
                 }
                 else
                   gcode.process_subcommands_now(F("G29 J"));
                 planner.synchronize();
                 Redraw_Menu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, F("Create New Mesh"));
+              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_UBL_BUILD_MESH_MENU));
             else {
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot, true); break; }
+              #endif
+              PreheatBefore();
               Popup_Handler(Home);
               gcode.home_all_axes(true);
               #if ENABLED(AUTO_BED_LEVELING_UBL)
-                #if ENABLED(PREHEAT_BEFORE_LEVELING)
-                  Popup_Handler(Heating);
-                  probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
-                #endif
                 #if HAS_BED_PROBE
                   Popup_Handler(Level);
-                  gcode.process_subcommands_now(F("G29 P0\nG29 P1"));
+                  gcode.process_subcommands_now(F("G29 P1"));
                   gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
                   planner.synchronize();
-                  Update_Status("Probed all reachable points");
+                  Update_Status(GET_TEXT_F(MSG_MESH_DONE));
                   Popup_Handler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
                   Popup_Handler(MoveWait);
                   mesh_conf.manual_mesh_move();
                   Draw_Menu(UBLMesh);
                 #endif
               #elif HAS_BED_PROBE
                 Popup_Handler(Level);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
+                Update_Status(GET_TEXT_F(MSG_MESH_DONE));
                 Popup_Handler(SaveLevel);
               #else
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
-                gridpoint = 1;
+                temp_val.gridpoint = 1;
                 Popup_Handler(MoveWait);
-                gcode.process_subcommands_now(F("G29"));
+                gcode.process_subcommands_now(F("M211 S0\nG29"));
                 planner.synchronize();
                 Draw_Menu(ManualMesh);
               #endif
             }
             break;
           case LEVELING_MANUAL:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
+              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_UBL_MESH_EDIT), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-                if (!leveling_is_valid()) {
-                  Confirm_Handler(InvalidMesh);
-                  break;
-                }
+                if (!leveling_is_valid()) { Confirm_Handler(InvalidMesh); break; }
               #endif
               #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (bedlevel.storage_slot < 0) {
-                  Popup_Handler(MeshSlot);
-                  break;
-                }
+                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
               #endif
-              if (axes_should_home()) {
-                Popup_Handler(Home);
-                gcode.home_all_axes(true);
-              }
+              PreheatBefore();
+              if (axes_should_home()) { Popup_Handler(Home); gcode.home_all_axes(true); }
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
               mesh_conf.goto_mesh_value = false;
-              #if ENABLED(PREHEAT_BEFORE_LEVELING)
-                Popup_Handler(Heating);
-                #if HAS_HOTEND
-                  if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
-                    thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
-                #endif
-                #if HAS_HEATED_BED
-                  if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
-                    thermalManager.setTargetBed(LEVELING_BED_TEMP);
-                #endif
-                TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
-                TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
-              #endif
               Popup_Handler(MoveWait);
               mesh_conf.manual_mesh_move();
+              gcode.process_subcommands_now(F("M211 S0"));
               Draw_Menu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (bedlevel.storage_slot < 0) {
-                  Popup_Handler(MeshSlot);
-                  break;
-                }
+                if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
               #endif
               Draw_Menu(LevelView);
             }
             break;
           case LEVELING_SETTINGS:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, F("Leveling Settings"), nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, GET_TEXT_F(MSG_ADVANCED_SETTINGS), nullptr, true);
             else
               Draw_Menu(LevelSettings);
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_SLOT:
             if (draw) {
-              Draw_Menu_Item(row, ICON_PrintSize, F("Mesh Slot"));
+              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_UBL_STORAGE_SLOT));
               Draw_Float(bedlevel.storage_slot, row, false, 1);
             }
             else
               Modify_Value(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
             break;
           case LEVELING_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Load Mesh"));
+              Draw_Menu_Item(row, ICON_ReadEEPROM, GET_TEXT_F(MSG_UBL_LOAD_MESH));
             else {
-              if (bedlevel.storage_slot < 0) {
-                Popup_Handler(MeshSlot);
-                break;
-              }
+              if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
               gcode.process_subcommands_now(F("G29 L"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           case LEVELING_SAVE:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save Mesh"));
+              Draw_Menu_Item(row, ICON_WriteEEPROM, GET_TEXT_F(MSG_UBL_SAVE_MESH));
             else {
-              if (bedlevel.storage_slot < 0) {
-                Popup_Handler(MeshSlot);
-                break;
-              }
+              if (bedlevel.storage_slot < 0) { Popup_Handler(MeshSlot); break; }
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           #endif
         }
         break;
 
       case LevelView:
 
         #define LEVELING_VIEW_BACK 0
         #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
         #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
         #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
         #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
               Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
               Draw_Menu(MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
@@ -3193,88 +3951,122 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
               Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
             }
             break;
         }
         break;
 
       case LevelSettings:
 
         #define LEVELING_SETTINGS_BACK 0
-        #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
+        #define LEVELING_SETTINGS_LEVELTEMP_MODE (LEVELING_SETTINGS_BACK + ENABLED(PREHEAT_BEFORE_LEVELING))
+        #define LEVELING_SETTINGS_HOTENDTEMP (LEVELING_SETTINGS_LEVELTEMP_MODE + ENABLED(PREHEAT_BEFORE_LEVELING))
+        #define LEVELING_SETTINGS_BEDTEMP (LEVELING_SETTINGS_HOTENDTEMP + ENABLED(PREHEAT_BEFORE_LEVELING))
+        #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BEDTEMP + 1)
         #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
 
         switch (item) {
           case LEVELING_SETTINGS_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else
               Draw_Menu(Leveling, LEVELING_SETTINGS);
             break;
-          case LEVELING_SETTINGS_FADE:
+          #if ENABLED(PREHEAT_BEFORE_LEVELING)
+            case LEVELING_SETTINGS_LEVELTEMP_MODE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
+              Draw_Option(temp_val.LevelingTempmode, preheat_levmodes, row);
+            }
+            else
+              Modify_Option(temp_val.LevelingTempmode, preheat_levmodes, 3);
+            break;
+            case LEVELING_SETTINGS_HOTENDTEMP:
               if (draw) {
-                Draw_Menu_Item(row, ICON_Fade, F("Fade Mesh within"));
-                Draw_Float(planner.z_fade_height, row, false, 1);
-              }
-              else {
-                Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
-                planner.z_fade_height = -1;
-                set_z_fade_height(planner.z_fade_height);
+                Draw_Menu_Item(row, ICON_SetEndTemp, F("Preheat Hotend"));
+                Draw_Float(eeprom_settings.hotend_levtemp, row, false, 1);
               }
+              else
+                Modify_Value(eeprom_settings.hotend_levtemp, MIN_E_TEMP, MAX_E_TEMP, 1);
               break;
+            case LEVELING_SETTINGS_BEDTEMP:
+              if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Preheat Bed"));
+              Draw_Float(eeprom_settings.bed_levtemp, row, false, 1);
+            }
+            else
+              Modify_Value(eeprom_settings.bed_levtemp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+          #endif
+          case LEVELING_SETTINGS_FADE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Fade, GET_TEXT_F(MSG_Z_FADE_HEIGHT));
+              Draw_Float(planner.z_fade_height, row, false, 1);
+            }
+            else {
+              Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
+              planner.z_fade_height = -1;
+              set_z_fade_height(planner.z_fade_height);
+            }
+            break;
 
           #if ENABLED(AUTO_BED_LEVELING_UBL)
+
             case LEVELING_SETTINGS_TILT:
               if (draw) {
-                Draw_Menu_Item(row, ICON_Tilt, F("Tilting Grid Size"));
+                Draw_Menu_Item(row, ICON_Tilt, F("Tilting Grid"));
                 Draw_Float(mesh_conf.tilt_grid, row, false, 1);
               }
               else
                 Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
               break;
+
             case LEVELING_SETTINGS_PLANE:
               if (draw)
                 Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
               else {
                 if (mesh_conf.create_plane_from_mesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 AudioFeedback(true);
               }
               break;
+
             case LEVELING_SETTINGS_ZERO:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, F("Zero Current Mesh"));
               else
                 ZERO(bedlevel.z_values);
               break;
+
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, F("Clear Current Mesh"));
               else
                 bedlevel.invalidate();
               break;
+
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
       case MeshViewer:
         #define MESHVIEW_BACK 0
         #define MESHVIEW_TOTAL MESHVIEW_BACK
 
         if (item == MESHVIEW_BACK) {
           if (draw) {
-            Draw_Menu_Item(0, ICON_Back, F("Back"));
+            Draw_Menu_Item(0, ICON_Back, GET_TEXT_F(MSG_BACK));
             mesh_conf.Draw_Bed_Mesh();
             mesh_conf.Set_Mesh_Viewer_Status();
           }
           else if (!mesh_conf.drawing_mesh) {
             Draw_Menu(LevelView, LEVELING_VIEW_MESH);
             Update_Status("");
           }
         }
         break;
 
@@ -3287,54 +4079,54 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
         #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
         #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else {
               set_bed_leveling_enabled(level_state);
               TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
               Draw_Menu(Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MoveX, F("Mesh Point X"));
+              Draw_Menu_Item(row, ICON_MoveX, GET_TEXT_F(MSG_MESH_X));
               Draw_Float(mesh_conf.mesh_x, row, 0, 1);
             }
             else
               Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
             break;
           case LEVELING_M_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MoveY, F("Mesh Point Y"));
+              Draw_Menu_Item(row, ICON_MoveY, GET_TEXT_F(MSG_MESH_Y));
               Draw_Float(mesh_conf.mesh_y, row, 0, 1);
             }
             else
               Modify_Value(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
             break;
           case LEVELING_M_NEXT:
             if (draw)
-              Draw_Menu_Item(row, ICON_More, F("Next Point"));
+              Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
-                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && !(mesh_conf.mesh_y & 1)) || (!mesh_conf.mesh_x && (mesh_conf.mesh_y & 1)))
                   mesh_conf.mesh_y++;
-                else if (mesh_conf.mesh_y % 2 == 0)
-                  mesh_conf.mesh_x++;
-                else
+                else if (mesh_conf.mesh_y & 1)
                   mesh_conf.mesh_x--;
+                else
+                  mesh_conf.mesh_x++;
                 mesh_conf.manual_mesh_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
               Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
@@ -3400,62 +4192,62 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define UBL_M_NEXT (UBL_M_BACK + 1)
         #define UBL_M_PREV (UBL_M_NEXT + 1)
         #define UBL_M_OFFSET (UBL_M_PREV + 1)
         #define UBL_M_UP (UBL_M_OFFSET + 1)
         #define UBL_M_DOWN (UBL_M_UP + 1)
         #define UBL_M_TOTAL UBL_M_DOWN
 
         switch (item) {
           case UBL_M_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
             else {
               set_bed_leveling_enabled(level_state);
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case UBL_M_NEXT:
             if (draw) {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
-                Draw_Menu_Item(row, ICON_More, F("Next Point"));
+                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
               else
-                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
+                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_UBL_SAVE_MESH));
             }
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
-                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && !(mesh_conf.mesh_y & 1)) || (!mesh_conf.mesh_x && (mesh_conf.mesh_y & 1)))
                   mesh_conf.mesh_y++;
-                else if (mesh_conf.mesh_y % 2 == 0)
-                  mesh_conf.mesh_x++;
-                else
+                else if (mesh_conf.mesh_y & 1)
                   mesh_conf.mesh_x--;
+                else
+                  mesh_conf.mesh_x++;
                 mesh_conf.manual_mesh_move();
               }
               else {
                 gcode.process_subcommands_now(F("G29 S"));
                 planner.synchronize();
                 AudioFeedback(true);
                 Draw_Menu(Leveling, LEVELING_GET_MESH);
               }
             }
             break;
           case UBL_M_PREV:
             if (draw)
               Draw_Menu_Item(row, ICON_More, F("Previous Point"));
             else {
               if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
-                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && (mesh_conf.mesh_y & 1)) || (!mesh_conf.mesh_x && !(mesh_conf.mesh_y & 1)))
                   mesh_conf.mesh_y--;
-                else if (mesh_conf.mesh_y % 2 == 0)
-                  mesh_conf.mesh_x--;
-                else
+                else if (mesh_conf.mesh_y & 1)
                   mesh_conf.mesh_x++;
+                else
+                  mesh_conf.mesh_x--;
                 mesh_conf.manual_mesh_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
               Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
@@ -3499,40 +4291,40 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define MMESH_NEXT (MMESH_BACK + 1)
         #define MMESH_OFFSET (MMESH_NEXT + 1)
         #define MMESH_UP (MMESH_OFFSET + 1)
         #define MMESH_DOWN (MMESH_UP + 1)
         #define MMESH_OLD (MMESH_DOWN + 1)
         #define MMESH_TOTAL MMESH_OLD
 
         switch (item) {
           case MMESH_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
+              Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_CANCEL));
             else {
               gcode.process_subcommands_now(F("G29 A"));
               planner.synchronize();
               set_bed_leveling_enabled(level_state);
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_NEXT:
             if (draw) {
-              if (gridpoint < GRID_MAX_POINTS)
-                Draw_Menu_Item(row, ICON_More, F("Next Point"));
+              if (temp_val.gridpoint < GRID_MAX_POINTS)
+                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_LEVEL_BED_NEXT_POINT));
               else
-                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
+                Draw_Menu_Item(row, ICON_More, GET_TEXT_F(MSG_UBL_SAVE_MESH));
             }
-            else if (gridpoint < GRID_MAX_POINTS) {
+            else if (temp_val.gridpoint < GRID_MAX_POINTS) {
               Popup_Handler(MoveWait);
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
-              gridpoint++;
+              temp_val.gridpoint++;
               Redraw_Menu();
             }
             else {
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               AudioFeedback(settings.save());
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_OFFSET:
@@ -3562,30 +4354,30 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(current_position.z, row - 2, false, 100);
             }
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
             // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
-            mesh_y = (gridpoint - 1) / (GRID_MAX_POINTS_Y);
-            mesh_x = (gridpoint - 1) % (GRID_MAX_POINTS_X);
+            mesh_y = (temp_val.gridpoint - 1) / (GRID_MAX_POINTS_Y);
+            mesh_x = (temp_val.gridpoint - 1) % (GRID_MAX_POINTS_X);
 
-            if (mesh_y % 2 == 1)
+            if (mesh_y & 1)
               mesh_x = (GRID_MAX_POINTS_X) - mesh_x - 1;
 
             const float currval = bedlevel.z_values[mesh_x][mesh_y];
 
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, F("Goto Mesh Value"));
+              Draw_Menu_Item(row, ICON_Zoffset, GET_TEXT_F(MSG_MESH_EDIT_Z));
               Draw_Float(currval, row, false, 100);
             }
             else if (!isnan(currval)) {
               current_position.z = currval;
               planner.synchronize();
               planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
               planner.synchronize();
               Draw_Float(current_position.z, row - 3, false, 100);
             }
             break;
@@ -3597,46 +4389,49 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
       #define TUNE_BACK 0
       #define TUNE_SPEED (TUNE_BACK + 1)
       #define TUNE_FLOW (TUNE_SPEED + ENABLED(HAS_HOTEND))
       #define TUNE_HOTEND (TUNE_FLOW + ENABLED(HAS_HOTEND))
       #define TUNE_BED (TUNE_HOTEND + ENABLED(HAS_HEATED_BED))
       #define TUNE_FAN (TUNE_BED + ENABLED(HAS_FAN))
       #define TUNE_ZOFFSET (TUNE_FAN + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_ZUP (TUNE_ZOFFSET + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
-      #define TUNE_CHANGEFIL (TUNE_ZDOWN + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
+      #define TUNE_FWRETRACT (TUNE_ZDOWN + ENABLED(FWRETRACT))
+      #define TUNE_HOSTACTIONS (TUNE_FWRETRACT + ENABLED(HAS_HOSTACTION_MENUS))
+      #define TUNE_CHANGEFIL (TUNE_HOSTACTIONS + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
       #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
       #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
-      #define TUNE_TOTAL TUNE_BACKLIGHT
+      #define TUNE_CASELIGHT (TUNE_BACKLIGHT + ENABLED(CASE_LIGHT_MENU))
+      #define TUNE_LEDCONTROL (TUNE_CASELIGHT + (ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)))
+      #define TUNE_LOCKSCREEN (TUNE_LEDCONTROL + ENABLED(HAS_LOCKSCREEN))
+      #define TUNE_TOTAL TUNE_LOCKSCREEN
 
       switch (item) {
         case TUNE_BACK:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Back, F("Back"));
-          else
-            Draw_Print_Screen();
+          if (draw) Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BACK));
+          else Draw_Print_Screen();
           break;
         case TUNE_SPEED:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Speed, F("Print Speed"));
+            Draw_Menu_Item(row, ICON_Speed, GET_TEXT_F(MSG_SPEED));
             Draw_Float(feedrate_percentage, row, false, 1);
           }
           else
             Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
           break;
 
         #if HAS_HOTEND
           case TUNE_FLOW:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
+              Draw_Menu_Item(row, ICON_Speed, GET_TEXT_F(MSG_FLOW));
               Draw_Float(planner.flow_percentage[0], row, false, 1);
             }
             else
               Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
             break;
           case TUNE_HOTEND:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
@@ -3652,302 +4447,398 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Float(thermalManager.temp_bed.target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
 
         #if HAS_FAN
           case TUNE_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Menu_Item(row, ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED));
               Draw_Float(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
 
         #if HAS_ZOFFSET_ITEM
           case TUNE_ZOFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_FanSpeed, F("Z-Offset"));
-              Draw_Float(zoffsetvalue, row, false, 100);
+              Draw_Float(temp_val.zoffsetvalue, row, false, 100);
             }
             else
-              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              Modify_Value(temp_val.zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case TUNE_ZUP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, F("Z-Offset Up"));
-            else if (zoffsetvalue < MAX_Z_OFFSET) {
-              gcode.process_subcommands_now(F("M290 Z0.01"));
-              zoffsetvalue += 0.01;
-              Draw_Float(zoffsetvalue, row - 1, false, 100);
+              Draw_Menu_Item(row, ICON_Axis, F("Z-Offset Up"));
+            else if (temp_val.zoffsetvalue < MAX_Z_OFFSET) {
+              gcode.process_subcommands_now(F("M290 Z0.01"));
+              temp_val.zoffsetvalue += 0.01;
+              Draw_Float(temp_val.zoffsetvalue, row - 1, false, 100);
+            }
+            break;
+          case TUNE_ZDOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, F("Z-Offset Down"));
+            else if (temp_val.zoffsetvalue > MIN_Z_OFFSET) {
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
+              temp_val.zoffsetvalue -= 0.01;
+              Draw_Float(temp_val.zoffsetvalue, row - 2, false, 100);
+            }
+            break;
+        #endif
+
+        #if ENABLED(FWRETRACT)
+          case TUNE_FWRETRACT:
+            if (draw)
+              Draw_Menu_Item(row, ICON_StepE, GET_TEXT_F(MSG_AUTORETRACT), nullptr, true);
+            else {
+              temp_val.flag_tune = true;
+              last_pos_selection = selection;
+              Draw_Menu(FwRetraction);
             }
             break;
-          case TUNE_ZDOWN:
+        #endif
+
+        #if HAS_HOSTACTION_MENUS
+          case TUNE_HOSTACTIONS:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, F("Z-Offset Down"));
-            else if (zoffsetvalue > MIN_Z_OFFSET) {
-              gcode.process_subcommands_now(F("M290 Z-0.01"));
-              zoffsetvalue -= 0.01;
-              Draw_Float(zoffsetvalue, row - 2, false, 100);
+              Draw_Menu_Item(row, ICON_SetHome, F("Host Actions"), nullptr, true);
+            else {
+              temp_val.flag_tune = true;
+              last_pos_selection = selection;
+              Draw_Menu(HostActions);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
-            if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
-            else
-              Popup_Handler(ConfFilChange);
+            if (draw) Draw_Menu_Item(row, ICON_ResumeEEPROM, GET_TEXT_F(MSG_FILAMENTCHANGE));
+            else Popup_Handler(ConfFilChange);
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
+              Draw_Menu_Item(row, ICON_Extruder, GET_TEXT_F(MSG_RUNOUT_SENSOR));
               Draw_Checkbox(row, runout.enabled);
             }
             else {
               runout.enabled = !runout.enabled;
               Draw_Checkbox(row, runout.enabled);
             }
             break;
         #endif
 
         case TUNE_BACKLIGHT_OFF:
-          if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
-          else
-            ui.set_brightness(0);
+          if (draw) Draw_Menu_Item(row, ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF));
+          else ui.set_brightness(0);
           break;
         case TUNE_BACKLIGHT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
+            Draw_Menu_Item(row, ICON_Brightness,  GET_TEXT_F(MSG_BRIGHTNESS));
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
             Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
-      }
-      break;
-
-    #if HAS_PREHEAT && HAS_HOTEND
-
-      case PreheatHotend:
-
-        #define PREHEATHOTEND_BACK 0
-        #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
-        #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
-        #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
-        #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
-        #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
-        #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
-        #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
-        #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
-
-        switch (item) {
-          case PREHEATHOTEND_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
+        #if ENABLED(CASE_LIGHT_MENU)
+          case TUNE_CASELIGHT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT));
+              Draw_Checkbox(row, caselight.on);
+            }
             else {
-              thermalManager.setTargetHotend(0, 0);
-              thermalManager.set_fan_speed(0, 0);
-              Redraw_Menu(false, true, true);
+              caselight.on = !caselight.on;
+              caselight.update_enabled();
+              Draw_Checkbox(row, caselight.on);
             }
             break;
-          case PREHEATHOTEND_CONTINUE:
-            if (draw)
-              Draw_Menu_Item(row, ICON_SetEndTemp, F("Continue"));
+        #endif
+        #if ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
+          case TUNE_LEDCONTROL:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_LedControl, GET_TEXT_F(MSG_LEDS));
+              Draw_Checkbox(row, leds.lights_on);
+            }
             else {
-              Popup_Handler(Heating);
-              thermalManager.wait_for_hotend(0);
-              switch (last_menu) {
-                case Prepare:
-                  Popup_Handler(FilChange);
-                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                  gcode.process_subcommands_now(cmd);
-                  break;
-                #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-                  case ChangeFilament:
-                    switch (last_selection) {
-                      case CHANGEFIL_LOAD:
-                        Popup_Handler(FilLoad);
-                        gcode.process_subcommands_now(F("M701"));
-                        planner.synchronize();
-                        Redraw_Menu(true, true, true);
-                        break;
-                      case CHANGEFIL_UNLOAD:
-                        Popup_Handler(FilLoad, true);
-                        gcode.process_subcommands_now(F("M702"));
-                        planner.synchronize();
-                        Redraw_Menu(true, true, true);
-                        break;
-                      case CHANGEFIL_CHANGE:
-                        Popup_Handler(FilChange);
-                        sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                        gcode.process_subcommands_now(cmd);
-                        break;
-                    }
-                    break;
-                #endif
-                default:
-                  Redraw_Menu(true, true, true);
-                  break;
-              }
+              leds.toggle();
+              Draw_Checkbox(row, leds.lights_on);
             }
             break;
+        #endif
+        #if HAS_LOCKSCREEN
+          case TUNE_LOCKSCREEN:
+            if (draw) Draw_Menu_Item(row, ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN));
+            else DWIN_LockScreen();
+            break;
+        #endif
+      }
+      break;
 
+    #if HAS_PREHEAT && HAS_HOTEND
+      case PreheatHotend:
 
-          #define _PREHEAT_HOTEND_CASE(N) \
-            case PREHEATHOTEND_##N: \
-              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
-              else ui.preheat_hotend_and_fan((N) - 1); \
+          #define PREHEATHOTEND_BACK 0
+          #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
+          #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
+          #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
+          #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
+          #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
+          #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
+          #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
+          #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
+
+          switch (item) {
+            case PREHEATHOTEND_BACK:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Back, GET_TEXT_F(MSG_BUTTON_CANCEL));
+              else {
+                thermalManager.setTargetHotend(0, 0);
+                thermalManager.set_fan_speed(0, 0);
+                Redraw_Menu(false, true, true);
+              }
+              break;
+            case PREHEATHOTEND_CONTINUE:
+              if (draw)
+                Draw_Menu_Item(row, ICON_SetEndTemp, GET_TEXT_F(MSG_BUTTON_CONTINUE));
+              else {
+                Popup_Handler(Heating);
+                thermalManager.wait_for_hotend(0);
+                switch (last_menu) {
+                  case Prepare:
+                    Popup_Handler(FilChange);
+                    sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                    gcode.process_subcommands_now(cmd);
+                    Draw_Menu(Prepare, PREPARE_CHANGEFIL);
+                    break;
+                  #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                    case ChangeFilament:
+                      switch (last_selection) {
+                        case CHANGEFIL_LOAD:
+                          Popup_Handler(FilLoad);
+                          Update_Status(GET_TEXT(MSG_FILAMENTLOAD));
+                          gcode.process_subcommands_now(F("M701"));
+                          planner.synchronize();
+                          Draw_Menu(ChangeFilament, CHANGEFIL_LOAD);
+                          break;
+                        case CHANGEFIL_UNLOAD:
+                          Popup_Handler(FilLoad, true);
+                          Update_Status(GET_TEXT(MSG_FILAMENTUNLOAD));
+                          gcode.process_subcommands_now(F("M702"));
+                          planner.synchronize();
+                          Draw_Menu(ChangeFilament, CHANGEFIL_UNLOAD);
+                          break;
+                        case CHANGEFIL_CHANGE:
+                          Popup_Handler(FilChange);
+                          Update_Status(GET_TEXT(MSG_FILAMENTCHANGE));
+                          sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                          gcode.process_subcommands_now(cmd);
+                          Draw_Menu(ChangeFilament, CHANGEFIL_CHANGE);
+                          break;
+                      }
+                      break;
+                  #endif
+                  default:
+                    Redraw_Menu(true, true, true);
+                    break;
+                }
+              }
               break;
 
-          REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
+            #define _PREHEAT_HOTEND_CASE(N) \
+              case PREHEATHOTEND_##N: \
+                if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+                else ui.preheat_hotend_and_fan((N) - 1); \
+                break;
 
-          case PREHEATHOTEND_CUSTOM:
-            if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, F("Custom"));
-              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
-            }
-            else
-              Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
-            break;
-        }
+            REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
+
+            case PREHEATHOTEND_CUSTOM:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_Temperature, GET_TEXT_F(MSG_PREHEAT_CUSTOM));
+                Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+              }
+              else
+                Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
+              break;
+          }
         break;
 
     #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
 
 FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
   switch (menu) {
-    case MainMenu:          return F("Main Menu");
-    case Prepare:           return F("Prepare");
-    case HomeMenu:          return F("Homing Menu");
-    case Move:              return F("Move");
-    case ManualLevel:       return F("Manual Leveling");
+    case MainMenu:          return GET_TEXT_F(MSG_MAIN);
+    case Prepare:           return GET_TEXT_F(MSG_PREPARE);
+    case HomeMenu:          return GET_TEXT_F(MSG_HOMING);
+    case Move:              return GET_TEXT_F(MSG_MOVE_AXIS);
+    case ManualLevel:       return GET_TEXT_F(MSG_BED_TRAMMING_MANUAL);
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return F("Z Offset");
     #endif
     #if HAS_PREHEAT
       case Preheat:         return F("Preheat");
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return F("Change Filament");
+      case ChangeFilament:  return GET_TEXT_F(MSG_FILAMENTCHANGE);
+    #endif
+    #if HAS_HOSTACTION_MENUS
+      case HostActions:     return F("Host Actions");
     #endif
     #if HAS_CUSTOM_MENU
       case MenuCustom:
         #ifdef CUSTOM_MENU_CONFIG_TITLE
           return F(CUSTOM_MENU_CONFIG_TITLE);
         #else
           return F("Custom Commands");
         #endif
     #endif
-    case Control:           return F("Control");
-    case TempMenu:          return F("Temperature");
+    case Control:           return GET_TEXT_F(MSG_CONTROL);
+    case TempMenu:          return GET_TEXT_F(MSG_TEMPERATURE);
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return F("PID Menu");
     #endif
     #if HAS_HOTEND
       case HotendPID:       return F("Hotend PID Settings");
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return F("Bed PID Settings");
     #endif
     #if HAS_PREHEAT
       #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
     case Motion:            return F("Motion Settings");
-    case HomeOffsets:       return F("Home Offsets");
-    case MaxSpeed:          return F("Max Speed");
-    case MaxAcceleration:   return F("Max Acceleration");
+    #if ENABLED(FWRETRACT)
+      case FwRetraction:    return F("Firmware Retract");
+    #endif
+    case HomeOffsets:       return GET_TEXT_F(MSG_SET_HOME_OFFSETS);
+    case MaxSpeed:          return GET_TEXT_F(MSG_SPEED);
+    case MaxAcceleration:   return GET_TEXT_F(MSG_ACCELERATION);
     #if HAS_CLASSIC_JERK
-      case MaxJerk:         return F("Max Jerk");
+      case MaxJerk:         return GET_TEXT_F(MSG_JERK);
+    #endif
+    #if HAS_JUNCTION_DEVIATION
+      case JDmenu:          return GET_TEXT_F(MSG_JUNCTION_DEVIATION);
     #endif
-    case Steps:             return F("Steps/mm");
+    case Steps:             return GET_TEXT_F(MSG_STEPS_PER_MM);
     case Visual:            return F("Visual Settings");
-    case Advanced:          return F("Advanced Settings");
+    #if HAS_HOSTACTION_MENUS
+      case HostSettings:    return F("Host Settings");
+      case ActionCommands:  return F("Host Actions");
+    #endif
+    case Advanced:          return GET_TEXT_F(MSG_ADVANCED_SETTINGS);
     #if HAS_BED_PROBE
-      case ProbeMenu:       return F("Probe Menu");
+      case ProbeMenu:       return GET_TEXT_F(MSG_ZPROBE_SETTINGS);
     #endif
     case ColorSettings:     return F("UI Color Settings");
-    case Info:              return F("Info");
-    case InfoMain:          return F("Info");
+    case Info:
+    case InfoMain:          return GET_TEXT_F(MSG_INFO_SCREEN);
     #if HAS_MESH
-      case Leveling:        return F("Leveling");
+      case Leveling:        return GET_TEXT_F(MSG_BED_LEVELING);
       case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelSettings:   return F("Leveling Settings");
       case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
-      case LevelManual:     return F("Manual Tuning");
+      case LevelManual:     return GET_TEXT_F(MSG_UBL_FINE_TUNE_MESH);
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:         return F("UBL Bed Leveling");
+      case UBLMesh:         return GET_TEXT_F(MSG_UBL_LEVEL_BED);
     #endif
     #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return F("Mesh Bed Leveling");
+      case ManualMesh:      return GET_TEXT_F(MSG_MESH_LEVELING);
     #endif
-    case Tune:              return F("Tune");
+    case Tune:              return GET_TEXT_F(MSG_TUNE);
     case PreheatHotend:     return F("Preheat Hotend");
+    #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
+      case Ledsmenu:        return F("Light Settings");
+      #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+        case CaseLightmenu: return GET_TEXT_F(MSG_CASE_LIGHT);
+      #endif
+      #if ENABLED(LED_CONTROL_MENU)
+        case LedControlmenu: return GET_TEXT_F(MSG_LED_CONTROL);
+        #if HAS_COLOR_LEDS
+          #if ENABLED(LED_COLOR_PRESETS)
+            case LedControlpresets: return GET_TEXT_F(MSG_LED_PRESETS);
+          #else
+            case LedControlcustom: return GET_TEXT_F(MSG_CUSTOM_LEDS);
+          #endif
+        #endif
+      #endif
+    #endif
   }
   return F("");
 }
 
 uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
   switch (menu) {
     case Prepare:           return PREPARE_TOTAL;
     case HomeMenu:          return HOME_TOTAL;
     case Move:              return MOVE_TOTAL;
     case ManualLevel:       return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return ZOFFSET_TOTAL;
     #endif
     #if HAS_PREHEAT
       case Preheat:         return PREHEAT_TOTAL;
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:  return CHANGEFIL_TOTAL;
     #endif
+    #if HAS_HOSTACTION_MENUS
+      case HostActions:     return HOSTACTIONS_TOTAL;
+    #endif
     #if HAS_CUSTOM_MENU
       case MenuCustom:      return CUSTOM_MENU_TOTAL;
     #endif
     case Control:           return CONTROL_TOTAL;
     case TempMenu:          return TEMP_TOTAL;
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return PID_TOTAL;
     #endif
     #if HAS_HOTEND
       case HotendPID:       return HOTENDPID_TOTAL;
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return BEDPID_TOTAL;
     #endif
     #if HAS_PREHEAT
       case Preheat1 ... CAT(Preheat, PREHEAT_COUNT):
                             return PREHEAT_SUBMENU_TOTAL;
     #endif
     case Motion:            return MOTION_TOTAL;
+    #if ENABLED(FWRETRACT)
+      case FwRetraction:    return FWR_TOTAL;
+    #endif
     case HomeOffsets:       return HOMEOFFSETS_TOTAL;
     case MaxSpeed:          return SPEED_TOTAL;
     case MaxAcceleration:   return ACCEL_TOTAL;
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return JERK_TOTAL;
     #endif
+    #if HAS_JUNCTION_DEVIATION
+      case JDmenu:          return JD_TOTAL;
+    #endif
     case Steps:             return STEPS_TOTAL;
     case Visual:            return VISUAL_TOTAL;
+    #if HAS_HOSTACTION_MENUS
+      case HostSettings:    return HOSTSETTINGS_TOTAL;
+      case ActionCommands:  return ACTIONCOMMANDS_TOTAL;
+    #endif
     case Advanced:          return ADVANCED_TOTAL;
     #if HAS_BED_PROBE
       case ProbeMenu:       return PROBE_TOTAL;
     #endif
     case Info:              return INFO_TOTAL;
     case InfoMain:          return INFO_TOTAL;
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case UBLMesh:         return UBL_M_TOTAL;
     #endif
     #if ENABLED(PROBE_MANUALLY)
@@ -3960,59 +4851,81 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
       case MeshViewer:      return MESHVIEW_TOTAL;
       case LevelManual:     return LEVELING_M_TOTAL;
     #endif
     case Tune:              return TUNE_TOTAL;
 
     #if HAS_PREHEAT && HAS_HOTEND
       case PreheatHotend:   return PREHEATHOTEND_TOTAL;
     #endif
 
     case ColorSettings:     return COLORSETTINGS_TOTAL;
+    #if ANY(CASE_LIGHT_MENU, LED_CONTROL_MENU)
+      case Ledsmenu:         return LEDS_TOTAL;
+      #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+        case CaseLightmenu: return CASE_LIGHT_TOTAL;
+      #endif
+      #if ENABLED(LED_CONTROL_MENU)
+        case LedControlmenu: return LEDCONTROL_TOTAL;
+        #if HAS_COLOR_LEDS
+          #if ENABLED(LED_COLOR_PRESETS)
+            case LedControlpresets: return LEDCONTROL_PRESETS_TOTAL;
+          #else
+            case LedControlcustom: return LEDCONTROL_CUSTOM_TOTAL;
+          #endif
+        #endif
+      #endif
+    #endif
   }
   return 0;
 }
 
 /* Popup Config */
 
 void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
-    case Pause:         Draw_Popup(F("Pause Print"), F(""), F(""), Popup); break;
-    case Stop:          Draw_Popup(F("Stop Print"), F(""), F(""), Popup); break;
-    case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
+    case Pause:         Draw_Popup(GET_TEXT_F(MSG_PAUSE_PRINT), F(""), F(""), Popup); break;
+    case Stop:          Draw_Popup(GET_TEXT_F(MSG_STOP_PRINT), F(""), F(""), Popup); break;
+    case Resume:        Draw_Popup(GET_TEXT_F(MSG_RESUME_PRINT), F("Looks Like the last"), F("print was interrupted."), Popup); break;
     case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
     case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
     case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
     case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
-    case ETemp:         Draw_Popup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
+    case ETemp:         Draw_Popup(GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT), F(""), Popup); break;
     case ManualProbing: Draw_Popup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
-    case Level:         Draw_Popup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
-    case Home:          Draw_Popup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case MoveWait:      Draw_Popup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case Heating:       Draw_Popup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Level:         Draw_Popup(F("Auto Bed Leveling"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_AutoLeveling); break;
+    case Home:          Draw_Popup(option ? GET_TEXT_F(MSG_PAUSE_PRINT_PARKING) : GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
+    case MoveWait:      Draw_Popup(GET_TEXT_F(MSG_MOVING), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
+    case Heating:       Draw_Popup(GET_TEXT_F(MSG_HEATING), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
+    case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
     case FilChange:     Draw_Popup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
-    case TempWarn:      Draw_Popup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
+    case TempWarn:      Draw_Popup(option ? GET_TEXT_F(MSG_HOTEND_TOO_COLD) : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
     case Runout:        Draw_Popup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
-    case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
-    case Resuming:      Draw_Popup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
-    case Custom:        Draw_Popup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    #if !HAS_PIDPLOT
+      case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), GET_TEXT_F(MSG_PLEASE_WAIT), Wait, ICON_BLTouch); break;
+    #endif
+    case Resuming:      Draw_Popup(F("Resuming Print"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
+    #if HAS_CUSTOM_MENU
+      case Custom:        Draw_Popup(F("Running Custom GCode"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Wait, ICON_BLTouch); break;
+    #endif
+    case PrintConfirm: Draw_Popup(option ? F("") : F("Print file?"), F(""), F(""), Popup); break;
     default: break;
   }
 }
 
-void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
+void CrealityDWINClass::Confirm_Handler(PopupID popupid, bool option/*=false*/) {
   popup = popupid;
   switch (popupid) {
     case FilInsert:   Draw_Popup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
-    case HeaterTime:  Draw_Popup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
-    case UserInput:   Draw_Popup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
+    case HeaterTime:  Draw_Popup(GET_TEXT_F(MSG_HEATER_TIMEOUT), GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), F(""), Confirm); break;
+    case UserInput:   Draw_Popup(option ? GET_TEXT_F(MSG_STOPPED) : F("Waiting for Input"), GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), F(""), Confirm); break;
+    case Level:       Draw_Popup(F("Bed Leveling"), GET_TEXT_F(MSG_PLEASE_WAIT), F(""), Cancel, ICON_AutoLeveling); break;
     case LevelError:  Draw_Popup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
     case InvalidMesh: Draw_Popup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
     default: break;
   }
 }
 
 /* Navigation and Control */
 
 void CrealityDWINClass::Main_Menu_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
@@ -4032,106 +4945,168 @@ void CrealityDWINClass::Main_Menu_Control() {
       case PAGE_CONTROL: Draw_Menu(Control); break;
       case PAGE_INFO_LEVELING: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
     }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Menu_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection++; // Select Down
     if (selection > scrollpos+MROWS) {
       scrollpos++;
-      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      DWIN_Frame_AreaMove(1, 2, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
       Menu_Item_Handler(active_menu, selection);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
-      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      DWIN_Frame_AreaMove(1, 3, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
       Menu_Item_Handler(active_menu, selection);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     Menu_Item_Handler(active_menu, selection, false);
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Value_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  float difvalue = 0;
   if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW)
+  if (encoder_diffState == ENCODER_DIFF_CW) {
     tempvalue += EncoderRate.encoderMoveValue;
-  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    difvalue = EncoderRate.encoderMoveValue;
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW) {
     tempvalue -= EncoderRate.encoderMoveValue;
+    difvalue = - EncoderRate.encoderMoveValue;
+  }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
     EncoderRate.enabled = false;
     Draw_Float(tempvalue / valueunit, selection - scrollpos, false, valueunit);
     DWIN_UpdateLCD();
-    if (active_menu == ZOffset && liveadjust) {
+    if (active_menu == ZOffset && temp_val.zoffsetmode != 0) {
       planner.synchronize();
-      current_position.z += (tempvalue / valueunit - zoffsetvalue);
-      planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+      if (temp_val.zoffsetmode == 1) {
+        current_position.z += (tempvalue / valueunit - temp_val.zoffsetvalue);
+        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+      }
       current_position.z = 0;
       sync_plan_position();
     }
     else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
-      sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - zoffsetvalue), 1, 3, str_1));
+      sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - temp_val.zoffsetvalue), 1, 3, str_1));
       gcode.process_subcommands_now(cmd);
     }
     if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
       tempvalue = scalePID_i(tempvalue);
     if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
       tempvalue = scalePID_d(tempvalue);
     switch (valuetype) {
       case 0: *(float*)valuepointer = tempvalue / valueunit; break;
       case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
       case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
       case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
       case 4: *(uint32_t*)valuepointer = tempvalue / valueunit; break;
       case 5: *(int8_t*)valuepointer = tempvalue / valueunit; break;
     }
     switch (active_menu) {
       case Move:
         planner.synchronize();
         planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
         break;
       #if HAS_MESH
-        case ManualMesh:
-          planner.synchronize();
-          planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
-          planner.synchronize();
-          break;
-        case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
+        #if ENABLED(PROBE_MANUALLY)
+          case ManualMesh:
+            planner.synchronize();
+            planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+            planner.synchronize();
+            break;
+        #endif
+        #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+          case UBLMesh: mesh_conf.manual_mesh_move(true); break;
+        #endif
         case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
       #endif
     }
     if (valuepointer == &planner.flow_percentage[0])
       planner.refresh_e_factor(0);
+    #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+      if (valuepointer == &caselight.brightness)
+        caselight.update_brightness();
+    #endif
+    #if HAS_COLOR_LEDS
+      if ((valuepointer == &leds.color.r) || (valuepointer == &leds.color.g) || (valuepointer == &leds.color.b))
+        ApplyLEDColor();
+        #if HAS_WHITE_LED
+          if (valuepointer == &leds.color.w) ApplyLEDColor();
+        #endif
+    #endif
+
     if (funcpointer) funcpointer();
     return;
   }
   NOLESS(tempvalue, (valuemin * valueunit));
   NOMORE(tempvalue, (valuemax * valueunit));
   Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
   DWIN_UpdateLCD();
-  if (active_menu == Move && livemove) {
-    *(float*)valuepointer = tempvalue / valueunit;
-    planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
+
+  if (valuepointer == &ui.brightness) {
+    *(uint8_t*)valuepointer = tempvalue / valueunit;
+    ui.refresh_brightness();
+  }
+
+  switch (active_menu) {
+    case Move:
+      if (temp_val.livemove) {
+        *(float*)valuepointer = tempvalue / valueunit;
+        planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
+      }
+      break;
+    case ZOffset:
+      if (temp_val.zoffsetmode == 2) {
+        planner.synchronize();
+        sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((difvalue / valueunit), 1, 3, str_1));
+        gcode.process_subcommands_now(cmd);
+        planner.synchronize();
+      }
+      break;
+    case Tune:
+      if (selection == TUNE_ZOFFSET) {
+        planner.synchronize();
+        sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((difvalue / valueunit), 1, 3, str_1));
+        gcode.process_subcommands_now(cmd);
+        planner.synchronize();
+      }
+      break;
+    #if ENABLED(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+      case CaseLightmenu:
+        *(uint8_t*)valuepointer = tempvalue / valueunit;
+        caselight.update_brightness();
+        break;
+    #endif
+    #if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+      case LedControlmenu:
+        *(uint8_t*)valuepointer = tempvalue / valueunit;
+        leds.update();
+        break;
+    #endif
+    default : break;
   }
 }
 
 void CrealityDWINClass::Option_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += EncoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= EncoderRate.encoderMoveValue;
@@ -4148,21 +5123,51 @@ void CrealityDWINClass::Option_Control() {
         case COLORSETTINGS_PROGRESS_PERCENT: eeprom_settings.progress_percent = tempvalue; break;
         case COLORSETTINGS_PROGRESS_TIME: eeprom_settings.progress_time = tempvalue; break;
         case COLORSETTINGS_PROGRESS_STATUS_BAR: eeprom_settings.status_bar_text = tempvalue; break;
         case COLORSETTINGS_PROGRESS_STATUS_AREA: eeprom_settings.status_area_text = tempvalue; break;
         case COLORSETTINGS_PROGRESS_COORDINATES: eeprom_settings.coordinates_text = tempvalue; break;
         case COLORSETTINGS_PROGRESS_COORDINATES_LINE: eeprom_settings.coordinates_split_line = tempvalue; break;
       }
       Redraw_Screen();
     }
     else if (valuepointer == &preheat_modes)
-      preheatmode = tempvalue;
+      temp_val.preheatmode = tempvalue;
+    #if ENABLED(PREHEAT_BEFORE_LEVELING)
+      else if (valuepointer == &preheat_levmodes) {
+        temp_val.LevelingTempmode = tempvalue;
+        eeprom_settings.ena_hotend_levtemp = false;
+        eeprom_settings.ena_bed_levtemp = false;
+        if (temp_val.LevelingTempmode == 0 || temp_val.LevelingTempmode == 1) eeprom_settings.ena_hotend_levtemp = true;
+        if (temp_val.LevelingTempmode == 0 || temp_val.LevelingTempmode == 2) eeprom_settings.ena_bed_levtemp = true;
+      }
+    #endif
+    else if (valuepointer == &zoffset_modes) {
+      temp_val.zoffsetmode = tempvalue;
+      if (temp_val.zoffsetmode == 1 || temp_val.zoffsetmode == 2) {
+        if (axes_should_home()) {
+          Popup_Handler(Home);
+          gcode.home_all_axes(true);
+        }
+        Popup_Handler(MoveWait);
+        #if ENABLED(Z_SAFE_HOMING)
+          planner.synchronize();
+          sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
+          gcode.process_subcommands_now(cmd);
+        #else
+          sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2));
+          gcode.process_subcommands_now(cmd);
+        #endif
+        gcode.process_subcommands_now(F("G0 F300 Z0"));
+        planner.synchronize();
+        Redraw_Menu();
+      }
+    }
 
     Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
     DWIN_UpdateLCD();
     return;
   }
   NOLESS(tempvalue, valuemin);
   NOMORE(tempvalue, valuemax);
   Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
   DWIN_UpdateLCD();
 }
@@ -4186,76 +5191,80 @@ void CrealityDWINClass::File_Control() {
         len = _MIN(pos, MENU_CHAR_LIMIT);
         char name[len + 1];
         if (pos >= 0) {
           LOOP_L_N(i, len) name[i] = filename[i + filescrl];
         }
         else {
           LOOP_L_N(i, MENU_CHAR_LIMIT + pos) name[i] = ' ';
           LOOP_S_L_N(i, MENU_CHAR_LIMIT + pos, MENU_CHAR_LIMIT) name[i] = filename[i - (MENU_CHAR_LIMIT + pos)];
         }
         name[len] = '\0';
-        DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+        DWIN_Draw_Rectangle(1, Def_Background_Color, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
         Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
         if (-pos >= MENU_CHAR_LIMIT) filescrl = 0;
         filescrl++;
         DWIN_UpdateLCD();
       }
     }
     return;
   }
   if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_Files()) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     if (selection > 0) {
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+      DWIN_Draw_Rectangle(1, Def_Background_Color, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
       Draw_SD_Item(selection, selection - scrollpos);
     }
     filescrl = 0;
     selection++; // Select Down
     if (selection > scrollpos + MROWS) {
       scrollpos++;
-      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      DWIN_Frame_AreaMove(1, 2, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
       Draw_SD_Item(selection, selection - scrollpos);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
     Draw_SD_Item(selection, selection - scrollpos);
     filescrl = 0;
     selection--; // Select Up
     if (selection < scrollpos) {
       scrollpos--;
-      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      DWIN_Frame_AreaMove(1, 3, MLINE, Def_Background_Color, 0, 31, DWIN_WIDTH, 349);
       Draw_SD_Item(selection, selection - scrollpos);
     }
-    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Def_Cursor_color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     if (selection == 0) {
       if (card.flag.workDirIsRoot) {
         process = Main;
         Draw_Main_Menu();
       }
       else {
         card.cdup();
         Draw_SD_List();
       }
     }
     else {
       card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
       if (card.flag.filenameIsDir) {
         card.cd(card.filename);
         Draw_SD_List();
       }
       else {
-        card.openAndPrintFile(card.filename);
+        #if HAS_GCODE_PREVIEW
+          Preview_DrawFromSD();
+        #else
+          card.openAndPrintFile(card.filename);
+        #endif
       }
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Print_Screen_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
@@ -4266,37 +5275,37 @@ void CrealityDWINClass::Print_Screen_Control() {
     selection--; // Select Up
     Print_Screen_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (selection) {
       case PRINT_SETUP:
         Draw_Menu(Tune);
         Update_Status_Bar(true);
         break;
       case PRINT_PAUSE_RESUME:
-        if (paused) {
-          if (sdprint) {
+        if (temp_val.paused) {
+          if (temp_val.sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
               char cmd[20];
               #if HAS_HEATED_BED
-                sprintf_P(cmd, PSTR("M140 S%i"), pausebed);
+                sprintf_P(cmd, PSTR("M140 S%i"), temp_val.pausebed);
                 gcode.process_subcommands_now(cmd);
               #endif
               #if HAS_EXTRUDERS
-                sprintf_P(cmd, PSTR("M109 S%i"), pausetemp);
+                sprintf_P(cmd, PSTR("M109 S%i"), temp_val.pausetemp);
                 gcode.process_subcommands_now(cmd);
               #endif
-              TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
+              TERN_(HAS_FAN, thermalManager.fan_speed[0] = temp_val.pausefan);
               planner.synchronize();
               TERN_(SDSUPPORT, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           Draw_Print_Screen();
         }
         else
@@ -4316,49 +5325,49 @@ void CrealityDWINClass::Popup_Control() {
     Popup_Select();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--;
     Popup_Select();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
       case Pause:
         if (selection == 0) {
-          if (sdprint) {
+          if (temp_val.sdprint) {
             #if ENABLED(POWER_LOSS_RECOVERY)
               if (recovery.enabled) recovery.save(true);
             #endif
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               Popup_Handler(Home, true);
               #if ENABLED(SDSUPPORT)
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
               queue.inject(F("M125"));
               planner.synchronize();
             #else
               queue.inject(F("M25"));
-              TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
-              TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
-              TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
+              TERN_(HAS_HOTEND, temp_val.pausetemp = thermalManager.temp_hotend[0].target);
+              TERN_(HAS_HEATED_BED, temp_val.pausebed = thermalManager.temp_bed.target);
+              TERN_(HAS_FAN, temp_val.pausefan = thermalManager.fan_speed[0]);
               thermalManager.cooldown();
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.pause());
           }
         }
         Draw_Print_Screen();
         break;
       case Stop:
         if (selection == 0) {
-          if (sdprint) {
+          if (temp_val.sdprint) {
             ui.abort_print();
             thermalManager.cooldown();
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
           }
         }
         else
           Draw_Print_Screen();
         break;
@@ -4380,21 +5389,21 @@ void CrealityDWINClass::Popup_Control() {
           }
           else
             Redraw_Menu(true, true, false);
           break;
       #endif
 
       #if HAS_BED_PROBE
         case ManualProbing:
           if (selection == 0) {
             char buf[80];
-            const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - corner_avg;
+            const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - temp_val.corner_avg;
             sprintf_P(buf, dif > 0 ? PSTR("Corner is %smm high") : PSTR("Corner is %smm low"), dtostrf(abs(dif), 1, 3, str_1));
             Update_Status(buf);
           }
           else {
             Redraw_Menu(true, true, false);
             Update_Status("");
           }
           break;
       #endif
 
@@ -4416,26 +5425,34 @@ void CrealityDWINClass::Popup_Control() {
           else
             Redraw_Menu(true, true, false);
           break;
         case PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
             Popup_Handler(FilChange);
           }
           else {
             pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
-            if (printing) Popup_Handler(Resuming);
+            if (temp_val.printing) Popup_Handler(Resuming);
             else Redraw_Menu(true, true, (active_menu==PreheatHotend));
           }
           break;
       #endif // ADVANCED_PAUSE_FEATURE
 
+      case PrintConfirm:
+        if (selection==0) {
+          card.openAndPrintFile(card.filename);}
+        else{
+          Redraw_Menu(true, true, true);
+          gcode.process_subcommands_now(F("M117"));}
+        break;
+
       #if HAS_MESH
         case SaveLevel:
           if (selection == 0) {
             #if ENABLED(AUTO_BED_LEVELING_UBL)
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               AudioFeedback(true);
             #else
               AudioFeedback(settings.save());
             #endif
@@ -4463,31 +5480,158 @@ void CrealityDWINClass::Confirm_Control() {
     switch (popup) {
       case Complete:
         Draw_Main_Menu();
         break;
       case FilInsert:
         Popup_Handler(FilChange);
         wait_for_user = false;
         break;
       case HeaterTime:
         Popup_Handler(Heating);
+        Update_Status(GET_TEXT_F(MSG_HEATING));
         wait_for_user = false;
         break;
+      #if HAS_ESDIAG
+        case ESDiagPopup:
+          wait_for_user = false;
+          Redraw_Menu(true, true, false);
+          break;
+      #endif
       default:
         Redraw_Menu(true, true, false);
         wait_for_user = false;
         break;
     }
   }
   DWIN_UpdateLCD();
 }
 
+#if HAS_HOSTACTION_MENUS
+
+  void CrealityDWINClass::Keyboard_Control() {
+    const uint8_t keyboard_size = 34;
+    static uint8_t key_selection = 0, cursor = 0;
+    static char string[31];
+    static bool uppercase = false, locked = false;
+    if (reset_keyboard) {
+      if (strcmp(stringpointer, "-") == 0) stringpointer[0] = '\0';
+      key_selection = 0, cursor = strlen(stringpointer);
+      uppercase = false, locked = false;
+      reset_keyboard = false;
+      strcpy(string, stringpointer);
+    }
+    EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    if (encoder_diffState == ENCODER_DIFF_CW && key_selection < keyboard_size) {
+      Draw_Keys(key_selection, false, uppercase, locked);
+      key_selection++;
+      Draw_Keys(key_selection, true, uppercase, locked);
+    }
+    else if (encoder_diffState == ENCODER_DIFF_CCW && key_selection > 0) {
+      Draw_Keys(key_selection, false, uppercase, locked);
+      key_selection--;
+      Draw_Keys(key_selection, true, uppercase, locked);
+    }
+    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+      if (key_selection < 28) {
+        if (key_selection == 19) {
+          if (!numeric_keyboard) {
+            if (locked) {
+              uppercase = false, locked = false;
+              Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
+            } else if (uppercase) {
+              locked = true;
+              Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
+            }
+            else {
+              uppercase = true;
+              Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
+            }
+          }
+        }
+        else if (key_selection == 27) {
+          cursor--;
+          string[cursor] = '\0';
+        }
+        else {
+          uint8_t index = key_selection;
+          if (index > 19) index--;
+          if (index > 27) index--;
+          const char *keys;
+          if (numeric_keyboard) keys = "1234567890&<>() {}[]*\"\':;!?";
+          else keys = (uppercase) ? "QWERTYUIOPASDFGHJKLZXCVBNM" : "qwertyuiopasdfghjklzxcvbnm";
+          if (!(keyboard_restrict && numeric_keyboard && index > 9)) {
+            string[cursor] = keys[index];
+            cursor++;
+            string[cursor] = '\0';
+          }
+          if (!locked && uppercase) {
+            uppercase = false;
+            Draw_Keyboard(keyboard_restrict, false, key_selection, uppercase, locked);
+          }
+        }
+      }
+      else {
+        switch (key_selection) {
+          case 28:
+            if (!numeric_keyboard) uppercase = false, locked = false;
+            Draw_Keyboard(keyboard_restrict, !numeric_keyboard, key_selection, uppercase, locked);
+            break;
+          case 29:
+            string[cursor] = '-';
+            cursor++;
+            string[cursor] = '\0';
+            break;
+          case 30:
+            string[cursor] = '_';
+            cursor++;
+            string[cursor] = '\0';
+            break;
+          case 31:
+            if (!keyboard_restrict) {
+              string[cursor] = ' ';
+              cursor++;
+              string[cursor] = '\0';
+            }
+            break;
+          case 32:
+            if (!keyboard_restrict) {
+              string[cursor] = '.';
+              cursor++;
+              string[cursor] = '\0';
+            }
+            break;
+          case 33:
+            if (!keyboard_restrict) {
+              string[cursor] = '/';
+              cursor++;
+              string[cursor] = '\0';
+            }
+            break;
+          case 34:
+            if (string[0] == '\0') strcpy(string, "-");
+            strcpy(stringpointer, string);
+            process = Menu;
+            DWIN_Draw_Rectangle(1, Def_Background_Color, 0, KEY_Y_START, DWIN_WIDTH-2, DWIN_HEIGHT-2);
+            Draw_Status_Area(true);
+            Update_Status_Bar(true);
+            break;
+        }
+      }
+      if (strlen(string) > maxstringlen) string[maxstringlen] = '\0', cursor = maxstringlen;
+      Draw_String(string, selection, (process==Keyboard), (maxstringlen > 10));
+    }
+    DWIN_UpdateLCD();
+  }
+
+#endif // HAS_HOSTACTION_MENUS
+
 /* In-Menu Value Modification */
 
 void CrealityDWINClass::Setup_Value(float value, float min, float max, float unit, uint8_t type) {
   if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
     tempvalue = unscalePID_i(value) * unit;
   else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
     tempvalue = unscalePID_d(value) * unit;
   else
     tempvalue = value * unit;
   valuemin = min;
@@ -4533,131 +5677,156 @@ void CrealityDWINClass::Modify_Value(int8_t &value, float min, float max, float
 void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * options, uint8_t max) {
   tempvalue = value;
   valuepointer = const_cast<const char * *>(options);
   valuemin = 0;
   valuemax = max;
   process = Option;
   EncoderRate.enabled = true;
   Draw_Option(value, options, selection - scrollpos, true);
 }
 
+#if HAS_HOSTACTION_MENUS
+  void CrealityDWINClass::Modify_String(char * string, uint8_t maxlength, bool restrict) {
+    stringpointer = string;
+    maxstringlen = maxlength;
+    reset_keyboard = true;
+    Draw_Keyboard(restrict, false);
+    Draw_String(string, selection, true, (maxstringlen > 10));
+  }
+#endif
+
 /* Main Functions */
 
+void CrealityDWINClass::Update_Print_Filename(const char * const text) {
+  LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i];
+  filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
+  Draw_Print_Filename(true);
+}
+
 void CrealityDWINClass::Update_Status(const char * const text) {
-  if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
-    LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
-    filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
-    Draw_Print_Filename(true);
-  }
-  else {
-    LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
-    statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
-  }
+  LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
+  statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
+}
+
+void CrealityDWINClass::Update_Status(FSTR_P text) {
+  Update_Status(FTOP(text));
 }
 
 void CrealityDWINClass::Start_Print(bool sd) {
-  sdprint = sd;
-  if (!printing) {
-    printing = true;
+  temp_val.sdprint = sd;
+  if (!temp_val.printing) {
+    temp_val.printing = true;
     statusmsg[0] = '\0';
     if (sd) {
       #if ENABLED(POWER_LOSS_RECOVERY)
         if (recovery.valid()) {
           SdFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
         }
       #endif
       strcpy(filename, card.longest_filename());
     }
-    else
-      strcpy_P(filename, PSTR("Host Print"));
     TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
     TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
     Draw_Print_Screen();
   }
 }
 
 void CrealityDWINClass::Stop_Print() {
-  printing = false;
-  sdprint = false;
+  temp_val.printing = false;
+  temp_val.sdprint = false;
   thermalManager.cooldown();
   TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(100 * (PROGRESS_SCALE)));
   TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
-  Draw_Print_confirm();
+  Draw_PrintDone_confirm();
+  filename[0] = '\0';
 }
 
 void CrealityDWINClass::Update() {
   State_Update();
   Screen_Update();
   switch (process) {
     case Main:    Main_Menu_Control();    break;
     case Menu:    Menu_Control();         break;
     case Value:   Value_Control();        break;
     case Option:  Option_Control();       break;
     case File:    File_Control();         break;
     case Print:   Print_Screen_Control(); break;
     case Popup:   Popup_Control();        break;
     case Confirm: Confirm_Control();      break;
+    #if HAS_HOSTACTION_MENUS
+      case Keyboard: Keyboard_Control();  break;
+    #endif
+    case Cancel:  Confirm_Control();      break;
+    #if HAS_LOCKSCREEN
+      case Locked: HMI_LockScreen();      break;
+    #endif
   }
 }
 
 void MarlinUI::update() { CrealityDWIN.Update(); }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
 #endif
 
 void CrealityDWINClass::State_Update() {
-  if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
-    if (!printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
+  if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != temp_val.printing) {
+    if (!temp_val.printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
     else Stop_Print();
   }
-  if (print_job_timer.isPaused() != paused) {
-    paused = print_job_timer.isPaused();
+  if (print_job_timer.isPaused() != temp_val.paused) {
+    temp_val.paused = print_job_timer.isPaused();
     if (process == Print) Print_Screen_Icons();
-    if (process == Wait && !paused) Redraw_Menu(true, true);
+    if (process == Wait && !temp_val.paused) Redraw_Menu(true, true);
   }
   if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
     Confirm_Handler(UserInput);
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     if (process == Popup && popup == PurgeMore) {
       if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
         Popup_Handler(FilChange);
       else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
-        if (printing) Popup_Handler(Resuming);
+        if (temp_val.printing) Popup_Handler(Resuming);
         else Redraw_Menu(true, true, (active_menu==PreheatHotend));
       }
     }
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     static bool ranout = false;
     if (runout.filament_ran_out != ranout) {
       ranout = runout.filament_ran_out;
       if (ranout) Popup_Handler(Runout);
     }
   #endif
 }
 
 void CrealityDWINClass::Screen_Update() {
   const millis_t ms = millis();
   static millis_t scrltime = 0;
   if (ELAPSED(ms, scrltime)) {
     scrltime = ms + 200;
-    Update_Status_Bar();
+    if (process != Keyboard) Update_Status_Bar();
     if (process == Print) Draw_Print_Filename();
   }
 
   static millis_t statustime = 0;
-  if (ELAPSED(ms, statustime)) {
+  if (ELAPSED(ms, statustime) && process != Keyboard) {
     statustime = ms + 500;
     Draw_Status_Area();
+    #if HAS_ESDIAG
+      if (process == Confirm && popup == ESDiagPopup) ESDiag.Update();
+    #endif
+    #if HAS_PIDPLOT
+      if (process == Wait && (popup == PIDWaitH || popup == PIDWaitB)) Plot.Update((popup == PIDWaitH) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
+    #endif
   }
 
   static millis_t printtime = 0;
   if (ELAPSED(ms, printtime)) {
     printtime = ms + 1000;
     if (process == Print) {
       Draw_Print_ProgressBar();
       Draw_Print_ProgressElapsed();
       TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
     }
@@ -4674,36 +5843,36 @@ void CrealityDWINClass::Screen_Update() {
     static int16_t hotendtarget = -1;
   #endif
   #if HAS_HEATED_BED
     static int16_t bedtarget = -1;
   #endif
   #if HAS_FAN
     static int16_t fanspeed = -1;
   #endif
 
   #if HAS_ZOFFSET_ITEM
-    static float lastzoffset = zoffsetvalue;
-    if (zoffsetvalue != lastzoffset) {
-      lastzoffset = zoffsetvalue;
+    static float lastzoffset = temp_val.zoffsetvalue;
+    if (temp_val.zoffsetvalue != lastzoffset) {
+      lastzoffset = temp_val.zoffsetvalue;
       #if HAS_BED_PROBE
-        probe.offset.z = zoffsetvalue;
+        probe.offset.z = temp_val.zoffsetvalue;
       #else
-        set_home_offset(Z_AXIS, -zoffsetvalue);
+        set_home_offset(Z_AXIS, -temp_val.zoffsetvalue);
       #endif
     }
 
     #if HAS_BED_PROBE
       if (probe.offset.z != lastzoffset)
-        zoffsetvalue = lastzoffset = probe.offset.z;
+        temp_val.zoffsetvalue = lastzoffset = probe.offset.z;
     #else
       if (-home_offset.z != lastzoffset)
-        zoffsetvalue = lastzoffset = -home_offset.z;
+        temp_val.zoffsetvalue = lastzoffset = -home_offset.z;
     #endif
   #endif // HAS_ZOFFSET_ITEM
 
   if (process == Menu || process == Value) {
     switch (active_menu) {
       case TempMenu:
         #if HAS_HOTEND
           if (thermalManager.temp_hotend[0].target != hotendtarget) {
             hotendtarget = thermalManager.temp_hotend[0].target;
             if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
@@ -4765,30 +5934,59 @@ void CrealityDWINClass::Screen_Update() {
 }
 
 void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
   if (ui.sound_on)
     DONE_BUZZ(success);
   else
     Update_Status(success ? "Success" : "Failed");
 }
 
 void CrealityDWINClass::Save_Settings(char *buff) {
+  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("Save_Settings"));
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
-  eeprom_settings.corner_pos = corner_pos * 10;
+  eeprom_settings.corner_pos = temp_val.corner_pos * 10;
+  #if HAS_HOSTACTION_MENUS
+    eeprom_settings.host_action_label_1 = Encode_String(action1);
+    eeprom_settings.host_action_label_2 = Encode_String(action2);
+    eeprom_settings.host_action_label_3 = Encode_String(action3);
+  #endif
+  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("eeprom_settings size: ", sizeof(eeprom_settings_t)));
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
 
 void CrealityDWINClass::Load_Settings(const char *buff) {
   memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
-  corner_pos = eeprom_settings.corner_pos / 10.0f;
+  temp_val.corner_pos = eeprom_settings.corner_pos / 10.0f;
+  #if ENABLED(BAUD_RATE_GCODE)
+    if (eeprom_settings.Baud115k) queue.inject(F("M575 P0 B115200"));
+  #endif
+  #if ENABLED(FWRETRACT)
+    temp_val.auto_fw_retract = fwretract.autoretract_enabled;
+  #endif
+  #if ENABLED(PREHEAT_BEFORE_LEVELING)
+    temp_val.LevelingTempmode = 2 * !eeprom_settings.ena_hotend_levtemp + !eeprom_settings.ena_bed_levtemp;
+  #endif
+  #if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+    leds.set_color(
+    (temp_val.LED_Color >> 16) & 0xFF,
+    (temp_val.LED_Color >>  8) & 0xFF,
+    (temp_val.LED_Color >>  0) & 0xFF
+    OPTARG(HAS_WHITE_LED, (temp_val.LED_Color >> 24) & 0xFF)
+    );
+  #endif
+  #if HAS_HOSTACTION_MENUS
+    Decode_String(eeprom_settings.host_action_label_1, action1);
+    Decode_String(eeprom_settings.host_action_label_2, action2);
+    Decode_String(eeprom_settings.host_action_label_3, action3);
+  #endif
   Redraw_Screen();
   #if ENABLED(POWER_LOSS_RECOVERY)
     static bool init = true;
     if (init) {
       init = false;
       queue.inject(F("M1000 S"));
     }
   #endif
 }
 
@@ -4801,48 +5999,196 @@ void CrealityDWINClass::Reset_Settings() {
   eeprom_settings.menu_top_bg = 0;
   eeprom_settings.menu_top_txt = 0;
   eeprom_settings.highlight_box = 0;
   eeprom_settings.progress_percent = 0;
   eeprom_settings.progress_time = 0;
   eeprom_settings.status_bar_text = 0;
   eeprom_settings.status_area_text = 0;
   eeprom_settings.coordinates_text = 0;
   eeprom_settings.coordinates_split_line = 0;
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
-  corner_pos = eeprom_settings.corner_pos / 10.0f;
+  temp_val.corner_pos = eeprom_settings.corner_pos / 10.0f;
   TERN_(SOUND_MENU_ITEM, ui.sound_on = ENABLED(SOUND_ON_DEFAULT));
+  TERN_(BAUD_RATE_GCODE, eeprom_settings.Baud115k = false);
+  TERN_(FWRETRACT, temp_val.auto_fw_retract = fwretract.autoretract_enabled);
+  #if ENABLED(PREHEAT_BEFORE_LEVELING)
+    eeprom_settings.ena_hotend_levtemp = true;
+    eeprom_settings.ena_bed_levtemp = true;
+    eeprom_settings.hotend_levtemp = LEVELING_NOZZLE_TEMP;
+    eeprom_settings.bed_levtemp = LEVELING_BED_TEMP;
+  #endif
+  #if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+    leds.setup();
+    #if ENABLED(LED_COLOR_PRESETS)
+      leds.set_default();
+    #endif
+      temp_val.LED_Color = Def_Leds_Color;
+      leds.set_color(
+      (temp_val.LED_Color >> 16) & 0xFF,
+      (temp_val.LED_Color >>  8) & 0xFF,
+      (temp_val.LED_Color >>  0) & 0xFF
+      OPTARG(HAS_WHITE_LED, (temp_val.LED_Color >> 24) & 0xFF)
+      );
+  #endif
+  #if HAS_HOSTACTION_MENUS
+    eeprom_settings.host_action_label_1 = 0;
+    eeprom_settings.host_action_label_2 = 0;
+    eeprom_settings.host_action_label_3 = 0;
+    action1[0] = action2[0] = action3[0] = '-';
+  #endif
   Redraw_Screen();
 }
 
+void CrealityDWINClass::PreheatBefore() {
+  #if ENABLED(PREHEAT_BEFORE_LEVELING)
+    Popup_Handler(Heating);
+    #if HAS_BED_PROBE
+      probe.preheat_for_probing(eeprom_settings.ena_hotend_levtemp, eeprom_settings.ena_bed_levtemp);
+    #else
+      #if HAS_HOTEND
+        if (thermalManager.degTargetHotend(0) < eeprom_settings.hotend_levtemp && (eeprom_settings.ena_hotend_levtemp))
+          thermalManager.setTargetHotend(eeprom_settings.hotend_levtemp, 0);
+      #endif
+      #if HAS_HEATED_BED
+        if (thermalManager.degTargetBed() < eeprom_settings.bed_levtemp && (eeprom_settings.ena_bed_levtemp))
+          thermalManager.setTargetBed(eeprom_settings.bed_levtemp);
+      #endif
+      TERN_(HAS_HOTEND, if (eeprom_settings.ena_hotend_levtemp) thermalManager.wait_for_hotend(0));
+      TERN_(HAS_HEATED_BED, if (eeprom_settings.ena_bed_levtemp) thermalManager.wait_for_bed_heating());
+    #endif
+    Update_Status("");
+  #endif
+}
+
 void MarlinUI::init_lcd() {
-  delay(800);
-  SERIAL_ECHOPGM("\nDWIN handshake ");
-  if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
-  DWIN_Frame_SetDir(1); // Orientation 90°
-  DWIN_UpdateLCD();     // Show bootscreen (first image)
+  DWINUI::init();
   Encoder_Configuration();
+  DWIN_JPG_ShowAndCache(0);
   for (uint16_t t = 0; t <= 100; t += 2) {
-    DWIN_ICON_Show(ICON, ICON_Bar, 15, 260);
-    DWIN_Draw_Rectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
+    DWINUI::DRAW_IconWB(ICON, ICON_Bar, 15, 260);
+    DWIN_Draw_Rectangle(1, Def_Background_Color, 15 + t * 242 / 100, 260, 257, 280);
     DWIN_UpdateLCD();
     delay(20);
   }
-
-  DWIN_JPG_ShowAndCache(3);
   DWIN_JPG_CacheTo1(Language_English);
   CrealityDWIN.Redraw_Screen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     switch (message) {
       case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
-      case PAUSE_MESSAGE_PURGE:
-      case PAUSE_MESSAGE_OPTION:  CrealityDWIN.Popup_Handler(PurgeMore);    break;
+      case PAUSE_MESSAGE_PURGE:   break;
+      case PAUSE_MESSAGE_OPTION:  pause_menu_response = PAUSE_RESPONSE_WAIT_FOR; CrealityDWIN.Popup_Handler(PurgeMore); break;
       case PAUSE_MESSAGE_HEAT:    CrealityDWIN.Confirm_Handler(HeaterTime); break;
       case PAUSE_MESSAGE_WAITING: CrealityDWIN.Draw_Print_Screen();         break;
       default: break;
     }
   }
 #endif
 
+// End-stops diagnostic from DWIN PROUI
+#if HAS_ESDIAG
+  void CrealityDWINClass::DWIN_EndstopsDiag() {
+    last_process = process;
+    last_selection = selection;
+    process = Confirm;
+    popup = ESDiagPopup;
+    ESDiag.Draw();
+  }
+#endif
+
+// Lock screen from DWIN PROUI
+#if HAS_LOCKSCREEN
+  void CrealityDWINClass::DWIN_LockScreen() {
+    if (process != Locked) {
+      lockScreen.rprocess = process;
+      process = Locked;
+      lockScreen.init();
+    }
+  }
+
+  void CrealityDWINClass::DWIN_UnLockScreen() {
+    if (process == Locked) {
+      process = lockScreen.rprocess;
+      if (!temp_val.printing) Draw_Main_Menu(); else Draw_Print_Screen();
+    }
+  }
+
+  void CrealityDWINClass::HMI_LockScreen() {
+    EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    lockScreen.onEncoder(encoder_diffState);
+    if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
+  }
+#endif
+
+// Reboot screen from DWIN PROUI
+void CrealityDWINClass::DWIN_RebootScreen() {
+  DWIN_Frame_Clear(Def_Background_Color);
+  DWIN_JPG_ShowAndCache(0);
+  DWINUI::Draw_CenteredString(Def_Text_Color, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
+  DWIN_UpdateLCD();
+  delay(500);
+}
+
+// Reboot Printer from DWIN PROUI
+void CrealityDWINClass::RebootPrinter() {
+  wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
+  thermalManager.disable_all_heaters();
+  planner.finish_and_disable();
+  DWIN_RebootScreen();
+  hal.reboot();
+}
+
+#if ENABLED(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+  void CrealityDWINClass::ApplyLEDColor() {
+    temp_val.LED_Color = TERN0(HAS_WHITE_LED,(leds.color.w << 24)) | (leds.color.r << 16) | (leds.color.g << 8) | (leds.color.b);
+  }
+#endif
+
+#if HAS_PIDPLOT
+  void CrealityDWINClass::DWIN_Draw_PIDPopup(const pidresult_t pidresult) {
+    frame_rect_t gfrm = {40, 160, DWIN_WIDTH - 80, 150};
+    DWINUI::ClearMainArea();
+    DWIN_Draw_Rectangle(1, Def_PopupBg_color, 14, 60, 258, 330);
+    DWIN_Draw_Rectangle(0, Def_Highlight_Color, 14, 60, 258, 330);
+    DWINUI::Draw_CenteredString(Def_PopupTxt_Color, 80, GET_TEXT_F(MSG_PID_AUTOTUNE));
+    DWINUI::Draw_String(Def_PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
+    switch (pidresult) {
+      case PID_EXTR_START:
+        DWINUI::Draw_CenteredString(Def_PopupTxt_Color, 100, F("for Nozzle is running."));
+        Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], temp_val.PID_e_temp);
+        DWINUI::Draw_Int(Def_PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, temp_val.PID_e_temp);
+        break;
+      case PID_BED_START:
+        DWINUI::Draw_CenteredString(Def_PopupTxt_Color, 100, F("for BED is running."));
+        Plot.Draw(gfrm, BED_MAXTEMP, temp_val.PID_bed_temp);
+        DWINUI::Draw_Int(Def_PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, temp_val.PID_bed_temp);
+        break;
+      default:
+        break;
+    }
+  }
+#endif
+
+#if HAS_PID_HEATING
+  void CrealityDWINClass::DWIN_PidTuning(const pidresult_t pidresult) {
+    switch (pidresult) {
+      case PID_STARTED:  break;
+      #if HAS_PIDPLOT
+        case PID_EXTR_START:  last_process = process; last_selection = selection; process = Wait; popup = PIDWaitH; DWIN_Draw_PIDPopup(pidresult); break;
+        case PID_BED_START:  last_process = process; last_selection = selection; process = Wait; popup = PIDWaitB; DWIN_Draw_PIDPopup(pidresult); break;
+      #else
+        case PID_EXTR_START:  Popup_Handler(PIDWait); break;
+        case PID_BED_START:  Popup_Handler(PIDWait, true); break;
+      #endif
+      case PID_BAD_EXTRUDER_NUM:  Confirm_Handler(BadextruderNumber);  break;
+      case PID_TEMP_TOO_HIGH:  Confirm_Handler(TempTooHigh);  break;
+      case PID_TUNING_TIMEOUT:  Confirm_Handler(PIDTimeout);  break;
+      case PID_DONE: Confirm_Handler(PIDDone);  break;
+      default: break;
+    }
+  }
+#endif
+
 #endif // DWIN_CREALITY_LCD_JYERSUI

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ♻️ Encapsulate PID in class (#24389)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 5f1507feb3..285013d750 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1195,21 +1195,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 Draw_Menu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                   Popup_Handler(ETemp);
                 else {
-                  if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                  if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                     Popup_Handler(Heating);
                     thermalManager.wait_for_hotend(0);
                   }
                   Popup_Handler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                   gcode.process_subcommands_now(cmd);
                 }
               #endif
             }
             break;
@@ -1338,21 +1338,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_Extruder, F("Extruder"));
               current_position.e = 0;
               sync_plan_position();
               Draw_Float(current_position.e, row);
             }
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
-                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                   Redraw_Menu();
                 }
                 current_position.e = 0;
                 sync_plan_position();
                 Modify_Value(current_position.e, -500, 500, 10);
               }
             }
           break;
@@ -1725,58 +1725,58 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             else
               Draw_Menu(Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
-                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
-                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
               Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
-                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                 gcode.process_subcommands_now(cmd);
               }
             }
             break;
         }
@@ -4397,21 +4397,21 @@ void CrealityDWINClass::Popup_Control() {
           }
           break;
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         case ConfFilChange:
           if (selection == 0) {
             if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
               Popup_Handler(ETemp);
             else {
-              if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+              if (thermalManager.temp_hotend[0].is_below_target(-2)) {
                 Popup_Handler(Heating);
                 thermalManager.wait_for_hotend(0);
               }
               Popup_Handler(FilChange);
               sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
               gcode.process_subcommands_now(cmd);
             }
           }
           else
             Redraw_Menu(true, true, false);

commit d8545551fed8498f1c420ec3b301d4d77d0de8b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 05:47:18 2022 -0500

    🐛 Fix Manual Move axis selection (#24404)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 19155fd5e5..5f1507feb3 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -276,21 +276,21 @@ CrealityDWINClass CrealityDWIN;
     #else
 
       void manual_value_update() {
         sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
         gcode.process_subcommands_now(cmd);
         planner.synchronize();
       }
 
     #endif
 
-    void manual_move(bool zmove=false) {
+    void manual_mesh_move(const bool zmove=false) {
       if (zmove) {
         planner.synchronize();
         current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
         CrealityDWIN.Popup_Handler(MoveWait);
         sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
         gcode.process_subcommands_now(cmd);
@@ -3028,21 +3028,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
                   planner.synchronize();
                   Update_Status("Probed all reachable points");
                   Popup_Handler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
                   Popup_Handler(MoveWait);
-                  mesh_conf.manual_move();
+                  mesh_conf.manual_mesh_move();
                   Draw_Menu(UBLMesh);
                 #endif
               #elif HAS_BED_PROBE
                 Popup_Handler(Level);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
                 Popup_Handler(SaveLevel);
               #else
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
@@ -3084,21 +3084,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                     thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
                 #endif
                 #if HAS_HEATED_BED
                   if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
                     thermalManager.setTargetBed(LEVELING_BED_TEMP);
                 #endif
                 TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
                 TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
               #endif
               Popup_Handler(MoveWait);
-              mesh_conf.manual_move();
+              mesh_conf.manual_mesh_move();
               Draw_Menu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (bedlevel.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
@@ -3321,21 +3321,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             if (draw)
               Draw_Menu_Item(row, ICON_More, F("Next Point"));
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
-                mesh_conf.manual_move();
+                mesh_conf.manual_mesh_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
               Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
@@ -3368,21 +3368,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
               Draw_Menu_Item(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             else {
               mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
               current_position.z = 0;
-              mesh_conf.manual_move(true);
+              mesh_conf.manual_mesh_move(true);
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_M_UNDEF:
             if (draw)
               Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Clear Point Value"));
             else {
               mesh_conf.manual_value_update(true);
               Redraw_Menu(false);
@@ -3421,42 +3421,42 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
             }
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
-                mesh_conf.manual_move();
+                mesh_conf.manual_mesh_move();
               }
               else {
                 gcode.process_subcommands_now(F("G29 S"));
                 planner.synchronize();
                 AudioFeedback(true);
                 Draw_Menu(Leveling, LEVELING_GET_MESH);
               }
             }
             break;
           case UBL_M_PREV:
             if (draw)
               Draw_Menu_Item(row, ICON_More, F("Previous Point"));
             else {
               if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
                   mesh_conf.mesh_y--;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x--;
                 else
                   mesh_conf.mesh_x++;
-                mesh_conf.manual_move();
+                mesh_conf.manual_mesh_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
               Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
@@ -4102,22 +4102,22 @@ void CrealityDWINClass::Value_Control() {
       case Move:
         planner.synchronize();
         planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
         break;
       #if HAS_MESH
         case ManualMesh:
           planner.synchronize();
           planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
           planner.synchronize();
           break;
-        case UBLMesh:     mesh_conf.manual_move(true); break;
-        case LevelManual: mesh_conf.manual_move(selection == LEVELING_M_OFFSET); break;
+        case UBLMesh:     mesh_conf.manual_mesh_move(true); break;
+        case LevelManual: mesh_conf.manual_mesh_move(selection == LEVELING_M_OFFSET); break;
       #endif
     }
     if (valuepointer == &planner.flow_percentage[0])
       planner.refresh_e_factor(0);
     if (funcpointer) funcpointer();
     return;
   }
   NOLESS(tempvalue, (valuemin * valueunit));
   NOMORE(tempvalue, (valuemax * valueunit));
   Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    🧑‍💻 Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index f8ba1090d9..19155fd5e5 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4273,28 +4273,28 @@ void CrealityDWINClass::Print_Screen_Control() {
         Update_Status_Bar(true);
         break;
       case PRINT_PAUSE_RESUME:
         if (paused) {
           if (sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
-              char cmnd[20];
+              char cmd[20];
               #if HAS_HEATED_BED
-                cmnd[sprintf_P(cmnd, PSTR("M140 S%i"), pausebed)] = '\0';
-                gcode.process_subcommands_now(cmnd);
+                sprintf_P(cmd, PSTR("M140 S%i"), pausebed);
+                gcode.process_subcommands_now(cmd);
               #endif
               #if HAS_EXTRUDERS
-                cmnd[sprintf_P(cmnd, PSTR("M109 S%i"), pausetemp)] = '\0';
-                gcode.process_subcommands_now(cmnd);
+                sprintf_P(cmd, PSTR("M109 S%i"), pausetemp);
+                gcode.process_subcommands_now(cmd);
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
               TERN_(SDSUPPORT, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           Draw_Print_Screen();

commit f6b425613e0e2eb01ab7fe06bd29fcd34885544b
Author: bryan065 <30362590+bryan065@users.noreply.github.com>
Date:   Thu Jun 2 04:51:39 2022 -0400

    🚸 Custom Menu Items for JyersUI (#24270)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 9fed9fee83..f8ba1090d9 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -114,20 +114,40 @@
 
   #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
   #define MIN_E_TEMP    0
 #endif
 
 #if HAS_HEATED_BED
   #define MAX_BED_TEMP  BED_MAXTEMP
   #define MIN_BED_TEMP  0
 #endif
 
+/**
+ * Custom menu items with jyersLCD
+ */
+#if ENABLED(CUSTOM_MENU_CONFIG)
+  #ifdef CONFIG_MENU_ITEM_5_DESC
+    #define CUSTOM_MENU_COUNT 5
+  #elif defined(CONFIG_MENU_ITEM_4_DESC)
+    #define CUSTOM_MENU_COUNT 4
+  #elif defined(CONFIG_MENU_ITEM_3_DESC)
+    #define CUSTOM_MENU_COUNT 3
+  #elif defined(CONFIG_MENU_ITEM_2_DESC)
+    #define CUSTOM_MENU_COUNT 2
+  #elif defined(CONFIG_MENU_ITEM_1_DESC)
+    #define CUSTOM_MENU_COUNT 1
+  #endif
+  #if CUSTOM_MENU_COUNT
+    #define HAS_CUSTOM_MENU 1
+  #endif
+#endif
+
 constexpr uint16_t TROWS = 6, MROWS = TROWS - 1,
                    TITLE_HEIGHT = 30,
                    MLINE = 53,
                    LBLX = 60,
                    MENU_CHR_W = 8, MENU_CHR_H = 16, STAT_CHR_W = 10;
 
 #define MBASE(L) (49 + MLINE * (L))
 
 constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
 constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
@@ -1071,21 +1091,22 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
       #define PREPARE_COOLDOWN (PREPARE_PREHEAT + EITHER(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
-      #define PREPARE_TOTAL PREPARE_CHANGEFIL
+      #define PREPARE_CUSTOM_MENU (PREPARE_CHANGEFIL + ENABLED(HAS_CUSTOM_MENU))
+      #define PREPARE_TOTAL PREPARE_CUSTOM_MENU
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Main_Menu(1);
           break;
         case PREPARE_MOVE:
           if (draw)
@@ -1146,20 +1167,32 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #if HAS_HOTEND || HAS_HEATED_BED
           case PREPARE_COOLDOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_Cool, F("Cooldown"));
             else
               thermalManager.cooldown();
             break;
         #endif
 
+        #if HAS_CUSTOM_MENU
+          case PREPARE_CUSTOM_MENU:
+            #ifndef CUSTOM_MENU_CONFIG_TITLE
+              #define CUSTOM_MENU_CONFIG_TITLE "Custom Commands"
+            #endif
+            if (draw)
+              Draw_Menu_Item(row, ICON_Version, F(CUSTOM_MENU_CONFIG_TITLE));
+            else
+              Draw_Menu(MenuCustom);
+            break;
+        #endif
+
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
               Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament")
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
@@ -1743,20 +1776,140 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                 gcode.process_subcommands_now(cmd);
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
+    #if HAS_CUSTOM_MENU
+
+      case MenuCustom:
+
+        #define CUSTOM_MENU_BACK 0
+        #define CUSTOM_MENU_1 1
+        #define CUSTOM_MENU_2 2
+        #define CUSTOM_MENU_3 3
+        #define CUSTOM_MENU_4 4
+        #define CUSTOM_MENU_5 5
+        #define CUSTOM_MENU_TOTAL CUSTOM_MENU_COUNT
+
+        switch (item) {
+          case CUSTOM_MENU_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
+            else
+              Draw_Menu(Prepare, PREPARE_CUSTOM_MENU);
+            break;
+
+          #if CUSTOM_MENU_COUNT >= 1
+            case CUSTOM_MENU_1:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_1_DESC));
+              else {
+                Popup_Handler(Custom);
+                //queue.inject(F(CONFIG_MENU_ITEM_1_GCODE)); // Old code
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_1_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 2
+            case CUSTOM_MENU_2:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_2_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_2_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 3
+            case CUSTOM_MENU_3:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_3_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_3_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 4
+            case CUSTOM_MENU_4:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_4_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_4_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif
+
+          #if CUSTOM_MENU_COUNT >= 5
+            case CUSTOM_MENU_5:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Info, F(CONFIG_MENU_ITEM_5_DESC));
+              else {
+                Popup_Handler(Custom);
+                gcode.process_subcommands_now(F(CONFIG_MENU_ITEM_5_GCODE));
+                planner.synchronize();
+                Redraw_Menu();
+                #if ENABLED(CUSTOM_MENU_CONFIG_SCRIPT_AUDIBLE_FEEDBACK)
+                  AudioFeedback();
+                #endif
+                #ifdef CUSTOM_MENU_CONFIG_SCRIPT_RETURN
+                  queue.inject(F(CUSTOM_MENU_CONFIG_SCRIPT_DONE));
+                #endif
+              }
+              break;
+          #endif // Custom Menu
+        }
+        break;
+
+    #endif // HAS_CUSTOM_MENU
+
     case Control:
 
       #define CONTROL_BACK 0
       #define CONTROL_TEMP (CONTROL_BACK + 1)
       #define CONTROL_MOTION (CONTROL_TEMP + 1)
       #define CONTROL_VISUAL (CONTROL_MOTION + 1)
       #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
       #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
@@ -3681,20 +3834,28 @@ FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
     case ManualLevel:       return F("Manual Leveling");
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return F("Z Offset");
     #endif
     #if HAS_PREHEAT
       case Preheat:         return F("Preheat");
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:  return F("Change Filament");
     #endif
+    #if HAS_CUSTOM_MENU
+      case MenuCustom:
+        #ifdef CUSTOM_MENU_CONFIG_TITLE
+          return F(CUSTOM_MENU_CONFIG_TITLE);
+        #else
+          return F("Custom Commands");
+        #endif
+    #endif
     case Control:           return F("Control");
     case TempMenu:          return F("Temperature");
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return F("PID Menu");
     #endif
     #if HAS_HOTEND
       case HotendPID:       return F("Hotend PID Settings");
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return F("Bed PID Settings");
@@ -3746,20 +3907,23 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
     case ManualLevel:       return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return ZOFFSET_TOTAL;
     #endif
     #if HAS_PREHEAT
       case Preheat:         return PREHEAT_TOTAL;
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:  return CHANGEFIL_TOTAL;
     #endif
+    #if HAS_CUSTOM_MENU
+      case MenuCustom:      return CUSTOM_MENU_TOTAL;
+    #endif
     case Control:           return CONTROL_TOTAL;
     case TempMenu:          return TEMP_TOTAL;
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return PID_TOTAL;
     #endif
     #if HAS_HOTEND
       case HotendPID:       return HOTENDPID_TOTAL;
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return BEDPID_TOTAL;
@@ -3824,20 +3988,21 @@ void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
     case Level:         Draw_Popup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
     case Home:          Draw_Popup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case MoveWait:      Draw_Popup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case Heating:       Draw_Popup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case FilChange:     Draw_Popup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
     case TempWarn:      Draw_Popup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
     case Runout:        Draw_Popup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
     case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
     case Resuming:      Draw_Popup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Custom:        Draw_Popup(F("Running Custom GCode"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
 void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
     case FilInsert:   Draw_Popup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
     case HeaterTime:  Draw_Popup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
     case UserInput:   Draw_Popup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ♻️ Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index e8d6abab0c..9fed9fee83 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2937,21 +2937,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
                 TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
               #endif
               Popup_Handler(MoveWait);
               mesh_conf.manual_move();
               Draw_Menu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT(MSG_MESH_VIEW), nullptr, true);
+              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (bedlevel.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
               #endif
               Draw_Menu(LevelView);
             }
             break;
@@ -3010,21 +3010,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT(MSG_MESH_VIEW), nullptr, true);
+              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
               Draw_Menu(MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
               Draw_Menu_Item(row, ICON_Contact, F("Viewer Show Values"));
               Draw_Checkbox(row, mesh_conf.viewer_print_value);
             }
             else {
               mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ♻️ Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 9d6871fc2d..e8d6abab0c 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -200,40 +200,38 @@ CrealityDWINClass CrealityDWIN;
       void manual_value_update(bool undefined=false) {
         sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
         gcode.process_subcommands_now(cmd);
         planner.synchronize();
       }
 
       bool create_plane_from_mesh() {
         struct linear_fit_data lsf_results;
         incremental_LSF_reset(&lsf_results);
         GRID_LOOP(x, y) {
-          if (!isnan(Z_VALUES_ARR[x][y])) {
-            xy_pos_t rpos;
-            rpos.x = ubl.mesh_index_to_xpos(x);
-            rpos.y = ubl.mesh_index_to_ypos(y);
-            incremental_LSF(&lsf_results, rpos, Z_VALUES_ARR[x][y]);
+          if (!isnan(bedlevel.z_values[x][y])) {
+            xy_pos_t rpos = { bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) };
+            incremental_LSF(&lsf_results, rpos, bedlevel.z_values[x][y]);
           }
         }
 
         if (finish_incremental_LSF(&lsf_results)) {
           SERIAL_ECHOPGM("Could not complete LSF!");
           return true;
         }
 
-        ubl.set_all_mesh_points_to_value(0);
+        bedlevel.set_all_mesh_points_to_value(0);
 
         matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
         GRID_LOOP(i, j) {
-          float mx = ubl.mesh_index_to_xpos(i),
-                my = ubl.mesh_index_to_ypos(j),
-                mz = Z_VALUES_ARR[i][j];
+          float mx = bedlevel.get_mesh_x(i),
+                my = bedlevel.get_mesh_y(j),
+                mz = bedlevel.z_values[i][j];
 
           if (DEBUGGING(LEVELING)) {
             DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(my, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(mz, 7);
             DEBUG_ECHOPGM("]   ---> ");
             DEBUG_DELAY(20);
           }
@@ -243,121 +241,121 @@ CrealityDWINClass CrealityDWIN;
           if (DEBUGGING(LEVELING)) {
             DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(my, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(mz, 7);
             DEBUG_ECHOLNPGM("]");
             DEBUG_DELAY(20);
           }
 
-          Z_VALUES_ARR[i][j] = mz - lsf_results.D;
+          bedlevel.z_values[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
 
       void manual_value_update() {
         sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
         gcode.process_subcommands_now(cmd);
         planner.synchronize();
       }
 
     #endif
 
     void manual_move(bool zmove=false) {
       if (zmove) {
         planner.synchronize();
-        current_position.z = goto_mesh_value ? Z_VALUES_ARR[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
         CrealityDWIN.Popup_Handler(MoveWait);
         sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
         gcode.process_subcommands_now(cmd);
         sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
         gcode.process_subcommands_now(cmd);
         planner.synchronize();
-        current_position.z = goto_mesh_value ? Z_VALUES_ARR[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        current_position.z = goto_mesh_value ? bedlevel.z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
         CrealityDWIN.Redraw_Menu();
       }
     }
 
     float get_max_value() {
       float max = __FLT_MIN__;
       GRID_LOOP(x, y) {
-        if (!isnan(Z_VALUES_ARR[x][y]) && Z_VALUES_ARR[x][y] > max)
-          max = Z_VALUES_ARR[x][y];
+        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] > max)
+          max = bedlevel.z_values[x][y];
       }
       return max;
     }
 
     float get_min_value() {
       float min = __FLT_MAX__;
       GRID_LOOP(x, y) {
-        if (!isnan(Z_VALUES_ARR[x][y]) && Z_VALUES_ARR[x][y] < min)
-          min = Z_VALUES_ARR[x][y];
+        if (!isnan(bedlevel.z_values[x][y]) && bedlevel.z_values[x][y] < min)
+          min = bedlevel.z_values[x][y];
       }
       return min;
     }
 
     void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
       drawing_mesh = true;
-      const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x;
-      const uint16_t cell_width_px  = total_width_px / GRID_MAX_POINTS_X;
-      const uint16_t cell_height_px = total_width_px / GRID_MAX_POINTS_Y;
+      const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x,
+                     cell_width_px  = total_width_px / (GRID_MAX_POINTS_X),
+                     cell_height_px = total_width_px / (GRID_MAX_POINTS_Y);
       const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
       DWIN_Draw_Rectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
-        const auto selected_y = selected / GRID_MAX_POINTS_X;
-        const auto selected_x = selected - (GRID_MAX_POINTS_X * selected_y);
+        const auto selected_y = selected / (GRID_MAX_POINTS_X);
+        const auto selected_x = selected - (GRID_MAX_POINTS_X) * selected_y;
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
         DWIN_Draw_Rectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       char buf[8];
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
         DWIN_Draw_Rectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
-          isnan(Z_VALUES_ARR[x][y]) ? Color_Grey : (                                                           // gray if undefined
-            (Z_VALUES_ARR[x][y] < 0 ?
-              (uint16_t)round(0x1F * -Z_VALUES_ARR[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
-              (uint16_t)round(0x3F *  Z_VALUES_ARR[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
-                _MIN(0x1F, (((uint8_t)abs(Z_VALUES_ARR[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
+          isnan(bedlevel.z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
+            (bedlevel.z_values[x][y] < 0 ?
+              (uint16_t)round(0x1F * -bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
+              (uint16_t)round(0x3F *  bedlevel.z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
+                _MIN(0x1F, (((uint8_t)abs(bedlevel.z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
-          if (isnan(Z_VALUES_ARR[x][y])) {  // undefined
+          if (isnan(bedlevel.z_values[x][y])) {  // undefined
             DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             if (GRID_MAX_POINTS_X < 10)
-              sprintf_P(buf, PSTR("%s"), dtostrf(abs(Z_VALUES_ARR[x][y]), 1, 2, str_1));
+              sprintf_P(buf, PSTR("%s"), dtostrf(abs(bedlevel.z_values[x][y]), 1, 2, str_1));
             else
-              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(Z_VALUES_ARR[x][y] - (int16_t)Z_VALUES_ARR[x][y]) * 100));
+              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(bedlevel.z_values[x][y] - (int16_t)bedlevel.z_values[x][y]) * 100));
             offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
             if (!(GRID_MAX_POINTS_X < 10))
               DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
             DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
@@ -410,28 +408,28 @@ void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=fal
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
     DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
     DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
     DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
 void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
-  uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
-  uint16_t tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
+  uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black,
+           tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
   DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
   DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
 uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
-  switch (color){
+  switch (color) {
     case Default:
       return original;
       break;
     case White:
       return (light) ? Color_Light_White : Color_White;
       break;
     case Green:
       return (light) ? Color_Light_Green : Color_Green;
       break;
     case Cyan:
@@ -2835,21 +2833,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
               Draw_Checkbox(row, planner.leveling_active);
             }
             break;
           #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
                 Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
-                if (ubl.storage_slot < 0) {
+                if (bedlevel.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
                 Popup_Handler(Home);
                 gcode.home_all_axes(true);
                 Popup_Handler(Level);
                 if (mesh_conf.tilt_grid > 1) {
                   sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
                   gcode.process_subcommands_now(cmd);
                 }
@@ -2907,21 +2905,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
                 if (!leveling_is_valid()) {
                   Confirm_Handler(InvalidMesh);
                   break;
                 }
               #endif
               #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (ubl.storage_slot < 0) {
+                if (bedlevel.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
               #endif
               if (axes_should_home()) {
                 Popup_Handler(Home);
                 gcode.home_all_axes(true);
               }
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
@@ -2942,61 +2940,61 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Popup_Handler(MoveWait);
               mesh_conf.manual_move();
               Draw_Menu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, GET_TEXT(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
-                if (ubl.storage_slot < 0) {
+                if (bedlevel.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
               #endif
               Draw_Menu(LevelView);
             }
             break;
           case LEVELING_SETTINGS:
             if (draw)
               Draw_Menu_Item(row, ICON_Step, F("Leveling Settings"), nullptr, true);
             else
               Draw_Menu(LevelSettings);
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_SLOT:
             if (draw) {
               Draw_Menu_Item(row, ICON_PrintSize, F("Mesh Slot"));
-              Draw_Float(ubl.storage_slot, row, false, 1);
+              Draw_Float(bedlevel.storage_slot, row, false, 1);
             }
             else
-              Modify_Value(ubl.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
+              Modify_Value(bedlevel.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
             break;
           case LEVELING_LOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_ReadEEPROM, F("Load Mesh"));
             else {
-              if (ubl.storage_slot < 0) {
+              if (bedlevel.storage_slot < 0) {
                 Popup_Handler(MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 L"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           case LEVELING_SAVE:
             if (draw)
               Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save Mesh"));
             else {
-              if (ubl.storage_slot < 0) {
+              if (bedlevel.storage_slot < 0) {
                 Popup_Handler(MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           #endif
         }
@@ -3091,27 +3089,27 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 if (mesh_conf.create_plane_from_mesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 AudioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, F("Zero Current Mesh"));
               else
-                ZERO(Z_VALUES_ARR);
+                ZERO(bedlevel.z_values);
               break;
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, F("Clear Current Mesh"));
               else
-                ubl.invalidate();
+                bedlevel.invalidate();
               break;
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
       case MeshViewer:
         #define MESHVIEW_BACK 0
         #define MESHVIEW_TOTAL MESHVIEW_BACK
 
         if (item == MESHVIEW_BACK) {
@@ -3139,21 +3137,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
-              TERN_(AUTO_BED_LEVELING_BILINEAR, bbl.refresh_bed_level());
+              TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
               Draw_Menu(Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
               Draw_Menu_Item(row, ICON_MoveX, F("Mesh Point X"));
               Draw_Float(mesh_conf.mesh_x, row, 0, 1);
             }
             else
               Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
@@ -3177,50 +3175,50 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
-              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
-              if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
-                Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case LEVELING_M_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
-            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
-              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case LEVELING_M_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
-            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
-              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
               Draw_Menu_Item(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             else {
               mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
               current_position.z = 0;
@@ -3298,50 +3296,50 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   mesh_conf.mesh_x--;
                 else
                   mesh_conf.mesh_x++;
                 mesh_conf.manual_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
-              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
-              if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
-                Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              if (isnan(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case UBL_M_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
-            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
-              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case UBL_M_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, F("Microstep Down"));
-            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
-              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+            else if (bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+              Draw_Float(bedlevel.z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
         break;
     #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
 
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:
 
         #define MMESH_BACK 0
@@ -3411,27 +3409,27 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(current_position.z, row - 2, false, 100);
             }
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
             // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
-            mesh_y = (gridpoint - 1) / GRID_MAX_POINTS_Y;
-            mesh_x = (gridpoint - 1) % GRID_MAX_POINTS_X;
+            mesh_y = (gridpoint - 1) / (GRID_MAX_POINTS_Y);
+            mesh_x = (gridpoint - 1) % (GRID_MAX_POINTS_X);
 
             if (mesh_y % 2 == 1)
-              mesh_x = GRID_MAX_POINTS_X - mesh_x - 1;
+              mesh_x = (GRID_MAX_POINTS_X) - mesh_x - 1;
 
-            const float currval = Z_VALUES_ARR[mesh_x][mesh_y];
+            const float currval = bedlevel.z_values[mesh_x][mesh_y];
 
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, F("Goto Mesh Value"));
               Draw_Float(currval, row, false, 100);
             }
             else if (!isnan(currval)) {
               current_position.z = currval;
               planner.synchronize();
               planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
               planner.synchronize();
@@ -4276,21 +4274,21 @@ void CrealityDWINClass::Popup_Control() {
             #else
               AudioFeedback(settings.save());
             #endif
           }
           Draw_Menu(Leveling, LEVELING_GET_MESH);
           break;
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         case MeshSlot:
-          if (selection == 0) ubl.storage_slot = 0;
+          if (selection == 0) bedlevel.storage_slot = 0;
           Redraw_Menu(true, true);
           break;
       #endif
       default: break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Confirm_Control() {

commit 310ff2367690a9b3c40cec756f193add76900fe3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 17 15:05:25 2022 -0500

    🎨 Misc. E3V2 DWIN cleanup

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 04a612a9cc..9d6871fc2d 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1239,21 +1239,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 Z"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_SET:
           if (draw)
             Draw_Menu_Item(row, ICON_SetHome, F("Set Home Position"));
           else {
-            gcode.process_subcommands_now(F("G92 X0 Y0 Z0"));
+            gcode.process_subcommands_now(F("G92X0Y0Z0"));
             AudioFeedback();
           }
           break;
       }
       break;
 
     case Move:
 
       #define MOVE_BACK 0
       #define MOVE_X (MOVE_BACK + 1)

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ✨ SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index fd51ab4686..04a612a9cc 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2580,25 +2580,25 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
               Draw_Menu_Item(row, ICON_Version, F("LCD Beeper"));
-              Draw_Checkbox(row, ui.buzzer_enabled);
+              Draw_Checkbox(row, ui.sound_on);
             }
             else {
-              ui.buzzer_enabled = !ui.buzzer_enabled;
-              Draw_Checkbox(row, ui.buzzer_enabled);
+              ui.sound_on = !ui.sound_on;
+              Draw_Checkbox(row, ui.sound_on);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
               Draw_Menu_Item(row, ICON_StepX, F("Probe"), nullptr, true);
             else
               Draw_Menu(ProbeMenu);
@@ -4595,21 +4595,21 @@ void CrealityDWINClass::Screen_Update() {
                 Draw_Float(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
     }
   }
 }
 
 void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
-  if (ui.buzzer_enabled)
+  if (ui.sound_on)
     DONE_BUZZ(success);
   else
     Update_Status(success ? "Success" : "Failed");
 }
 
 void CrealityDWINClass::Save_Settings(char *buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
@@ -4639,21 +4639,21 @@ void CrealityDWINClass::Reset_Settings() {
   eeprom_settings.menu_top_txt = 0;
   eeprom_settings.highlight_box = 0;
   eeprom_settings.progress_percent = 0;
   eeprom_settings.progress_time = 0;
   eeprom_settings.status_bar_text = 0;
   eeprom_settings.status_area_text = 0;
   eeprom_settings.coordinates_text = 0;
   eeprom_settings.coordinates_split_line = 0;
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   corner_pos = eeprom_settings.corner_pos / 10.0f;
-  TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
+  TERN_(SOUND_MENU_ITEM, ui.sound_on = ENABLED(SOUND_ON_DEFAULT));
   Redraw_Screen();
 }
 
 void MarlinUI::init_lcd() {
   delay(800);
   SERIAL_ECHOPGM("\nDWIN handshake ");
   if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
   DWIN_Frame_SetDir(1); // Orientation 90°
   DWIN_UpdateLCD();     // Show bootscreen (first image)
   Encoder_Configuration();

commit 4a73fa18d8d6b7b8909fad8a84dfe90cf8fefab1
Author: Mateusz Kleina <mateuszkleina@gmail.com>
Date:   Fri Apr 22 12:12:39 2022 +0200

    🐛 Fix ProUI / JyersUI leveling preheat (#24064)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 347ac6f97c..fd51ab4686 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2862,30 +2862,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           #endif
           case LEVELING_GET_MESH:
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, F("Create New Mesh"));
             else {
               Popup_Handler(Home);
               gcode.home_all_axes(true);
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 #if ENABLED(PREHEAT_BEFORE_LEVELING)
                   Popup_Handler(Heating);
-                  #if HAS_HOTEND
-                    if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
-                      thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
-                  #endif
-                  #if HAS_HEATED_BED
-                    if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
-                      thermalManager.setTargetBed(LEVELING_BED_TEMP);
-                  #endif
-                  thermalManager.wait_for_hotend(0);
-                  TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
+                  probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, LEVELING_BED_TEMP);
                 #endif
                 #if HAS_BED_PROBE
                   Popup_Handler(Level);
                   gcode.process_subcommands_now(F("G29 P0\nG29 P1"));
                   gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
                   planner.synchronize();
                   Update_Status("Probed all reachable points");
                   Popup_Handler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;

commit 42be79b3a2f4ccbaf244cf659eb7da83e118e8a0
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Apr 19 17:16:26 2022 -0700

    🐛 Fix JyersUI Preheat Items (#24060)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 107d4a6a19..347ac6f97c 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2072,21 +2072,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HEATED_BED
 
     #if HAS_PREHEAT
-      #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu(N, item, TEMP_PREHEAT##N); break;
+      #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu((N) - 1, item, TEMP_PREHEAT##N); break;
       REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
     #endif
 
     case Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))

commit 9d623160a60edc15a95014559787d43dd7652f4d
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Mon Apr 18 03:46:58 2022 -0700

    🧑‍💻 Preheat menu improvements (#24017)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 26e9c5f3f5..107d4a6a19 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1005,24 +1005,76 @@ void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
         const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
         DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
       }
     }
   }
 }
 
 /* Menu Item Config */
 
 void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
-  uint8_t row = item - scrollpos;
+  const uint8_t row = item - scrollpos;
   #if HAS_LEVELING
     static bool level_state;
   #endif
+
+  #if HAS_PREHEAT
+
+    #define PREHEAT_BACK 0
+    #define PREHEAT_SUBMENU_HOTEND (PREHEAT_BACK + ENABLED(HAS_HOTEND))
+    #define PREHEAT_SUBMENU_BED (PREHEAT_SUBMENU_HOTEND + ENABLED(HAS_HEATED_BED))
+    #define PREHEAT_SUBMENU_FAN (PREHEAT_SUBMENU_BED + ENABLED(HAS_FAN))
+    #define PREHEAT_SUBMENU_TOTAL PREHEAT_SUBMENU_FAN
+
+    auto preheat_submenu = [&](const int index, const uint8_t item, const uint8_t sel) {
+      switch (item) {
+        case PREHEAT_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
+          else
+            Draw_Menu(TempMenu, sel);
+          break;
+        #if HAS_HOTEND
+          case PREHEAT_SUBMENU_HOTEND:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
+              Draw_Float(ui.material_preset[index].hotend_temp, row, false, 1);
+            }
+            else
+              Modify_Value(ui.material_preset[index].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+        #endif
+        #if HAS_HEATED_BED
+          case PREHEAT_SUBMENU_BED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
+              Draw_Float(ui.material_preset[index].bed_temp, row, false, 1);
+            }
+            else
+              Modify_Value(ui.material_preset[index].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+        #endif
+        #if HAS_FAN
+          case PREHEAT_SUBMENU_FAN:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
+              Draw_Float(ui.material_preset[index].fan_speed, row, false, 1);
+            }
+            else
+              Modify_Value(ui.material_preset[index].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+            break;
+        #endif
+      }
+    };
+
+  #endif
+
   switch (menu) {
     case Prepare:
 
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
@@ -1577,21 +1629,20 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               else
                 AudioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
 
     #if HAS_PREHEAT
       case Preheat: {
-        #define PREHEAT_BACK 0
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
         #define PREHEAT_1 (PREHEAT_MODE + 1)
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
         auto do_preheat = [](const uint8_t m) {
           thermalManager.cooldown();
@@ -1599,73 +1650,37 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
         };
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Prepare, PREPARE_PREHEAT);
             break;
+
           case PREHEAT_MODE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
               Draw_Option(preheatmode, preheat_modes, row);
             }
             else
               Modify_Option(preheatmode, preheat_modes, 2);
             break;
 
-          #if PREHEAT_COUNT >= 1
-            case PREHEAT_1:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_1_LABEL));
-              else
-                do_preheat(0);
-              break;
-          #endif
-
-          #if PREHEAT_COUNT >= 2
-            case PREHEAT_2:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_2_LABEL));
-              else
-                do_preheat(1);
-              break;
-          #endif
-
-          #if PREHEAT_COUNT >= 3
-            case PREHEAT_3:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_3_LABEL));
-              else
-                do_preheat(2);
-              break;
-          #endif
-
-          #if PREHEAT_COUNT >= 4
-            case PREHEAT_4:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_4_LABEL));
-              else
-                do_preheat(3);
-              break;
-          #endif
+          #define _PREHEAT_CASE(N) \
+            case PREHEAT_##N: { \
+              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+              else do_preheat(N - 1); \
+            } break;
 
-          #if PREHEAT_COUNT >= 5
-            case PREHEAT_5:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_5_LABEL));
-              else
-                do_preheat(4);
-              break;
-          #endif
+          REPEAT_1(PREHEAT_COUNT, _PREHEAT_CASE)
         }
       } break;
     #endif // HAS_PREHEAT
 
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:
 
         #define CHANGEFIL_BACK 0
         #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
@@ -1864,60 +1879,28 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             break;
         #endif
         #if HAS_HOTEND || HAS_HEATED_BED
           case TEMP_PID:
             if (draw)
               Draw_Menu_Item(row, ICON_Step, F("PID"), nullptr, true);
             else
               Draw_Menu(PID);
             break;
         #endif
-        #if PREHEAT_COUNT >= 1
-          case TEMP_PREHEAT1:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_1_LABEL), nullptr, true);
-            else
-              Draw_Menu(Preheat1);
-            break;
-        #endif
-        #if PREHEAT_COUNT >= 2
-          case TEMP_PREHEAT2:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_2_LABEL), nullptr, true);
-            else
-              Draw_Menu(Preheat2);
-            break;
-        #endif
-        #if PREHEAT_COUNT >= 3
-          case TEMP_PREHEAT3:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_3_LABEL), nullptr, true);
-            else
-              Draw_Menu(Preheat3);
-            break;
-        #endif
-        #if PREHEAT_COUNT >= 4
-          case TEMP_PREHEAT4:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_4_LABEL), nullptr, true);
-            else
-              Draw_Menu(Preheat4);
-            break;
-        #endif
-        #if PREHEAT_COUNT >= 5
-          case TEMP_PREHEAT5:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_5_LABEL), nullptr, true);
-            else
-              Draw_Menu(Preheat5);
-            break;
-        #endif
+
+        #define _TEMP_PREHEAT_CASE(N) \
+          case TEMP_PREHEAT##N: { \
+            if (draw) Draw_Menu_Item(row, ICON_Step, F(PREHEAT_## N ##_LABEL), nullptr, true); \
+            else Draw_Menu(Preheat##N); \
+          } break;
+
+        REPEAT_1(PREHEAT_COUNT, _TEMP_PREHEAT_CASE)
       }
       break;
 
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:
 
         #define PID_BACK 0
         #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
         #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PID_CYCLES (PID_BED + 1)
@@ -2088,269 +2071,24 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
               Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HEATED_BED
 
-    #if PREHEAT_COUNT >= 1
-      case Preheat1:
-
-        #define PREHEAT1_BACK 0
-        #define PREHEAT1_HOTEND (PREHEAT1_BACK + ENABLED(HAS_HOTEND))
-        #define PREHEAT1_BED (PREHEAT1_HOTEND + ENABLED(HAS_HEATED_BED))
-        #define PREHEAT1_FAN (PREHEAT1_BED + ENABLED(HAS_FAN))
-        #define PREHEAT1_TOTAL PREHEAT1_FAN
-
-        switch (item) {
-          case PREHEAT1_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
-            else
-              Draw_Menu(TempMenu, TEMP_PREHEAT1);
-            break;
-          #if HAS_HOTEND
-            case PREHEAT1_HOTEND:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-                Draw_Float(ui.material_preset[0].hotend_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[0].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-              break;
-          #endif
-          #if HAS_HEATED_BED
-            case PREHEAT1_BED:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-                Draw_Float(ui.material_preset[0].bed_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[0].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-              break;
-          #endif
-          #if HAS_FAN
-            case PREHEAT1_FAN:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-                Draw_Float(ui.material_preset[0].fan_speed, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[0].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-              break;
-          #endif
-        }
-        break;
-    #endif // PREHEAT_COUNT >= 1
-
-    #if PREHEAT_COUNT >= 2
-      case Preheat2:
-
-        #define PREHEAT2_BACK 0
-        #define PREHEAT2_HOTEND (PREHEAT2_BACK + ENABLED(HAS_HOTEND))
-        #define PREHEAT2_BED (PREHEAT2_HOTEND + ENABLED(HAS_HEATED_BED))
-        #define PREHEAT2_FAN (PREHEAT2_BED + ENABLED(HAS_FAN))
-        #define PREHEAT2_TOTAL PREHEAT2_FAN
-
-        switch (item) {
-          case PREHEAT2_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
-            else
-              Draw_Menu(TempMenu, TEMP_PREHEAT2);
-            break;
-          #if HAS_HOTEND
-            case PREHEAT2_HOTEND:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-                Draw_Float(ui.material_preset[1].hotend_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[1].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-              break;
-          #endif
-          #if HAS_HEATED_BED
-            case PREHEAT2_BED:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-                Draw_Float(ui.material_preset[1].bed_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[1].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-              break;
-          #endif
-          #if HAS_FAN
-            case PREHEAT2_FAN:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-                Draw_Float(ui.material_preset[1].fan_speed, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[1].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-              break;
-          #endif
-        }
-        break;
-    #endif // PREHEAT_COUNT >= 2
-
-    #if PREHEAT_COUNT >= 3
-      case Preheat3:
-
-        #define PREHEAT3_BACK 0
-        #define PREHEAT3_HOTEND (PREHEAT3_BACK + ENABLED(HAS_HOTEND))
-        #define PREHEAT3_BED (PREHEAT3_HOTEND + ENABLED(HAS_HEATED_BED))
-        #define PREHEAT3_FAN (PREHEAT3_BED + ENABLED(HAS_FAN))
-        #define PREHEAT3_TOTAL PREHEAT3_FAN
-
-        switch (item) {
-          case PREHEAT3_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
-            else
-              Draw_Menu(TempMenu, TEMP_PREHEAT3);
-            break;
-          #if HAS_HOTEND
-            case PREHEAT3_HOTEND:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-                Draw_Float(ui.material_preset[2].hotend_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[2].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-              break;
-          #endif
-          #if HAS_HEATED_BED
-            case PREHEAT3_BED:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-                Draw_Float(ui.material_preset[2].bed_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[2].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-              break;
-          #endif
-          #if HAS_FAN
-            case PREHEAT3_FAN:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-                Draw_Float(ui.material_preset[2].fan_speed, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[2].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-              break;
-          #endif
-        }
-        break;
-    #endif // PREHEAT_COUNT >= 3
-
-    #if PREHEAT_COUNT >= 4
-      case Preheat4:
-
-        #define PREHEAT4_BACK 0
-        #define PREHEAT4_HOTEND (PREHEAT4_BACK + ENABLED(HAS_HOTEND))
-        #define PREHEAT4_BED (PREHEAT4_HOTEND + ENABLED(HAS_HEATED_BED))
-        #define PREHEAT4_FAN (PREHEAT4_BED + ENABLED(HAS_FAN))
-        #define PREHEAT4_TOTAL PREHEAT4_FAN
-
-        switch (item) {
-          case PREHEAT4_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
-            else
-              Draw_Menu(TempMenu, TEMP_PREHEAT4);
-            break;
-          #if HAS_HOTEND
-            case PREHEAT4_HOTEND:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-                Draw_Float(ui.material_preset[3].hotend_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[3].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-              break;
-          #endif
-          #if HAS_HEATED_BED
-            case PREHEAT4_BED:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-                Draw_Float(ui.material_preset[3].bed_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[3].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-              break;
-          #endif
-          #if HAS_FAN
-            case PREHEAT4_FAN:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-                Draw_Float(ui.material_preset[3].fan_speed, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[3].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-              break;
-          #endif
-        }
-        break;
-    #endif // PREHEAT_COUNT >= 4
-
-    #if PREHEAT_COUNT >= 5
-      case Preheat5:
-
-        #define PREHEAT5_BACK 0
-        #define PREHEAT5_HOTEND (PREHEAT5_BACK + ENABLED(HAS_HOTEND))
-        #define PREHEAT5_BED (PREHEAT5_HOTEND + ENABLED(HAS_HEATED_BED))
-        #define PREHEAT5_FAN (PREHEAT5_BED + ENABLED(HAS_FAN))
-        #define PREHEAT5_TOTAL PREHEAT5_FAN
-
-        switch (item) {
-          case PREHEAT5_BACK:
-            if (draw)
-              Draw_Menu_Item(row, ICON_Back, F("Back"));
-            else
-              Draw_Menu(TempMenu, TEMP_PREHEAT5);
-            break;
-          #if HAS_HOTEND
-            case PREHEAT5_HOTEND:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
-                Draw_Float(ui.material_preset[4].hotend_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[4].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
-              break;
-          #endif
-          #if HAS_HEATED_BED
-            case PREHEAT5_BED:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
-                Draw_Float(ui.material_preset[4].bed_temp, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[4].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
-              break;
-          #endif
-          #if HAS_FAN
-            case PREHEAT5_FAN:
-              if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
-                Draw_Float(ui.material_preset[4].fan_speed, row, false, 1);
-              }
-              else
-                Modify_Value(ui.material_preset[4].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
-              break;
-          #endif
-        }
-        break;
-    #endif // PREHEAT_COUNT >= 5
+    #if HAS_PREHEAT
+      #define _PREHEAT_SUBMENU_CASE(N) case Preheat##N: preheat_submenu(N, item, TEMP_PREHEAT##N); break;
+      REPEAT_1(PREHEAT_COUNT, _PREHEAT_SUBMENU_CASE)
+    #endif
 
     case Motion:
 
       #define MOTION_BACK 0
       #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
       #define MOTION_STEPS (MOTION_JERK + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
@@ -3848,21 +3586,23 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           if (draw) {
             Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
             Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
       }
       break;
 
-    case PreheatHotend:
+    #if HAS_PREHEAT && HAS_HOTEND
+
+      case PreheatHotend:
 
         #define PREHEATHOTEND_BACK 0
         #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
         #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
         #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
         #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
         #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
         #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
         #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
         #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
@@ -3911,70 +3651,42 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                         break;
                     }
                     break;
                 #endif
                 default:
                   Redraw_Menu(true, true, true);
                   break;
               }
             }
             break;
-          #if PREHEAT_COUNT >= 1
-            case PREHEATHOTEND_1:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_1_LABEL));
-              else
-                ui.preheat_hotend_and_fan(0);
-              break;
-          #endif
-          #if PREHEAT_COUNT >= 2
-            case PREHEATHOTEND_2:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_2_LABEL));
-              else
-                ui.preheat_hotend_and_fan(1);
-              break;
-          #endif
-          #if PREHEAT_COUNT >= 3
-            case PREHEATHOTEND_3:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_3_LABEL));
-              else
-                ui.preheat_hotend_and_fan(2);
-              break;
-          #endif
-          #if PREHEAT_COUNT >= 4
-            case PREHEATHOTEND_4:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_4_LABEL));
-              else
-                ui.preheat_hotend_and_fan(3);
-              break;
-          #endif
-          #if PREHEAT_COUNT >= 5
-            case PREHEATHOTEND_5:
-              if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_5_LABEL));
-              else
-                ui.preheat_hotend_and_fan(4);
+
+
+          #define _PREHEAT_HOTEND_CASE(N) \
+            case PREHEATHOTEND_##N: \
+              if (draw) Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_## N ##_LABEL)); \
+              else ui.preheat_hotend_and_fan((N) - 1); \
               break;
-          #endif
+
+          REPEAT_1(PREHEAT_COUNT, _PREHEAT_HOTEND_CASE)
+
           case PREHEATHOTEND_CUSTOM:
             if (draw) {
               Draw_Menu_Item(row, ICON_Temperature, F("Custom"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
+
+    #endif // HAS_PREHEAT && HAS_HOTEND
   }
 }
 
 FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
   switch (menu) {
     case MainMenu:          return F("Main Menu");
     case Prepare:           return F("Prepare");
     case HomeMenu:          return F("Homing Menu");
     case Move:              return F("Move");
     case ManualLevel:       return F("Manual Leveling");
@@ -3991,34 +3703,23 @@ FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
     case TempMenu:          return F("Temperature");
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return F("PID Menu");
     #endif
     #if HAS_HOTEND
       case HotendPID:       return F("Hotend PID Settings");
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return F("Bed PID Settings");
     #endif
-    #if PREHEAT_COUNT >= 1
-      case Preheat1:        return F(PREHEAT_1_LABEL " Settings");
-    #endif
-    #if PREHEAT_COUNT >= 2
-      case Preheat2:        return F(PREHEAT_2_LABEL " Settings");
-    #endif
-    #if PREHEAT_COUNT >= 3
-      case Preheat3:        return F(PREHEAT_3_LABEL " Settings");
-    #endif
-    #if PREHEAT_COUNT >= 4
-      case Preheat4:        return F(PREHEAT_4_LABEL " Settings");
-    #endif
-    #if PREHEAT_COUNT >= 5
-      case Preheat5:        return F(PREHEAT_5_LABEL " Settings");
+    #if HAS_PREHEAT
+      #define _PREHEAT_TITLE_CASE(N) case Preheat##N: return F(PREHEAT_## N ##_LABEL " Settings");
+      REPEAT_1(PREHEAT_COUNT, _PREHEAT_TITLE_CASE)
     #endif
     case Motion:            return F("Motion Settings");
     case HomeOffsets:       return F("Home Offsets");
     case MaxSpeed:          return F("Max Speed");
     case MaxAcceleration:   return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return F("Max Jerk");
     #endif
     case Steps:             return F("Steps/mm");
     case Visual:            return F("Visual Settings");
@@ -4067,34 +3768,23 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
     case TempMenu:          return TEMP_TOTAL;
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:             return PID_TOTAL;
     #endif
     #if HAS_HOTEND
       case HotendPID:       return HOTENDPID_TOTAL;
     #endif
     #if HAS_HEATED_BED
       case BedPID:          return BEDPID_TOTAL;
     #endif
-    #if PREHEAT_COUNT >= 1
-      case Preheat1:        return PREHEAT1_TOTAL;
-    #endif
-    #if PREHEAT_COUNT >= 2
-      case Preheat2:        return PREHEAT2_TOTAL;
-    #endif
-    #if PREHEAT_COUNT >= 3
-      case Preheat3:        return PREHEAT3_TOTAL;
-    #endif
-    #if PREHEAT_COUNT >= 4
-      case Preheat4:        return PREHEAT4_TOTAL;
-    #endif
-    #if PREHEAT_COUNT >= 5
-      case Preheat5:        return PREHEAT5_TOTAL;
+    #if HAS_PREHEAT
+      case Preheat1 ... CAT(Preheat, PREHEAT_COUNT):
+                            return PREHEAT_SUBMENU_TOTAL;
     #endif
     case Motion:            return MOTION_TOTAL;
     case HomeOffsets:       return HOMEOFFSETS_TOTAL;
     case MaxSpeed:          return SPEED_TOTAL;
     case MaxAcceleration:   return ACCEL_TOTAL;
     #if HAS_CLASSIC_JERK
       case MaxJerk:         return JERK_TOTAL;
     #endif
     case Steps:             return STEPS_TOTAL;
     case Visual:            return VISUAL_TOTAL;
@@ -4111,21 +3801,25 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
       case ManualMesh:      return MMESH_TOTAL;
     #endif
     #if HAS_MESH
       case Leveling:        return LEVELING_TOTAL;
       case LevelView:       return LEVELING_VIEW_TOTAL;
       case LevelSettings:   return LEVELING_SETTINGS_TOTAL;
       case MeshViewer:      return MESHVIEW_TOTAL;
       case LevelManual:     return LEVELING_M_TOTAL;
     #endif
     case Tune:              return TUNE_TOTAL;
-    case PreheatHotend:     return PREHEATHOTEND_TOTAL;
+
+    #if HAS_PREHEAT && HAS_HOTEND
+      case PreheatHotend:   return PREHEATHOTEND_TOTAL;
+    #endif
+
     case ColorSettings:     return COLORSETTINGS_TOTAL;
   }
   return 0;
 }
 
 /* Popup Config */
 
 void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {

commit 3d3898145ab501792a731cfeec7b859aa7a2dda7
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Apr 18 11:43:34 2022 +0200

    🌐 Update German language, FTDI cleanup (#24047)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index d0f9e2e1b3..26e9c5f3f5 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -3148,21 +3148,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
                   planner.synchronize();
                   Update_Status("Probed all reachable points");
                   Popup_Handler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
                   Popup_Handler(MoveWait);
-                  mesh_conf.manual_move();;
+                  mesh_conf.manual_move();
                   Draw_Menu(UBLMesh);
                 #endif
               #elif HAS_BED_PROBE
                 Popup_Handler(Level);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
                 Popup_Handler(SaveLevel);
               #else
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);

commit ae53033cea506209310fb014b304f3a07c59e9d7
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 03:13:16 2022 +0100

    ♻️ Refactor and fix ABL Bilinear (#23868)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 3e777d4aaa..d0f9e2e1b3 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -3410,21 +3410,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
-              TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
+              TERN_(AUTO_BED_LEVELING_BILINEAR, bbl.refresh_bed_level());
               Draw_Menu(Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
               Draw_Menu_Item(row, ICON_MoveX, F("Mesh Point X"));
               Draw_Float(mesh_conf.mesh_x, row, 0, 1);
             }
             else
               Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);

commit e354cd15b224a4e12d3c5ba63986a249ad055f83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 17:12:21 2022 -0600

    🩹 Fix FSTR / PSTR usage

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 51df15da73..3e777d4aaa 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -951,22 +951,22 @@ void CrealityDWINClass::Popup_Select() {
   DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
   DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
   DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
   DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
 }
 
 void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
   static bool new_msg;
   static uint8_t msgscrl = 0;
   static char lastmsg[64];
-  if (strcmp_P(lastmsg, statusmsg) != 0 || refresh) {
-    strcpy_P(lastmsg, statusmsg);
+  if (strcmp(lastmsg, statusmsg) != 0 || refresh) {
+    strcpy(lastmsg, statusmsg);
     msgscrl = 0;
     new_msg = true;
   }
   size_t len = strlen(statusmsg);
   int8_t pos = len;
   if (pos > 30) {
     pos -= msgscrl;
     len = pos;
     if (len > 30)
       len = 30;
@@ -4688,24 +4688,21 @@ void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * option
   valuemin = 0;
   valuemax = max;
   process = Option;
   EncoderRate.enabled = true;
   Draw_Option(value, options, selection - scrollpos, true);
 }
 
 /* Main Functions */
 
 void CrealityDWINClass::Update_Status(const char * const text) {
-  char header[4];
-  LOOP_L_N(i, 3) header[i] = text[i];
-  header[3] = '\0';
-  if (strcmp_P(header, PSTR("<F>")) == 0) {
+  if (strncmp_P(text, PSTR("<F>"), 3) == 0) {
     LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
     filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
     Draw_Print_Filename(true);
   }
   else {
     LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
@@ -4715,24 +4712,24 @@ void CrealityDWINClass::Start_Print(bool sd) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {
       #if ENABLED(POWER_LOSS_RECOVERY)
         if (recovery.valid()) {
           SdFile *diveDir = nullptr;
           const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
           card.selectFileByName(fname);
         }
       #endif
-      strcpy_P(filename, card.longest_filename());
+      strcpy(filename, card.longest_filename());
     }
     else
-      strcpy_P(filename, "Host Print");
+      strcpy_P(filename, PSTR("Host Print"));
     TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
     TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
     Draw_Print_Screen();
   }
 }
 
 void CrealityDWINClass::Stop_Print() {
   printing = false;
   sdprint = false;
   thermalManager.cooldown();

commit 89a9c3a391101e4d2d8dbfbf0cdb261ad2d9592b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 16:34:58 2022 -0600

    🧑‍💻  Add standard BUZZ types

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index d384bae3e3..51df15da73 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4913,32 +4913,24 @@ void CrealityDWINClass::Screen_Update() {
                 Draw_Float(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
             }
           }
         #endif
         break;
     }
   }
 }
 
 void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
-  if (success) {
-    if (ui.buzzer_enabled) {
-      BUZZ(100, 659);
-      BUZZ( 10,   0);
-      BUZZ(100, 698);
-    }
-    else Update_Status("Success");
-  }
-  else if (ui.buzzer_enabled)
-    BUZZ(40, 440);
+  if (ui.buzzer_enabled)
+    DONE_BUZZ(success);
   else
-    Update_Status("Failed");
+    Update_Status(success ? "Success" : "Failed");
 }
 
 void CrealityDWINClass::Save_Settings(char *buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
 
 void CrealityDWINClass::Load_Settings(const char *buff) {
   memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));

commit 9ef01d43bb2f4384482ae8205ca6c80ebe388a52
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Mar 1 17:25:30 2022 -0500

    ⚡️ E3V2 blank bg for S1 compatibility (#23822)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 0eedddb500..d384bae3e3 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4982,20 +4982,22 @@ void MarlinUI::init_lcd() {
   if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
   DWIN_Frame_SetDir(1); // Orientation 90°
   DWIN_UpdateLCD();     // Show bootscreen (first image)
   Encoder_Configuration();
   for (uint16_t t = 0; t <= 100; t += 2) {
     DWIN_ICON_Show(ICON, ICON_Bar, 15, 260);
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
     DWIN_UpdateLCD();
     delay(20);
   }
+
+  DWIN_JPG_ShowAndCache(3);
   DWIN_JPG_CacheTo1(Language_English);
   CrealityDWIN.Redraw_Screen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     switch (message) {
       case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
       case PAUSE_MESSAGE_PURGE:
       case PAUSE_MESSAGE_OPTION:  CrealityDWIN.Popup_Handler(PurgeMore);    break;

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    🚸 Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 1356c0e475..0eedddb500 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -75,24 +75,20 @@
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
 #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 
-#ifndef CORP_WEBSITE
-   #define CORP_WEBSITE WEBSITE_URL
- #endif
-
 #define DWIN_FONT_MENU font8x16
 #define DWIN_FONT_STAT font10x20
 #define DWIN_FONT_HEAD font10x20
 
 #define MENU_CHAR_LIMIT  24
 #define STATUS_Y 352
 
 #define MAX_PRINT_SPEED   500
 #define MIN_PRINT_SPEED   10
 

commit d5f2334140e6f8ead29d3648b371547ebe72c7aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 22 10:14:47 2022 -0600

    ♻️ Adjust LCD init, contrast default, settings load

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index eea464dcfd..1356c0e475 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4973,21 +4973,21 @@ void CrealityDWINClass::Reset_Settings() {
   eeprom_settings.status_bar_text = 0;
   eeprom_settings.status_area_text = 0;
   eeprom_settings.coordinates_text = 0;
   eeprom_settings.coordinates_split_line = 0;
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   corner_pos = eeprom_settings.corner_pos / 10.0f;
   TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
   Redraw_Screen();
 }
 
-void MarlinUI::init() {
+void MarlinUI::init_lcd() {
   delay(800);
   SERIAL_ECHOPGM("\nDWIN handshake ");
   if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
   DWIN_Frame_SetDir(1); // Orientation 90°
   DWIN_UpdateLCD();     // Show bootscreen (first image)
   Encoder_Configuration();
   for (uint16_t t = 0; t <= 100; t += 2) {
     DWIN_ICON_Show(ICON, ICON_Bar, 15, 260);
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
     DWIN_UpdateLCD();

commit b7be62ad36d9d2e8bc4d0718b8cba94321267077
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Wed Nov 17 12:09:01 2021 -0500

    🎨 Fix misspelling (#23137)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 4c838a2e21..eea464dcfd 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4128,21 +4128,21 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
   return 0;
 }
 
 /* Popup Config */
 
 void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
     case Pause:         Draw_Popup(F("Pause Print"), F(""), F(""), Popup); break;
     case Stop:          Draw_Popup(F("Stop Print"), F(""), F(""), Popup); break;
-    case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interupted."), Popup); break;
+    case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interrupted."), Popup); break;
     case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
     case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
     case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
     case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
     case ETemp:         Draw_Popup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
     case ManualProbing: Draw_Popup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
     case Level:         Draw_Popup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
     case Home:          Draw_Popup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case MoveWait:      Draw_Popup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     case Heating:       Draw_Popup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;

commit 30a69f76a3dc9deaef6974d18107d7f759502092
Author: dwzg <50058606+dwzg@users.noreply.github.com>
Date:   Sun Nov 7 04:48:00 2021 +0100

    🐛 Fix JyersUI scrolling filename, etc. (#23082)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 80ef88d0b2..4c838a2e21 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -671,45 +671,45 @@ void CrealityDWINClass::Draw_Print_Screen() {
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
   Draw_Print_Filename(true);
 }
 
 void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
   static uint8_t namescrl = 0;
   if (reset) namescrl = 0;
   if (process == Print) {
-    size_t len = strlen(filename);
-    int8_t pos = len;
-    if (pos > 30) {
-      pos -= namescrl;
-      len = _MIN(pos, 30);
-      char dispname[len + 1];
+    constexpr int8_t maxlen = 30;
+    char *outstr = filename;
+    size_t slen = strlen(filename);
+    int8_t outlen = slen;
+    if (slen > maxlen) {
+      char dispname[maxlen + 1];
+      int8_t pos = slen - namescrl, len = maxlen;
       if (pos >= 0) {
+        NOMORE(len, pos);
         LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
       }
       else {
-        LOOP_L_N(i, 30 + pos) dispname[i] = ' ';
-        LOOP_S_L_N(i, 30 + pos, 30) dispname[i] = filename[i - (30 + pos)];
+        const int8_t mp = maxlen + pos;
+        LOOP_L_N(i, mp) dispname[i] = ' ';
+        LOOP_S_L_N(i, mp, maxlen) dispname[i] = filename[i - mp];
+        if (mp <= 0) namescrl = 0;
       }
       dispname[len] = '\0';
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
-      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, dispname);
-      if (-pos >= 30) namescrl = 0;
+      outstr = dispname;
+      outlen = maxlen;
       namescrl++;
     }
-    else {
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
-      const int8_t npos = (DWIN_WIDTH - strlen(filename) * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, filename);
-    }
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
+    const int8_t npos = (DWIN_WIDTH - outlen * MENU_CHR_W) / 2;
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, outstr);
   }
 }
 
 void CrealityDWINClass::Draw_Print_ProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
   DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
   DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
   DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
 }
@@ -4695,21 +4695,21 @@ void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * option
   EncoderRate.enabled = true;
   Draw_Option(value, options, selection - scrollpos, true);
 }
 
 /* Main Functions */
 
 void CrealityDWINClass::Update_Status(const char * const text) {
   char header[4];
   LOOP_L_N(i, 3) header[i] = text[i];
   header[3] = '\0';
-  if (strcmp_P(header,"<F>") == 0) {
+  if (strcmp_P(header, PSTR("<F>")) == 0) {
     LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
     filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
     Draw_Print_Filename(true);
   }
   else {
     LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
@@ -4791,36 +4791,37 @@ void CrealityDWINClass::State_Update() {
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     static bool ranout = false;
     if (runout.filament_ran_out != ranout) {
       ranout = runout.filament_ran_out;
       if (ranout) Popup_Handler(Runout);
     }
   #endif
 }
 
 void CrealityDWINClass::Screen_Update() {
+  const millis_t ms = millis();
   static millis_t scrltime = 0;
-  if (ELAPSED(millis(), scrltime)) {
-    scrltime = millis() + 200;
+  if (ELAPSED(ms, scrltime)) {
+    scrltime = ms + 200;
     Update_Status_Bar();
     if (process == Print) Draw_Print_Filename();
   }
 
   static millis_t statustime = 0;
-  if (ELAPSED(millis(), statustime)) {
-    statustime = millis() + 500;
+  if (ELAPSED(ms, statustime)) {
+    statustime = ms + 500;
     Draw_Status_Area();
   }
 
   static millis_t printtime = 0;
-  if (ELAPSED(millis(), printtime)) {
-    printtime = millis() + 1000;
+  if (ELAPSED(ms, printtime)) {
+    printtime = ms + 1000;
     if (process == Print) {
       Draw_Print_ProgressBar();
       Draw_Print_ProgressElapsed();
       TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
     }
   }
 
   static bool mounted = card.isMounted();
   if (mounted != card.isMounted()) {
     mounted = card.isMounted();
@@ -4993,19 +4994,20 @@ void MarlinUI::init() {
     delay(20);
   }
   DWIN_JPG_CacheTo1(Language_English);
   CrealityDWIN.Redraw_Screen();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     switch (message) {
       case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
+      case PAUSE_MESSAGE_PURGE:
       case PAUSE_MESSAGE_OPTION:  CrealityDWIN.Popup_Handler(PurgeMore);    break;
       case PAUSE_MESSAGE_HEAT:    CrealityDWIN.Confirm_Handler(HeaterTime); break;
       case PAUSE_MESSAGE_WAITING: CrealityDWIN.Draw_Print_Screen();         break;
       default: break;
     }
   }
 #endif
 
 #endif // DWIN_CREALITY_LCD_JYERSUI

commit 70e31bff45165dd07375cd6140fc0a72468e0894
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:36:06 2021 -0500

    🎨 Standard 'cooldown' method

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 54266e717b..80ef88d0b2 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1023,21 +1023,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
   switch (menu) {
     case Prepare:
 
       #define PREPARE_BACK 0
       #define PREPARE_MOVE (PREPARE_BACK + 1)
       #define PREPARE_DISABLE (PREPARE_MOVE + 1)
       #define PREPARE_HOME (PREPARE_DISABLE + 1)
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
-      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ENABLED(HAS_PREHEAT))
+      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + EITHER(HAS_HOTEND, HAS_HEATED_BED))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define PREPARE_TOTAL PREPARE_CHANGEFIL
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Main_Menu(1);
           break;
@@ -1089,27 +1089,28 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             break;
         #endif
 
         #if HAS_PREHEAT
           case PREPARE_PREHEAT:
             if (draw)
               Draw_Menu_Item(row, ICON_Temperature, F("Preheat"), nullptr, true);
             else
               Draw_Menu(Preheat);
             break;
+        #endif
+
+        #if HAS_HOTEND || HAS_HEATED_BED
           case PREPARE_COOLDOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_Cool, F("Cooldown"));
-            else {
-              TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-              thermalManager.disable_all_heaters();
-            }
+            else
+              thermalManager.cooldown();
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
               Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament")
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
@@ -1590,22 +1591,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PREHEAT_BACK 0
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
         #define PREHEAT_1 (PREHEAT_MODE + 1)
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
         auto do_preheat = [](const uint8_t m) {
-          thermalManager.disable_all_heaters();
-          TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+          thermalManager.cooldown();
           if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
           if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
         };
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Prepare, PREPARE_PREHEAT);
@@ -4489,36 +4489,34 @@ void CrealityDWINClass::Popup_Control() {
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
               queue.inject(F("M125"));
               planner.synchronize();
             #else
               queue.inject(F("M25"));
               TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
               TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
-              thermalManager.disable_all_heaters();
-              TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+              thermalManager.cooldown();
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.pause());
           }
         }
         Draw_Print_Screen();
         break;
       case Stop:
         if (selection == 0) {
           if (sdprint) {
             ui.abort_print();
-            TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-            thermalManager.disable_all_heaters();
+            thermalManager.cooldown();
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
           }
         }
         else
           Draw_Print_Screen();
         break;
       case Resume:
         if (selection == 0)
@@ -4734,22 +4732,21 @@ void CrealityDWINClass::Start_Print(bool sd) {
       strcpy_P(filename, "Host Print");
     TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
     TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
     Draw_Print_Screen();
   }
 }
 
 void CrealityDWINClass::Stop_Print() {
   printing = false;
   sdprint = false;
-  TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-  thermalManager.disable_all_heaters();
+  thermalManager.cooldown();
   TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(100 * (PROGRESS_SCALE)));
   TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
   Draw_Print_confirm();
 }
 
 void CrealityDWINClass::Update() {
   State_Update();
   Screen_Update();
   switch (process) {
     case Main:    Main_Menu_Control();    break;

commit b09038fcc72bc8df4ec8a7014597586e0b0390ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 20:01:44 2021 -0500

    🎨 Standard material presets behavior

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 9cecf202b2..54266e717b 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1577,140 +1577,102 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             case ZOFFSET_SAVE:
               if (draw)
                 Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save"));
               else
                 AudioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
-    #if HAS_PREHEAT
-      case Preheat:
 
+    #if HAS_PREHEAT
+      case Preheat: {
         #define PREHEAT_BACK 0
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
         #define PREHEAT_1 (PREHEAT_MODE + 1)
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
+        auto do_preheat = [](const uint8_t m) {
+          thermalManager.disable_all_heaters();
+          TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+          if (preheatmode == 0 || preheatmode == 1) { ui.preheat_hotend_and_fan(m); }
+          if (preheatmode == 0 || preheatmode == 2) ui.preheat_bed(m);
+        };
+
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Prepare, PREPARE_PREHEAT);
             break;
           case PREHEAT_MODE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
               Draw_Option(preheatmode, preheat_modes, row);
             }
             else
               Modify_Option(preheatmode, preheat_modes, 2);
             break;
 
           #if PREHEAT_COUNT >= 1
             case PREHEAT_1:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_1_LABEL));
-              else {
-                thermalManager.disable_all_heaters();
-                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-                if (preheatmode == 0 || preheatmode == 1) {
-                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[0].hotend_temp, 0));
-                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[0].fan_speed));
-                }
-                #if HAS_HEATED_BED
-                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[0].bed_temp);
-                #endif
-              }
+              else
+                do_preheat(0);
               break;
           #endif
 
           #if PREHEAT_COUNT >= 2
             case PREHEAT_2:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_2_LABEL));
-              else {
-                thermalManager.disable_all_heaters();
-                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-                if (preheatmode == 0 || preheatmode == 1) {
-                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[1].hotend_temp, 0));
-                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[1].fan_speed));
-                }
-                #if HAS_HEATED_BED
-                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[1].bed_temp);
-                #endif
-              }
+              else
+                do_preheat(1);
               break;
           #endif
 
           #if PREHEAT_COUNT >= 3
             case PREHEAT_3:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_3_LABEL));
-              else {
-                thermalManager.disable_all_heaters();
-                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-                if (preheatmode == 0 || preheatmode == 1) {
-                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[2].hotend_temp, 0));
-                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[2].fan_speed));
-                }
-                #if HAS_HEATED_BED
-                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[2].bed_temp);
-                #endif
-              }
+              else
+                do_preheat(2);
               break;
           #endif
 
           #if PREHEAT_COUNT >= 4
             case PREHEAT_4:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_4_LABEL));
-              else {
-                thermalManager.disable_all_heaters();
-                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-                if (preheatmode == 0 || preheatmode == 1) {
-                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[3].hotend_temp, 0));
-                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[3].fan_speed));
-                }
-                #if HAS_HEATED_BED
-                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[3].bed_temp);
-                #endif
-              }
+              else
+                do_preheat(3);
               break;
           #endif
 
           #if PREHEAT_COUNT >= 5
             case PREHEAT_5:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_5_LABEL));
-              else {
-                thermalManager.disable_all_heaters();
-                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-                if (preheatmode == 0 || preheatmode == 1) {
-                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[4].hotend_temp, 0));
-                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[4].fan_speed));
-                }
-                #if HAS_HEATED_BED
-                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[4].bed_temp);
-                #endif
-              }
+              else
+                do_preheat(4);
               break;
           #endif
         }
-        break;
-    #endif
+      } break;
+    #endif // HAS_PREHEAT
 
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       case ChangeFilament:
 
         #define CHANGEFIL_BACK 0
         #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
         #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
         #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
 
@@ -3957,64 +3919,54 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 default:
                   Redraw_Menu(true, true, true);
                   break;
               }
             }
             break;
           #if PREHEAT_COUNT >= 1
             case PREHEATHOTEND_1:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_1_LABEL));
-              else {
-                thermalManager.setTargetHotend(ui.material_preset[0].hotend_temp, 0);
-                thermalManager.set_fan_speed(0, ui.material_preset[0].fan_speed);
-              }
+              else
+                ui.preheat_hotend_and_fan(0);
               break;
           #endif
           #if PREHEAT_COUNT >= 2
             case PREHEATHOTEND_2:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_2_LABEL));
-              else {
-                thermalManager.setTargetHotend(ui.material_preset[1].hotend_temp, 0);
-                thermalManager.set_fan_speed(0, ui.material_preset[1].fan_speed);
-              }
+              else
+                ui.preheat_hotend_and_fan(1);
               break;
           #endif
           #if PREHEAT_COUNT >= 3
             case PREHEATHOTEND_3:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_3_LABEL));
-              else {
-                thermalManager.setTargetHotend(ui.material_preset[2].hotend_temp, 0);
-                thermalManager.set_fan_speed(0, ui.material_preset[2].fan_speed);
-              }
+              else
+                ui.preheat_hotend_and_fan(2);
               break;
           #endif
           #if PREHEAT_COUNT >= 4
             case PREHEATHOTEND_4:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_4_LABEL));
-              else {
-                thermalManager.setTargetHotend(ui.material_preset[3].hotend_temp, 0);
-                thermalManager.set_fan_speed(0, ui.material_preset[3].fan_speed);
-              }
+              else
+                ui.preheat_hotend_and_fan(3);
               break;
           #endif
           #if PREHEAT_COUNT >= 5
             case PREHEATHOTEND_5:
               if (draw)
                 Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_5_LABEL));
-              else {
-                thermalManager.setTargetHotend(ui.material_preset[4].hotend_temp, 0);
-                thermalManager.set_fan_speed(0, ui.material_preset[4].fan_speed);
-              }
+              else
+                ui.preheat_hotend_and_fan(4);
               break;
           #endif
           case PREHEATHOTEND_CUSTOM:
             if (draw) {
               Draw_Menu_Item(row, ICON_Temperature, F("Custom"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;

commit 1d80464ba77bc576426f15af28a633bf48d769ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:15:58 2021 -0500

    🎨 Define HAS_PREHEAT conditional

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 691c03af0d..9cecf202b2 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -69,24 +69,20 @@
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../../libs/least_squares_fit.h"
   #include "../../../libs/vector_3.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
-#if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_FAN) && PREHEAT_COUNT
-  #define HAS_PREHEAT 1
-#endif
-
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
 #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 
 #ifndef CORP_WEBSITE
    #define CORP_WEBSITE WEBSITE_URL
  #endif
 
@@ -1586,21 +1582,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               break;
           #endif
         }
         break;
     #endif
     #if HAS_PREHEAT
       case Preheat:
 
         #define PREHEAT_BACK 0
         #define PREHEAT_MODE (PREHEAT_BACK + 1)
-        #define PREHEAT_1 (PREHEAT_MODE + (PREHEAT_COUNT >= 1))
+        #define PREHEAT_1 (PREHEAT_MODE + 1)
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, F("Back"));

commit f6c7fbd1ab62b0c3aa70c971ad6c30d062d3252a
Author: Dennis <Stuxles@users.noreply.github.com>
Date:   Mon Oct 25 07:35:11 2021 +0200

    🐛 Fix JyersUI current positions (scaling) (#23005)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index a4e05cace9..691c03af0d 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -897,35 +897,35 @@ void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
     DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
   }
   if (update_x) {
     x = current_position.x;
     if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x * 10);
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x);
   }
   if (update_y) {
     y = current_position.y;
     if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y * 10);
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y);
   }
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
     else
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z * 100 : 0);
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z : 0);
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
   if (process != Confirm && process != Popup && process != Wait) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
   Clear_Screen();
   DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);

commit b93c3301f2146bed7287ad097b95b53507c35420
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 18 02:03:01 2021 -0400

    Fix JyersUI ZOffset Multiplication (#22975)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 6fe3db438d..a4e05cace9 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -412,21 +412,21 @@ void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
 }
 
 void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
   const uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
   const uint16_t xpos = 240 - (digits * 8);
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
   if (isnan(value))
     DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
-    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value) * minunit);
+    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value));
     DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
 void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
   uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
   uint16_t tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
   DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
   DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
@@ -864,21 +864,21 @@ void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
 
   #if HAS_ZOFFSET_ITEM
     static float offset = -1;
 
     if (icons) {
       offset = -1;
       DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
     }
     if (zoffsetvalue != offset) {
       offset = zoffsetvalue;
-      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue) * 100);
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue));
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
     }
   #endif
 
   static int16_t feedrate = -1;
   if (icons) {
     feedrate = -1;
     DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
     DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
   }

commit ee28a14e8e7f6b33fe5813dbedcd85380207c345
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 15 00:24:08 2021 -0500

    🎨 Refactor Host Actions as singleton

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 9bb324b05e..6fe3db438d 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4496,21 +4496,21 @@ void CrealityDWINClass::Print_Screen_Control() {
               #if HAS_EXTRUDERS
                 cmnd[sprintf_P(cmnd, PSTR("M109 S%i"), pausetemp)] = '\0';
                 gcode.process_subcommands_now(cmnd);
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
               TERN_(SDSUPPORT, queue.inject(F("M24")));
             #endif
           }
           else {
-            TERN_(HOST_ACTION_COMMANDS, host_action_resume());
+            TERN_(HOST_ACTION_COMMANDS, hostui.resume());
           }
           Draw_Print_Screen();
         }
         else
           Popup_Handler(Pause);
         break;
       case PRINT_STOP: Popup_Handler(Stop); break;
     }
   }
   DWIN_UpdateLCD();
@@ -4546,34 +4546,34 @@ void CrealityDWINClass::Popup_Control() {
             #else
               queue.inject(F("M25"));
               TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
               TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
               thermalManager.disable_all_heaters();
               TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
             #endif
           }
           else {
-            TERN_(HOST_ACTION_COMMANDS, host_action_pause());
+            TERN_(HOST_ACTION_COMMANDS, hostui.pause());
           }
         }
         Draw_Print_Screen();
         break;
       case Stop:
         if (selection == 0) {
           if (sdprint) {
             ui.abort_print();
             TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
             thermalManager.disable_all_heaters();
           }
           else {
-            TERN_(HOST_ACTION_COMMANDS, host_action_cancel());
+            TERN_(HOST_ACTION_COMMANDS, hostui.cancel());
           }
         }
         else
           Draw_Print_Screen();
         break;
       case Resume:
         if (selection == 0)
           queue.inject(F("M1000"));
         else {
           queue.inject(F("M1000 C"));

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    🎨 Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 8e4abbe4bc..9bb324b05e 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -942,21 +942,21 @@ void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
     Popup_Select();
   }
   else if (mode == Confirm) {
     DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
   }
 }
 
-void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
+void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const) {
   CrealityDWIN.Draw_Popup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
 }
 
 void CrealityDWINClass::Popup_Select() {
   const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
                  c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
   DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
   DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
   DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
   DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    🎨 Apply F() to G-code suite and queue

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 11c2c01259..8e4abbe4bc 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -1048,21 +1048,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         case PREPARE_MOVE:
           if (draw)
             Draw_Menu_Item(row, ICON_Axis, F("Move"), nullptr, true);
           else
             Draw_Menu(Move);
           break;
         case PREPARE_DISABLE:
           if (draw)
             Draw_Menu_Item(row, ICON_CloseMotor, F("Disable Stepper"));
           else
-            queue.inject_P(PSTR("M84"));
+            queue.inject(F("M84"));
           break;
         case PREPARE_HOME:
           if (draw)
             Draw_Menu_Item(row, ICON_SetHome, F("Homing"), nullptr, true);
           else
             Draw_Menu(HomeMenu);
           break;
         case PREPARE_MANUALLEVEL:
           if (draw)
             Draw_Menu_Item(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
@@ -4492,21 +4492,21 @@ void CrealityDWINClass::Print_Screen_Control() {
               #if HAS_HEATED_BED
                 cmnd[sprintf_P(cmnd, PSTR("M140 S%i"), pausebed)] = '\0';
                 gcode.process_subcommands_now(cmnd);
               #endif
               #if HAS_EXTRUDERS
                 cmnd[sprintf_P(cmnd, PSTR("M109 S%i"), pausetemp)] = '\0';
                 gcode.process_subcommands_now(cmnd);
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
-              TERN_(SDSUPPORT, queue.inject_P(PSTR("M24")));
+              TERN_(SDSUPPORT, queue.inject(F("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, host_action_resume());
           }
           Draw_Print_Screen();
         }
         else
           Popup_Handler(Pause);
         break;
@@ -4534,24 +4534,24 @@ void CrealityDWINClass::Popup_Control() {
           if (sdprint) {
             #if ENABLED(POWER_LOSS_RECOVERY)
               if (recovery.enabled) recovery.save(true);
             #endif
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               Popup_Handler(Home, true);
               #if ENABLED(SDSUPPORT)
                 if (IS_SD_PRINTING()) card.pauseSDPrint();
               #endif
               planner.synchronize();
-              queue.inject_P(PSTR("M125"));
+              queue.inject(F("M125"));
               planner.synchronize();
             #else
-              queue.inject_P(PSTR("M25"));
+              queue.inject(F("M25"));
               TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
               TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
               TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
               thermalManager.disable_all_heaters();
               TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, host_action_pause());
           }
@@ -4567,23 +4567,23 @@ void CrealityDWINClass::Popup_Control() {
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, host_action_cancel());
           }
         }
         else
           Draw_Print_Screen();
         break;
       case Resume:
         if (selection == 0)
-          queue.inject_P(PSTR("M1000"));
+          queue.inject(F("M1000"));
         else {
-          queue.inject_P(PSTR("M1000 C"));
+          queue.inject(F("M1000 C"));
           Draw_Main_Menu();
         }
         break;
 
       #if HAS_HOTEND
         case ETemp:
           if (selection == 0) {
             thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
             thermalManager.set_fan_speed(0, MAX_FAN_SPEED);
             Draw_Menu(PreheatHotend);
@@ -5001,21 +5001,21 @@ void CrealityDWINClass::Save_Settings(char *buff) {
 void CrealityDWINClass::Load_Settings(const char *buff) {
   memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
   corner_pos = eeprom_settings.corner_pos / 10.0f;
   Redraw_Screen();
   #if ENABLED(POWER_LOSS_RECOVERY)
     static bool init = true;
     if (init) {
       init = false;
-      queue.inject_P(PSTR("M1000 S"));
+      queue.inject(F("M1000 S"));
     }
   #endif
 }
 
 void CrealityDWINClass::Reset_Settings() {
   eeprom_settings.time_format_textual = false;
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
   eeprom_settings.corner_pos = 325;
   eeprom_settings.cursor_color = 0;
   eeprom_settings.menu_split_line = 0;

commit 64a919da2a6dbe8b529c3471935a6d632420ca3a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 05:59:03 2021 -0500

    🎨 Apply F() to E3V2 titles, popups

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 2bdb15a30f..11c2c01259 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -463,33 +463,49 @@ uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool ligh
     case Brown:
       return (light) ? Color_Light_Brown : Color_Brown;
       break;
     case Black:
       return Color_Black;
       break;
   }
   return Color_White;
 }
 
-void CrealityDWINClass::Draw_Title(const char * title) {
-  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(title) * STAT_CHR_W) / 2, 5, title);
+void CrealityDWINClass::Draw_Title(const char * ctitle) {
+  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(ctitle) * STAT_CHR_W) / 2, 5, ctitle);
+}
+void CrealityDWINClass::Draw_Title(FSTR_P const ftitle) {
+  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen_P(FTOP(ftitle)) * STAT_CHR_W) / 2, 5, ftitle);
+}
+
+void _Decorate_Menu_Item(uint8_t row, uint8_t icon, bool more) {
+  if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
+  if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
+  DWIN_Draw_Line(CrealityDWIN.GetColor(CrealityDWIN.eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
 void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
-  const uint8_t label_offset_y = !(label1 && label2) ? 0 : MENU_CHR_H * 3 / 5;
-  const uint8_t label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2);
-  const uint8_t label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
+  const uint8_t label_offset_y = (label1 || label2) ? MENU_CHR_H * 3 / 5 : 0,
+                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2),
+                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
   if (label1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
   if (label2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
-  if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
-  if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
-  DWIN_Draw_Line(GetColor(eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+  _Decorate_Menu_Item(row, icon, more);
+}
+
+void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, FSTR_P const flabel1, FSTR_P const flabel2, bool more/*=false*/, bool centered/*=false*/) {
+  const uint8_t label_offset_y = (flabel1 || flabel2) ? MENU_CHR_H * 3 / 5 : 0,
+                label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel1 ? strlen_P(FTOP(flabel1)) : 0) * MENU_CHR_W) / 2),
+                label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (flabel2 ? strlen_P(FTOP(flabel2)) : 0) * MENU_CHR_W) / 2);
+  if (flabel1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, flabel1); // Draw Label
+  if (flabel2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, flabel2); // Draw Label
+  _Decorate_Menu_Item(row, icon, more);
 }
 
 void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
     DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     DWIN_Draw_Rectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
     if (value) {
       DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
@@ -735,21 +751,21 @@ void CrealityDWINClass::Draw_Print_confirm() {
   process = Confirm;
   popup = Complete;
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
   DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
 }
 
 void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
   if (item == 0)
-    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? "Back" : "..");
+    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? F("Back") : F(".."));
   else {
     card.getfilename_sorted(SD_ORDER(item - 1, card.get_num_Files()));
     char * const filename = card.longest_filename();
     size_t max = MENU_CHAR_LIMIT;
     size_t pos = strlen(filename), len = pos;
     if (!card.flag.filenameIsDir)
       while (pos && filename[pos] != '.') pos--;
     len = pos;
     if (len > max) len = max;
     char name[len + 1];
@@ -765,21 +781,21 @@ void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
   Clear_Screen();
   Draw_Title("Select File");
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
     LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
       Draw_SD_Item(i, i);
   }
   else {
-    Draw_Menu_Item(0, ICON_Back, "Back");
+    Draw_Menu_Item(0, ICON_Back, F("Back"));
     DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
 void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
 
   if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
@@ -900,48 +916,48 @@ void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
       DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
     else
       DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z * 100 : 0);
   }
   DWIN_UpdateLCD();
 }
 
-void CrealityDWINClass::Draw_Popup(PGM_P const line1, PGM_P const line2, PGM_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
+void CrealityDWINClass::Draw_Popup(FSTR_P const line1, FSTR_P const line2, FSTR_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
   if (process != Confirm && process != Popup && process != Wait) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
   Clear_Screen();
   DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
   DWIN_Draw_Rectangle(1, Color_Bg_Window, 14, 60, 258, 350);
   const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
   if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line1)) / 2, ypos, line1);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line2)) / 2, ypos + 30, line2);
-  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line3)) / 2, ypos + 60, line3);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line1))) / 2, ypos, line1);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line2))) / 2, ypos + 30, line2);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(FTOP(line3))) / 2, ypos + 60, line3);
   if (mode == Popup) {
     selection = 0;
     DWIN_Draw_Rectangle(1, Confirm_Color, 26, 280, 125, 317);
     DWIN_Draw_Rectangle(1, Cancel_Color, 146, 280, 245, 317);
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
     Popup_Select();
   }
   else if (mode == Confirm) {
     DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
     DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
   }
 }
 
 void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
-  CrealityDWIN.Draw_Popup(PSTR("Printer Kill Reason:"), error, PSTR("Restart Required"), Wait, ICON_BLTouch);
+  CrealityDWIN.Draw_Popup(F("Printer Kill Reason:"), error, F("Restart Required"), Wait, ICON_BLTouch);
 }
 
 void CrealityDWINClass::Popup_Select() {
   const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
                  c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
   DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
   DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
   DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
   DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
 }
@@ -1018,93 +1034,93 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
       #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
       #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
       #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ENABLED(HAS_PREHEAT))
       #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define PREPARE_TOTAL PREPARE_CHANGEFIL
 
       switch (item) {
         case PREPARE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Main_Menu(1);
           break;
         case PREPARE_MOVE:
           if (draw)
-            Draw_Menu_Item(row, ICON_Axis, "Move", nullptr, true);
+            Draw_Menu_Item(row, ICON_Axis, F("Move"), nullptr, true);
           else
             Draw_Menu(Move);
           break;
         case PREPARE_DISABLE:
           if (draw)
-            Draw_Menu_Item(row, ICON_CloseMotor, "Disable Stepper");
+            Draw_Menu_Item(row, ICON_CloseMotor, F("Disable Stepper"));
           else
             queue.inject_P(PSTR("M84"));
           break;
         case PREPARE_HOME:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, "Homing", nullptr, true);
+            Draw_Menu_Item(row, ICON_SetHome, F("Homing"), nullptr, true);
           else
             Draw_Menu(HomeMenu);
           break;
         case PREPARE_MANUALLEVEL:
           if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, "Manual Leveling", nullptr, true);
+            Draw_Menu_Item(row, ICON_PrintSize, F("Manual Leveling"), nullptr, true);
           else {
             if (axes_should_home()) {
               Popup_Handler(Home);
               gcode.home_all_axes(true);
             }
             #if HAS_LEVELING
               level_state = planner.leveling_active;
               set_bed_leveling_enabled(false);
             #endif
             Draw_Menu(ManualLevel);
           }
           break;
 
         #if HAS_ZOFFSET_ITEM
           case PREPARE_ZOFFSET:
             if (draw)
-              Draw_Menu_Item(row, ICON_Zoffset, "Z-Offset", nullptr, true);
+              Draw_Menu_Item(row, ICON_Zoffset, F("Z-Offset"), nullptr, true);
             else {
               #if HAS_LEVELING
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
               #endif
               Draw_Menu(ZOffset);
             }
             break;
         #endif
 
         #if HAS_PREHEAT
           case PREPARE_PREHEAT:
             if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, "Preheat", nullptr, true);
+              Draw_Menu_Item(row, ICON_Temperature, F("Preheat"), nullptr, true);
             else
               Draw_Menu(Preheat);
             break;
           case PREPARE_COOLDOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_Cool, "Cooldown");
+              Draw_Menu_Item(row, ICON_Cool, F("Cooldown"));
             else {
               TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
               thermalManager.disable_all_heaters();
             }
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case PREPARE_CHANGEFIL:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament"
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament")
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   , nullptr, true
                 #endif
               );
             }
             else {
               #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                 Draw_Menu(ChangeFilament);
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
@@ -1131,66 +1147,66 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define HOME_ALL   (HOME_BACK + 1)
       #define HOME_X     (HOME_ALL + 1)
       #define HOME_Y     (HOME_X + 1)
       #define HOME_Z     (HOME_Y + 1)
       #define HOME_SET   (HOME_Z + 1)
       #define HOME_TOTAL HOME_SET
 
       switch (item) {
         case HOME_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Prepare, PREPARE_HOME);
           break;
         case HOME_ALL:
           if (draw)
-            Draw_Menu_Item(row, ICON_Homing, "Home All");
+            Draw_Menu_Item(row, ICON_Homing, F("Home All"));
           else {
             Popup_Handler(Home);
             gcode.home_all_axes(true);
             Redraw_Menu();
           }
           break;
         case HOME_X:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveX, "Home X");
+            Draw_Menu_Item(row, ICON_MoveX, F("Home X"));
           else {
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 X"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_Y:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveY, "Home Y");
+            Draw_Menu_Item(row, ICON_MoveY, F("Home Y"));
           else {
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 Y"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_Z:
           if (draw)
-            Draw_Menu_Item(row, ICON_MoveZ,"Home Z");
+            Draw_Menu_Item(row, ICON_MoveZ, F("Home Z"));
           else {
             Popup_Handler(Home);
             gcode.process_subcommands_now(F("G28 Z"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_SET:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, "Set Home Position");
+            Draw_Menu_Item(row, ICON_SetHome, F("Set Home Position"));
           else {
             gcode.process_subcommands_now(F("G92 X0 Y0 Z0"));
             AudioFeedback();
           }
           break;
       }
       break;
 
     case Move:
 
@@ -1199,58 +1215,58 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define MOVE_Y (MOVE_X + 1)
       #define MOVE_Z (MOVE_Y + 1)
       #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
       #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
       #define MOVE_LIVE (MOVE_P + 1)
       #define MOVE_TOTAL MOVE_LIVE
 
       switch (item) {
         case MOVE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else {
             #if HAS_BED_PROBE
               probe_deployed = false;
               probe.set_deployed(probe_deployed);
             #endif
             Draw_Menu(Prepare, PREPARE_MOVE);
           }
           break;
         case MOVE_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveX, "Move X");
+            Draw_Menu_Item(row, ICON_MoveX, F("Move X"));
             Draw_Float(current_position.x, row, false);
           }
           else
             Modify_Value(current_position.x, X_MIN_POS, X_MAX_POS, 10);
           break;
         case MOVE_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveY, "Move Y");
+            Draw_Menu_Item(row, ICON_MoveY, F("Move Y"));
             Draw_Float(current_position.y, row);
           }
           else
             Modify_Value(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
           break;
         case MOVE_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MoveZ, "Move Z");
+            Draw_Menu_Item(row, ICON_MoveZ, F("Move Z"));
             Draw_Float(current_position.z, row);
           }
           else
             Modify_Value(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
           break;
 
         #if HAS_HOTEND
           case MOVE_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, "Extruder");
+              Draw_Menu_Item(row, ICON_Extruder, F("Extruder"));
               current_position.e = 0;
               sync_plan_position();
               Draw_Float(current_position.e, row);
             }
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
@@ -1262,34 +1278,34 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 sync_plan_position();
                 Modify_Value(current_position.e, -500, 500, 10);
               }
             }
           break;
         #endif // HAS_HOTEND
 
         #if HAS_BED_PROBE
           case MOVE_P:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, "Probe");
+              Draw_Menu_Item(row, ICON_StockConfiguration, F("Probe"));
               Draw_Checkbox(row, probe_deployed);
             }
             else {
               probe_deployed = !probe_deployed;
               probe.set_deployed(probe_deployed);
               Draw_Checkbox(row, probe_deployed);
             }
             break;
         #endif
 
         case MOVE_LIVE:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Axis, "Live Movement");
+            Draw_Menu_Item(row, ICON_Axis, F("Live Movement"));
             Draw_Checkbox(row, livemove);
           }
           else {
             livemove = !livemove;
             Draw_Checkbox(row, livemove);
           }
           break;
       }
       break;
     case ManualLevel:
@@ -1303,30 +1319,30 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define MLEVEL_C (MLEVEL_BR + 1)
       #define MLEVEL_ZPOS (MLEVEL_C + 1)
       #define MLEVEL_TOTAL MLEVEL_ZPOS
 
       static float mlev_z_pos = 0;
       static bool use_probe = false;
 
       switch (item) {
         case MLEVEL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else {
             TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
             Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
           }
           break;
         #if HAS_BED_PROBE
           case MLEVEL_PROBE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, "Use Probe");
+              Draw_Menu_Item(row, ICON_Zoffset, F("Use Probe"));
               Draw_Checkbox(row, use_probe);
             }
             else {
               use_probe = !use_probe;
               Draw_Checkbox(row, use_probe);
               if (use_probe) {
                 Popup_Handler(Level);
                 corner_avg = 0;
                 #define PROBE_X_MIN _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x
                 #define PROBE_X_MAX _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x
@@ -1337,126 +1353,126 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
                 corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
                 corner_avg /= 4;
                 Redraw_Menu();
               }
             }
             break;
         #endif
         case MLEVEL_BL:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisBL, "Bottom Left");
+            Draw_Menu_Item(row, ICON_AxisBL, F("Bottom Left"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisTL, "Top Left");
+            Draw_Menu_Item(row, ICON_AxisTL, F("Top Left"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisTR, "Top Right");
+            Draw_Menu_Item(row, ICON_AxisTR, F("Top Right"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisBR, "Bottom Right");
+            Draw_Menu_Item(row, ICON_AxisBR, F("Bottom Right"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
-            Draw_Menu_Item(row, ICON_AxisC, "Center");
+            Draw_Menu_Item(row, ICON_AxisC, F("Center"));
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_ZPOS:
           if (draw) {
-            Draw_Menu_Item(row, ICON_SetZOffset, "Z Position");
+            Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
             Draw_Float(mlev_z_pos, row, false, 100);
           }
           else
             Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
           break;
       }
       break;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:
 
@@ -1465,49 +1481,49 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
         #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
         #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
         #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
         #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
         #define ZOFFSET_TOTAL ZOFFSET_SAVE
 
         switch (item) {
           case ZOFFSET_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else {
               liveadjust = false;
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
               Draw_Menu(Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
-              Draw_Menu_Item(row, ICON_Homing, "Home Z Axis");
+              Draw_Menu_Item(row, ICON_Homing, F("Home Z Axis"));
             else {
               Popup_Handler(Home);
               gcode.process_subcommands_now(F("G28 Z"));
               Popup_Handler(MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
                 gcode.process_subcommands_now(cmd);
               #else
                 gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
               #endif
               gcode.process_subcommands_now(F("G0 F300 Z0"));
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case ZOFFSET_MODE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, "Live Adjustment");
+              Draw_Menu_Item(row, ICON_Zoffset, F("Live Adjustment"));
               Draw_Checkbox(row, liveadjust);
             }
             else {
               if (!liveadjust) {
                 if (axes_should_home()) {
                   Popup_Handler(Home);
                   gcode.home_all_axes(true);
                 }
                 Popup_Handler(MoveWait);
                 #if ENABLED(Z_SAFE_HOMING)
@@ -1520,58 +1536,58 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 gcode.process_subcommands_now(F("G0 F300 Z0"));
                 planner.synchronize();
                 Redraw_Menu();
               }
               liveadjust = !liveadjust;
               Draw_Checkbox(row, liveadjust);
             }
             break;
           case ZOFFSET_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, "Z Offset");
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Offset"));
               Draw_Float(zoffsetvalue, row, false, 100);
             }
             else
               Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case ZOFFSET_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
             else {
               if (zoffsetvalue < MAX_Z_OFFSET) {
                 if (liveadjust) {
                   gcode.process_subcommands_now(F("M290 Z0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue += 0.01;
                 Draw_Float(zoffsetvalue, row - 1, false, 100);
               }
             }
             break;
           case ZOFFSET_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
+              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
             else {
               if (zoffsetvalue > MIN_Z_OFFSET) {
                 if (liveadjust) {
                   gcode.process_subcommands_now(F("M290 Z-0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue -= 0.01;
                 Draw_Float(zoffsetvalue, row - 2, false, 100);
               }
             }
             break;
           #if ENABLED(EEPROM_SETTINGS)
             case ZOFFSET_SAVE:
               if (draw)
-                Draw_Menu_Item(row, ICON_WriteEEPROM, "Save");
+                Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save"));
               else
                 AudioFeedback(settings.save());
               break;
           #endif
         }
         break;
     #endif
     #if HAS_PREHEAT
       case Preheat:
 
@@ -1580,109 +1596,109 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PREHEAT_1 (PREHEAT_MODE + (PREHEAT_COUNT >= 1))
         #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
         #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
         #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
         #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
         #define PREHEAT_TOTAL PREHEAT_5
 
         switch (item) {
           case PREHEAT_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Prepare, PREPARE_PREHEAT);
             break;
           case PREHEAT_MODE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Homing, "Preheat Mode");
+              Draw_Menu_Item(row, ICON_Homing, F("Preheat Mode"));
               Draw_Option(preheatmode, preheat_modes, row);
             }
             else
               Modify_Option(preheatmode, preheat_modes, 2);
             break;
 
           #if PREHEAT_COUNT >= 1
             case PREHEAT_1:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_1_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_1_LABEL));
               else {
                 thermalManager.disable_all_heaters();
                 TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
                 if (preheatmode == 0 || preheatmode == 1) {
                   TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[0].hotend_temp, 0));
                   TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[0].fan_speed));
                 }
                 #if HAS_HEATED_BED
                   if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[0].bed_temp);
                 #endif
               }
               break;
           #endif
 
           #if PREHEAT_COUNT >= 2
             case PREHEAT_2:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_2_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_2_LABEL));
               else {
                 thermalManager.disable_all_heaters();
                 TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
                 if (preheatmode == 0 || preheatmode == 1) {
                   TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[1].hotend_temp, 0));
                   TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[1].fan_speed));
                 }
                 #if HAS_HEATED_BED
                   if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[1].bed_temp);
                 #endif
               }
               break;
           #endif
 
           #if PREHEAT_COUNT >= 3
             case PREHEAT_3:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_3_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_3_LABEL));
               else {
                 thermalManager.disable_all_heaters();
                 TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
                 if (preheatmode == 0 || preheatmode == 1) {
                   TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[2].hotend_temp, 0));
                   TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[2].fan_speed));
                 }
                 #if HAS_HEATED_BED
                   if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[2].bed_temp);
                 #endif
               }
               break;
           #endif
 
           #if PREHEAT_COUNT >= 4
             case PREHEAT_4:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_4_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_4_LABEL));
               else {
                 thermalManager.disable_all_heaters();
                 TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
                 if (preheatmode == 0 || preheatmode == 1) {
                   TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[3].hotend_temp, 0));
                   TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[3].fan_speed));
                 }
                 #if HAS_HEATED_BED
                   if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[3].bed_temp);
                 #endif
               }
               break;
           #endif
 
           #if PREHEAT_COUNT >= 5
             case PREHEAT_5:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_5_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_5_LABEL));
               else {
                 thermalManager.disable_all_heaters();
                 TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
                 if (preheatmode == 0 || preheatmode == 1) {
                   TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[4].hotend_temp, 0));
                   TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[4].fan_speed));
                 }
                 #if HAS_HEATED_BED
                   if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[4].bed_temp);
                 #endif
@@ -1698,64 +1714,64 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define CHANGEFIL_BACK 0
         #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
         #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
         #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
         #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
 
         switch (item) {
           case CHANGEFIL_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Prepare, PREPARE_CHANGEFIL);
             break;
           case CHANGEFIL_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, "Load Filament");
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad);
                 gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, "Unload Filament");
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad, true);
                 gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament");
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
@@ -1776,73 +1792,73 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
       #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
       #define CONTROL_INFO (CONTROL_RESET + 1)
       #define CONTROL_TOTAL CONTROL_INFO
 
       switch (item) {
         case CONTROL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Main_Menu(2);
           break;
         case CONTROL_TEMP:
           if (draw)
-            Draw_Menu_Item(row, ICON_Temperature, "Temperature", nullptr, true);
+            Draw_Menu_Item(row, ICON_Temperature, F("Temperature"), nullptr, true);
           else
             Draw_Menu(TempMenu);
           break;
         case CONTROL_MOTION:
           if (draw)
-            Draw_Menu_Item(row, ICON_Motion, "Motion", nullptr, true);
+            Draw_Menu_Item(row, ICON_Motion, F("Motion"), nullptr, true);
           else
             Draw_Menu(Motion);
           break;
         case CONTROL_VISUAL:
           if (draw)
-            Draw_Menu_Item(row, ICON_PrintSize, "Visual", nullptr, true);
+            Draw_Menu_Item(row, ICON_PrintSize, F("Visual"), nullptr, true);
           else
             Draw_Menu(Visual);
           break;
         case CONTROL_ADVANCED:
           if (draw)
-            Draw_Menu_Item(row, ICON_Version, "Advanced", nullptr, true);
+            Draw_Menu_Item(row, ICON_Version, F("Advanced"), nullptr, true);
           else
             Draw_Menu(Advanced);
           break;
         #if ENABLED(EEPROM_SETTINGS)
           case CONTROL_SAVE:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, "Store Settings");
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Store Settings"));
             else
               AudioFeedback(settings.save());
             break;
           case CONTROL_RESTORE:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, "Restore Settings");
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Restore Settings"));
             else
               AudioFeedback(settings.load());
             break;
           case CONTROL_RESET:
             if (draw)
-              Draw_Menu_Item(row, ICON_Temperature, "Reset to Defaults");
+              Draw_Menu_Item(row, ICON_Temperature, F("Reset to Defaults"));
             else {
               settings.reset();
               AudioFeedback();
             }
             break;
         #endif
         case CONTROL_INFO:
           if (draw)
-            Draw_Menu_Item(row, ICON_Info, "Info");
+            Draw_Menu_Item(row, ICON_Info, F("Info"));
           else
             Draw_Menu(Info);
           break;
       }
       break;
 
     case TempMenu:
 
       #define TEMP_BACK 0
       #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
@@ -1852,98 +1868,98 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
       #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
       #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
       #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
       #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
       #define TEMP_TOTAL TEMP_PREHEAT5
 
       switch (item) {
         case TEMP_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Control, CONTROL_TEMP);
           break;
         #if HAS_HOTEND
           case TEMP_HOTEND:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
         #if HAS_HEATED_BED
           case TEMP_BED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
               Draw_Float(thermalManager.temp_bed.target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
         #if HAS_FAN
           case TEMP_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
               Draw_Float(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
         #if HAS_HOTEND || HAS_HEATED_BED
           case TEMP_PID:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, "PID", nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F("PID"), nullptr, true);
             else
               Draw_Menu(PID);
             break;
         #endif
         #if PREHEAT_COUNT >= 1
           case TEMP_PREHEAT1:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, PREHEAT_1_LABEL, nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_1_LABEL), nullptr, true);
             else
               Draw_Menu(Preheat1);
             break;
         #endif
         #if PREHEAT_COUNT >= 2
           case TEMP_PREHEAT2:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, PREHEAT_2_LABEL, nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_2_LABEL), nullptr, true);
             else
               Draw_Menu(Preheat2);
             break;
         #endif
         #if PREHEAT_COUNT >= 3
           case TEMP_PREHEAT3:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, PREHEAT_3_LABEL, nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_3_LABEL), nullptr, true);
             else
               Draw_Menu(Preheat3);
             break;
         #endif
         #if PREHEAT_COUNT >= 4
           case TEMP_PREHEAT4:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, PREHEAT_4_LABEL, nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_4_LABEL), nullptr, true);
             else
               Draw_Menu(Preheat4);
             break;
         #endif
         #if PREHEAT_COUNT >= 5
           case TEMP_PREHEAT5:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, PREHEAT_5_LABEL, nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F(PREHEAT_5_LABEL), nullptr, true);
             else
               Draw_Menu(Preheat5);
             break;
         #endif
       }
       break;
 
     #if HAS_HOTEND || HAS_HEATED_BED
       case PID:
 
@@ -1951,43 +1967,43 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
         #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PID_CYCLES (PID_BED + 1)
         #define PID_TOTAL PID_CYCLES
 
         static uint8_t PID_cycles = 5;
 
         switch (item) {
           case PID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(TempMenu, TEMP_PID);
             break;
           #if HAS_HOTEND
             case PID_HOTEND:
               if (draw)
-                Draw_Menu_Item(row, ICON_HotendTemp, "Hotend", nullptr, true);
+                Draw_Menu_Item(row, ICON_HotendTemp, F("Hotend"), nullptr, true);
               else
                 Draw_Menu(HotendPID);
               break;
           #endif
           #if HAS_HEATED_BED
             case PID_BED:
               if (draw)
-                Draw_Menu_Item(row, ICON_BedTemp, "Bed", nullptr, true);
+                Draw_Menu_Item(row, ICON_BedTemp, F("Bed"), nullptr, true);
               else
                 Draw_Menu(BedPID);
               break;
           #endif
           case PID_CYCLES:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, "Cycles");
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Cycles"));
               Draw_Float(PID_cycles, row, false, 1);
             }
             else
               Modify_Value(PID_cycles, 3, 50, 1);
             break;
         }
         break;
     #endif // HAS_HOTEND || HAS_HEATED_BED
 
     #if HAS_HOTEND
@@ -1999,62 +2015,62 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
         #define HOTENDPID_KI (HOTENDPID_KP + 1)
         #define HOTENDPID_KD (HOTENDPID_KI + 1)
         #define HOTENDPID_TOTAL HOTENDPID_KD
 
         static uint16_t PID_e_temp = 180;
 
         switch (item) {
           case HOTENDPID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, "Autotune");
+              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
             else {
               Popup_Handler(PIDWait);
               sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, "Temperature");
+              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
               Draw_Float(PID_e_temp, row, false, 1);
             }
             else
               Modify_Value(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
           case HOTENDPID_KP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "Kp Value");
+              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
               Draw_Float(thermalManager.temp_hotend[0].pid.Kp, row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KI:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "Ki Value");
+              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
               Draw_Float(unscalePID_i(thermalManager.temp_hotend[0].pid.Ki), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case HOTENDPID_KD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "Kd Value");
+              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
               Draw_Float(unscalePID_d(thermalManager.temp_hotend[0].pid.Kd), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
@@ -2066,63 +2082,63 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define BEDPID_KP (BEDPID_TEMP + 1)
         #define BEDPID_KI (BEDPID_KP + 1)
         #define BEDPID_KD (BEDPID_KI + 1)
         #define BEDPID_TOTAL BEDPID_KD
 
         static uint16_t PID_bed_temp = 60;
 
         switch (item) {
           case BEDPID_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
-              Draw_Menu_Item(row, ICON_HotendTemp, "Autotune");
+              Draw_Menu_Item(row, ICON_HotendTemp, F("Autotune"));
             else {
               Popup_Handler(PIDWait);
               sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
               gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, "Temperature");
+              Draw_Menu_Item(row, ICON_Temperature, F("Temperature"));
               Draw_Float(PID_bed_temp, row, false, 1);
             }
             else
               Modify_Value(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
           case BEDPID_KP:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "Kp Value");
+              Draw_Menu_Item(row, ICON_Version, F("Kp Value"));
               Draw_Float(thermalManager.temp_bed.pid.Kp, row, false, 100);
             }
             else {
               Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
             }
             break;
           case BEDPID_KI:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "Ki Value");
+              Draw_Menu_Item(row, ICON_Version, F("Ki Value"));
               Draw_Float(unscalePID_i(thermalManager.temp_bed.pid.Ki), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
             break;
           case BEDPID_KD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "Kd Value");
+              Draw_Menu_Item(row, ICON_Version, F("Kd Value"));
               Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
             }
             else
               Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
             break;
         }
         break;
     #endif // HAS_HEATED_BED
 
     #if PREHEAT_COUNT >= 1
@@ -2130,48 +2146,48 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define PREHEAT1_BACK 0
         #define PREHEAT1_HOTEND (PREHEAT1_BACK + ENABLED(HAS_HOTEND))
         #define PREHEAT1_BED (PREHEAT1_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PREHEAT1_FAN (PREHEAT1_BED + ENABLED(HAS_FAN))
         #define PREHEAT1_TOTAL PREHEAT1_FAN
 
         switch (item) {
           case PREHEAT1_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(TempMenu, TEMP_PREHEAT1);
             break;
           #if HAS_HOTEND
             case PREHEAT1_HOTEND:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
                 Draw_Float(ui.material_preset[0].hotend_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[0].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
               break;
           #endif
           #if HAS_HEATED_BED
             case PREHEAT1_BED:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
                 Draw_Float(ui.material_preset[0].bed_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[0].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
               break;
           #endif
           #if HAS_FAN
             case PREHEAT1_FAN:
               if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
                 Draw_Float(ui.material_preset[0].fan_speed, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[0].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
               break;
           #endif
         }
         break;
     #endif // PREHEAT_COUNT >= 1
 
@@ -2180,48 +2196,48 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define PREHEAT2_BACK 0
         #define PREHEAT2_HOTEND (PREHEAT2_BACK + ENABLED(HAS_HOTEND))
         #define PREHEAT2_BED (PREHEAT2_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PREHEAT2_FAN (PREHEAT2_BED + ENABLED(HAS_FAN))
         #define PREHEAT2_TOTAL PREHEAT2_FAN
 
         switch (item) {
           case PREHEAT2_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(TempMenu, TEMP_PREHEAT2);
             break;
           #if HAS_HOTEND
             case PREHEAT2_HOTEND:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
                 Draw_Float(ui.material_preset[1].hotend_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[1].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
               break;
           #endif
           #if HAS_HEATED_BED
             case PREHEAT2_BED:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
                 Draw_Float(ui.material_preset[1].bed_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[1].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
               break;
           #endif
           #if HAS_FAN
             case PREHEAT2_FAN:
               if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
                 Draw_Float(ui.material_preset[1].fan_speed, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[1].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
               break;
           #endif
         }
         break;
     #endif // PREHEAT_COUNT >= 2
 
@@ -2230,48 +2246,48 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define PREHEAT3_BACK 0
         #define PREHEAT3_HOTEND (PREHEAT3_BACK + ENABLED(HAS_HOTEND))
         #define PREHEAT3_BED (PREHEAT3_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PREHEAT3_FAN (PREHEAT3_BED + ENABLED(HAS_FAN))
         #define PREHEAT3_TOTAL PREHEAT3_FAN
 
         switch (item) {
           case PREHEAT3_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(TempMenu, TEMP_PREHEAT3);
             break;
           #if HAS_HOTEND
             case PREHEAT3_HOTEND:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
                 Draw_Float(ui.material_preset[2].hotend_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[2].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
               break;
           #endif
           #if HAS_HEATED_BED
             case PREHEAT3_BED:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
                 Draw_Float(ui.material_preset[2].bed_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[2].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
               break;
           #endif
           #if HAS_FAN
             case PREHEAT3_FAN:
               if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
                 Draw_Float(ui.material_preset[2].fan_speed, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[2].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
               break;
           #endif
         }
         break;
     #endif // PREHEAT_COUNT >= 3
 
@@ -2280,48 +2296,48 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define PREHEAT4_BACK 0
         #define PREHEAT4_HOTEND (PREHEAT4_BACK + ENABLED(HAS_HOTEND))
         #define PREHEAT4_BED (PREHEAT4_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PREHEAT4_FAN (PREHEAT4_BED + ENABLED(HAS_FAN))
         #define PREHEAT4_TOTAL PREHEAT4_FAN
 
         switch (item) {
           case PREHEAT4_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(TempMenu, TEMP_PREHEAT4);
             break;
           #if HAS_HOTEND
             case PREHEAT4_HOTEND:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
                 Draw_Float(ui.material_preset[3].hotend_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[3].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
               break;
           #endif
           #if HAS_HEATED_BED
             case PREHEAT4_BED:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
                 Draw_Float(ui.material_preset[3].bed_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[3].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
               break;
           #endif
           #if HAS_FAN
             case PREHEAT4_FAN:
               if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
                 Draw_Float(ui.material_preset[3].fan_speed, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[3].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
               break;
           #endif
         }
         break;
     #endif // PREHEAT_COUNT >= 4
 
@@ -2330,48 +2346,48 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define PREHEAT5_BACK 0
         #define PREHEAT5_HOTEND (PREHEAT5_BACK + ENABLED(HAS_HOTEND))
         #define PREHEAT5_BED (PREHEAT5_HOTEND + ENABLED(HAS_HEATED_BED))
         #define PREHEAT5_FAN (PREHEAT5_BED + ENABLED(HAS_FAN))
         #define PREHEAT5_TOTAL PREHEAT5_FAN
 
         switch (item) {
           case PREHEAT5_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(TempMenu, TEMP_PREHEAT5);
             break;
           #if HAS_HOTEND
             case PREHEAT5_HOTEND:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
                 Draw_Float(ui.material_preset[4].hotend_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[4].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
               break;
           #endif
           #if HAS_HEATED_BED
             case PREHEAT5_BED:
               if (draw) {
-                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
                 Draw_Float(ui.material_preset[4].bed_temp, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[4].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
               break;
           #endif
           #if HAS_FAN
             case PREHEAT5_FAN:
               if (draw) {
-                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
                 Draw_Float(ui.material_preset[4].fan_speed, row, false, 1);
               }
               else
                 Modify_Value(ui.material_preset[4].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
               break;
           #endif
         }
         break;
     #endif // PREHEAT_COUNT >= 5
 
@@ -2382,152 +2398,152 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
       #define MOTION_ACCEL (MOTION_SPEED + 1)
       #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
       #define MOTION_STEPS (MOTION_JERK + 1)
       #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
       #define MOTION_TOTAL MOTION_FLOW
 
       switch (item) {
         case MOTION_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Control, CONTROL_MOTION);
           break;
         case MOTION_HOMEOFFSETS:
           if (draw)
-            Draw_Menu_Item(row, ICON_SetHome, "Home Offsets", nullptr, true);
+            Draw_Menu_Item(row, ICON_SetHome, F("Home Offsets"), nullptr, true);
           else
             Draw_Menu(HomeOffsets);
           break;
         case MOTION_SPEED:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Max Speed", nullptr, true);
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Max Speed"), nullptr, true);
           else
             Draw_Menu(MaxSpeed);
           break;
         case MOTION_ACCEL:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxAccelerated, "Max Acceleration", nullptr, true);
+            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Max Acceleration"), nullptr, true);
           else
             Draw_Menu(MaxAcceleration);
           break;
         #if HAS_CLASSIC_JERK
           case MOTION_JERK:
             if (draw)
-              Draw_Menu_Item(row, ICON_MaxJerk, "Max Jerk", nullptr, true);
+              Draw_Menu_Item(row, ICON_MaxJerk, F("Max Jerk"), nullptr, true);
             else
               Draw_Menu(MaxJerk);
             break;
         #endif
         case MOTION_STEPS:
           if (draw)
-            Draw_Menu_Item(row, ICON_Step, "Steps/mm", nullptr, true);
+            Draw_Menu_Item(row, ICON_Step, F("Steps/mm"), nullptr, true);
           else
             Draw_Menu(Steps);
           break;
         #if HAS_HOTEND
           case MOTION_FLOW:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, "Flow Rate");
+              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
               Draw_Float(planner.flow_percentage[0], row, false, 1);
             }
             else
               Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
             break;
         #endif
       }
       break;
 
     case HomeOffsets:
 
       #define HOMEOFFSETS_BACK 0
       #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
       #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
       #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
 
       switch (item) {
         case HOMEOFFSETS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_HOMEOFFSETS);
           break;
         case HOMEOFFSETS_XOFFSET:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, "X Offset");
+            Draw_Menu_Item(row, ICON_StepX, F("X Offset"));
             Draw_Float(home_offset.x, row, false, 100);
           }
           else
             Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
         case HOMEOFFSETS_YOFFSET:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, "Y Offset");
+            Draw_Menu_Item(row, ICON_StepY, F("Y Offset"));
             Draw_Float(home_offset.y, row, false, 100);
           }
           else
             Modify_Value(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
           break;
       }
       break;
     case MaxSpeed:
 
       #define SPEED_BACK 0
       #define SPEED_X (SPEED_BACK + 1)
       #define SPEED_Y (SPEED_X + 1)
       #define SPEED_Z (SPEED_Y + 1)
       #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
       #define SPEED_TOTAL SPEED_E
 
       switch (item) {
         case SPEED_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_SPEED);
           break;
         case SPEED_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeedX, "X Axis");
+            Draw_Menu_Item(row, ICON_MaxSpeedX, F("X Axis"));
             Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
           break;
 
         #if HAS_Y_AXIS
           case SPEED_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedY, "Y Axis");
+              Draw_Menu_Item(row, ICON_MaxSpeedY, F("Y Axis"));
               Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
             break;
         #endif
 
         #if HAS_Z_AXIS
           case SPEED_Z:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedZ, "Z Axis");
+              Draw_Menu_Item(row, ICON_MaxSpeedZ, F("Z Axis"));
               Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], 0, default_max_feedrate[Z_AXIS] * 2, 1);
             break;
         #endif
 
         #if HAS_HOTEND
           case SPEED_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedE, "Extruder");
+              Draw_Menu_Item(row, ICON_MaxSpeedE, F("Extruder"));
               Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], 0, default_max_feedrate[E_AXIS] * 2, 1);
             break;
         #endif
       }
       break;
 
     case MaxAcceleration:
@@ -2535,52 +2551,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define ACCEL_BACK 0
       #define ACCEL_X (ACCEL_BACK + 1)
       #define ACCEL_Y (ACCEL_X + 1)
       #define ACCEL_Z (ACCEL_Y + 1)
       #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
       #define ACCEL_TOTAL ACCEL_E
 
       switch (item) {
         case ACCEL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_ACCEL);
           break;
         case ACCEL_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccX, "X Axis");
+            Draw_Menu_Item(row, ICON_MaxAccX, F("X Axis"));
             Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], 0, default_max_acceleration[X_AXIS] * 2, 1);
           break;
         case ACCEL_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccY, "Y Axis");
+            Draw_Menu_Item(row, ICON_MaxAccY, F("Y Axis"));
             Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], 0, default_max_acceleration[Y_AXIS] * 2, 1);
           break;
         case ACCEL_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccZ, "Z Axis");
+            Draw_Menu_Item(row, ICON_MaxAccZ, F("Z Axis"));
             Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, 1);
           }
           else
             Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], 0, default_max_acceleration[Z_AXIS] * 2, 1);
           break;
         #if HAS_HOTEND
           case ACCEL_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccE, "Extruder");
+              Draw_Menu_Item(row, ICON_MaxAccE, F("Extruder"));
               Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, 1);
             }
             else
               Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], 0, default_max_acceleration[E_AXIS] * 2, 1);
             break;
         #endif
       }
       break;
     #if HAS_CLASSIC_JERK
       case MaxJerk:
@@ -2588,52 +2604,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define JERK_BACK 0
         #define JERK_X (JERK_BACK + 1)
         #define JERK_Y (JERK_X + 1)
         #define JERK_Z (JERK_Y + 1)
         #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
         #define JERK_TOTAL JERK_E
 
         switch (item) {
           case JERK_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Motion, MOTION_JERK);
             break;
           case JERK_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkX, "X Axis");
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkX, F("X Axis"));
               Draw_Float(planner.max_jerk[X_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.max_jerk[X_AXIS], 0, default_max_jerk[X_AXIS] * 2, 10);
             break;
           case JERK_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, "Y Axis");
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, F("Y Axis"));
               Draw_Float(planner.max_jerk[Y_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.max_jerk[Y_AXIS], 0, default_max_jerk[Y_AXIS] * 2, 10);
             break;
           case JERK_Z:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, "Z Axis");
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, F("Z Axis"));
               Draw_Float(planner.max_jerk[Z_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.max_jerk[Z_AXIS], 0, default_max_jerk[Z_AXIS] * 2, 10);
             break;
           #if HAS_HOTEND
             case JERK_E:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, "Extruder");
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, F("Extruder"));
                 Draw_Float(planner.max_jerk[E_AXIS], row, false, 10);
               }
               else
                 Modify_Value(planner.max_jerk[E_AXIS], 0, default_max_jerk[E_AXIS] * 2, 10);
               break;
           #endif
         }
         break;
     #endif
     case Steps:
@@ -2641,52 +2657,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define STEPS_BACK 0
       #define STEPS_X (STEPS_BACK + 1)
       #define STEPS_Y (STEPS_X + 1)
       #define STEPS_Z (STEPS_Y + 1)
       #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
       #define STEPS_TOTAL STEPS_E
 
       switch (item) {
         case STEPS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Motion, MOTION_STEPS);
           break;
         case STEPS_X:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepX, "X Axis");
+            Draw_Menu_Item(row, ICON_StepX, F("X Axis"));
             Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, 10);
           }
           else
             Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], 0, default_steps[X_AXIS] * 2, 10);
           break;
         case STEPS_Y:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepY, "Y Axis");
+            Draw_Menu_Item(row, ICON_StepY, F("Y Axis"));
             Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, 10);
           }
           else
             Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], 0, default_steps[Y_AXIS] * 2, 10);
           break;
         case STEPS_Z:
           if (draw) {
-            Draw_Menu_Item(row, ICON_StepZ, "Z Axis");
+            Draw_Menu_Item(row, ICON_StepZ, F("Z Axis"));
             Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, 10);
           }
           else
             Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], 0, default_steps[Z_AXIS] * 2, 10);
           break;
         #if HAS_HOTEND
           case STEPS_E:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StepE, "Extruder");
+              Draw_Menu_Item(row, ICON_StepE, F("Extruder"));
               Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, 10);
             }
             else
               Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], 0, 1000, 10);
             break;
         #endif
       }
       break;
 
     case Visual:
@@ -2694,51 +2710,51 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define VISUAL_BACK 0
       #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
       #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
       #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
       #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
       #define VISUAL_TOTAL VISUAL_COLOR_THEMES
 
       switch (item) {
         case VISUAL_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Control, CONTROL_VISUAL);
           break;
         case VISUAL_BACKLIGHT:
           if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, "Display Off");
+            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
           else
             ui.set_brightness(0);
           break;
         case VISUAL_BRIGHTNESS:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness, "LCD Brightness");
+            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
             Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
         case VISUAL_TIME_FORMAT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_PrintTime, "Progress as __h__m");
+            Draw_Menu_Item(row, ICON_PrintTime, F("Progress as __h__m"));
             Draw_Checkbox(row, eeprom_settings.time_format_textual);
           }
           else {
             eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
             Draw_Checkbox(row, eeprom_settings.time_format_textual);
           }
           break;
         case VISUAL_COLOR_THEMES:
           if (draw)
-            Draw_Menu_Item(row, ICON_MaxSpeed, "UI Color Settings", nullptr, true);
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("UI Color Settings"), nullptr, true);
           else
             Draw_Menu(ColorSettings);
         break;
       }
       break;
 
     case ColorSettings:
 
       #define COLORSETTINGS_BACK 0
       #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
@@ -2750,107 +2766,107 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
       #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
       #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
       #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
 
       switch (item) {
         case COLORSETTINGS_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Visual, VISUAL_COLOR_THEMES);
           break;
         case COLORSETTINGS_CURSOR:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Cursor");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Cursor"));
             Draw_Option(eeprom_settings.cursor_color, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.cursor_color, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_SPLIT_LINE:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Menu Split Line");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Split Line"));
             Draw_Option(eeprom_settings.menu_split_line, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.menu_split_line, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_MENU_TOP_TXT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Menu Header Text");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Text"));
             Draw_Option(eeprom_settings.menu_top_txt, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.menu_top_txt, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_MENU_TOP_BG:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Menu Header Bg");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Menu Header Bg"));
             Draw_Option(eeprom_settings.menu_top_bg, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.menu_top_bg, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_HIGHLIGHT_BORDER:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Highlight Box");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Highlight Box"));
             Draw_Option(eeprom_settings.highlight_box, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.highlight_box, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_PERCENT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Progress Percent");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Percent"));
             Draw_Option(eeprom_settings.progress_percent, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.progress_percent, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_TIME:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Progress Time");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Progress Time"));
             Draw_Option(eeprom_settings.progress_time, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.progress_time, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_STATUS_BAR:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Status Bar Text");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Bar Text"));
             Draw_Option(eeprom_settings.status_bar_text, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.status_bar_text, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_STATUS_AREA:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Status Area Text");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Status Area Text"));
             Draw_Option(eeprom_settings.status_area_text, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.status_area_text, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_COORDINATES:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Coordinates Text");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Text"));
             Draw_Option(eeprom_settings.coordinates_text, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.coordinates_text, color_names, Custom_Colors);
           break;
         case COLORSETTINGS_PROGRESS_COORDINATES_LINE:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxSpeed, "Coordinates Line");
+            Draw_Menu_Item(row, ICON_MaxSpeed, F("Coordinates Line"));
             Draw_Option(eeprom_settings.coordinates_split_line, color_names, row, false, true);
           }
           else
             Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
           break;
       } // switch (item)
       break;
 
     case Advanced:
 
@@ -2863,127 +2879,127 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
       #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
 
       switch (item) {
         case ADVANCED_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Menu(Control, CONTROL_ADVANCED);
           break;
 
         #if ENABLED(SOUND_MENU_ITEM)
           case ADVANCED_BEEPER:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Version, "LCD Beeper");
+              Draw_Menu_Item(row, ICON_Version, F("LCD Beeper"));
               Draw_Checkbox(row, ui.buzzer_enabled);
             }
             else {
               ui.buzzer_enabled = !ui.buzzer_enabled;
               Draw_Checkbox(row, ui.buzzer_enabled);
             }
             break;
         #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
-              Draw_Menu_Item(row, ICON_StepX, "Probe", nullptr, true);
+              Draw_Menu_Item(row, ICON_StepX, F("Probe"), nullptr, true);
             else
               Draw_Menu(ProbeMenu);
             break;
         #endif
 
         case ADVANCED_CORNER:
           if (draw) {
-            Draw_Menu_Item(row, ICON_MaxAccelerated, "Bed Screw Inset");
+            Draw_Menu_Item(row, ICON_MaxAccelerated, F("Bed Screw Inset"));
             Draw_Float(corner_pos, row, false, 10);
           }
           else
             Modify_Value(corner_pos, 1, 100, 10);
           break;
 
         #if ENABLED(LIN_ADVANCE)
           case ADVANCED_LA:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MaxAccelerated, "Lin Advance Kp");
+              Draw_Menu_Item(row, ICON_MaxAccelerated, F("Lin Advance Kp"));
               Draw_Float(planner.extruder_advance_K[0], row, false, 100);
             }
             else
               Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
             break;
         #endif
 
         #if ENABLED(ADVANCED_PAUSE_FEATURE)
           case ADVANCED_LOAD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_WriteEEPROM, "Load Length");
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Load Length"));
               Draw_Float(fc_settings[0].load_length, row, false, 1);
             }
             else
               Modify_Value(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
           case ADVANCED_UNLOAD:
             if (draw) {
-              Draw_Menu_Item(row, ICON_ReadEEPROM, "Unload Length");
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Unload Length"));
               Draw_Float(fc_settings[0].unload_length, row, false, 1);
             }
             else
               Modify_Value(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
             break;
         #endif // ADVANCED_PAUSE_FEATURE
 
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           case ADVANCED_COLD_EXTRUDE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Cool, "Min Extrusion T");
+              Draw_Menu_Item(row, ICON_Cool, F("Min Extrusion T"));
               Draw_Float(thermalManager.extrude_min_temp, row, false, 1);
             }
             else {
               Modify_Value(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
               thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case ADVANCED_FILSENSORENABLED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, "Filament Sensor");
+              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
               Draw_Checkbox(row, runout.enabled);
             }
             else {
               runout.enabled = !runout.enabled;
               Draw_Checkbox(row, runout.enabled);
             }
             break;
 
           #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
             case ADVANCED_FILSENSORDISTANCE:
               if (draw) {
-                Draw_Menu_Item(row, ICON_MaxAccE, "Runout Distance");
+                Draw_Menu_Item(row, ICON_MaxAccE, F("Runout Distance"));
                 Draw_Float(runout.runout_distance(), row, false, 10);
               }
               else
                 Modify_Value(runout.runout_distance(), 0, 999, 10);
               break;
           #endif
         #endif // FILAMENT_RUNOUT_SENSOR
 
         #if ENABLED(POWER_LOSS_RECOVERY)
           case ADVANCED_POWER_LOSS:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Motion, "Power-loss recovery");
+              Draw_Menu_Item(row, ICON_Motion, F("Power-loss recovery"));
               Draw_Checkbox(row, recovery.enabled);
             }
             else {
               recovery.enable(!recovery.enabled);
               Draw_Checkbox(row, recovery.enabled);
             }
             break;
         #endif
       }
       break;
@@ -2996,52 +3012,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
         #define PROBE_TEST (PROBE_YOFFSET + 1)
         #define PROBE_TEST_COUNT (PROBE_TEST + 1)
         #define PROBE_TOTAL PROBE_TEST_COUNT
 
         static uint8_t testcount = 4;
 
         switch (item) {
           case PROBE_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Advanced, ADVANCED_PROBE);
             break;
 
             case PROBE_XOFFSET:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepX, "Probe X Offset");
+                Draw_Menu_Item(row, ICON_StepX, F("Probe X Offset"));
                 Draw_Float(probe.offset.x, row, false, 10);
               }
               else
                 Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_YOFFSET:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, "Probe Y Offset");
+                Draw_Menu_Item(row, ICON_StepY, F("Probe Y Offset"));
                 Draw_Float(probe.offset.y, row, false, 10);
               }
               else
                 Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_TEST:
               if (draw)
-                Draw_Menu_Item(row, ICON_StepY, "M48 Probe Test");
+                Draw_Menu_Item(row, ICON_StepY, F("M48 Probe Test"));
               else {
                 sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
                 gcode.process_subcommands_now(cmd);
               }
               break;
             case PROBE_TEST_COUNT:
               if (draw) {
-                Draw_Menu_Item(row, ICON_StepY, "Probe Test Count");
+                Draw_Menu_Item(row, ICON_StepY, F("Probe Test Count"));
                 Draw_Float(testcount, row, false, 1);
               }
               else
                 Modify_Value(testcount, 4, 50, 1);
               break;
         }
         break;
     #endif
 
     case InfoMain:
@@ -3051,40 +3067,40 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
       #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
       #define INFO_SIZE (INFO_PRINTTIME + 1)
       #define INFO_VERSION (INFO_SIZE + 1)
       #define INFO_CONTACT (INFO_VERSION + 1)
       #define INFO_TOTAL INFO_BACK
 
       switch (item) {
         case INFO_BACK:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
 
             #if ENABLED(PRINTCOUNTER)
               char row1[50], row2[50], buf[32];
               printStatistics ps = print_job_timer.getStats();
 
               sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
               sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
               Draw_Menu_Item(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
 
               duration_t(print_job_timer.getStats().printTime).toString(buf);
               sprintf_P(row1, PSTR("Printed: %s"), buf);
               duration_t(print_job_timer.getStats().longestPrint).toString(buf);
               sprintf_P(row2, PSTR("Longest: %s"), buf);
               Draw_Menu_Item(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
             #endif
 
-            Draw_Menu_Item(INFO_SIZE, ICON_PrintSize, MACHINE_SIZE, nullptr, false, true);
-            Draw_Menu_Item(INFO_VERSION, ICON_Version, SHORT_BUILD_VERSION, nullptr, false, true);
-            Draw_Menu_Item(INFO_CONTACT, ICON_Contact, CORP_WEBSITE, nullptr, false, true);
+            Draw_Menu_Item(INFO_SIZE, ICON_PrintSize, F(MACHINE_SIZE), nullptr, false, true);
+            Draw_Menu_Item(INFO_VERSION, ICON_Version, F(SHORT_BUILD_VERSION), nullptr, false, true);
+            Draw_Menu_Item(INFO_CONTACT, ICON_Contact, F(CORP_WEBSITE), nullptr, false, true);
           }
           else {
             if (menu == Info)
               Draw_Menu(Control, CONTROL_INFO);
             else
               Draw_Main_Menu(3);
           }
           break;
       }
       break;
@@ -3100,46 +3116,46 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_VIEW (LEVELING_MANUAL + 1)
         #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
         #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_TOTAL LEVELING_SAVE
 
         switch (item) {
           case LEVELING_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Main_Menu(3);
             break;
           case LEVELING_ACTIVE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, "Leveling Active");
+              Draw_Menu_Item(row, ICON_StockConfiguration, F("Leveling Active"));
               Draw_Checkbox(row, planner.leveling_active);
             }
             else {
               if (!planner.leveling_active) {
                 set_bed_leveling_enabled(!planner.leveling_active);
                 if (!planner.leveling_active) {
                   Confirm_Handler(LevelError);
                   break;
                 }
               }
               else
                 set_bed_leveling_enabled(!planner.leveling_active);
               Draw_Checkbox(row, planner.leveling_active);
             }
             break;
           #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
             case LEVELING_GET_TILT:
               if (draw)
-                Draw_Menu_Item(row, ICON_Tilt, "Autotilt Current Mesh");
+                Draw_Menu_Item(row, ICON_Tilt, F("Autotilt Current Mesh"));
               else {
                 if (ubl.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
                 Popup_Handler(Home);
                 gcode.home_all_axes(true);
                 Popup_Handler(Level);
                 if (mesh_conf.tilt_grid > 1) {
                   sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
@@ -3147,21 +3163,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 }
                 else
                   gcode.process_subcommands_now(F("G29 J"));
                 planner.synchronize();
                 Redraw_Menu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, "Create New Mesh");
+              Draw_Menu_Item(row, ICON_Mesh, F("Create New Mesh"));
             else {
               Popup_Handler(Home);
               gcode.home_all_axes(true);
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 #if ENABLED(PREHEAT_BEFORE_LEVELING)
                   Popup_Handler(Heating);
                   #if HAS_HOTEND
                     if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
                       thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
                   #endif
@@ -3199,21 +3215,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 gridpoint = 1;
                 Popup_Handler(MoveWait);
                 gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
                 Draw_Menu(ManualMesh);
               #endif
             }
             break;
           case LEVELING_MANUAL:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, "Manual Tuning", nullptr, true);
+              Draw_Menu_Item(row, ICON_Mesh, F("Manual Tuning"), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
                 if (!leveling_is_valid()) {
                   Confirm_Handler(InvalidMesh);
                   break;
                 }
               #endif
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (ubl.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
@@ -3253,49 +3269,49 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 if (ubl.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
               #endif
               Draw_Menu(LevelView);
             }
             break;
           case LEVELING_SETTINGS:
             if (draw)
-              Draw_Menu_Item(row, ICON_Step, "Leveling Settings", nullptr, true);
+              Draw_Menu_Item(row, ICON_Step, F("Leveling Settings"), nullptr, true);
             else
               Draw_Menu(LevelSettings);
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_SLOT:
             if (draw) {
-              Draw_Menu_Item(row, ICON_PrintSize, "Mesh Slot");
+              Draw_Menu_Item(row, ICON_PrintSize, F("Mesh Slot"));
               Draw_Float(ubl.storage_slot, row, false, 1);
             }
             else
               Modify_Value(ubl.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
             break;
           case LEVELING_LOAD:
             if (draw)
-              Draw_Menu_Item(row, ICON_ReadEEPROM, "Load Mesh");
+              Draw_Menu_Item(row, ICON_ReadEEPROM, F("Load Mesh"));
             else {
               if (ubl.storage_slot < 0) {
                 Popup_Handler(MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 L"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           case LEVELING_SAVE:
             if (draw)
-              Draw_Menu_Item(row, ICON_WriteEEPROM, "Save Mesh");
+              Draw_Menu_Item(row, ICON_WriteEEPROM, F("Save Mesh"));
             else {
               if (ubl.storage_slot < 0) {
                 Popup_Handler(MeshSlot);
                 break;
               }
               gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
@@ -3307,43 +3323,43 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         #define LEVELING_VIEW_BACK 0
         #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
         #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
         #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
         #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
               Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT(MSG_MESH_VIEW), nullptr, true);
             else
               Draw_Menu(MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Contact, "Viewer Show Values");
+              Draw_Menu_Item(row, ICON_Contact, F("Viewer Show Values"));
               Draw_Checkbox(row, mesh_conf.viewer_print_value);
             }
             else {
               mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
               Draw_Checkbox(row, mesh_conf.viewer_print_value);
             }
             break;
           case LEVELING_VIEW_ASYMMETRIC:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Axis, "Viewer Asymmetric");
+              Draw_Menu_Item(row, ICON_Axis, F("Viewer Asymmetric"));
               Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
             }
             else {
               mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
               Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
             }
             break;
         }
         break;
 
@@ -3353,78 +3369,78 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
         #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
 
         switch (item) {
           case LEVELING_SETTINGS_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else
               Draw_Menu(Leveling, LEVELING_SETTINGS);
             break;
           case LEVELING_SETTINGS_FADE:
               if (draw) {
-                Draw_Menu_Item(row, ICON_Fade, "Fade Mesh within");
+                Draw_Menu_Item(row, ICON_Fade, F("Fade Mesh within"));
                 Draw_Float(planner.z_fade_height, row, false, 1);
               }
               else {
                 Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
                 planner.z_fade_height = -1;
                 set_z_fade_height(planner.z_fade_height);
               }
               break;
 
           #if ENABLED(AUTO_BED_LEVELING_UBL)
             case LEVELING_SETTINGS_TILT:
               if (draw) {
-                Draw_Menu_Item(row, ICON_Tilt, "Tilting Grid Size");
+                Draw_Menu_Item(row, ICON_Tilt, F("Tilting Grid Size"));
                 Draw_Float(mesh_conf.tilt_grid, row, false, 1);
               }
               else
                 Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
               break;
             case LEVELING_SETTINGS_PLANE:
               if (draw)
-                Draw_Menu_Item(row, ICON_ResumeEEPROM, "Convert Mesh to Plane");
+                Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Convert Mesh to Plane"));
               else {
                 if (mesh_conf.create_plane_from_mesh()) break;
                 gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 AudioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
-                Draw_Menu_Item(row, ICON_Mesh, "Zero Current Mesh");
+                Draw_Menu_Item(row, ICON_Mesh, F("Zero Current Mesh"));
               else
                 ZERO(Z_VALUES_ARR);
               break;
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
-                Draw_Menu_Item(row, ICON_Mesh, "Clear Current Mesh");
+                Draw_Menu_Item(row, ICON_Mesh, F("Clear Current Mesh"));
               else
                 ubl.invalidate();
               break;
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
 
       case MeshViewer:
         #define MESHVIEW_BACK 0
         #define MESHVIEW_TOTAL MESHVIEW_BACK
 
         if (item == MESHVIEW_BACK) {
           if (draw) {
-            Draw_Menu_Item(0, ICON_Back, "Back");
+            Draw_Menu_Item(0, ICON_Back, F("Back"));
             mesh_conf.Draw_Bed_Mesh();
             mesh_conf.Set_Mesh_Viewer_Status();
           }
           else if (!mesh_conf.drawing_mesh) {
             Draw_Menu(LevelView, LEVELING_VIEW_MESH);
             Update_Status("");
           }
         }
         break;
 
@@ -3437,109 +3453,109 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
         #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
         #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
         #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
         #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
         #define LEVELING_M_TOTAL LEVELING_M_UNDEF
 
         switch (item) {
           case LEVELING_M_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
               TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
               Draw_Menu(Leveling, LEVELING_MANUAL);
             }
             break;
           case LEVELING_M_X:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MoveX, "Mesh Point X");
+              Draw_Menu_Item(row, ICON_MoveX, F("Mesh Point X"));
               Draw_Float(mesh_conf.mesh_x, row, 0, 1);
             }
             else
               Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
             break;
           case LEVELING_M_Y:
             if (draw) {
-              Draw_Menu_Item(row, ICON_MoveY, "Mesh Point Y");
+              Draw_Menu_Item(row, ICON_MoveY, F("Mesh Point Y"));
               Draw_Float(mesh_conf.mesh_y, row, 0, 1);
             }
             else
               Modify_Value(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
             break;
           case LEVELING_M_NEXT:
             if (draw)
-              Draw_Menu_Item(row, ICON_More, "Next Point");
+              Draw_Menu_Item(row, ICON_More, F("Next Point"));
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, "Point Z Offset");
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
               Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case LEVELING_M_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case LEVELING_M_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
+              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguration, "Go to Mesh Z Value");
+              Draw_Menu_Item(row, ICON_StockConfiguration, F("Go to Mesh Z Value"));
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             else {
               mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
               current_position.z = 0;
               mesh_conf.manual_move(true);
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
           case LEVELING_M_UNDEF:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Clear Point Value");
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Clear Point Value"));
             else {
               mesh_conf.manual_value_update(true);
               Redraw_Menu(false);
             }
             break;
           #endif
         }
         break;
     #endif // HAS_MESH
 
@@ -3550,32 +3566,32 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define UBL_M_NEXT (UBL_M_BACK + 1)
         #define UBL_M_PREV (UBL_M_NEXT + 1)
         #define UBL_M_OFFSET (UBL_M_PREV + 1)
         #define UBL_M_UP (UBL_M_OFFSET + 1)
         #define UBL_M_DOWN (UBL_M_UP + 1)
         #define UBL_M_TOTAL UBL_M_DOWN
 
         switch (item) {
           case UBL_M_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Back");
+              Draw_Menu_Item(row, ICON_Back, F("Back"));
             else {
               set_bed_leveling_enabled(level_state);
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case UBL_M_NEXT:
             if (draw) {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
-                Draw_Menu_Item(row, ICON_More, "Next Point");
+                Draw_Menu_Item(row, ICON_More, F("Next Point"));
               else
-                Draw_Menu_Item(row, ICON_More, "Save Mesh");
+                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
             }
             else {
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_move();
@@ -3583,59 +3599,59 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               else {
                 gcode.process_subcommands_now(F("G29 S"));
                 planner.synchronize();
                 AudioFeedback(true);
                 Draw_Menu(Leveling, LEVELING_GET_MESH);
               }
             }
             break;
           case UBL_M_PREV:
             if (draw)
-              Draw_Menu_Item(row, ICON_More, "Previous Point");
+              Draw_Menu_Item(row, ICON_More, F("Previous Point"));
             else {
               if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
                   mesh_conf.mesh_y--;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x--;
                 else
                   mesh_conf.mesh_x++;
                 mesh_conf.manual_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, "Point Z Offset");
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Point Z Offset"));
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
               if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
               Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case UBL_M_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case UBL_M_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, "Microstep Down");
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Down"));
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
@@ -3649,93 +3665,93 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define MMESH_NEXT (MMESH_BACK + 1)
         #define MMESH_OFFSET (MMESH_NEXT + 1)
         #define MMESH_UP (MMESH_OFFSET + 1)
         #define MMESH_DOWN (MMESH_UP + 1)
         #define MMESH_OLD (MMESH_DOWN + 1)
         #define MMESH_TOTAL MMESH_OLD
 
         switch (item) {
           case MMESH_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Cancel");
+              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
             else {
               gcode.process_subcommands_now(F("G29 A"));
               planner.synchronize();
               set_bed_leveling_enabled(level_state);
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_NEXT:
             if (draw) {
               if (gridpoint < GRID_MAX_POINTS)
-                Draw_Menu_Item(row, ICON_More, "Next Point");
+                Draw_Menu_Item(row, ICON_More, F("Next Point"));
               else
-                Draw_Menu_Item(row, ICON_More, "Save Mesh");
+                Draw_Menu_Item(row, ICON_More, F("Save Mesh"));
             }
             else if (gridpoint < GRID_MAX_POINTS) {
               Popup_Handler(MoveWait);
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               gridpoint++;
               Redraw_Menu();
             }
             else {
               gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               AudioFeedback(settings.save());
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_OFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetZOffset, "Z Position");
+              Draw_Menu_Item(row, ICON_SetZOffset, F("Z Position"));
               current_position.z = MANUAL_PROBE_START_Z;
               Draw_Float(current_position.z, row, false, 100);
             }
             else
               Modify_Value(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case MMESH_UP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+              Draw_Menu_Item(row, ICON_Axis, F("Microstep Up"));
             else if (current_position.z < MAX_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               Draw_Float(current_position.z, row - 1, false, 100);
             }
             break;
           case MMESH_DOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
+              Draw_Menu_Item(row, ICON_AxisD, F("Microstep Down"));
             else if (current_position.z > MIN_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(current_position.z, row - 2, false, 100);
             }
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
             // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
             mesh_y = (gridpoint - 1) / GRID_MAX_POINTS_Y;
             mesh_x = (gridpoint - 1) % GRID_MAX_POINTS_X;
 
             if (mesh_y % 2 == 1)
               mesh_x = GRID_MAX_POINTS_X - mesh_x - 1;
 
             const float currval = Z_VALUES_ARR[mesh_x][mesh_y];
 
             if (draw) {
-              Draw_Menu_Item(row, ICON_Zoffset, "Goto Mesh Value");
+              Draw_Menu_Item(row, ICON_Zoffset, F("Goto Mesh Value"));
               Draw_Float(currval, row, false, 100);
             }
             else if (!isnan(currval)) {
               current_position.z = currval;
               planner.synchronize();
               planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
               planner.synchronize();
               Draw_Float(current_position.z, row - 3, false, 100);
             }
             break;
@@ -3756,134 +3772,134 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
       #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
       #define TUNE_CHANGEFIL (TUNE_ZDOWN + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
       #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
       #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
       #define TUNE_TOTAL TUNE_BACKLIGHT
 
       switch (item) {
         case TUNE_BACK:
           if (draw)
-            Draw_Menu_Item(row, ICON_Back, "Back");
+            Draw_Menu_Item(row, ICON_Back, F("Back"));
           else
             Draw_Print_Screen();
           break;
         case TUNE_SPEED:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Speed, "Print Speed");
+            Draw_Menu_Item(row, ICON_Speed, F("Print Speed"));
             Draw_Float(feedrate_percentage, row, false, 1);
           }
           else
             Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
           break;
 
         #if HAS_HOTEND
           case TUNE_FLOW:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Speed, "Flow Rate");
+              Draw_Menu_Item(row, ICON_Speed, F("Flow Rate"));
               Draw_Float(planner.flow_percentage[0], row, false, 1);
             }
             else
               Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
             break;
           case TUNE_HOTEND:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Hotend"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
             break;
         #endif
 
         #if HAS_HEATED_BED
           case TUNE_BED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+              Draw_Menu_Item(row, ICON_SetBedTemp, F("Bed"));
               Draw_Float(thermalManager.temp_bed.target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
             break;
         #endif
 
         #if HAS_FAN
           case TUNE_FAN:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Fan"));
               Draw_Float(thermalManager.fan_speed[0], row, false, 1);
             }
             else
               Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
             break;
         #endif
 
         #if HAS_ZOFFSET_ITEM
           case TUNE_ZOFFSET:
             if (draw) {
-              Draw_Menu_Item(row, ICON_FanSpeed, "Z-Offset");
+              Draw_Menu_Item(row, ICON_FanSpeed, F("Z-Offset"));
               Draw_Float(zoffsetvalue, row, false, 100);
             }
             else
               Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case TUNE_ZUP:
             if (draw)
-              Draw_Menu_Item(row, ICON_Axis, "Z-Offset Up");
+              Draw_Menu_Item(row, ICON_Axis, F("Z-Offset Up"));
             else if (zoffsetvalue < MAX_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z0.01"));
               zoffsetvalue += 0.01;
               Draw_Float(zoffsetvalue, row - 1, false, 100);
             }
             break;
           case TUNE_ZDOWN:
             if (draw)
-              Draw_Menu_Item(row, ICON_AxisD, "Z-Offset Down");
+              Draw_Menu_Item(row, ICON_AxisD, F("Z-Offset Down"));
             else if (zoffsetvalue > MIN_Z_OFFSET) {
               gcode.process_subcommands_now(F("M290 Z-0.01"));
               zoffsetvalue -= 0.01;
               Draw_Float(zoffsetvalue, row - 2, false, 100);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
-              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament");
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, F("Change Filament"));
             else
               Popup_Handler(ConfFilChange);
             break;
         #endif
 
         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
           case TUNE_FILSENSORENABLED:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Extruder, "Filament Sensor");
+              Draw_Menu_Item(row, ICON_Extruder, F("Filament Sensor"));
               Draw_Checkbox(row, runout.enabled);
             }
             else {
               runout.enabled = !runout.enabled;
               Draw_Checkbox(row, runout.enabled);
             }
             break;
         #endif
 
         case TUNE_BACKLIGHT_OFF:
           if (draw)
-            Draw_Menu_Item(row, ICON_Brightness, "Display Off");
+            Draw_Menu_Item(row, ICON_Brightness, F("Display Off"));
           else
             ui.set_brightness(0);
           break;
         case TUNE_BACKLIGHT:
           if (draw) {
-            Draw_Menu_Item(row, ICON_Brightness, "LCD Brightness");
+            Draw_Menu_Item(row, ICON_Brightness, F("LCD Brightness"));
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
             Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
       }
       break;
 
     case PreheatHotend:
 
@@ -3893,30 +3909,30 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
         #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
         #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
         #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
         #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
         #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
 
         switch (item) {
           case PREHEATHOTEND_BACK:
             if (draw)
-              Draw_Menu_Item(row, ICON_Back, "Cancel");
+              Draw_Menu_Item(row, ICON_Back, F("Cancel"));
             else {
               thermalManager.setTargetHotend(0, 0);
               thermalManager.set_fan_speed(0, 0);
               Redraw_Menu(false, true, true);
             }
             break;
           case PREHEATHOTEND_CONTINUE:
             if (draw)
-              Draw_Menu_Item(row, ICON_SetEndTemp, "Continue");
+              Draw_Menu_Item(row, ICON_SetEndTemp, F("Continue"));
             else {
               Popup_Handler(Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
                 case Prepare:
                   Popup_Handler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
                   gcode.process_subcommands_now(cmd);
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
@@ -3944,155 +3960,155 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 #endif
                 default:
                   Redraw_Menu(true, true, true);
                   break;
               }
             }
             break;
           #if PREHEAT_COUNT >= 1
             case PREHEATHOTEND_1:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_1_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_1_LABEL));
               else {
                 thermalManager.setTargetHotend(ui.material_preset[0].hotend_temp, 0);
                 thermalManager.set_fan_speed(0, ui.material_preset[0].fan_speed);
               }
               break;
           #endif
           #if PREHEAT_COUNT >= 2
             case PREHEATHOTEND_2:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_2_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_2_LABEL));
               else {
                 thermalManager.setTargetHotend(ui.material_preset[1].hotend_temp, 0);
                 thermalManager.set_fan_speed(0, ui.material_preset[1].fan_speed);
               }
               break;
           #endif
           #if PREHEAT_COUNT >= 3
             case PREHEATHOTEND_3:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_3_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_3_LABEL));
               else {
                 thermalManager.setTargetHotend(ui.material_preset[2].hotend_temp, 0);
                 thermalManager.set_fan_speed(0, ui.material_preset[2].fan_speed);
               }
               break;
           #endif
           #if PREHEAT_COUNT >= 4
             case PREHEATHOTEND_4:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_4_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_4_LABEL));
               else {
                 thermalManager.setTargetHotend(ui.material_preset[3].hotend_temp, 0);
                 thermalManager.set_fan_speed(0, ui.material_preset[3].fan_speed);
               }
               break;
           #endif
           #if PREHEAT_COUNT >= 5
             case PREHEATHOTEND_5:
               if (draw)
-                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_5_LABEL);
+                Draw_Menu_Item(row, ICON_Temperature, F(PREHEAT_5_LABEL));
               else {
                 thermalManager.setTargetHotend(ui.material_preset[4].hotend_temp, 0);
                 thermalManager.set_fan_speed(0, ui.material_preset[4].fan_speed);
               }
               break;
           #endif
           case PREHEATHOTEND_CUSTOM:
             if (draw) {
-              Draw_Menu_Item(row, ICON_Temperature, "Custom");
+              Draw_Menu_Item(row, ICON_Temperature, F("Custom"));
               Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
             }
             else
               Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
             break;
         }
         break;
   }
 }
 
-const char * CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
+FSTR_P CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
   switch (menu) {
-    case MainMenu:          return "Main Menu";
-    case Prepare:           return "Prepare";
-    case HomeMenu:          return "Homing Menu";
-    case Move:              return "Move";
-    case ManualLevel:       return "Manual Leveling";
+    case MainMenu:          return F("Main Menu");
+    case Prepare:           return F("Prepare");
+    case HomeMenu:          return F("Homing Menu");
+    case Move:              return F("Move");
+    case ManualLevel:       return F("Manual Leveling");
     #if HAS_ZOFFSET_ITEM
-      case ZOffset:         return "Z Offset";
+      case ZOffset:         return F("Z Offset");
     #endif
     #if HAS_PREHEAT
-      case Preheat:         return "Preheat";
+      case Preheat:         return F("Preheat");
     #endif
     #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      case ChangeFilament:  return "Change Filament";
+      case ChangeFilament:  return F("Change Filament");
     #endif
-    case Control:           return "Control";
-    case TempMenu:          return "Temperature";
+    case Control:           return F("Control");
+    case TempMenu:          return F("Temperature");
     #if HAS_HOTEND || HAS_HEATED_BED
-      case PID:             return "PID Menu";
+      case PID:             return F("PID Menu");
     #endif
     #if HAS_HOTEND
-      case HotendPID:       return "Hotend PID Settings";
+      case HotendPID:       return F("Hotend PID Settings");
     #endif
     #if HAS_HEATED_BED
-      case BedPID:          return "Bed PID Settings";
+      case BedPID:          return F("Bed PID Settings");
     #endif
     #if PREHEAT_COUNT >= 1
-      case Preheat1:        return (PREHEAT_1_LABEL " Settings");
+      case Preheat1:        return F(PREHEAT_1_LABEL " Settings");
     #endif
     #if PREHEAT_COUNT >= 2
-      case Preheat2:        return (PREHEAT_2_LABEL " Settings");
+      case Preheat2:        return F(PREHEAT_2_LABEL " Settings");
     #endif
     #if PREHEAT_COUNT >= 3
-      case Preheat3:        return (PREHEAT_3_LABEL " Settings");
+      case Preheat3:        return F(PREHEAT_3_LABEL " Settings");
     #endif
     #if PREHEAT_COUNT >= 4
-      case Preheat4:        return (PREHEAT_4_LABEL " Settings");
+      case Preheat4:        return F(PREHEAT_4_LABEL " Settings");
     #endif
     #if PREHEAT_COUNT >= 5
-      case Preheat5:        return (PREHEAT_5_LABEL " Settings");
+      case Preheat5:        return F(PREHEAT_5_LABEL " Settings");
     #endif
-    case Motion:            return "Motion Settings";
-    case HomeOffsets:       return "Home Offsets";
-    case MaxSpeed:          return "Max Speed";
-    case MaxAcceleration:   return "Max Acceleration";
+    case Motion:            return F("Motion Settings");
+    case HomeOffsets:       return F("Home Offsets");
+    case MaxSpeed:          return F("Max Speed");
+    case MaxAcceleration:   return F("Max Acceleration");
     #if HAS_CLASSIC_JERK
-      case MaxJerk:         return "Max Jerk";
+      case MaxJerk:         return F("Max Jerk");
     #endif
-    case Steps:             return "Steps/mm";
-    case Visual:            return "Visual Settings";
-    case Advanced:          return "Advanced Settings";
+    case Steps:             return F("Steps/mm");
+    case Visual:            return F("Visual Settings");
+    case Advanced:          return F("Advanced Settings");
     #if HAS_BED_PROBE
-      case ProbeMenu:       return "Probe Menu";
+      case ProbeMenu:       return F("Probe Menu");
     #endif
-    case ColorSettings:     return "UI Color Settings";
-    case Info:              return "Info";
-    case InfoMain:          return "Info";
+    case ColorSettings:     return F("UI Color Settings");
+    case Info:              return F("Info");
+    case InfoMain:          return F("Info");
     #if HAS_MESH
-      case Leveling:        return "Leveling";
-      case LevelView:       return GET_TEXT(MSG_MESH_VIEW);
-      case LevelSettings:   return "Leveling Settings";
-      case MeshViewer:      return GET_TEXT(MSG_MESH_VIEW);
-      case LevelManual:     return "Manual Tuning";
+      case Leveling:        return F("Leveling");
+      case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
+      case LevelSettings:   return F("Leveling Settings");
+      case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
+      case LevelManual:     return F("Manual Tuning");
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
-      case UBLMesh:         return "UBL Bed Leveling";
+      case UBLMesh:         return F("UBL Bed Leveling");
     #endif
     #if ENABLED(PROBE_MANUALLY)
-      case ManualMesh:      return "Mesh Bed Leveling";
+      case ManualMesh:      return F("Mesh Bed Leveling");
     #endif
-    case Tune:              return "Tune";
-    case PreheatHotend:     return "Preheat Hotend";
+    case Tune:              return F("Tune");
+    case PreheatHotend:     return F("Preheat Hotend");
   }
-  return "";
+  return F("");
 }
 
 uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
   switch (menu) {
     case Prepare:           return PREPARE_TOTAL;
     case HomeMenu:          return HOME_TOTAL;
     case Move:              return MOVE_TOTAL;
     case ManualLevel:       return MLEVEL_TOTAL;
     #if HAS_ZOFFSET_ITEM
       case ZOffset:         return ZOFFSET_TOTAL;
@@ -4162,51 +4178,51 @@ uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
     case ColorSettings:     return COLORSETTINGS_TOTAL;
   }
   return 0;
 }
 
 /* Popup Config */
 
 void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
   popup = last_popup = popupid;
   switch (popupid) {
-    case Pause:         Draw_Popup(PSTR("Pause Print"), PSTR(""), PSTR(""), Popup); break;
-    case Stop:          Draw_Popup(PSTR("Stop Print"), PSTR(""), PSTR(""), Popup); break;
-    case Resume:        Draw_Popup(PSTR("Resume Print?"), PSTR("Looks Like the last"), PSTR("print was interupted."), Popup); break;
-    case ConfFilChange: Draw_Popup(PSTR("Confirm Filament Change"), PSTR(""), PSTR(""), Popup); break;
-    case PurgeMore:     Draw_Popup(PSTR("Purge more filament?"), PSTR("(Cancel to finish process)"), PSTR(""), Popup); break;
-    case SaveLevel:     Draw_Popup(PSTR("Leveling Complete"), PSTR("Save to EEPROM?"), PSTR(""), Popup); break;
-    case MeshSlot:      Draw_Popup(PSTR("Mesh slot not selected"), PSTR("(Confirm to select slot 0)"), PSTR(""), Popup); break;
-    case ETemp:         Draw_Popup(PSTR("Nozzle is too cold"), PSTR("Open Preheat Menu?"), PSTR(""), Popup); break;
-    case ManualProbing: Draw_Popup(PSTR("Manual Probing"), PSTR("(Confirm to probe)"), PSTR("(cancel to exit)"), Popup); break;
-    case Level:         Draw_Popup(PSTR("Auto Bed Leveling"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_AutoLeveling); break;
-    case Home:          Draw_Popup(option ? PSTR("Parking") : PSTR("Homing"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
-    case MoveWait:      Draw_Popup(PSTR("Moving to Point"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
-    case Heating:       Draw_Popup(PSTR("Heating"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
-    case FilLoad:       Draw_Popup(option ? PSTR("Unloading Filament") : PSTR("Loading Filament"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
-    case FilChange:     Draw_Popup(PSTR("Filament Change"), PSTR("Please wait for prompt."), PSTR(""), Wait, ICON_BLTouch); break;
-    case TempWarn:      Draw_Popup(option ? PSTR("Nozzle temp too low!") : PSTR("Nozzle temp too high!"), PSTR(""), PSTR(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
-    case Runout:        Draw_Popup(PSTR("Filament Runout"), PSTR(""), PSTR(""), Wait, ICON_BLTouch); break;
-    case PIDWait:       Draw_Popup(PSTR("PID Autotune"), PSTR("in process"), PSTR("Please wait until done."), Wait, ICON_BLTouch); break;
-    case Resuming:      Draw_Popup(PSTR("Resuming Print"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
+    case Pause:         Draw_Popup(F("Pause Print"), F(""), F(""), Popup); break;
+    case Stop:          Draw_Popup(F("Stop Print"), F(""), F(""), Popup); break;
+    case Resume:        Draw_Popup(F("Resume Print?"), F("Looks Like the last"), F("print was interupted."), Popup); break;
+    case ConfFilChange: Draw_Popup(F("Confirm Filament Change"), F(""), F(""), Popup); break;
+    case PurgeMore:     Draw_Popup(F("Purge more filament?"), F("(Cancel to finish process)"), F(""), Popup); break;
+    case SaveLevel:     Draw_Popup(F("Leveling Complete"), F("Save to EEPROM?"), F(""), Popup); break;
+    case MeshSlot:      Draw_Popup(F("Mesh slot not selected"), F("(Confirm to select slot 0)"), F(""), Popup); break;
+    case ETemp:         Draw_Popup(F("Nozzle is too cold"), F("Open Preheat Menu?"), F(""), Popup); break;
+    case ManualProbing: Draw_Popup(F("Manual Probing"), F("(Confirm to probe)"), F("(cancel to exit)"), Popup); break;
+    case Level:         Draw_Popup(F("Auto Bed Leveling"), F("Please wait until done."), F(""), Wait, ICON_AutoLeveling); break;
+    case Home:          Draw_Popup(option ? F("Parking") : F("Homing"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case MoveWait:      Draw_Popup(F("Moving to Point"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case Heating:       Draw_Popup(F("Heating"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case FilLoad:       Draw_Popup(option ? F("Unloading Filament") : F("Loading Filament"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
+    case FilChange:     Draw_Popup(F("Filament Change"), F("Please wait for prompt."), F(""), Wait, ICON_BLTouch); break;
+    case TempWarn:      Draw_Popup(option ? F("Nozzle temp too low!") : F("Nozzle temp too high!"), F(""), F(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
+    case Runout:        Draw_Popup(F("Filament Runout"), F(""), F(""), Wait, ICON_BLTouch); break;
+    case PIDWait:       Draw_Popup(F("PID Autotune"), F("in process"), F("Please wait until done."), Wait, ICON_BLTouch); break;
+    case Resuming:      Draw_Popup(F("Resuming Print"), F("Please wait until done."), F(""), Wait, ICON_BLTouch); break;
     default: break;
   }
 }
 
 void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
   popup = popupid;
   switch (popupid) {
-    case FilInsert:   Draw_Popup(PSTR("Insert Filament"), PSTR("Press to Continue"), PSTR(""), Confirm); break;
-    case HeaterTime:  Draw_Popup(PSTR("Heater Timed Out"), PSTR("Press to Reheat"), PSTR(""), Confirm); break;
-    case UserInput:   Draw_Popup(PSTR("Waiting for Input"), PSTR("Press to Continue"), PSTR(""), Confirm); break;
-    case LevelError:  Draw_Popup(PSTR("Couldn't enable Leveling"), PSTR("(Valid mesh must exist)"), PSTR(""), Confirm); break;
-    case InvalidMesh: Draw_Popup(PSTR("Valid mesh must exist"), PSTR("before tuning can be"), PSTR("performed"), Confirm); break;
+    case FilInsert:   Draw_Popup(F("Insert Filament"), F("Press to Continue"), F(""), Confirm); break;
+    case HeaterTime:  Draw_Popup(F("Heater Timed Out"), F("Press to Reheat"), F(""), Confirm); break;
+    case UserInput:   Draw_Popup(F("Waiting for Input"), F("Press to Continue"), F(""), Confirm); break;
+    case LevelError:  Draw_Popup(F("Couldn't enable Leveling"), F("(Valid mesh must exist)"), F(""), Confirm); break;
+    case InvalidMesh: Draw_Popup(F("Valid mesh must exist"), F("before tuning can be"), F("performed"), Confirm); break;
     default: break;
   }
 }
 
 /* Navigation and Control */
 
 void CrealityDWINClass::Main_Menu_Control() {
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    🎨 Apply F() to G-code subcommands

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 6d4f8b0a3a..2bdb15a30f 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -200,21 +200,21 @@ CrealityDWINClass CrealityDWIN;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       uint8_t tilt_grid = 1;
 
       void manual_value_update(bool undefined=false) {
         sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
-        gcode.process_subcommands_now_P(cmd);
+        gcode.process_subcommands_now(cmd);
         planner.synchronize();
       }
 
       bool create_plane_from_mesh() {
         struct linear_fit_data lsf_results;
         incremental_LSF_reset(&lsf_results);
         GRID_LOOP(x, y) {
           if (!isnan(Z_VALUES_ARR[x][y])) {
             xy_pos_t rpos;
             rpos.x = ubl.mesh_index_to_xpos(x);
@@ -260,39 +260,39 @@ CrealityDWINClass CrealityDWIN;
 
           Z_VALUES_ARR[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
 
       void manual_value_update() {
         sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
-        gcode.process_subcommands_now_P(cmd);
+        gcode.process_subcommands_now(cmd);
         planner.synchronize();
       }
 
     #endif
 
     void manual_move(bool zmove=false) {
       if (zmove) {
         planner.synchronize();
         current_position.z = goto_mesh_value ? Z_VALUES_ARR[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
         CrealityDWIN.Popup_Handler(MoveWait);
         sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
-        gcode.process_subcommands_now_P(cmd);
+        gcode.process_subcommands_now(cmd);
         sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
-        gcode.process_subcommands_now_P(cmd);
+        gcode.process_subcommands_now(cmd);
         planner.synchronize();
         current_position.z = goto_mesh_value ? Z_VALUES_ARR[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
         CrealityDWIN.Redraw_Menu();
       }
     }
 
     float get_max_value() {
       float max = __FLT_MIN__;
@@ -1109,21 +1109,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               #else
                 if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                   Popup_Handler(ETemp);
                 else {
                   if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                     Popup_Handler(Heating);
                     thermalManager.wait_for_hotend(0);
                   }
                   Popup_Handler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                  gcode.process_subcommands_now_P(cmd);
+                  gcode.process_subcommands_now(cmd);
                 }
               #endif
             }
             break;
         #endif
       }
       break;
 
     case HomeMenu:
 
@@ -1149,50 +1149,50 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Popup_Handler(Home);
             gcode.home_all_axes(true);
             Redraw_Menu();
           }
           break;
         case HOME_X:
           if (draw)
             Draw_Menu_Item(row, ICON_MoveX, "Home X");
           else {
             Popup_Handler(Home);
-            gcode.process_subcommands_now_P(PSTR("G28 X"));
+            gcode.process_subcommands_now(F("G28 X"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_Y:
           if (draw)
             Draw_Menu_Item(row, ICON_MoveY, "Home Y");
           else {
             Popup_Handler(Home);
-            gcode.process_subcommands_now_P(PSTR("G28 Y"));
+            gcode.process_subcommands_now(F("G28 Y"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_Z:
           if (draw)
             Draw_Menu_Item(row, ICON_MoveZ,"Home Z");
           else {
             Popup_Handler(Home);
-            gcode.process_subcommands_now_P(PSTR("G28 Z"));
+            gcode.process_subcommands_now(F("G28 Z"));
             planner.synchronize();
             Redraw_Menu();
           }
           break;
         case HOME_SET:
           if (draw)
             Draw_Menu_Item(row, ICON_SetHome, "Set Home Position");
           else {
-            gcode.process_subcommands_now_P(PSTR("G92 X0 Y0 Z0"));
+            gcode.process_subcommands_now(F("G92 X0 Y0 Z0"));
             AudioFeedback();
           }
           break;
       }
       break;
 
     case Move:
 
       #define MOVE_BACK 0
       #define MOVE_X (MOVE_BACK + 1)
@@ -1343,112 +1343,112 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             break;
         #endif
         case MLEVEL_BL:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisBL, "Bottom Left");
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_TL:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisTL, "Top Left");
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_TR:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisTR, "Top Right");
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_BR:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisBR, "Bottom Right");
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_C:
           if (draw)
             Draw_Menu_Item(row, ICON_AxisC, "Center");
           else {
             Popup_Handler(MoveWait);
             if (use_probe) {
               #if HAS_BED_PROBE
                 sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
                 planner.synchronize();
                 Popup_Handler(ManualProbing);
               #endif
             }
             else {
               sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
           }
           break;
         case MLEVEL_ZPOS:
           if (draw) {
             Draw_Menu_Item(row, ICON_SetZOffset, "Z Position");
             Draw_Float(mlev_z_pos, row, false, 100);
           }
@@ -1477,54 +1477,54 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               liveadjust = false;
               TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
               Draw_Menu(Prepare, PREPARE_ZOFFSET);
             }
             break;
           case ZOFFSET_HOME:
             if (draw)
               Draw_Menu_Item(row, ICON_Homing, "Home Z Axis");
             else {
               Popup_Handler(Home);
-              gcode.process_subcommands_now_P(PSTR("G28 Z"));
+              gcode.process_subcommands_now(F("G28 Z"));
               Popup_Handler(MoveWait);
               #if ENABLED(Z_SAFE_HOMING)
                 planner.synchronize();
                 sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
               #else
-                gcode.process_subcommands_now_P(PSTR("G0 F4000 X117.5 Y117.5"));
+                gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
               #endif
-              gcode.process_subcommands_now_P(PSTR("G0 F300 Z0"));
+              gcode.process_subcommands_now(F("G0 F300 Z0"));
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case ZOFFSET_MODE:
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, "Live Adjustment");
               Draw_Checkbox(row, liveadjust);
             }
             else {
               if (!liveadjust) {
                 if (axes_should_home()) {
                   Popup_Handler(Home);
                   gcode.home_all_axes(true);
                 }
                 Popup_Handler(MoveWait);
                 #if ENABLED(Z_SAFE_HOMING)
                   planner.synchronize();
                   sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
-                  gcode.process_subcommands_now_P(cmd);
+                  gcode.process_subcommands_now(cmd);
                 #else
-                  gcode.process_subcommands_now_P(PSTR("G0 F4000 X117.5 Y117.5"));
+                  gcode.process_subcommands_now(F("G0 F4000 X117.5 Y117.5"));
                 #endif
-                gcode.process_subcommands_now_P(PSTR("G0 F300 Z0"));
+                gcode.process_subcommands_now(F("G0 F300 Z0"));
                 planner.synchronize();
                 Redraw_Menu();
               }
               liveadjust = !liveadjust;
               Draw_Checkbox(row, liveadjust);
             }
             break;
           case ZOFFSET_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, "Z Offset");
@@ -1532,35 +1532,35 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             }
             else
               Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case ZOFFSET_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
             else {
               if (zoffsetvalue < MAX_Z_OFFSET) {
                 if (liveadjust) {
-                  gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+                  gcode.process_subcommands_now(F("M290 Z0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue += 0.01;
                 Draw_Float(zoffsetvalue, row - 1, false, 100);
               }
             }
             break;
           case ZOFFSET_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
             else {
               if (zoffsetvalue > MIN_Z_OFFSET) {
                 if (liveadjust) {
-                  gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+                  gcode.process_subcommands_now(F("M290 Z-0.01"));
                   planner.synchronize();
                 }
                 zoffsetvalue -= 0.01;
                 Draw_Float(zoffsetvalue, row - 2, false, 100);
               }
             }
             break;
           #if ENABLED(EEPROM_SETTINGS)
             case ZOFFSET_SAVE:
               if (draw)
@@ -1714,59 +1714,59 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_WriteEEPROM, "Load Filament");
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad);
-                gcode.process_subcommands_now_P(PSTR("M701"));
+                gcode.process_subcommands_now(F("M701"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_UNLOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_ReadEEPROM, "Unload Filament");
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
                 Popup_Handler(ETemp);
               }
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilLoad, true);
-                gcode.process_subcommands_now_P(PSTR("M702"));
+                gcode.process_subcommands_now(F("M702"));
                 planner.synchronize();
                 Redraw_Menu();
               }
             }
             break;
           case CHANGEFIL_CHANGE:
             if (draw)
               Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament");
             else {
               if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
                 Popup_Handler(ETemp);
               else {
                 if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                   Popup_Handler(Heating);
                   thermalManager.wait_for_hotend(0);
                 }
                 Popup_Handler(FilChange);
                 sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
               }
             }
             break;
         }
         break;
     #endif // FILAMENT_LOAD_UNLOAD_GCODES
 
     case Control:
 
       #define CONTROL_BACK 0
@@ -2009,21 +2009,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_Back, "Back");
             else
               Draw_Menu(PID, PID_HOTEND);
             break;
           case HOTENDPID_TUNE:
             if (draw)
               Draw_Menu_Item(row, ICON_HotendTemp, "Autotune");
             else {
               Popup_Handler(PIDWait);
               sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case HOTENDPID_TEMP:
             if (draw) {
               Draw_Menu_Item(row, ICON_Temperature, "Temperature");
               Draw_Float(PID_e_temp, row, false, 1);
             }
             else
@@ -2076,21 +2076,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_Back, "Back");
             else
               Draw_Menu(PID, PID_BED);
             break;
           case BEDPID_TUNE:
             if (draw)
               Draw_Menu_Item(row, ICON_HotendTemp, "Autotune");
             else {
               Popup_Handler(PIDWait);
               sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
               planner.synchronize();
               Redraw_Menu();
             }
             break;
           case BEDPID_TEMP:
             if (draw) {
               Draw_Menu_Item(row, ICON_Temperature, "Temperature");
               Draw_Float(PID_bed_temp, row, false, 1);
             }
             else
@@ -3022,21 +3022,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 Draw_Float(probe.offset.y, row, false, 10);
               }
               else
                 Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
               break;
             case PROBE_TEST:
               if (draw)
                 Draw_Menu_Item(row, ICON_StepY, "M48 Probe Test");
               else {
                 sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
-                gcode.process_subcommands_now_P(cmd);
+                gcode.process_subcommands_now(cmd);
               }
               break;
             case PROBE_TEST_COUNT:
               if (draw) {
                 Draw_Menu_Item(row, ICON_StepY, "Probe Test Count");
                 Draw_Float(testcount, row, false, 1);
               }
               else
                 Modify_Value(testcount, 4, 50, 1);
               break;
@@ -3134,25 +3134,26 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               if (draw)
                 Draw_Menu_Item(row, ICON_Tilt, "Autotilt Current Mesh");
               else {
                 if (ubl.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
                 Popup_Handler(Home);
                 gcode.home_all_axes(true);
                 Popup_Handler(Level);
-                if (mesh_conf.tilt_grid > 1)
+                if (mesh_conf.tilt_grid > 1) {
                   sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
+                  gcode.process_subcommands_now(cmd);
+                }
                 else
-                  sprintf_P(cmd, PSTR("G29 J"));
-                gcode.process_subcommands_now_P(cmd);
+                  gcode.process_subcommands_now(F("G29 J"));
                 planner.synchronize();
                 Redraw_Menu();
               }
               break;
           #endif
           case LEVELING_GET_MESH:
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, "Create New Mesh");
             else {
               Popup_Handler(Home);
@@ -3166,45 +3167,45 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   #endif
                   #if HAS_HEATED_BED
                     if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
                       thermalManager.setTargetBed(LEVELING_BED_TEMP);
                   #endif
                   thermalManager.wait_for_hotend(0);
                   TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
                 #endif
                 #if HAS_BED_PROBE
                   Popup_Handler(Level);
-                  gcode.process_subcommands_now_P(PSTR("G29 P0\nG29 P1"));
-                  gcode.process_subcommands_now_P(PSTR("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
+                  gcode.process_subcommands_now(F("G29 P0\nG29 P1"));
+                  gcode.process_subcommands_now(F("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
                   planner.synchronize();
                   Update_Status("Probed all reachable points");
                   Popup_Handler(SaveLevel);
                 #else
                   level_state = planner.leveling_active;
                   set_bed_leveling_enabled(false);
                   mesh_conf.goto_mesh_value = true;
                   mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
                   Popup_Handler(MoveWait);
                   mesh_conf.manual_move();;
                   Draw_Menu(UBLMesh);
                 #endif
               #elif HAS_BED_PROBE
                 Popup_Handler(Level);
-                gcode.process_subcommands_now_P(PSTR("G29"));
+                gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
                 Popup_Handler(SaveLevel);
               #else
                 level_state = planner.leveling_active;
                 set_bed_leveling_enabled(false);
                 gridpoint = 1;
                 Popup_Handler(MoveWait);
-                gcode.process_subcommands_now_P(PSTR("G29"));
+                gcode.process_subcommands_now(F("G29"));
                 planner.synchronize();
                 Draw_Menu(ManualMesh);
               #endif
             }
             break;
           case LEVELING_MANUAL:
             if (draw)
               Draw_Menu_Item(row, ICON_Mesh, "Manual Tuning", nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -3273,34 +3274,34 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Modify_Value(ubl.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
             break;
           case LEVELING_LOAD:
             if (draw)
               Draw_Menu_Item(row, ICON_ReadEEPROM, "Load Mesh");
             else {
               if (ubl.storage_slot < 0) {
                 Popup_Handler(MeshSlot);
                 break;
               }
-              gcode.process_subcommands_now_P(PSTR("G29 L"));
+              gcode.process_subcommands_now(F("G29 L"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           case LEVELING_SAVE:
             if (draw)
               Draw_Menu_Item(row, ICON_WriteEEPROM, "Save Mesh");
             else {
               if (ubl.storage_slot < 0) {
                 Popup_Handler(MeshSlot);
                 break;
               }
-              gcode.process_subcommands_now_P(PSTR("G29 S"));
+              gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               AudioFeedback(true);
             }
             break;
           #endif
         }
         break;
 
       case LevelView:
 
@@ -3382,21 +3383,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 Draw_Float(mesh_conf.tilt_grid, row, false, 1);
               }
               else
                 Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
               break;
             case LEVELING_SETTINGS_PLANE:
               if (draw)
                 Draw_Menu_Item(row, ICON_ResumeEEPROM, "Convert Mesh to Plane");
               else {
                 if (mesh_conf.create_plane_from_mesh()) break;
-                gcode.process_subcommands_now_P(PSTR("M420 S1"));
+                gcode.process_subcommands_now(F("M420 S1"));
                 planner.synchronize();
                 AudioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, "Zero Current Mesh");
               else
                 ZERO(Z_VALUES_ARR);
               break;
@@ -3490,33 +3491,33 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
               Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case LEVELING_M_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
-              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case LEVELING_M_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
-              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
               Draw_Menu_Item(row, ICON_StockConfiguration, "Go to Mesh Z Value");
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
@@ -3573,21 +3574,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
                 if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
                   mesh_conf.mesh_y++;
                 else if (mesh_conf.mesh_y % 2 == 0)
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_move();
               }
               else {
-                gcode.process_subcommands_now_P(PSTR("G29 S"));
+                gcode.process_subcommands_now(F("G29 S"));
                 planner.synchronize();
                 AudioFeedback(true);
                 Draw_Menu(Leveling, LEVELING_GET_MESH);
               }
             }
             break;
           case UBL_M_PREV:
             if (draw)
               Draw_Menu_Item(row, ICON_More, "Previous Point");
             else {
@@ -3611,33 +3612,33 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
                 Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
               Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case UBL_M_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
-              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case UBL_M_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Down");
             else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
               Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
-              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
         break;
     #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
 
@@ -3650,72 +3651,72 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
         #define MMESH_UP (MMESH_OFFSET + 1)
         #define MMESH_DOWN (MMESH_UP + 1)
         #define MMESH_OLD (MMESH_DOWN + 1)
         #define MMESH_TOTAL MMESH_OLD
 
         switch (item) {
           case MMESH_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, "Cancel");
             else {
-              gcode.process_subcommands_now_P(PSTR("G29 A"));
+              gcode.process_subcommands_now(F("G29 A"));
               planner.synchronize();
               set_bed_leveling_enabled(level_state);
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_NEXT:
             if (draw) {
               if (gridpoint < GRID_MAX_POINTS)
                 Draw_Menu_Item(row, ICON_More, "Next Point");
               else
                 Draw_Menu_Item(row, ICON_More, "Save Mesh");
             }
             else if (gridpoint < GRID_MAX_POINTS) {
               Popup_Handler(MoveWait);
-              gcode.process_subcommands_now_P(PSTR("G29"));
+              gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               gridpoint++;
               Redraw_Menu();
             }
             else {
-              gcode.process_subcommands_now_P(PSTR("G29"));
+              gcode.process_subcommands_now(F("G29"));
               planner.synchronize();
               AudioFeedback(settings.save());
               Draw_Menu(Leveling, LEVELING_GET_MESH);
             }
             break;
           case MMESH_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, "Z Position");
               current_position.z = MANUAL_PROBE_START_Z;
               Draw_Float(current_position.z, row, false, 100);
             }
             else
               Modify_Value(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case MMESH_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
             else if (current_position.z < MAX_Z_OFFSET) {
-              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              gcode.process_subcommands_now(F("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
               Draw_Float(current_position.z, row - 1, false, 100);
             }
             break;
           case MMESH_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
             else if (current_position.z > MIN_Z_OFFSET) {
-              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
               Draw_Float(current_position.z, row - 2, false, 100);
             }
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
             // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
             mesh_y = (gridpoint - 1) / GRID_MAX_POINTS_Y;
@@ -3822,30 +3823,30 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
               Draw_Menu_Item(row, ICON_FanSpeed, "Z-Offset");
               Draw_Float(zoffsetvalue, row, false, 100);
             }
             else
               Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             break;
           case TUNE_ZUP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Z-Offset Up");
             else if (zoffsetvalue < MAX_Z_OFFSET) {
-              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              gcode.process_subcommands_now(F("M290 Z0.01"));
               zoffsetvalue += 0.01;
               Draw_Float(zoffsetvalue, row - 1, false, 100);
             }
             break;
           case TUNE_ZDOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, "Z-Offset Down");
             else if (zoffsetvalue > MIN_Z_OFFSET) {
-              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              gcode.process_subcommands_now(F("M290 Z-0.01"));
               zoffsetvalue -= 0.01;
               Draw_Float(zoffsetvalue, row - 2, false, 100);
             }
             break;
         #endif
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           case TUNE_CHANGEFIL:
             if (draw)
               Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament");
@@ -3909,41 +3910,41 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           case PREHEATHOTEND_CONTINUE:
             if (draw)
               Draw_Menu_Item(row, ICON_SetEndTemp, "Continue");
             else {
               Popup_Handler(Heating);
               thermalManager.wait_for_hotend(0);
               switch (last_menu) {
                 case Prepare:
                   Popup_Handler(FilChange);
                   sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                  gcode.process_subcommands_now_P(cmd);
+                  gcode.process_subcommands_now(cmd);
                   break;
                 #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
                   case ChangeFilament:
                     switch (last_selection) {
                       case CHANGEFIL_LOAD:
                         Popup_Handler(FilLoad);
-                        gcode.process_subcommands_now_P("M701");
+                        gcode.process_subcommands_now(F("M701"));
                         planner.synchronize();
                         Redraw_Menu(true, true, true);
                         break;
                       case CHANGEFIL_UNLOAD:
                         Popup_Handler(FilLoad, true);
-                        gcode.process_subcommands_now_P("M702");
+                        gcode.process_subcommands_now(F("M702"));
                         planner.synchronize();
                         Redraw_Menu(true, true, true);
                         break;
                       case CHANGEFIL_CHANGE:
                         Popup_Handler(FilChange);
                         sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-                        gcode.process_subcommands_now_P(cmd);
+                        gcode.process_subcommands_now(cmd);
                         break;
                     }
                     break;
                 #endif
                 default:
                   Redraw_Menu(true, true, true);
                   break;
               }
             }
             break;
@@ -4268,21 +4269,21 @@ void CrealityDWINClass::Value_Control() {
     DWIN_UpdateLCD();
     if (active_menu == ZOffset && liveadjust) {
       planner.synchronize();
       current_position.z += (tempvalue / valueunit - zoffsetvalue);
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
       current_position.z = 0;
       sync_plan_position();
     }
     else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
       sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - zoffsetvalue), 1, 3, str_1));
-      gcode.process_subcommands_now_P(cmd);
+      gcode.process_subcommands_now(cmd);
     }
     if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
       tempvalue = scalePID_i(tempvalue);
     if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
       tempvalue = scalePID_d(tempvalue);
     switch (valuetype) {
       case 0: *(float*)valuepointer = tempvalue / valueunit; break;
       case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
       case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
       case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
@@ -4467,25 +4468,25 @@ void CrealityDWINClass::Print_Screen_Control() {
         if (paused) {
           if (sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
               char cmnd[20];
               #if HAS_HEATED_BED
                 cmnd[sprintf_P(cmnd, PSTR("M140 S%i"), pausebed)] = '\0';
-                gcode.process_subcommands_now_P(PSTR(cmnd));
+                gcode.process_subcommands_now(cmnd);
               #endif
               #if HAS_EXTRUDERS
                 cmnd[sprintf_P(cmnd, PSTR("M109 S%i"), pausetemp)] = '\0';
-                gcode.process_subcommands_now_P(PSTR(cmnd));
+                gcode.process_subcommands_now(cmnd);
               #endif
               TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
               planner.synchronize();
               TERN_(SDSUPPORT, queue.inject_P(PSTR("M24")));
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, host_action_resume());
           }
           Draw_Print_Screen();
@@ -4596,21 +4597,21 @@ void CrealityDWINClass::Popup_Control() {
           if (selection == 0) {
             if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
               Popup_Handler(ETemp);
             else {
               if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
                 Popup_Handler(Heating);
                 thermalManager.wait_for_hotend(0);
               }
               Popup_Handler(FilChange);
               sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
-              gcode.process_subcommands_now_P(cmd);
+              gcode.process_subcommands_now(cmd);
             }
           }
           else
             Redraw_Menu(true, true, false);
           break;
         case PurgeMore:
           if (selection == 0) {
             pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
             Popup_Handler(FilChange);
           }
@@ -4619,21 +4620,21 @@ void CrealityDWINClass::Popup_Control() {
             if (printing) Popup_Handler(Resuming);
             else Redraw_Menu(true, true, (active_menu==PreheatHotend));
           }
           break;
       #endif // ADVANCED_PAUSE_FEATURE
 
       #if HAS_MESH
         case SaveLevel:
           if (selection == 0) {
             #if ENABLED(AUTO_BED_LEVELING_UBL)
-              gcode.process_subcommands_now_P(PSTR("G29 S"));
+              gcode.process_subcommands_now(F("G29 S"));
               planner.synchronize();
               AudioFeedback(true);
             #else
               AudioFeedback(settings.save());
             #endif
           }
           Draw_Menu(Leveling, LEVELING_GET_MESH);
           break;
       #endif
 

commit c6ceac9067b21a705f40fbcfc90bbc922945f82e
Author: Steven Haigh <netwiz@crc.id.au>
Date:   Thu Sep 30 02:22:46 2021 +1000

    🚑️ Fix DWIN_CompletedLeveling (#22851)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index a48987e68d..6d4f8b0a3a 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -3239,21 +3239,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
                 TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
               #endif
               Popup_Handler(MoveWait);
               mesh_conf.manual_move();
               Draw_Menu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
+              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (ubl.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
               #endif
               Draw_Menu(LevelView);
             }
             break;
@@ -3312,21 +3312,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, "Back");
             else
               Draw_Menu(Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
+              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT(MSG_MESH_VIEW), nullptr, true);
             else
               Draw_Menu(MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
               Draw_Menu_Item(row, ICON_Contact, "Viewer Show Values");
               Draw_Checkbox(row, mesh_conf.viewer_print_value);
             }
             else {
               mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
@@ -4063,23 +4063,23 @@ const char * CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
     case Visual:            return "Visual Settings";
     case Advanced:          return "Advanced Settings";
     #if HAS_BED_PROBE
       case ProbeMenu:       return "Probe Menu";
     #endif
     case ColorSettings:     return "UI Color Settings";
     case Info:              return "Info";
     case InfoMain:          return "Info";
     #if HAS_MESH
       case Leveling:        return "Leveling";
-      case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
+      case LevelView:       return GET_TEXT(MSG_MESH_VIEW);
       case LevelSettings:   return "Leveling Settings";
-      case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
+      case MeshViewer:      return GET_TEXT(MSG_MESH_VIEW);
       case LevelManual:     return "Manual Tuning";
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case UBLMesh:         return "UBL Bed Leveling";
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:      return "Mesh Bed Leveling";
     #endif
     case Tune:              return "Tune";
     case PreheatHotend:     return "Preheat Hotend";

commit 8ab02df63a2360b2dac86048b38311bbdfa42b3c
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Mon Sep 27 14:47:47 2021 -0500

    ✨ E3V2 (Enhanced) Mesh Viewer (#22844)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index eccbe8d141..a48987e68d 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -3239,21 +3239,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
                 TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
               #endif
               Popup_Handler(MoveWait);
               mesh_conf.manual_move();
               Draw_Menu(LevelManual);
             }
             break;
           case LEVELING_VIEW:
             if (draw)
-              Draw_Menu_Item(row, ICON_Mesh, "Mesh Viewer", nullptr, true);
+              Draw_Menu_Item(row, ICON_Mesh, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else {
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 if (ubl.storage_slot < 0) {
                   Popup_Handler(MeshSlot);
                   break;
                 }
               #endif
               Draw_Menu(LevelView);
             }
             break;
@@ -3312,21 +3312,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         switch (item) {
           case LEVELING_VIEW_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, "Back");
             else
               Draw_Menu(Leveling, LEVELING_VIEW);
             break;
           case LEVELING_VIEW_MESH:
             if (draw)
-              Draw_Menu_Item(row, ICON_PrintSize, "Mesh Viewer", nullptr, true);
+              Draw_Menu_Item(row, ICON_PrintSize, GET_TEXT_F(MSG_MESH_VIEW), nullptr, true);
             else
               Draw_Menu(MeshViewer);
             break;
           case LEVELING_VIEW_TEXT:
             if (draw) {
               Draw_Menu_Item(row, ICON_Contact, "Viewer Show Values");
               Draw_Checkbox(row, mesh_conf.viewer_print_value);
             }
             else {
               mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
@@ -4063,23 +4063,23 @@ const char * CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
     case Visual:            return "Visual Settings";
     case Advanced:          return "Advanced Settings";
     #if HAS_BED_PROBE
       case ProbeMenu:       return "Probe Menu";
     #endif
     case ColorSettings:     return "UI Color Settings";
     case Info:              return "Info";
     case InfoMain:          return "Info";
     #if HAS_MESH
       case Leveling:        return "Leveling";
-      case LevelView:       return "Mesh View";
+      case LevelView:       return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelSettings:   return "Leveling Settings";
-      case MeshViewer:      return "Mesh Viewer";
+      case MeshViewer:      return GET_TEXT_F(MSG_MESH_VIEW);
       case LevelManual:     return "Manual Tuning";
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
       case UBLMesh:         return "UBL Bed Leveling";
     #endif
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:      return "Mesh Bed Leveling";
     #endif
     case Tune:              return "Tune";
     case PreheatHotend:     return "Preheat Hotend";

commit 1ac7a56a823b5012250dd7259a9a7a46d3bfcde5
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sat Sep 25 05:59:43 2021 -0500

    🐛 E3V2 Brightness followup (#22821)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 55aee49f82..eccbe8d141 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -2710,21 +2710,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Draw_Menu_Item(row, ICON_Brightness, "Display Off");
           else
             ui.set_brightness(0);
           break;
         case VISUAL_BRIGHTNESS:
           if (draw) {
             Draw_Menu_Item(row, ICON_Brightness, "LCD Brightness");
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
-            Modify_Value(ui.brightness, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS, 1, ui.refresh_brightness);
+            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
         case VISUAL_TIME_FORMAT:
           if (draw) {
             Draw_Menu_Item(row, ICON_PrintTime, "Progress as __h__m");
             Draw_Checkbox(row, eeprom_settings.time_format_textual);
           }
           else {
             eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
             Draw_Checkbox(row, eeprom_settings.time_format_textual);
           }
@@ -3872,21 +3872,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             Draw_Menu_Item(row, ICON_Brightness, "Display Off");
           else
             ui.set_brightness(0);
           break;
         case TUNE_BACKLIGHT:
           if (draw) {
             Draw_Menu_Item(row, ICON_Brightness, "LCD Brightness");
             Draw_Float(ui.brightness, row, false, 1);
           }
           else
-            Modify_Value(ui.brightness, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS, 1, ui.refresh_brightness);
+            Modify_Value(ui.brightness, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, 1, ui.refresh_brightness);
           break;
       }
       break;
 
     case PreheatHotend:
 
         #define PREHEATHOTEND_BACK 0
         #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
         #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
         #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
@@ -4793,20 +4793,24 @@ void CrealityDWINClass::Update() {
     case Option:  Option_Control();       break;
     case File:    File_Control();         break;
     case Print:   Print_Screen_Control(); break;
     case Popup:   Popup_Control();        break;
     case Confirm: Confirm_Control();      break;
   }
 }
 
 void MarlinUI::update() { CrealityDWIN.Update(); }
 
+#if HAS_LCD_BRIGHTNESS
+  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+#endif
+
 void CrealityDWINClass::State_Update() {
   if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
     if (!printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
     else Stop_Print();
   }
   if (print_job_timer.isPaused() != paused) {
     paused = print_job_timer.isPaused();
     if (process == Print) Print_Screen_Icons();
     if (process == Wait && !paused) Redraw_Menu(true, true);
   }

commit 5b5a8798f8fe202e86c008088f847a3edb51cc71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Sep 15 19:48:29 2021 -0500

    🎨 Consolidate Ender-3 V2 DWIN common code (#22778)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 9b63d5331e..55aee49f82 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -33,20 +33,23 @@
 #include "../../marlinui.h"
 #include "../../../MarlinCore.h"
 
 #include "../../../gcode/gcode.h"
 #include "../../../module/temperature.h"
 #include "../../../module/planner.h"
 #include "../../../module/settings.h"
 #include "../../../libs/buzzer.h"
 #include "../../../inc/Conditionals_post.h"
 
+//#define DEBUG_OUT 1
+#include "../../../core/debug_out.h"
+
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../../../feature/pause.h"
 #endif
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   #include "../../../feature/runout.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
@@ -193,53 +196,52 @@ CrealityDWINClass CrealityDWIN;
 
   struct Mesh_Settings {
     bool viewer_asymmetric_range = false;
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      bed_mesh_t &mesh_z_values = ubl.z_values;
       uint8_t tilt_grid = 1;
 
       void manual_value_update(bool undefined=false) {
         sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
         gcode.process_subcommands_now_P(cmd);
         planner.synchronize();
       }
 
       bool create_plane_from_mesh() {
         struct linear_fit_data lsf_results;
         incremental_LSF_reset(&lsf_results);
         GRID_LOOP(x, y) {
-          if (!isnan(mesh_z_values[x][y])) {
+          if (!isnan(Z_VALUES_ARR[x][y])) {
             xy_pos_t rpos;
             rpos.x = ubl.mesh_index_to_xpos(x);
             rpos.y = ubl.mesh_index_to_ypos(y);
-            incremental_LSF(&lsf_results, rpos, mesh_z_values[x][y]);
+            incremental_LSF(&lsf_results, rpos, Z_VALUES_ARR[x][y]);
           }
         }
 
         if (finish_incremental_LSF(&lsf_results)) {
           SERIAL_ECHOPGM("Could not complete LSF!");
           return true;
         }
 
         ubl.set_all_mesh_points_to_value(0);
 
         matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
         GRID_LOOP(i, j) {
           float mx = ubl.mesh_index_to_xpos(i),
                 my = ubl.mesh_index_to_ypos(j),
-                mz = mesh_z_values[i][j];
+                mz = Z_VALUES_ARR[i][j];
 
           if (DEBUGGING(LEVELING)) {
             DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(my, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(mz, 7);
             DEBUG_ECHOPGM("]   ---> ");
             DEBUG_DELAY(20);
           }
@@ -249,71 +251,70 @@ CrealityDWINClass CrealityDWIN;
           if (DEBUGGING(LEVELING)) {
             DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(my, 7);
             DEBUG_CHAR(',');
             DEBUG_ECHO_F(mz, 7);
             DEBUG_ECHOLNPGM("]");
             DEBUG_DELAY(20);
           }
 
-          mesh_z_values[i][j] = mz - lsf_results.D;
+          Z_VALUES_ARR[i][j] = mz - lsf_results.D;
         }
         return false;
       }
 
     #else
-      bed_mesh_t &mesh_z_values = z_values;
 
       void manual_value_update() {
         sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
         gcode.process_subcommands_now_P(cmd);
         planner.synchronize();
       }
 
     #endif
 
     void manual_move(bool zmove=false) {
       if (zmove) {
         planner.synchronize();
-        current_position.z = goto_mesh_value ? mesh_z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        current_position.z = goto_mesh_value ? Z_VALUES_ARR[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
       }
       else {
         CrealityDWIN.Popup_Handler(MoveWait);
         sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
         gcode.process_subcommands_now_P(cmd);
         sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
         gcode.process_subcommands_now_P(cmd);
         planner.synchronize();
-        current_position.z = goto_mesh_value ? mesh_z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        current_position.z = goto_mesh_value ? Z_VALUES_ARR[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
         planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
         planner.synchronize();
         CrealityDWIN.Redraw_Menu();
       }
     }
 
     float get_max_value() {
       float max = __FLT_MIN__;
       GRID_LOOP(x, y) {
-        if (!isnan(mesh_z_values[x][y]) && mesh_z_values[x][y] > max)
-          max = mesh_z_values[x][y];
+        if (!isnan(Z_VALUES_ARR[x][y]) && Z_VALUES_ARR[x][y] > max)
+          max = Z_VALUES_ARR[x][y];
       }
       return max;
     }
 
     float get_min_value() {
       float min = __FLT_MAX__;
       GRID_LOOP(x, y) {
-        if (!isnan(mesh_z_values[x][y]) && mesh_z_values[x][y] < min)
-          min = mesh_z_values[x][y];
+        if (!isnan(Z_VALUES_ARR[x][y]) && Z_VALUES_ARR[x][y] < min)
+          min = Z_VALUES_ARR[x][y];
       }
       return min;
     }
 
     void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x;
       const uint16_t cell_width_px  = total_width_px / GRID_MAX_POINTS_X;
       const uint16_t cell_height_px = total_width_px / GRID_MAX_POINTS_Y;
       const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
@@ -328,47 +329,47 @@ CrealityDWINClass CrealityDWIN;
         DWIN_Draw_Rectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       char buf[8];
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
-        DWIN_Draw_Rectangle(1,                                                                                  // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
-          isnan(mesh_z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
-            (mesh_z_values[x][y] < 0 ?
-              (uint16_t)round(0x1F * -mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
-              (uint16_t)round(0x3F *  mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
-                _MIN(0x1F, (((uint8_t)abs(mesh_z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
+        DWIN_Draw_Rectangle(1,                                                                                 // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
+          isnan(Z_VALUES_ARR[x][y]) ? Color_Grey : (                                                           // gray if undefined
+            (Z_VALUES_ARR[x][y] < 0 ?
+              (uint16_t)round(0x1F * -Z_VALUES_ARR[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
+              (uint16_t)round(0x3F *  Z_VALUES_ARR[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
+                _MIN(0x1F, (((uint8_t)abs(Z_VALUES_ARR[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
           start_x_px, start_y_px, end_x_px, end_y_px
         );
 
         safe_delay(10);
         LCD_SERIAL.flushTX();
 
         // Draw value text on
         if (viewer_print_value) {
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
-          if (isnan(mesh_z_values[x][y])) {  // undefined
-            DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+          if (isnan(Z_VALUES_ARR[x][y])) {  // undefined
+            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             if (GRID_MAX_POINTS_X < 10)
-              sprintf_P(buf, PSTR("%s"), dtostrf(abs(mesh_z_values[x][y]), 1, 2, str_1));
+              sprintf_P(buf, PSTR("%s"), dtostrf(abs(Z_VALUES_ARR[x][y]), 1, 2, str_1));
             else
-              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(mesh_z_values[x][y] - (int16_t)mesh_z_values[x][y]) * 100));
+              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(Z_VALUES_ARR[x][y] - (int16_t)Z_VALUES_ARR[x][y]) * 100));
             offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
             if (!(GRID_MAX_POINTS_X < 10))
-              DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
-            DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
+              DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            DWIN_Draw_String(false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
           }
           safe_delay(10);
           LCD_SERIAL.flushTX();
         }
       }
     }
 
     void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
       float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
       if (v_min > 3e+10F) v_min = 0.0000001;
@@ -408,38 +409,33 @@ void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
   if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
   if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
   if (e == 4) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
 }
 
 void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
   const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
   const uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
   const uint16_t xpos = 240 - (digits * 8);
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
-  if (isnan(value)) {
-    DWIN_Draw_String(false, true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
-  }
-  else if (value < 0) {
-    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), -value * minunit);
-    DWIN_Draw_String(false, true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F("-"));
-  }
+  if (isnan(value))
+    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
   else {
-    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), value * minunit);
-    DWIN_Draw_String(false, true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" "));
+    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), (value < 0 ? -value : value) * minunit);
+    DWIN_Draw_String(true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), value < 0 ? F("-") : F(" "));
   }
 }
 
 void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
   uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
   uint16_t tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
   DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
-  DWIN_Draw_String(false, false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
+  DWIN_Draw_String(false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
 }
 
 uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
   switch (color){
     case Default:
       return original;
       break;
     case White:
       return (light) ? Color_Light_White : Color_White;
       break;
@@ -468,29 +464,29 @@ uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool ligh
       return (light) ? Color_Light_Brown : Color_Brown;
       break;
     case Black:
       return Color_Black;
       break;
   }
   return Color_White;
 }
 
 void CrealityDWINClass::Draw_Title(const char * title) {
-  DWIN_Draw_String(false, false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(title) * STAT_CHR_W) / 2, 5, title);
+  DWIN_Draw_String(false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(title) * STAT_CHR_W) / 2, 5, title);
 }
 
 void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
   const uint8_t label_offset_y = !(label1 && label2) ? 0 : MENU_CHR_H * 3 / 5;
   const uint8_t label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2);
   const uint8_t label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
-  if (label1) DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
-  if (label2) DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
+  if (label1) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
+  if (label2) DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
   if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
   if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
   DWIN_Draw_Line(GetColor(eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
 void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
     DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
   #else                                         // Draw a basic checkbox using rectangles and lines
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
@@ -540,133 +536,132 @@ void CrealityDWINClass::Redraw_Screen() {
   Draw_Status_Area(true);
   Update_Status_Bar(true);
 }
 
 /* Primary Menus and Screen Elements */
 
 void CrealityDWINClass::Main_Menu_Icons() {
   if (selection == 0) {
     DWIN_ICON_Show(ICON, ICON_Print_1, 17, 130);
     DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
   }
   else {
     DWIN_ICON_Show(ICON, ICON_Print_0, 17, 130);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
   }
   if (selection == 1) {
     DWIN_ICON_Show(ICON, ICON_Prepare_1, 145, 130);
     DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
   }
   else {
     DWIN_ICON_Show(ICON, ICON_Prepare_0, 145, 130);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
   }
   if (selection == 2) {
     DWIN_ICON_Show(ICON, ICON_Control_1, 17, 246);
     DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
   }
   else {
     DWIN_ICON_Show(ICON, ICON_Control_0, 17, 246);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
   }
   #if HAS_ABL_OR_UBL
     if (selection == 3) {
       DWIN_ICON_Show(ICON, ICON_Leveling_1, 145, 246);
       DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
     }
     else {
       DWIN_ICON_Show(ICON, ICON_Leveling_0, 145, 246);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
     }
   #else
     if (selection == 3) {
       DWIN_ICON_Show(ICON, ICON_Info_1, 145, 246);
       DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
     else {
       DWIN_ICON_Show(ICON, ICON_Info_0, 145, 246);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
-      //DWIN_Frame_AreaCopy(1, 132, 423, 159, 435, 186, 318);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
     }
   #endif
 }
 
 void CrealityDWINClass::Draw_Main_Menu(uint8_t select/*=0*/) {
   process = Main;
   active_menu = MainMenu;
   selection = select;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(MainMenu));
   SERIAL_ECHOPGM("\nDWIN handshake ");
   DWIN_ICON_Show(ICON, ICON_LOGO, 71, 72);
   Main_Menu_Icons();
 }
 
 void CrealityDWINClass::Print_Screen_Icons() {
   if (selection == 0) {
     DWIN_ICON_Show(ICON, ICON_Setup_1, 8, 252);
     DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
   }
   else {
     DWIN_ICON_Show(ICON, ICON_Setup_0, 8, 252);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
   }
   if (selection == 2) {
     DWIN_ICON_Show(ICON, ICON_Stop_1, 184, 252);
     DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
   }
   else {
     DWIN_ICON_Show(ICON, ICON_Stop_0, 184, 252);
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
   }
   if (paused) {
     if (selection == 1) {
       DWIN_ICON_Show(ICON, ICON_Continue_1, 96, 252);
       DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
     }
     else {
       DWIN_ICON_Show(ICON, ICON_Continue_0, 96, 252);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
     }
   }
   else {
     if (selection == 1) {
       DWIN_ICON_Show(ICON, ICON_Pause_1, 96, 252);
       DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
     }
     else {
       DWIN_ICON_Show(ICON, ICON_Pause_0, 96, 252);
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
     }
   }
 }
 
 void CrealityDWINClass::Draw_Print_Screen() {
   process = Print;
   selection = 0;
   Clear_Screen();
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
   Draw_Title("Printing...");
   Print_Screen_Icons();
   DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
   DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
-  DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, "Elapsed");
-  DWIN_Draw_String(false, false, DWIN_FONT_MENU,  Color_White, Color_Bg_Black, 176, 163, "Remaining");
+  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, F("Elapsed"));
+  DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 176, 163, F("Remaining"));
   Update_Status_Bar(true);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
   Draw_Print_Filename(true);
 }
 
 void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
   static uint8_t namescrl = 0;
   if (reset) namescrl = 0;
@@ -680,66 +675,66 @@ void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
       if (pos >= 0) {
         LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
       }
       else {
         LOOP_L_N(i, 30 + pos) dispname[i] = ' ';
         LOOP_S_L_N(i, 30 + pos, 30) dispname[i] = filename[i - (30 + pos)];
       }
       dispname[len] = '\0';
       DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
       const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, dispname);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, dispname);
       if (-pos >= 30) namescrl = 0;
       namescrl++;
     }
     else {
       DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
       const int8_t npos = (DWIN_WIDTH - strlen(filename) * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, filename);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, filename);
     }
   }
 }
 
 void CrealityDWINClass::Draw_Print_ProgressBar() {
   uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
   DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
   DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
-  DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, "%");
+  DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, F("%"));
 }
 
 #if ENABLED(USE_M73_REMAINING_TIME)
 
   void CrealityDWINClass::Draw_Print_ProgressRemain() {
     uint16_t remainingtime = ui.get_remaining_time();
     DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
     DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
     if (eeprom_settings.time_format_textual) {
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, "h");
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, "m");
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F("h"));
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, F("m"));
     }
     else
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, ":");
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, F(":"));
   }
 
 #endif
 
 void CrealityDWINClass::Draw_Print_ProgressElapsed() {
   duration_t elapsed = print_job_timer.duration();
   DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
   DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
   if (eeprom_settings.time_format_textual) {
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, "h");
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, "m");
+    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F("h"));
+    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, F("m"));
   }
   else
-    DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, ":");
+    DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, F(":"));
 }
 
 void CrealityDWINClass::Draw_Print_confirm() {
   Draw_Print_Screen();
   process = Confirm;
   popup = Complete;
   DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
   DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
   DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
@@ -772,67 +767,67 @@ void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
   selection = 0;
   scrollpos = 0;
   process = File;
   if (card.isMounted() && !removed) {
     LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
       Draw_SD_Item(i, i);
   }
   else {
     Draw_Menu_Item(0, ICON_Back, "Back");
     DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    DWIN_Draw_String(false, false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), "No Media");
+    DWIN_Draw_String(false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), F("No Media"));
   }
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
 }
 
 void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
 
   if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     static float hotend = -1;
     static int16_t hotendtarget = -1, flow = -1;
     if (icons) {
       hotend = -1;
       hotendtarget = -1;
       DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
-      DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     }
     if (thermalManager.temp_hotend[0].celsius != hotend) {
       hotend = thermalManager.temp_hotend[0].celsius;
       DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
       DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
     }
     if (thermalManager.temp_hotend[0].target != hotendtarget) {
       hotendtarget = thermalManager.temp_hotend[0].target;
       DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
       DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
     }
     if (icons) {
       flow = -1;
       DWIN_ICON_Show(ICON, ICON_StepE, 112, 417);
-      DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
     }
     if (planner.flow_percentage[0] != flow) {
       flow = planner.flow_percentage[0];
       DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     }
   #endif
 
   #if HAS_HEATED_BED
     static float bed = -1;
     static int16_t bedtarget = -1;
     if (icons) {
       bed = -1;
       bedtarget = -1;
       DWIN_ICON_Show(ICON, ICON_BedTemp, 10, 416);
-      DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+      DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     }
     if (thermalManager.temp_bed.celsius != bed) {
       bed = thermalManager.temp_bed.celsius;
       DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
       DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
     }
     if (thermalManager.temp_bed.target != bedtarget) {
       bedtarget = thermalManager.temp_bed.target;
       DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
       DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
@@ -853,36 +848,30 @@ void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
 
   #if HAS_ZOFFSET_ITEM
     static float offset = -1;
 
     if (icons) {
       offset = -1;
       DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
     }
     if (zoffsetvalue != offset) {
       offset = zoffsetvalue;
-      if (zoffsetvalue < 0) {
-        DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, -zoffsetvalue * 100);
-        DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, "-");
-      }
-      else {
-        DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, zoffsetvalue* 100);
-        DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, " ");
-      }
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, (zoffsetvalue < 0 ? -zoffsetvalue : zoffsetvalue) * 100);
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, zoffsetvalue < 0 ? F("-") : F(" "));
     }
   #endif
 
   static int16_t feedrate = -1;
   if (icons) {
     feedrate = -1;
     DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
-    DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+    DWIN_Draw_String(false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
   }
   if (feedrate_percentage != feedrate) {
     feedrate = feedrate_percentage;
     DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   }
 
   static float x = -1, y = -1, z = -1;
   static bool update_x = false, update_y = false, update_z = false;
   update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
   update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
@@ -890,64 +879,64 @@ void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
   if (icons) {
     x = y = z = -1;
     DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
     DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
   }
   if (update_x) {
     x = current_position.x;
     if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, "  -?-  ");
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, F("  -?-  "));
     else
       DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x * 10);
   }
   if (update_y) {
     y = current_position.y;
     if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, "  -?-  ");
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, F("  -?-  "));
     else
       DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y * 10);
   }
   if (update_z) {
     z = current_position.z;
     if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
-      DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, "  -?-  ");
+      DWIN_Draw_String(true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, F("  -?-  "));
     else
       DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z * 100 : 0);
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Draw_Popup(PGM_P const line1, PGM_P const line2, PGM_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
   if (process != Confirm && process != Popup && process != Wait) last_process = process;
   if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
   process = mode;
   Clear_Screen();
   DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
   DWIN_Draw_Rectangle(1, Color_Bg_Window, 14, 60, 258, 350);
   const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
   if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
-  DWIN_Draw_String(false, true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line1)) / 2, ypos, line1);
-  DWIN_Draw_String(false, true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line2)) / 2, ypos + 30, line2);
-  DWIN_Draw_String(false, true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line3)) / 2, ypos + 60, line3);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line1)) / 2, ypos, line1);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line2)) / 2, ypos + 30, line2);
+  DWIN_Draw_String(true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line3)) / 2, ypos + 60, line3);
   if (mode == Popup) {
     selection = 0;
     DWIN_Draw_Rectangle(1, Confirm_Color, 26, 280, 125, 317);
     DWIN_Draw_Rectangle(1, Cancel_Color, 146, 280, 245, 317);
-    DWIN_Draw_String(false, false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, "Confirm");
-    DWIN_Draw_String(false, false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, "Cancel");
+    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, F("Confirm"));
+    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, F("Cancel"));
     Popup_Select();
   }
   else if (mode == Confirm) {
     DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
-    DWIN_Draw_String(false, false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, "Continue");
+    DWIN_Draw_String(false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, F("Continue"));
   }
 }
 
 void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
   CrealityDWIN.Draw_Popup(PSTR("Printer Kill Reason:"), error, PSTR("Restart Required"), Wait, ICON_BLTouch);
 }
 
 void CrealityDWINClass::Popup_Select() {
   const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
                  c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
@@ -978,42 +967,42 @@ void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
       LOOP_L_N(i, len) dispmsg[i] = statusmsg[i + msgscrl];
     }
     else {
       LOOP_L_N(i, 30 + pos) dispmsg[i] = ' ';
       LOOP_S_L_N(i, 30 + pos, 30) dispmsg[i] = statusmsg[i - (30 + pos)];
     }
     dispmsg[len] = '\0';
     if (process == Print) {
       DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
       const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
     }
     else {
       DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
       const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
-      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
+      DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
     }
     if (-pos >= 30) msgscrl = 0;
     msgscrl++;
   }
   else {
     if (new_msg) {
       new_msg = false;
       if (process == Print) {
         DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
         const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, statusmsg);
+        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, statusmsg);
       }
       else {
         DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
         const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
-        DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
+        DWIN_Draw_String(false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
       }
     }
   }
 }
 
 /* Menu Item Config */
 
 void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
   uint8_t row = item - scrollpos;
   #if HAS_LEVELING
@@ -1273,21 +1262,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 sync_plan_position();
                 Modify_Value(current_position.e, -500, 500, 10);
               }
             }
           break;
         #endif // HAS_HOTEND
 
         #if HAS_BED_PROBE
           case MOVE_P:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguraton, "Probe");
+              Draw_Menu_Item(row, ICON_StockConfiguration, "Probe");
               Draw_Checkbox(row, probe_deployed);
             }
             else {
               probe_deployed = !probe_deployed;
               probe.set_deployed(probe_deployed);
               Draw_Checkbox(row, probe_deployed);
             }
             break;
         #endif
 
@@ -2859,50 +2848,52 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
           }
           else
             Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
           break;
       } // switch (item)
       break;
 
     case Advanced:
 
       #define ADVANCED_BACK 0
-      #define ADVANCED_BEEPER (ADVANCED_BACK + 1)
+      #define ADVANCED_BEEPER (ADVANCED_BACK + ENABLED(SOUND_MENU_ITEM))
       #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
       #define ADVANCED_CORNER (ADVANCED_PROBE + 1)
       #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
       #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
       #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
       #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
       #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
       #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
       #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
 
       switch (item) {
         case ADVANCED_BACK:
           if (draw)
             Draw_Menu_Item(row, ICON_Back, "Back");
           else
             Draw_Menu(Control, CONTROL_ADVANCED);
           break;
 
-        case ADVANCED_BEEPER:
-          if (draw) {
-            Draw_Menu_Item(row, ICON_Version, "LCD Beeper");
-            Draw_Checkbox(row, eeprom_settings.beeperenable);
-          }
-          else {
-            eeprom_settings.beeperenable = !eeprom_settings.beeperenable;
-            Draw_Checkbox(row, eeprom_settings.beeperenable);
-          }
-          break;
+        #if ENABLED(SOUND_MENU_ITEM)
+          case ADVANCED_BEEPER:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "LCD Beeper");
+              Draw_Checkbox(row, ui.buzzer_enabled);
+            }
+            else {
+              ui.buzzer_enabled = !ui.buzzer_enabled;
+              Draw_Checkbox(row, ui.buzzer_enabled);
+            }
+            break;
+        #endif
 
         #if HAS_BED_PROBE
           case ADVANCED_PROBE:
             if (draw)
               Draw_Menu_Item(row, ICON_StepX, "Probe", nullptr, true);
             else
               Draw_Menu(ProbeMenu);
             break;
         #endif
 
@@ -3115,21 +3106,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
 
         switch (item) {
           case LEVELING_BACK:
             if (draw)
               Draw_Menu_Item(row, ICON_Back, "Back");
             else
               Draw_Main_Menu(3);
             break;
           case LEVELING_ACTIVE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguraton, "Leveling Active");
+              Draw_Menu_Item(row, ICON_StockConfiguration, "Leveling Active");
               Draw_Checkbox(row, planner.leveling_active);
             }
             else {
               if (!planner.leveling_active) {
                 set_bed_leveling_enabled(!planner.leveling_active);
                 if (!planner.leveling_active) {
                   Confirm_Handler(LevelError);
                   break;
                 }
               }
@@ -3400,21 +3391,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                 if (mesh_conf.create_plane_from_mesh()) break;
                 gcode.process_subcommands_now_P(PSTR("M420 S1"));
                 planner.synchronize();
                 AudioFeedback(true);
               }
               break;
             case LEVELING_SETTINGS_ZERO:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, "Zero Current Mesh");
               else
-                ZERO(mesh_conf.mesh_z_values);
+                ZERO(Z_VALUES_ARR);
               break;
             case LEVELING_SETTINGS_UNDEF:
               if (draw)
                 Draw_Menu_Item(row, ICON_Mesh, "Clear Current Mesh");
               else
                 ubl.invalidate();
               break;
           #endif // AUTO_BED_LEVELING_UBL
         }
         break;
@@ -3486,55 +3477,55 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   mesh_conf.mesh_x++;
                 else
                   mesh_conf.mesh_x--;
                 mesh_conf.manual_move();
               }
             }
             break;
           case LEVELING_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, "Point Z Offset");
-              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
-              if (isnan(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
-                mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case LEVELING_M_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
-            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
-              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case LEVELING_M_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
-            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
-              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
           case LEVELING_M_GOTO_VALUE:
             if (draw) {
-              Draw_Menu_Item(row, ICON_StockConfiguraton, "Go to Mesh Z Value");
+              Draw_Menu_Item(row, ICON_StockConfiguration, "Go to Mesh Z Value");
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             else {
               mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
               current_position.z = 0;
               mesh_conf.manual_move(true);
               Draw_Checkbox(row, mesh_conf.goto_mesh_value);
             }
             break;
           #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -3607,50 +3598,50 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
                   mesh_conf.mesh_x--;
                 else
                   mesh_conf.mesh_x++;
                 mesh_conf.manual_move();
               }
             }
             break;
           case UBL_M_OFFSET:
             if (draw) {
               Draw_Menu_Item(row, ICON_SetZOffset, "Point Z Offset");
-              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
             }
             else {
-              if (isnan(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
-                mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
-              Modify_Value(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+              if (isnan(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
             }
             break;
           case UBL_M_UP:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
-            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
-              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
               gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
               planner.synchronize();
               current_position.z += 0.01f;
               sync_plan_position();
-              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
             }
             break;
           case UBL_M_DOWN:
             if (draw)
               Draw_Menu_Item(row, ICON_Axis, "Microstep Down");
-            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
-              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+            else if (Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
               gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
               planner.synchronize();
               current_position.z -= 0.01f;
               sync_plan_position();
-              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+              Draw_Float(Z_VALUES_ARR[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
             }
             break;
         }
         break;
     #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
 
     #if ENABLED(PROBE_MANUALLY)
       case ManualMesh:
 
         #define MMESH_BACK 0
@@ -3726,21 +3717,21 @@ void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/
             break;
           case MMESH_OLD:
             uint8_t mesh_x, mesh_y;
             // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
             mesh_y = (gridpoint - 1) / GRID_MAX_POINTS_Y;
             mesh_x = (gridpoint - 1) % GRID_MAX_POINTS_X;
 
             if (mesh_y % 2 == 1)
               mesh_x = GRID_MAX_POINTS_X - mesh_x - 1;
 
-            const float currval = mesh_conf.mesh_z_values[mesh_x][mesh_y];
+            const float currval = Z_VALUES_ARR[mesh_x][mesh_y];
 
             if (draw) {
               Draw_Menu_Item(row, ICON_Zoffset, "Goto Mesh Value");
               Draw_Float(currval, row, false, 100);
             }
             else if (!isnan(currval)) {
               current_position.z = currval;
               planner.synchronize();
               planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
               planner.synchronize();
@@ -4208,42 +4199,42 @@ void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
     case UserInput:   Draw_Popup(PSTR("Waiting for Input"), PSTR("Press to Continue"), PSTR(""), Confirm); break;
     case LevelError:  Draw_Popup(PSTR("Couldn't enable Leveling"), PSTR("(Valid mesh must exist)"), PSTR(""), Confirm); break;
     case InvalidMesh: Draw_Popup(PSTR("Valid mesh must exist"), PSTR("before tuning can be"), PSTR("performed"), Confirm); break;
     default: break;
   }
 }
 
 /* Navigation and Control */
 
 void CrealityDWINClass::Main_Menu_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {
     selection++; // Select Down
     Main_Menu_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     Main_Menu_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     switch (selection) {
       case PAGE_PRINT: card.mount(); Draw_SD_List(); break;
       case PAGE_PREPARE: Draw_Menu(Prepare); break;
       case PAGE_CONTROL: Draw_Menu(Control); break;
       case PAGE_INFO_LEVELING: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
     }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Menu_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection++; // Select Down
     if (selection > scrollpos+MROWS) {
       scrollpos++;
       DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
       Menu_Item_Handler(active_menu, selection);
     }
     DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
@@ -4257,21 +4248,21 @@ void CrealityDWINClass::Menu_Control() {
       Menu_Item_Handler(active_menu, selection);
     }
     DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     Menu_Item_Handler(active_menu, selection, false);
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Value_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += EncoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= EncoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
     EncoderRate.enabled = false;
     Draw_Float(tempvalue / valueunit, selection - scrollpos, false, valueunit);
     DWIN_UpdateLCD();
@@ -4322,21 +4313,21 @@ void CrealityDWINClass::Value_Control() {
   NOMORE(tempvalue, (valuemax * valueunit));
   Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
   DWIN_UpdateLCD();
   if (active_menu == Move && livemove) {
     *(float*)valuepointer = tempvalue / valueunit;
     planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
   }
 }
 
 void CrealityDWINClass::Option_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW)
     tempvalue += EncoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_CCW)
     tempvalue -= EncoderRate.encoderMoveValue;
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     process = Menu;
     EncoderRate.enabled = false;
     if (valuepointer == &color_names) {
       switch (selection) {
@@ -4361,21 +4352,21 @@ void CrealityDWINClass::Option_Control() {
     DWIN_UpdateLCD();
     return;
   }
   NOLESS(tempvalue, valuemin);
   NOMORE(tempvalue, valuemax);
   Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::File_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   static uint8_t filescrl = 0;
   if (encoder_diffState == ENCODER_DIFF_NO) {
     if (selection > 0) {
       card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
       char * const filename = card.longest_filename();
       size_t len = strlen(filename);
       int8_t pos = len;
       if (!card.flag.filenameIsDir)
         while (pos && filename[pos] != '.') pos--;
       if (pos > MENU_CHAR_LIMIT) {
@@ -4449,21 +4440,21 @@ void CrealityDWINClass::File_Control() {
       }
       else {
         card.openAndPrintFile(card.filename);
       }
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Print_Screen_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
     selection++; // Select Down
     Print_Screen_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     Print_Screen_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
@@ -4502,21 +4493,21 @@ void CrealityDWINClass::Print_Screen_Control() {
         else
           Popup_Handler(Pause);
         break;
       case PRINT_STOP: Popup_Handler(Stop); break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Popup_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
     selection++;
     Popup_Select();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--;
     Popup_Select();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
@@ -4652,21 +4643,21 @@ void CrealityDWINClass::Popup_Control() {
           Redraw_Menu(true, true);
           break;
       #endif
       default: break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Confirm_Control() {
-  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (popup) {
       case Complete:
         Draw_Main_Menu();
         break;
       case FilInsert:
         Popup_Handler(FilChange);
         wait_for_user = false;
         break;
@@ -4960,28 +4951,28 @@ void CrealityDWINClass::Screen_Update() {
             }
           }
         #endif
         break;
     }
   }
 }
 
 void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
   if (success) {
-    if (eeprom_settings.beeperenable) {
+    if (ui.buzzer_enabled) {
       BUZZ(100, 659);
       BUZZ( 10,   0);
       BUZZ(100, 698);
     }
     else Update_Status("Success");
   }
-  else if (eeprom_settings.beeperenable)
+  else if (ui.buzzer_enabled)
     BUZZ(40, 440);
   else
     Update_Status("Failed");
 }
 
 void CrealityDWINClass::Save_Settings(char *buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
   memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
@@ -4996,36 +4987,36 @@ void CrealityDWINClass::Load_Settings(const char *buff) {
     static bool init = true;
     if (init) {
       init = false;
       queue.inject_P(PSTR("M1000 S"));
     }
   #endif
 }
 
 void CrealityDWINClass::Reset_Settings() {
   eeprom_settings.time_format_textual = false;
-  eeprom_settings.beeperenable = true;
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
   eeprom_settings.corner_pos = 325;
   eeprom_settings.cursor_color = 0;
   eeprom_settings.menu_split_line = 0;
   eeprom_settings.menu_top_bg = 0;
   eeprom_settings.menu_top_txt = 0;
   eeprom_settings.highlight_box = 0;
   eeprom_settings.progress_percent = 0;
   eeprom_settings.progress_time = 0;
   eeprom_settings.status_bar_text = 0;
   eeprom_settings.status_area_text = 0;
   eeprom_settings.coordinates_text = 0;
   eeprom_settings.coordinates_split_line = 0;
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   corner_pos = eeprom_settings.corner_pos / 10.0f;
+  TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
   Redraw_Screen();
 }
 
 void MarlinUI::init() {
   delay(800);
   SERIAL_ECHOPGM("\nDWIN handshake ");
   if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
   DWIN_Frame_SetDir(1); // Orientation 90°
   DWIN_UpdateLCD();     // Show bootscreen (first image)
   Encoder_Configuration();

commit 8235ae9cc00b10362ca9f6e79acb4516c08557af
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Sep 15 01:44:28 2021 -0500

    🩹 Fix DWIN Enhanced Tune menu during homing (#22773)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index c02aa48b1a..9b63d5331e 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -134,29 +134,38 @@ constexpr uint16_t TROWS = 6, MROWS = TROWS - 1,
 
 #define MBASE(L) (49 + MLINE * (L))
 
 constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
 constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
 constexpr float default_steps[]               = DEFAULT_AXIS_STEPS_PER_UNIT;
 #if HAS_CLASSIC_JERK
   constexpr float default_max_jerk[]            = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
 #endif
 
-uint8_t active_menu = MainMenu;
-uint8_t last_menu = MainMenu;
-uint8_t selection = 0;
-uint8_t last_selection = 0;
+enum SelectItem : uint8_t {
+  PAGE_PRINT = 0,
+  PAGE_PREPARE,
+  PAGE_CONTROL,
+  PAGE_INFO_LEVELING,
+  PAGE_COUNT,
+
+  PRINT_SETUP = 0,
+  PRINT_PAUSE_RESUME,
+  PRINT_STOP,
+  PRINT_COUNT
+};
+
+uint8_t active_menu = MainMenu, last_menu = MainMenu;
+uint8_t selection = 0, last_selection = 0;
 uint8_t scrollpos = 0;
-uint8_t process = Main;
-uint8_t last_process = Main;
-PopupID popup;
-PopupID last_popup;
+uint8_t process = Main, last_process = Main;
+PopupID popup, last_popup;
 
 void (*funcpointer)() = nullptr;
 void *valuepointer = nullptr;
 float tempvalue;
 float valuemin;
 float valuemax;
 uint8_t valueunit;
 uint8_t valuetype;
 
 char cmd[MAX_CMD_SIZE+16], str_1[16], str_2[16], str_3[16];
@@ -4201,34 +4210,34 @@ void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
     case InvalidMesh: Draw_Popup(PSTR("Valid mesh must exist"), PSTR("before tuning can be"), PSTR("performed"), Confirm); break;
     default: break;
   }
 }
 
 /* Navigation and Control */
 
 void CrealityDWINClass::Main_Menu_Control() {
   ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < 3) {
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < PAGE_COUNT - 1) {
     selection++; // Select Down
     Main_Menu_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     Main_Menu_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER)
     switch (selection) {
-      case 0: card.mount(); Draw_SD_List(); break;
-      case 1: Draw_Menu(Prepare); break;
-      case 2: Draw_Menu(Control); break;
-      case 3: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
+      case PAGE_PRINT: card.mount(); Draw_SD_List(); break;
+      case PAGE_PREPARE: Draw_Menu(Prepare); break;
+      case PAGE_CONTROL: Draw_Menu(Control); break;
+      case PAGE_INFO_LEVELING: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
     }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Menu_Control() {
   ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
     DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
     selection++; // Select Down
@@ -4442,35 +4451,35 @@ void CrealityDWINClass::File_Control() {
         card.openAndPrintFile(card.filename);
       }
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Print_Screen_Control() {
   ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_CW && selection < 2) {
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < PRINT_COUNT - 1) {
     selection++; // Select Down
     Print_Screen_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
     selection--; // Select Up
     Print_Screen_Icons();
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (selection) {
-      case 0:
+      case PRINT_SETUP:
         Draw_Menu(Tune);
         Update_Status_Bar(true);
         break;
-      case 1:
+      case PRINT_PAUSE_RESUME:
         if (paused) {
           if (sdprint) {
             wait_for_user = false;
             #if ENABLED(PARK_HEAD_ON_PAUSE)
               card.startOrResumeFilePrinting();
               TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             #else
               char cmnd[20];
               #if HAS_HEATED_BED
                 cmnd[sprintf_P(cmnd, PSTR("M140 S%i"), pausebed)] = '\0';
@@ -4486,23 +4495,21 @@ void CrealityDWINClass::Print_Screen_Control() {
             #endif
           }
           else {
             TERN_(HOST_ACTION_COMMANDS, host_action_resume());
           }
           Draw_Print_Screen();
         }
         else
           Popup_Handler(Pause);
         break;
-      case 2:
-        Popup_Handler(Stop);
-        break;
+      case PRINT_STOP: Popup_Handler(Stop); break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 void CrealityDWINClass::Popup_Control() {
   ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
     selection++;

commit 3a457c9d13701428a4a276aaf43eb7961e9503a1
Author: tome9111991 <57866234+tome9111991@users.noreply.github.com>
Date:   Sun Sep 12 21:56:40 2021 +0200

    🐛 Fix JyersUI for LPC176x (#22745)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 6f76fe3d32..c02aa48b1a 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -300,74 +300,75 @@ CrealityDWINClass CrealityDWIN;
           min = mesh_z_values[x][y];
       }
       return min;
     }
 
     void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
       drawing_mesh = true;
       const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x;
       const uint16_t cell_width_px  = total_width_px / GRID_MAX_POINTS_X;
       const uint16_t cell_height_px = total_width_px / GRID_MAX_POINTS_Y;
-      const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = max(v_min, v_max);
+      const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
 
       // Clear background from previous selection and select new square
-      DWIN_Draw_Rectangle(1, Color_Bg_Black, max(0, padding_x - gridline_width), max(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, _MAX(0, padding_x - gridline_width), _MAX(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
       if (selected >= 0) {
         const auto selected_y = selected / GRID_MAX_POINTS_X;
         const auto selected_x = selected - (GRID_MAX_POINTS_X * selected_y);
         const auto start_y_px = padding_y_top + selected_y * cell_height_px;
         const auto start_x_px = padding_x + selected_x * cell_width_px;
-        DWIN_Draw_Rectangle(1, Color_White, max(0, start_x_px - gridline_width), max(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
+        DWIN_Draw_Rectangle(1, Color_White, _MAX(0, start_x_px - gridline_width), _MAX(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
       }
 
       // Draw value square grid
       char buf[8];
       GRID_LOOP(x, y) {
         const auto start_x_px = padding_x + x * cell_width_px;
         const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
         const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
         const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
-        DWIN_Draw_Rectangle(1,        // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
-          isnan(mesh_z_values[x][y]) ? Color_Grey : (                                                              // gray if undefined
+        DWIN_Draw_Rectangle(1,                                                                                  // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
+          isnan(mesh_z_values[x][y]) ? Color_Grey : (                                                           // gray if undefined
             (mesh_z_values[x][y] < 0 ?
-              (uint16_t)round(0b11111  * -mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
-              (uint16_t)round(0b111111 *  mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
-                min(0b11111, (((uint8_t)abs(mesh_z_values[x][y]) / 10) * 4))),                                     // + blue stepping for every mm
-          start_x_px, start_y_px, end_x_px, end_y_px);
-        while (LCD_SERIAL.availableForWrite() < 32) { // wait for serial to be available without blocking and resetting the MCU
-          gcode.process_subcommands_now_P("G4 P10");
-          planner.synchronize();
-        }
+              (uint16_t)round(0x1F * -mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
+              (uint16_t)round(0x3F *  mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
+                _MIN(0x1F, (((uint8_t)abs(mesh_z_values[x][y]) / 10) * 4))),                                    // + blue stepping for every mm
+          start_x_px, start_y_px, end_x_px, end_y_px
+        );
+
+        safe_delay(10);
+        LCD_SERIAL.flushTX();
+
         // Draw value text on
         if (viewer_print_value) {
-          gcode.process_subcommands_now_P("G4 P10");  // still fails without additional delay...
-          planner.synchronize();
           int8_t offset_x, offset_y = cell_height_px / 2 - 6;
           if (isnan(mesh_z_values[x][y])) {  // undefined
             DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
           }
           else {                          // has value
             if (GRID_MAX_POINTS_X < 10)
               sprintf_P(buf, PSTR("%s"), dtostrf(abs(mesh_z_values[x][y]), 1, 2, str_1));
             else
               sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(mesh_z_values[x][y] - (int16_t)mesh_z_values[x][y]) * 100));
             offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
             if (!(GRID_MAX_POINTS_X < 10))
               DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
             DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
           }
+          safe_delay(10);
+          LCD_SERIAL.flushTX();
         }
       }
     }
 
     void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
-      float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = max(v_min, v_max);
+      float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = _MAX(v_min, v_max);
       if (v_min > 3e+10F) v_min = 0.0000001;
       if (v_max > 3e+10F) v_max = 0.0000001;
       if (range > 3e+10F) range = 0.0000001;
       char msg[46];
       if (viewer_asymmetric_range) {
         dtostrf(-v_min, 1, 3, str_1);
         dtostrf( v_max, 1, 3, str_2);
       }
       else {
         dtostrf(-range, 1, 3, str_1);
@@ -463,22 +464,22 @@ uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool ligh
   }
   return Color_White;
 }
 
 void CrealityDWINClass::Draw_Title(const char * title) {
   DWIN_Draw_String(false, false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(title) * STAT_CHR_W) / 2, 5, title);
 }
 
 void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
   const uint8_t label_offset_y = !(label1 && label2) ? 0 : MENU_CHR_H * 3 / 5;
-  const uint8_t label1_offset_x = !centered ? LBLX : LBLX * 4/5 + max(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2);
-  const uint8_t label2_offset_x = !centered ? LBLX : LBLX * 4/5 + max(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
+  const uint8_t label1_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2);
+  const uint8_t label2_offset_x = !centered ? LBLX : LBLX * 4/5 + _MAX(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
   if (label1) DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
   if (label2) DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
   if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
   if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
   DWIN_Draw_Line(GetColor(eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
 }
 
 void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
   #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
     DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
@@ -494,21 +495,21 @@ void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
       DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
     }
   #endif
 }
 
 void CrealityDWINClass::Draw_Menu(uint8_t menu, uint8_t select/*=0*/, uint8_t scroll/*=0*/) {
   if (active_menu != menu) {
     last_menu = active_menu;
     if (process == Menu) last_selection = selection;
   }
-  selection = min(select, Get_Menu_Size(menu));
+  selection = _MIN(select, Get_Menu_Size(menu));
   scrollpos = scroll;
   if (selection - scrollpos > MROWS)
     scrollpos = selection - MROWS;
   process = Menu;
   active_menu = menu;
   Clear_Screen();
   Draw_Title(Get_Menu_Title(menu));
   LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
   DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
 }
@@ -4968,25 +4969,25 @@ void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
   }
   else if (eeprom_settings.beeperenable)
     BUZZ(40, 440);
   else
     Update_Status("Failed");
 }
 
 void CrealityDWINClass::Save_Settings(char *buff) {
   TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
   eeprom_settings.corner_pos = corner_pos * 10;
-  memcpy(buff, &eeprom_settings, min(sizeof(eeprom_settings), eeprom_data_size));
+  memcpy(buff, &eeprom_settings, _MIN(sizeof(eeprom_settings), eeprom_data_size));
 }
 
 void CrealityDWINClass::Load_Settings(const char *buff) {
-  memcpy(&eeprom_settings, buff, min(sizeof(eeprom_settings), eeprom_data_size));
+  memcpy(&eeprom_settings, buff, _MIN(sizeof(eeprom_settings), eeprom_data_size));
   TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
   if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
   corner_pos = eeprom_settings.corner_pos / 10.0f;
   Redraw_Screen();
   #if ENABLED(POWER_LOSS_RECOVERY)
     static bool init = true;
     if (init) {
       init = false;
       queue.inject_P(PSTR("M1000 S"));
     }

commit 453e60958a8cde6d7541b4dc3a99d054b53eb695
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 01:32:39 2021 -0500

    🐛 Followup to JyersUI
    
    Fix #22735, #22736

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index 2a2df68b1d..6f76fe3d32 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -4750,25 +4750,27 @@ void CrealityDWINClass::Update_Status(const char * const text) {
     statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
   }
 }
 
 void CrealityDWINClass::Start_Print(bool sd) {
   sdprint = sd;
   if (!printing) {
     printing = true;
     statusmsg[0] = '\0';
     if (sd) {
-      if (recovery.valid()) {
-        SdFile *diveDir = nullptr;
-        const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
-        card.selectFileByName(fname);
-      }
+      #if ENABLED(POWER_LOSS_RECOVERY)
+        if (recovery.valid()) {
+          SdFile *diveDir = nullptr;
+          const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
+          card.selectFileByName(fname);
+        }
+      #endif
       strcpy_P(filename, card.longest_filename());
     }
     else
       strcpy_P(filename, "Host Print");
     TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
     TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
     Draw_Print_Screen();
   }
 }
 
@@ -4794,21 +4796,21 @@ void CrealityDWINClass::Update() {
     case Print:   Print_Screen_Control(); break;
     case Popup:   Popup_Control();        break;
     case Confirm: Confirm_Control();      break;
   }
 }
 
 void MarlinUI::update() { CrealityDWIN.Update(); }
 
 void CrealityDWINClass::State_Update() {
   if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
-    if (!printing) Start_Print((card.isFileOpen() || recovery.valid()));
+    if (!printing) Start_Print(card.isFileOpen() || TERN0(POWER_LOSS_RECOVERY, recovery.valid()));
     else Stop_Print();
   }
   if (print_job_timer.isPaused() != paused) {
     paused = print_job_timer.isPaused();
     if (process == Print) Print_Screen_Icons();
     if (process == Wait && !paused) Redraw_Menu(true, true);
   }
   if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
     Confirm_Handler(UserInput);
   #if ENABLED(ADVANCED_PAUSE_FEATURE)

commit 67d82ff228789408f7f32e6c9af3108c989c0c90
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 10 18:49:57 2021 -0500

    🐛 Followup to JyersUI

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
index e41e51bee4..2a2df68b1d 100644
--- a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -26,20 +26,21 @@
 
 #include "../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
 
 #include "dwin.h"
 
 #include "../../marlinui.h"
 #include "../../../MarlinCore.h"
 
+#include "../../../gcode/gcode.h"
 #include "../../../module/temperature.h"
 #include "../../../module/planner.h"
 #include "../../../module/settings.h"
 #include "../../../libs/buzzer.h"
 #include "../../../inc/Conditionals_post.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../../../feature/pause.h"
 #endif
 
@@ -173,20 +174,21 @@ uint8_t preheatmode = 0;
 float zoffsetvalue = 0;
 uint8_t gridpoint;
 float corner_avg;
 float corner_pos;
 
 bool probe_deployed = false;
 
 CrealityDWINClass CrealityDWIN;
 
 #if HAS_MESH
+
   struct Mesh_Settings {
     bool viewer_asymmetric_range = false;
     bool viewer_print_value = false;
     bool goto_mesh_value = false;
     bool drawing_mesh = false;
     uint8_t mesh_x = 0;
     uint8_t mesh_y = 0;
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       bed_mesh_t &mesh_z_values = ubl.z_values;
@@ -355,37 +357,38 @@ CrealityDWINClass CrealityDWIN;
           }
         }
       }
     }
 
     void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
       float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = max(v_min, v_max);
       if (v_min > 3e+10F) v_min = 0.0000001;
       if (v_max > 3e+10F) v_max = 0.0000001;
       if (range > 3e+10F) range = 0.0000001;
-      char msg[32];
+      char msg[46];
       if (viewer_asymmetric_range) {
         dtostrf(-v_min, 1, 3, str_1);
         dtostrf( v_max, 1, 3, str_2);
       }
       else {
         dtostrf(-range, 1, 3, str_1);
         dtostrf( range, 1, 3, str_2);
       }
       sprintf_P(msg, PSTR("Red %s..0..%s Green"), str_1, str_2);
       CrealityDWIN.Update_Status(msg);
       drawing_mesh = false;
     }
 
   };
   Mesh_Settings mesh_conf;
-#endif
+
+#endif // HAS_MESH
 
 /* General Display Functions */
 
 struct CrealityDWINClass::EEPROM_Settings CrealityDWINClass::eeprom_settings{0};
 constexpr const char * const CrealityDWINClass::color_names[11];
 constexpr const char * const CrealityDWINClass::preheat_modes[3];
 
 // Clear a part of the screen
 //  4=Entire screen
 //  3=Title bar and Menu area (default)

commit 43a9c71ef7a1c9e9e294707017d372d344c774ce
Author: Jyers <76993396+Jyers@users.noreply.github.com>
Date:   Mon Sep 6 21:06:27 2021 -0700

    ✨ Ender-3 V2 with Jyers UI (#22422)

diff --git a/Marlin/src/lcd/e3v2/jyersui/dwin.cpp b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
new file mode 100644
index 0000000000..e41e51bee4
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/jyersui/dwin.cpp
@@ -0,0 +1,5041 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * lcd/e3v2/jyersui/dwin.cpp
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+
+#include "dwin.h"
+
+#include "../../marlinui.h"
+#include "../../../MarlinCore.h"
+
+#include "../../../module/temperature.h"
+#include "../../../module/planner.h"
+#include "../../../module/settings.h"
+#include "../../../libs/buzzer.h"
+#include "../../../inc/Conditionals_post.h"
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../../../feature/pause.h"
+#endif
+
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #include "../../../feature/runout.h"
+#endif
+
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "../../../feature/host_actions.h"
+#endif
+
+#if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
+  #define HAS_ZOFFSET_ITEM 1
+#endif
+
+#ifndef strcasecmp_P
+  #define strcasecmp_P(a, b) strcasecmp((a), (b))
+#endif
+
+#if HAS_LEVELING
+  #include "../../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../../libs/least_squares_fit.h"
+  #include "../../../libs/vector_3.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../../module/probe.h"
+#endif
+
+#if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_FAN) && PREHEAT_COUNT
+  #define HAS_PREHEAT 1
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../../feature/powerloss.h"
+#endif
+
+#define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
+
+#ifndef CORP_WEBSITE
+   #define CORP_WEBSITE WEBSITE_URL
+ #endif
+
+#define DWIN_FONT_MENU font8x16
+#define DWIN_FONT_STAT font10x20
+#define DWIN_FONT_HEAD font10x20
+
+#define MENU_CHAR_LIMIT  24
+#define STATUS_Y 352
+
+#define MAX_PRINT_SPEED   500
+#define MIN_PRINT_SPEED   10
+
+#if HAS_FAN
+  #define MAX_FAN_SPEED     255
+  #define MIN_FAN_SPEED     0
+#endif
+
+#define MAX_XY_OFFSET 100
+
+#if HAS_ZOFFSET_ITEM
+  #define MAX_Z_OFFSET 9.99
+  #if HAS_BED_PROBE
+    #define MIN_Z_OFFSET -9.99
+  #else
+    #define MIN_Z_OFFSET -1
+  #endif
+#endif
+
+#if HAS_HOTEND
+  #define MAX_FLOW_RATE   200
+  #define MIN_FLOW_RATE   10
+
+  #define MAX_E_TEMP    (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+  #define MIN_E_TEMP    0
+#endif
+
+#if HAS_HEATED_BED
+  #define MAX_BED_TEMP  BED_MAXTEMP
+  #define MIN_BED_TEMP  0
+#endif
+
+constexpr uint16_t TROWS = 6, MROWS = TROWS - 1,
+                   TITLE_HEIGHT = 30,
+                   MLINE = 53,
+                   LBLX = 60,
+                   MENU_CHR_W = 8, MENU_CHR_H = 16, STAT_CHR_W = 10;
+
+#define MBASE(L) (49 + MLINE * (L))
+
+constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
+constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
+constexpr float default_steps[]               = DEFAULT_AXIS_STEPS_PER_UNIT;
+#if HAS_CLASSIC_JERK
+  constexpr float default_max_jerk[]            = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+#endif
+
+uint8_t active_menu = MainMenu;
+uint8_t last_menu = MainMenu;
+uint8_t selection = 0;
+uint8_t last_selection = 0;
+uint8_t scrollpos = 0;
+uint8_t process = Main;
+uint8_t last_process = Main;
+PopupID popup;
+PopupID last_popup;
+
+void (*funcpointer)() = nullptr;
+void *valuepointer = nullptr;
+float tempvalue;
+float valuemin;
+float valuemax;
+uint8_t valueunit;
+uint8_t valuetype;
+
+char cmd[MAX_CMD_SIZE+16], str_1[16], str_2[16], str_3[16];
+char statusmsg[64];
+char filename[LONG_FILENAME_LENGTH];
+bool printing = false;
+bool paused = false;
+bool sdprint = false;
+
+int16_t pausetemp, pausebed, pausefan;
+
+bool livemove = false;
+bool liveadjust = false;
+uint8_t preheatmode = 0;
+float zoffsetvalue = 0;
+uint8_t gridpoint;
+float corner_avg;
+float corner_pos;
+
+bool probe_deployed = false;
+
+CrealityDWINClass CrealityDWIN;
+
+#if HAS_MESH
+  struct Mesh_Settings {
+    bool viewer_asymmetric_range = false;
+    bool viewer_print_value = false;
+    bool goto_mesh_value = false;
+    bool drawing_mesh = false;
+    uint8_t mesh_x = 0;
+    uint8_t mesh_y = 0;
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      bed_mesh_t &mesh_z_values = ubl.z_values;
+      uint8_t tilt_grid = 1;
+
+      void manual_value_update(bool undefined=false) {
+        sprintf_P(cmd, PSTR("M421 I%i J%i Z%s %s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1), undefined ? "N" : "");
+        gcode.process_subcommands_now_P(cmd);
+        planner.synchronize();
+      }
+
+      bool create_plane_from_mesh() {
+        struct linear_fit_data lsf_results;
+        incremental_LSF_reset(&lsf_results);
+        GRID_LOOP(x, y) {
+          if (!isnan(mesh_z_values[x][y])) {
+            xy_pos_t rpos;
+            rpos.x = ubl.mesh_index_to_xpos(x);
+            rpos.y = ubl.mesh_index_to_ypos(y);
+            incremental_LSF(&lsf_results, rpos, mesh_z_values[x][y]);
+          }
+        }
+
+        if (finish_incremental_LSF(&lsf_results)) {
+          SERIAL_ECHOPGM("Could not complete LSF!");
+          return true;
+        }
+
+        ubl.set_all_mesh_points_to_value(0);
+
+        matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
+        GRID_LOOP(i, j) {
+          float mx = ubl.mesh_index_to_xpos(i),
+                my = ubl.mesh_index_to_ypos(j),
+                mz = mesh_z_values[i][j];
+
+          if (DEBUGGING(LEVELING)) {
+            DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(my, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(mz, 7);
+            DEBUG_ECHOPGM("]   ---> ");
+            DEBUG_DELAY(20);
+          }
+
+          rotation.apply_rotation_xyz(mx, my, mz);
+
+          if (DEBUGGING(LEVELING)) {
+            DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(my, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(mz, 7);
+            DEBUG_ECHOLNPGM("]");
+            DEBUG_DELAY(20);
+          }
+
+          mesh_z_values[i][j] = mz - lsf_results.D;
+        }
+        return false;
+      }
+
+    #else
+      bed_mesh_t &mesh_z_values = z_values;
+
+      void manual_value_update() {
+        sprintf_P(cmd, PSTR("G29 I%i J%i Z%s"), mesh_x, mesh_y, dtostrf(current_position.z, 1, 3, str_1));
+        gcode.process_subcommands_now_P(cmd);
+        planner.synchronize();
+      }
+
+    #endif
+
+    void manual_move(bool zmove=false) {
+      if (zmove) {
+        planner.synchronize();
+        current_position.z = goto_mesh_value ? mesh_z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+        planner.synchronize();
+      }
+      else {
+        CrealityDWIN.Popup_Handler(MoveWait);
+        sprintf_P(cmd, PSTR("G0 F300 Z%s"), dtostrf(Z_CLEARANCE_BETWEEN_PROBES, 1, 3, str_1));
+        gcode.process_subcommands_now_P(cmd);
+        sprintf_P(cmd, PSTR("G42 F4000 I%i J%i"), mesh_x, mesh_y);
+        gcode.process_subcommands_now_P(cmd);
+        planner.synchronize();
+        current_position.z = goto_mesh_value ? mesh_z_values[mesh_x][mesh_y] : Z_CLEARANCE_BETWEEN_PROBES;
+        planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+        planner.synchronize();
+        CrealityDWIN.Redraw_Menu();
+      }
+    }
+
+    float get_max_value() {
+      float max = __FLT_MIN__;
+      GRID_LOOP(x, y) {
+        if (!isnan(mesh_z_values[x][y]) && mesh_z_values[x][y] > max)
+          max = mesh_z_values[x][y];
+      }
+      return max;
+    }
+
+    float get_min_value() {
+      float min = __FLT_MAX__;
+      GRID_LOOP(x, y) {
+        if (!isnan(mesh_z_values[x][y]) && mesh_z_values[x][y] < min)
+          min = mesh_z_values[x][y];
+      }
+      return min;
+    }
+
+    void Draw_Bed_Mesh(int16_t selected = -1, uint8_t gridline_width = 1, uint16_t padding_x = 8, uint16_t padding_y_top = 40 + 53 - 7) {
+      drawing_mesh = true;
+      const uint16_t total_width_px = DWIN_WIDTH - padding_x - padding_x;
+      const uint16_t cell_width_px  = total_width_px / GRID_MAX_POINTS_X;
+      const uint16_t cell_height_px = total_width_px / GRID_MAX_POINTS_Y;
+      const float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = max(v_min, v_max);
+
+      // Clear background from previous selection and select new square
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, max(0, padding_x - gridline_width), max(0, padding_y_top - gridline_width), padding_x + total_width_px, padding_y_top + total_width_px);
+      if (selected >= 0) {
+        const auto selected_y = selected / GRID_MAX_POINTS_X;
+        const auto selected_x = selected - (GRID_MAX_POINTS_X * selected_y);
+        const auto start_y_px = padding_y_top + selected_y * cell_height_px;
+        const auto start_x_px = padding_x + selected_x * cell_width_px;
+        DWIN_Draw_Rectangle(1, Color_White, max(0, start_x_px - gridline_width), max(0, start_y_px - gridline_width), start_x_px + cell_width_px, start_y_px + cell_height_px);
+      }
+
+      // Draw value square grid
+      char buf[8];
+      GRID_LOOP(x, y) {
+        const auto start_x_px = padding_x + x * cell_width_px;
+        const auto end_x_px   = start_x_px + cell_width_px - 1 - gridline_width;
+        const auto start_y_px = padding_y_top + (GRID_MAX_POINTS_Y - y - 1) * cell_height_px;
+        const auto end_y_px   = start_y_px + cell_height_px - 1 - gridline_width;
+        DWIN_Draw_Rectangle(1,        // RGB565 colors: http://www.barth-dev.de/online/rgb565-color-picker/
+          isnan(mesh_z_values[x][y]) ? Color_Grey : (                                                              // gray if undefined
+            (mesh_z_values[x][y] < 0 ?
+              (uint16_t)round(0b11111  * -mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_min)) << 11 : // red if mesh point value is negative
+              (uint16_t)round(0b111111 *  mesh_z_values[x][y] / (!viewer_asymmetric_range ? range : v_max)) << 5) | // green if mesh point value is positive
+                min(0b11111, (((uint8_t)abs(mesh_z_values[x][y]) / 10) * 4))),                                     // + blue stepping for every mm
+          start_x_px, start_y_px, end_x_px, end_y_px);
+        while (LCD_SERIAL.availableForWrite() < 32) { // wait for serial to be available without blocking and resetting the MCU
+          gcode.process_subcommands_now_P("G4 P10");
+          planner.synchronize();
+        }
+        // Draw value text on
+        if (viewer_print_value) {
+          gcode.process_subcommands_now_P("G4 P10");  // still fails without additional delay...
+          planner.synchronize();
+          int8_t offset_x, offset_y = cell_height_px / 2 - 6;
+          if (isnan(mesh_z_values[x][y])) {  // undefined
+            DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px + cell_width_px / 2 - 5, start_y_px + offset_y, F("X"));
+          }
+          else {                          // has value
+            if (GRID_MAX_POINTS_X < 10)
+              sprintf_P(buf, PSTR("%s"), dtostrf(abs(mesh_z_values[x][y]), 1, 2, str_1));
+            else
+              sprintf_P(buf, PSTR("%02i"), (uint16_t)(abs(mesh_z_values[x][y] - (int16_t)mesh_z_values[x][y]) * 100));
+            offset_x = cell_width_px / 2 - 3 * (strlen(buf)) - 2;
+            if (!(GRID_MAX_POINTS_X < 10))
+              DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px - 2 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, F("."));
+            DWIN_Draw_String(false, false, font6x12, Color_White, Color_Bg_Blue, start_x_px + 1 + offset_x, start_y_px + offset_y /*+ square / 2 - 6*/, buf);
+          }
+        }
+      }
+    }
+
+    void Set_Mesh_Viewer_Status() { // TODO: draw gradient with values as a legend instead
+      float v_max = abs(get_max_value()), v_min = abs(get_min_value()), range = max(v_min, v_max);
+      if (v_min > 3e+10F) v_min = 0.0000001;
+      if (v_max > 3e+10F) v_max = 0.0000001;
+      if (range > 3e+10F) range = 0.0000001;
+      char msg[32];
+      if (viewer_asymmetric_range) {
+        dtostrf(-v_min, 1, 3, str_1);
+        dtostrf( v_max, 1, 3, str_2);
+      }
+      else {
+        dtostrf(-range, 1, 3, str_1);
+        dtostrf( range, 1, 3, str_2);
+      }
+      sprintf_P(msg, PSTR("Red %s..0..%s Green"), str_1, str_2);
+      CrealityDWIN.Update_Status(msg);
+      drawing_mesh = false;
+    }
+
+  };
+  Mesh_Settings mesh_conf;
+#endif
+
+/* General Display Functions */
+
+struct CrealityDWINClass::EEPROM_Settings CrealityDWINClass::eeprom_settings{0};
+constexpr const char * const CrealityDWINClass::color_names[11];
+constexpr const char * const CrealityDWINClass::preheat_modes[3];
+
+// Clear a part of the screen
+//  4=Entire screen
+//  3=Title bar and Menu area (default)
+//  2=Menu area
+//  1=Title bar
+void CrealityDWINClass::Clear_Screen(uint8_t e/*=3*/) {
+  if (e == 1 || e == 3 || e == 4) DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.menu_top_bg, Color_Bg_Blue, false), 0, 0, DWIN_WIDTH, TITLE_HEIGHT); // Clear Title Bar
+  if (e == 2 || e == 3) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, STATUS_Y); // Clear Menu Area
+  if (e == 4) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, 31, DWIN_WIDTH, DWIN_HEIGHT); // Clear Popup Area
+}
+
+void CrealityDWINClass::Draw_Float(float value, uint8_t row, bool selected/*=false*/, uint8_t minunit/*=10*/) {
+  const uint8_t digits = (uint8_t)floor(log10(abs(value))) + log10(minunit) + (minunit > 1);
+  const uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
+  const uint16_t xpos = 240 - (digits * 8);
+  DWIN_Draw_Rectangle(1, Color_Bg_Black, 194, MBASE(row), 234 - (digits * 8), MBASE(row) + 16);
+  if (isnan(value)) {
+    DWIN_Draw_String(false, true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" NaN"));
+  }
+  else if (value < 0) {
+    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), -value * minunit);
+    DWIN_Draw_String(false, true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F("-"));
+  }
+  else {
+    DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, Color_White, bColor, digits - log10(minunit) + 1, log10(minunit), xpos, MBASE(row), value * minunit);
+    DWIN_Draw_String(false, true, DWIN_FONT_MENU, Color_White, bColor, xpos - 8, MBASE(row), F(" "));
+  }
+}
+
+void CrealityDWINClass::Draw_Option(uint8_t value, const char * const * options, uint8_t row, bool selected/*=false*/, bool color/*=false*/) {
+  uint16_t bColor = (selected) ? Select_Color : Color_Bg_Black;
+  uint16_t tColor = (color) ? GetColor(value, Color_White, false) : Color_White;
+  DWIN_Draw_Rectangle(1, bColor, 202, MBASE(row) + 14, 258, MBASE(row) - 2);
+  DWIN_Draw_String(false, false, DWIN_FONT_MENU, tColor, bColor, 202, MBASE(row) - 1, options[value]);
+}
+
+uint16_t CrealityDWINClass::GetColor(uint8_t color, uint16_t original, bool light/*=false*/) {
+  switch (color){
+    case Default:
+      return original;
+      break;
+    case White:
+      return (light) ? Color_Light_White : Color_White;
+      break;
+    case Green:
+      return (light) ? Color_Light_Green : Color_Green;
+      break;
+    case Cyan:
+      return (light) ? Color_Light_Cyan : Color_Cyan;
+      break;
+    case Blue:
+      return (light) ? Color_Light_Blue : Color_Blue;
+      break;
+    case Magenta:
+      return (light) ? Color_Light_Magenta : Color_Magenta;
+      break;
+    case Red:
+      return (light) ? Color_Light_Red : Color_Red;
+      break;
+    case Orange:
+      return (light) ? Color_Light_Orange : Color_Orange;
+      break;
+    case Yellow:
+      return (light) ? Color_Light_Yellow : Color_Yellow;
+      break;
+    case Brown:
+      return (light) ? Color_Light_Brown : Color_Brown;
+      break;
+    case Black:
+      return Color_Black;
+      break;
+  }
+  return Color_White;
+}
+
+void CrealityDWINClass::Draw_Title(const char * title) {
+  DWIN_Draw_String(false, false, DWIN_FONT_HEAD, GetColor(eeprom_settings.menu_top_txt, Color_White, false), Color_Bg_Blue, (DWIN_WIDTH - strlen(title) * STAT_CHR_W) / 2, 5, title);
+}
+
+void CrealityDWINClass::Draw_Menu_Item(uint8_t row, uint8_t icon/*=0*/, const char * label1, const char * label2, bool more/*=false*/, bool centered/*=false*/) {
+  const uint8_t label_offset_y = !(label1 && label2) ? 0 : MENU_CHR_H * 3 / 5;
+  const uint8_t label1_offset_x = !centered ? LBLX : LBLX * 4/5 + max(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label1 ? strlen(label1) : 0) * MENU_CHR_W) / 2);
+  const uint8_t label2_offset_x = !centered ? LBLX : LBLX * 4/5 + max(LBLX * 1U/5, (DWIN_WIDTH - LBLX - (label2 ? strlen(label2) : 0) * MENU_CHR_W) / 2);
+  if (label1) DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label1_offset_x, MBASE(row) - 1 - label_offset_y, label1); // Draw Label
+  if (label2) DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, label2_offset_x, MBASE(row) - 1 + label_offset_y, label2); // Draw Label
+  if (icon) DWIN_ICON_Show(ICON, icon, 26, MBASE(row) - 3);   //Draw Menu Icon
+  if (more) DWIN_ICON_Show(ICON, ICON_More, 226, MBASE(row) - 3); // Draw More Arrow
+  DWIN_Draw_Line(GetColor(eeprom_settings.menu_split_line, Line_Color, true), 16, MBASE(row) + 33, 256, MBASE(row) + 33); // Draw Menu Line
+}
+
+void CrealityDWINClass::Draw_Checkbox(uint8_t row, bool value) {
+  #if ENABLED(DWIN_CREALITY_LCD_CUSTOM_ICONS) // Draw appropriate checkbox icon
+    DWIN_ICON_Show(ICON, (value ? ICON_Checkbox_T : ICON_Checkbox_F), 226, MBASE(row) - 3);
+  #else                                         // Draw a basic checkbox using rectangles and lines
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    DWIN_Draw_Rectangle(0, Color_White, 226, MBASE(row) - 3, 226 + 20, MBASE(row) - 3 + 20);
+    if (value) {
+      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 11, 226 + 8, MBASE(row) - 3 + 17);
+      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 17, 226 + 19, MBASE(row) - 3 + 1);
+      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 12, 226 + 8, MBASE(row) - 3 + 18);
+      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 18, 226 + 19, MBASE(row) - 3 + 2);
+      DWIN_Draw_Line(Check_Color, 227, MBASE(row) - 3 + 13, 226 + 8, MBASE(row) - 3 + 19);
+      DWIN_Draw_Line(Check_Color, 227 + 8, MBASE(row) - 3 + 19, 226 + 19, MBASE(row) - 3 + 3);
+    }
+  #endif
+}
+
+void CrealityDWINClass::Draw_Menu(uint8_t menu, uint8_t select/*=0*/, uint8_t scroll/*=0*/) {
+  if (active_menu != menu) {
+    last_menu = active_menu;
+    if (process == Menu) last_selection = selection;
+  }
+  selection = min(select, Get_Menu_Size(menu));
+  scrollpos = scroll;
+  if (selection - scrollpos > MROWS)
+    scrollpos = selection - MROWS;
+  process = Menu;
+  active_menu = menu;
+  Clear_Screen();
+  Draw_Title(Get_Menu_Title(menu));
+  LOOP_L_N(i, TROWS) Menu_Item_Handler(menu, i + scrollpos);
+  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+}
+
+void CrealityDWINClass::Redraw_Menu(bool lastprocess/*=true*/, bool lastselection/*=false*/, bool lastmenu/*=false*/) {
+  switch ((lastprocess) ? last_process : process) {
+    case Menu:
+      Draw_Menu((lastmenu) ? last_menu : active_menu, (lastselection) ? last_selection : selection, (lastmenu) ? 0 : scrollpos);
+      break;
+    case Main:  Draw_Main_Menu((lastselection) ? last_selection : selection); break;
+    case Print: Draw_Print_Screen(); break;
+    case File:  Draw_SD_List(); break;
+    default: break;
+  }
+}
+
+void CrealityDWINClass::Redraw_Screen() {
+  Redraw_Menu(false);
+  Draw_Status_Area(true);
+  Update_Status_Bar(true);
+}
+
+/* Primary Menus and Screen Elements */
+
+void CrealityDWINClass::Main_Menu_Icons() {
+  if (selection == 0) {
+    DWIN_ICON_Show(ICON, ICON_Print_1, 17, 130);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 130, 126, 229);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Print_0, 17, 130);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 52, 200, F("Print"));
+  }
+  if (selection == 1) {
+    DWIN_ICON_Show(ICON, ICON_Prepare_1, 145, 130);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 130, 254, 229);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Prepare_0, 145, 130);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 170, 200, F("Prepare"));
+  }
+  if (selection == 2) {
+    DWIN_ICON_Show(ICON, ICON_Control_1, 17, 246);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 17, 246, 126, 345);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Control_0, 17, 246);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 43, 317, F("Control"));
+  }
+  #if HAS_ABL_OR_UBL
+    if (selection == 3) {
+      DWIN_ICON_Show(ICON, ICON_Leveling_1, 145, 246);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Leveling_0, 145, 246);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 179, 317, F("Level"));
+    }
+  #else
+    if (selection == 3) {
+      DWIN_ICON_Show(ICON, ICON_Info_1, 145, 246);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 145, 246, 254, 345);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Info_0, 145, 246);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 181, 317, F("Info"));
+      //DWIN_Frame_AreaCopy(1, 132, 423, 159, 435, 186, 318);
+    }
+  #endif
+}
+
+void CrealityDWINClass::Draw_Main_Menu(uint8_t select/*=0*/) {
+  process = Main;
+  active_menu = MainMenu;
+  selection = select;
+  Clear_Screen();
+  Draw_Title(Get_Menu_Title(MainMenu));
+  SERIAL_ECHOPGM("\nDWIN handshake ");
+  DWIN_ICON_Show(ICON, ICON_LOGO, 71, 72);
+  Main_Menu_Icons();
+}
+
+void CrealityDWINClass::Print_Screen_Icons() {
+  if (selection == 0) {
+    DWIN_ICON_Show(ICON, ICON_Setup_1, 8, 252);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 8, 252, 87, 351);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Setup_0, 8, 252);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 30, 322, F("Tune"));
+  }
+  if (selection == 2) {
+    DWIN_ICON_Show(ICON, ICON_Stop_1, 184, 252);
+    DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 184, 252, 263, 351);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+  }
+  else {
+    DWIN_ICON_Show(ICON, ICON_Stop_0, 184, 252);
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 205, 322, F("Stop"));
+  }
+  if (paused) {
+    if (selection == 1) {
+      DWIN_ICON_Show(ICON, ICON_Continue_1, 96, 252);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Continue_0, 96, 252);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Print"));
+    }
+  }
+  else {
+    if (selection == 1) {
+      DWIN_ICON_Show(ICON, ICON_Pause_1, 96, 252);
+      DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 96, 252, 175, 351);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+    }
+    else {
+      DWIN_ICON_Show(ICON, ICON_Pause_0, 96, 252);
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Blue, 114, 322, F("Pause"));
+    }
+  }
+}
+
+void CrealityDWINClass::Draw_Print_Screen() {
+  process = Print;
+  selection = 0;
+  Clear_Screen();
+  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+  Draw_Title("Printing...");
+  Print_Screen_Icons();
+  DWIN_ICON_Show(ICON, ICON_PrintTime, 14, 171);
+  DWIN_ICON_Show(ICON, ICON_RemainTime, 147, 169);
+  DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, 41, 163, "Elapsed");
+  DWIN_Draw_String(false, false, DWIN_FONT_MENU,  Color_White, Color_Bg_Black, 176, 163, "Remaining");
+  Update_Status_Bar(true);
+  Draw_Print_ProgressBar();
+  Draw_Print_ProgressElapsed();
+  TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
+  Draw_Print_Filename(true);
+}
+
+void CrealityDWINClass::Draw_Print_Filename(const bool reset/*=false*/) {
+  static uint8_t namescrl = 0;
+  if (reset) namescrl = 0;
+  if (process == Print) {
+    size_t len = strlen(filename);
+    int8_t pos = len;
+    if (pos > 30) {
+      pos -= namescrl;
+      len = _MIN(pos, 30);
+      char dispname[len + 1];
+      if (pos >= 0) {
+        LOOP_L_N(i, len) dispname[i] = filename[i + namescrl];
+      }
+      else {
+        LOOP_L_N(i, 30 + pos) dispname[i] = ' ';
+        LOOP_S_L_N(i, 30 + pos, 30) dispname[i] = filename[i - (30 + pos)];
+      }
+      dispname[len] = '\0';
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
+      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, dispname);
+      if (-pos >= 30) namescrl = 0;
+      namescrl++;
+    }
+    else {
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 50, DWIN_WIDTH - 8, 80);
+      const int8_t npos = (DWIN_WIDTH - strlen(filename) * MENU_CHR_W) / 2;
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, Color_White, Color_Bg_Black, npos, 60, filename);
+    }
+  }
+}
+
+void CrealityDWINClass::Draw_Print_ProgressBar() {
+  uint8_t printpercent = sdprint ? card.percentDone() : (ui._get_progress() / 100);
+  DWIN_ICON_Show(ICON, ICON_Bar, 15, 93);
+  DWIN_Draw_Rectangle(1, BarFill_Color, 16 + printpercent * 240 / 100, 93, 256, 113);
+  DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 3, 109, 133, printpercent);
+  DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_percent, Percent_Color), Color_Bg_Black, 133, 133, "%");
+}
+
+#if ENABLED(USE_M73_REMAINING_TIME)
+
+  void CrealityDWINClass::Draw_Print_ProgressRemain() {
+    uint16_t remainingtime = ui.get_remaining_time();
+    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 176, 187, remainingtime / 3600);
+    DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 200, 187, (remainingtime % 3600) / 60);
+    if (eeprom_settings.time_format_textual) {
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, "h");
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 216, 187, "m");
+    }
+    else
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 192, 187, ":");
+  }
+
+#endif
+
+void CrealityDWINClass::Draw_Print_ProgressElapsed() {
+  duration_t elapsed = print_job_timer.duration();
+  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 42, 187, elapsed.value / 3600);
+  DWIN_Draw_IntValue(true, true, 1, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 2, 66, 187, (elapsed.value % 3600) / 60);
+  if (eeprom_settings.time_format_textual) {
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, "h");
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 82, 187, "m");
+  }
+  else
+    DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.progress_time, Color_White), Color_Bg_Black, 58, 187, ":");
+}
+
+void CrealityDWINClass::Draw_Print_confirm() {
+  Draw_Print_Screen();
+  process = Confirm;
+  popup = Complete;
+  DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 252, 263, 351);
+  DWIN_ICON_Show(ICON, ICON_Confirm_E, 87, 283);
+  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 86, 282, 187, 321);
+  DWIN_Draw_Rectangle(0, GetColor(eeprom_settings.highlight_box, Color_White), 85, 281, 188, 322);
+}
+
+void CrealityDWINClass::Draw_SD_Item(uint8_t item, uint8_t row) {
+  if (item == 0)
+    Draw_Menu_Item(0, ICON_Back, card.flag.workDirIsRoot ? "Back" : "..");
+  else {
+    card.getfilename_sorted(SD_ORDER(item - 1, card.get_num_Files()));
+    char * const filename = card.longest_filename();
+    size_t max = MENU_CHAR_LIMIT;
+    size_t pos = strlen(filename), len = pos;
+    if (!card.flag.filenameIsDir)
+      while (pos && filename[pos] != '.') pos--;
+    len = pos;
+    if (len > max) len = max;
+    char name[len + 1];
+    LOOP_L_N(i, len) name[i] = filename[i];
+    if (pos > max)
+      LOOP_S_L_N(i, len - 3, len) name[i] = '.';
+    name[len] = '\0';
+    Draw_Menu_Item(row, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
+  }
+}
+
+void CrealityDWINClass::Draw_SD_List(bool removed/*=false*/) {
+  Clear_Screen();
+  Draw_Title("Select File");
+  selection = 0;
+  scrollpos = 0;
+  process = File;
+  if (card.isMounted() && !removed) {
+    LOOP_L_N(i, _MIN(card.get_num_Files() + 1, TROWS))
+      Draw_SD_Item(i, i);
+  }
+  else {
+    Draw_Menu_Item(0, ICON_Back, "Back");
+    DWIN_Draw_Rectangle(1, Color_Bg_Red, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    DWIN_Draw_String(false, false, font16x32, Color_Yellow, Color_Bg_Red, ((DWIN_WIDTH) - 8 * 16) / 2, MBASE(3), "No Media");
+  }
+  DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(0) - 18, 14, MBASE(0) + 33);
+}
+
+void CrealityDWINClass::Draw_Status_Area(bool icons/*=false*/) {
+
+  if (icons) DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, STATUS_Y, DWIN_WIDTH, DWIN_HEIGHT - 1);
+
+  #if HAS_HOTEND
+    static float hotend = -1;
+    static int16_t hotendtarget = -1, flow = -1;
+    if (icons) {
+      hotend = -1;
+      hotendtarget = -1;
+      DWIN_ICON_Show(ICON, ICON_HotendTemp, 10, 383);
+      DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+    }
+    if (thermalManager.temp_hotend[0].celsius != hotend) {
+      hotend = thermalManager.temp_hotend[0].celsius;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 384, thermalManager.temp_hotend[0].celsius);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 386);
+    }
+    if (thermalManager.temp_hotend[0].target != hotendtarget) {
+      hotendtarget = thermalManager.temp_hotend[0].target;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.temp_hotend[0].target);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 386);
+    }
+    if (icons) {
+      flow = -1;
+      DWIN_ICON_Show(ICON, ICON_StepE, 112, 417);
+      DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+    }
+    if (planner.flow_percentage[0] != flow) {
+      flow = planner.flow_percentage[0];
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+    }
+  #endif
+
+  #if HAS_HEATED_BED
+    static float bed = -1;
+    static int16_t bedtarget = -1;
+    if (icons) {
+      bed = -1;
+      bedtarget = -1;
+      DWIN_ICON_Show(ICON, ICON_BedTemp, 10, 416);
+      DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+    }
+    if (thermalManager.temp_bed.celsius != bed) {
+      bed = thermalManager.temp_bed.celsius;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 28, 417, thermalManager.temp_bed.celsius);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 3 * STAT_CHR_W + 5, 419);
+    }
+    if (thermalManager.temp_bed.target != bedtarget) {
+      bedtarget = thermalManager.temp_bed.target;
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.temp_bed.target);
+      DWIN_Draw_DegreeSymbol(GetColor(eeprom_settings.status_area_text, Color_White), 25 + 4 * STAT_CHR_W + 39, 419);
+    }
+  #endif
+
+  #if HAS_FAN
+    static uint8_t fan = -1;
+    if (icons) {
+      fan = -1;
+      DWIN_ICON_Show(ICON, ICON_FanSpeed, 187, 383);
+    }
+    if (thermalManager.fan_speed[0] != fan) {
+      fan = thermalManager.fan_speed[0];
+      DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+    }
+  #endif
+
+  #if HAS_ZOFFSET_ITEM
+    static float offset = -1;
+
+    if (icons) {
+      offset = -1;
+      DWIN_ICON_Show(ICON, ICON_Zoffset, 187, 416);
+    }
+    if (zoffsetvalue != offset) {
+      offset = zoffsetvalue;
+      if (zoffsetvalue < 0) {
+        DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, -zoffsetvalue * 100);
+        DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, "-");
+      }
+      else {
+        DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 2, 2, 207, 417, zoffsetvalue* 100);
+        DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 205, 419, " ");
+      }
+    }
+  #endif
+
+  static int16_t feedrate = -1;
+  if (icons) {
+    feedrate = -1;
+    DWIN_ICON_Show(ICON, ICON_Speed, 113, 383);
+    DWIN_Draw_String(false, false, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+  }
+  if (feedrate_percentage != feedrate) {
+    feedrate = feedrate_percentage;
+    DWIN_Draw_IntValue(true, true, 0, DWIN_FONT_STAT, GetColor(eeprom_settings.status_area_text, Color_White), Color_Bg_Black, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+  }
+
+  static float x = -1, y = -1, z = -1;
+  static bool update_x = false, update_y = false, update_z = false;
+  update_x = (current_position.x != x || axis_should_home(X_AXIS) || update_x);
+  update_y = (current_position.y != y || axis_should_home(Y_AXIS) || update_y);
+  update_z = (current_position.z != z || axis_should_home(Z_AXIS) || update_z);
+  if (icons) {
+    x = y = z = -1;
+    DWIN_Draw_Line(GetColor(eeprom_settings.coordinates_split_line, Line_Color, true), 16, 450, 256, 450);
+    DWIN_ICON_Show(ICON, ICON_MaxSpeedX,  10, 456);
+    DWIN_ICON_Show(ICON, ICON_MaxSpeedY,  95, 456);
+    DWIN_ICON_Show(ICON, ICON_MaxSpeedZ, 180, 456);
+  }
+  if (update_x) {
+    x = current_position.x;
+    if ((update_x = axis_should_home(X_AXIS) && ui.get_blink()))
+      DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 35, 459, "  -?-  ");
+    else
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 35, 459, current_position.x * 10);
+  }
+  if (update_y) {
+    y = current_position.y;
+    if ((update_y = axis_should_home(Y_AXIS) && ui.get_blink()))
+      DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 120, 459, "  -?-  ");
+    else
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 1, 120, 459, current_position.y * 10);
+  }
+  if (update_z) {
+    z = current_position.z;
+    if ((update_z = axis_should_home(Z_AXIS) && ui.get_blink()))
+      DWIN_Draw_String(false, true, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 205, 459, "  -?-  ");
+    else
+      DWIN_Draw_FloatValue(true, true, 0, DWIN_FONT_MENU, GetColor(eeprom_settings.coordinates_text, Color_White), Color_Bg_Black, 3, 2, 205, 459, (current_position.z>=0) ? current_position.z * 100 : 0);
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Draw_Popup(PGM_P const line1, PGM_P const line2, PGM_P const line3, uint8_t mode, uint8_t icon/*=0*/) {
+  if (process != Confirm && process != Popup && process != Wait) last_process = process;
+  if ((process == Menu || process == Wait) && mode == Popup) last_selection = selection;
+  process = mode;
+  Clear_Screen();
+  DWIN_Draw_Rectangle(0, Color_White, 13, 59, 259, 351);
+  DWIN_Draw_Rectangle(1, Color_Bg_Window, 14, 60, 258, 350);
+  const uint8_t ypos = (mode == Popup || mode == Confirm) ? 150 : 230;
+  if (icon > 0) DWIN_ICON_Show(ICON, icon, 101, 105);
+  DWIN_Draw_String(false, true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line1)) / 2, ypos, line1);
+  DWIN_Draw_String(false, true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line2)) / 2, ypos + 30, line2);
+  DWIN_Draw_String(false, true, DWIN_FONT_MENU, Popup_Text_Color, Color_Bg_Window, (272 - 8 * strlen_P(line3)) / 2, ypos + 60, line3);
+  if (mode == Popup) {
+    selection = 0;
+    DWIN_Draw_Rectangle(1, Confirm_Color, 26, 280, 125, 317);
+    DWIN_Draw_Rectangle(1, Cancel_Color, 146, 280, 245, 317);
+    DWIN_Draw_String(false, false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 39, 290, "Confirm");
+    DWIN_Draw_String(false, false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 165, 290, "Cancel");
+    Popup_Select();
+  }
+  else if (mode == Confirm) {
+    DWIN_Draw_Rectangle(1, Confirm_Color, 87, 280, 186, 317);
+    DWIN_Draw_String(false, false, DWIN_FONT_STAT, Color_White, Color_Bg_Window, 96, 290, "Continue");
+  }
+}
+
+void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
+  CrealityDWIN.Draw_Popup(PSTR("Printer Kill Reason:"), error, PSTR("Restart Required"), Wait, ICON_BLTouch);
+}
+
+void CrealityDWINClass::Popup_Select() {
+  const uint16_t c1 = (selection == 0) ? GetColor(eeprom_settings.highlight_box, Color_White) : Color_Bg_Window,
+                 c2 = (selection == 0) ? Color_Bg_Window : GetColor(eeprom_settings.highlight_box, Color_White);
+  DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
+  DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
+  DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
+  DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
+}
+
+void CrealityDWINClass::Update_Status_Bar(bool refresh/*=false*/) {
+  static bool new_msg;
+  static uint8_t msgscrl = 0;
+  static char lastmsg[64];
+  if (strcmp_P(lastmsg, statusmsg) != 0 || refresh) {
+    strcpy_P(lastmsg, statusmsg);
+    msgscrl = 0;
+    new_msg = true;
+  }
+  size_t len = strlen(statusmsg);
+  int8_t pos = len;
+  if (pos > 30) {
+    pos -= msgscrl;
+    len = pos;
+    if (len > 30)
+      len = 30;
+    char dispmsg[len + 1];
+    if (pos >= 0) {
+      LOOP_L_N(i, len) dispmsg[i] = statusmsg[i + msgscrl];
+    }
+    else {
+      LOOP_L_N(i, 30 + pos) dispmsg[i] = ' ';
+      LOOP_S_L_N(i, 30 + pos, 30) dispmsg[i] = statusmsg[i - (30 + pos)];
+    }
+    dispmsg[len] = '\0';
+    if (process == Print) {
+      DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, dispmsg);
+    }
+    else {
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+      const int8_t npos = (DWIN_WIDTH - 30 * MENU_CHR_W) / 2;
+      DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, dispmsg);
+    }
+    if (-pos >= 30) msgscrl = 0;
+    msgscrl++;
+  }
+  else {
+    if (new_msg) {
+      new_msg = false;
+      if (process == Print) {
+        DWIN_Draw_Rectangle(1, Color_Grey, 8, 214, DWIN_WIDTH - 8, 238);
+        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
+        DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 219, statusmsg);
+      }
+      else {
+        DWIN_Draw_Rectangle(1, Color_Bg_Black, 8, 352, DWIN_WIDTH - 8, 376);
+        const int8_t npos = (DWIN_WIDTH - strlen(statusmsg) * MENU_CHR_W) / 2;
+        DWIN_Draw_String(false, false, DWIN_FONT_MENU, GetColor(eeprom_settings.status_bar_text, Color_White), Color_Bg_Black, npos, 357, statusmsg);
+      }
+    }
+  }
+}
+
+/* Menu Item Config */
+
+void CrealityDWINClass::Menu_Item_Handler(uint8_t menu, uint8_t item, bool draw/*=true*/) {
+  uint8_t row = item - scrollpos;
+  #if HAS_LEVELING
+    static bool level_state;
+  #endif
+  switch (menu) {
+    case Prepare:
+
+      #define PREPARE_BACK 0
+      #define PREPARE_MOVE (PREPARE_BACK + 1)
+      #define PREPARE_DISABLE (PREPARE_MOVE + 1)
+      #define PREPARE_HOME (PREPARE_DISABLE + 1)
+      #define PREPARE_MANUALLEVEL (PREPARE_HOME + 1)
+      #define PREPARE_ZOFFSET (PREPARE_MANUALLEVEL + ENABLED(HAS_ZOFFSET_ITEM))
+      #define PREPARE_PREHEAT (PREPARE_ZOFFSET + ENABLED(HAS_PREHEAT))
+      #define PREPARE_COOLDOWN (PREPARE_PREHEAT + ENABLED(HAS_PREHEAT))
+      #define PREPARE_CHANGEFIL (PREPARE_COOLDOWN + ENABLED(ADVANCED_PAUSE_FEATURE))
+      #define PREPARE_TOTAL PREPARE_CHANGEFIL
+
+      switch (item) {
+        case PREPARE_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Main_Menu(1);
+          break;
+        case PREPARE_MOVE:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Axis, "Move", nullptr, true);
+          else
+            Draw_Menu(Move);
+          break;
+        case PREPARE_DISABLE:
+          if (draw)
+            Draw_Menu_Item(row, ICON_CloseMotor, "Disable Stepper");
+          else
+            queue.inject_P(PSTR("M84"));
+          break;
+        case PREPARE_HOME:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, "Homing", nullptr, true);
+          else
+            Draw_Menu(HomeMenu);
+          break;
+        case PREPARE_MANUALLEVEL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_PrintSize, "Manual Leveling", nullptr, true);
+          else {
+            if (axes_should_home()) {
+              Popup_Handler(Home);
+              gcode.home_all_axes(true);
+            }
+            #if HAS_LEVELING
+              level_state = planner.leveling_active;
+              set_bed_leveling_enabled(false);
+            #endif
+            Draw_Menu(ManualLevel);
+          }
+          break;
+
+        #if HAS_ZOFFSET_ITEM
+          case PREPARE_ZOFFSET:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Zoffset, "Z-Offset", nullptr, true);
+            else {
+              #if HAS_LEVELING
+                level_state = planner.leveling_active;
+                set_bed_leveling_enabled(false);
+              #endif
+              Draw_Menu(ZOffset);
+            }
+            break;
+        #endif
+
+        #if HAS_PREHEAT
+          case PREPARE_PREHEAT:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Temperature, "Preheat", nullptr, true);
+            else
+              Draw_Menu(Preheat);
+            break;
+          case PREPARE_COOLDOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Cool, "Cooldown");
+            else {
+              TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+              thermalManager.disable_all_heaters();
+            }
+            break;
+        #endif
+
+        #if ENABLED(ADVANCED_PAUSE_FEATURE)
+          case PREPARE_CHANGEFIL:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament"
+                #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                  , nullptr, true
+                #endif
+              );
+            }
+            else {
+              #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                Draw_Menu(ChangeFilament);
+              #else
+                if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                  Popup_Handler(ETemp);
+                else {
+                  if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                    Popup_Handler(Heating);
+                    thermalManager.wait_for_hotend(0);
+                  }
+                  Popup_Handler(FilChange);
+                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                  gcode.process_subcommands_now_P(cmd);
+                }
+              #endif
+            }
+            break;
+        #endif
+      }
+      break;
+
+    case HomeMenu:
+
+      #define HOME_BACK  0
+      #define HOME_ALL   (HOME_BACK + 1)
+      #define HOME_X     (HOME_ALL + 1)
+      #define HOME_Y     (HOME_X + 1)
+      #define HOME_Z     (HOME_Y + 1)
+      #define HOME_SET   (HOME_Z + 1)
+      #define HOME_TOTAL HOME_SET
+
+      switch (item) {
+        case HOME_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Prepare, PREPARE_HOME);
+          break;
+        case HOME_ALL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Homing, "Home All");
+          else {
+            Popup_Handler(Home);
+            gcode.home_all_axes(true);
+            Redraw_Menu();
+          }
+          break;
+        case HOME_X:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MoveX, "Home X");
+          else {
+            Popup_Handler(Home);
+            gcode.process_subcommands_now_P(PSTR("G28 X"));
+            planner.synchronize();
+            Redraw_Menu();
+          }
+          break;
+        case HOME_Y:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MoveY, "Home Y");
+          else {
+            Popup_Handler(Home);
+            gcode.process_subcommands_now_P(PSTR("G28 Y"));
+            planner.synchronize();
+            Redraw_Menu();
+          }
+          break;
+        case HOME_Z:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MoveZ,"Home Z");
+          else {
+            Popup_Handler(Home);
+            gcode.process_subcommands_now_P(PSTR("G28 Z"));
+            planner.synchronize();
+            Redraw_Menu();
+          }
+          break;
+        case HOME_SET:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, "Set Home Position");
+          else {
+            gcode.process_subcommands_now_P(PSTR("G92 X0 Y0 Z0"));
+            AudioFeedback();
+          }
+          break;
+      }
+      break;
+
+    case Move:
+
+      #define MOVE_BACK 0
+      #define MOVE_X (MOVE_BACK + 1)
+      #define MOVE_Y (MOVE_X + 1)
+      #define MOVE_Z (MOVE_Y + 1)
+      #define MOVE_E (MOVE_Z + ENABLED(HAS_HOTEND))
+      #define MOVE_P (MOVE_E + ENABLED(HAS_BED_PROBE))
+      #define MOVE_LIVE (MOVE_P + 1)
+      #define MOVE_TOTAL MOVE_LIVE
+
+      switch (item) {
+        case MOVE_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else {
+            #if HAS_BED_PROBE
+              probe_deployed = false;
+              probe.set_deployed(probe_deployed);
+            #endif
+            Draw_Menu(Prepare, PREPARE_MOVE);
+          }
+          break;
+        case MOVE_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MoveX, "Move X");
+            Draw_Float(current_position.x, row, false);
+          }
+          else
+            Modify_Value(current_position.x, X_MIN_POS, X_MAX_POS, 10);
+          break;
+        case MOVE_Y:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MoveY, "Move Y");
+            Draw_Float(current_position.y, row);
+          }
+          else
+            Modify_Value(current_position.y, Y_MIN_POS, Y_MAX_POS, 10);
+          break;
+        case MOVE_Z:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MoveZ, "Move Z");
+            Draw_Float(current_position.z, row);
+          }
+          else
+            Modify_Value(current_position.z, Z_MIN_POS, Z_MAX_POS, 10);
+          break;
+
+        #if HAS_HOTEND
+          case MOVE_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Extruder, "Extruder");
+              current_position.e = 0;
+              sync_plan_position();
+              Draw_Float(current_position.e, row);
+            }
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+                Popup_Handler(ETemp);
+              }
+              else {
+                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                  Redraw_Menu();
+                }
+                current_position.e = 0;
+                sync_plan_position();
+                Modify_Value(current_position.e, -500, 500, 10);
+              }
+            }
+          break;
+        #endif // HAS_HOTEND
+
+        #if HAS_BED_PROBE
+          case MOVE_P:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StockConfiguraton, "Probe");
+              Draw_Checkbox(row, probe_deployed);
+            }
+            else {
+              probe_deployed = !probe_deployed;
+              probe.set_deployed(probe_deployed);
+              Draw_Checkbox(row, probe_deployed);
+            }
+            break;
+        #endif
+
+        case MOVE_LIVE:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Axis, "Live Movement");
+            Draw_Checkbox(row, livemove);
+          }
+          else {
+            livemove = !livemove;
+            Draw_Checkbox(row, livemove);
+          }
+          break;
+      }
+      break;
+    case ManualLevel:
+
+      #define MLEVEL_BACK 0
+      #define MLEVEL_PROBE (MLEVEL_BACK + ENABLED(HAS_BED_PROBE))
+      #define MLEVEL_BL (MLEVEL_PROBE + 1)
+      #define MLEVEL_TL (MLEVEL_BL + 1)
+      #define MLEVEL_TR (MLEVEL_TL + 1)
+      #define MLEVEL_BR (MLEVEL_TR + 1)
+      #define MLEVEL_C (MLEVEL_BR + 1)
+      #define MLEVEL_ZPOS (MLEVEL_C + 1)
+      #define MLEVEL_TOTAL MLEVEL_ZPOS
+
+      static float mlev_z_pos = 0;
+      static bool use_probe = false;
+
+      switch (item) {
+        case MLEVEL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else {
+            TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
+            Draw_Menu(Prepare, PREPARE_MANUALLEVEL);
+          }
+          break;
+        #if HAS_BED_PROBE
+          case MLEVEL_PROBE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Zoffset, "Use Probe");
+              Draw_Checkbox(row, use_probe);
+            }
+            else {
+              use_probe = !use_probe;
+              Draw_Checkbox(row, use_probe);
+              if (use_probe) {
+                Popup_Handler(Level);
+                corner_avg = 0;
+                #define PROBE_X_MIN _MAX(0 + corner_pos, X_MIN_POS + probe.offset.x, X_MIN_POS + PROBING_MARGIN) - probe.offset.x
+                #define PROBE_X_MAX _MIN((X_BED_SIZE + X_MIN_POS) - corner_pos, X_MAX_POS + probe.offset.x, X_MAX_POS - PROBING_MARGIN) - probe.offset.x
+                #define PROBE_Y_MIN _MAX(0 + corner_pos, Y_MIN_POS + probe.offset.y, Y_MIN_POS + PROBING_MARGIN) - probe.offset.y
+                #define PROBE_Y_MAX _MIN((Y_BED_SIZE + Y_MIN_POS) - corner_pos, Y_MAX_POS + probe.offset.y, Y_MAX_POS - PROBING_MARGIN) - probe.offset.y
+                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MIN, PROBE_PT_RAISE, 0, false);
+                corner_avg += probe.probe_at_point(PROBE_X_MIN, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
+                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MAX, PROBE_PT_RAISE, 0, false);
+                corner_avg += probe.probe_at_point(PROBE_X_MAX, PROBE_Y_MIN, PROBE_PT_STOW, 0, false);
+                corner_avg /= 4;
+                Redraw_Menu();
+              }
+            }
+            break;
+        #endif
+        case MLEVEL_BL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisBL, "Bottom Left");
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
+                gcode.process_subcommands_now_P(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_TL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisTL, "Top Left");
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MIN, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
+                gcode.process_subcommands_now_P(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf(corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_TR:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisTR, "Top Right");
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MAX, 1, 3, str_2));
+                gcode.process_subcommands_now_P(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) - corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_BR:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisBR, "Bottom Right");
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(PROBE_X_MAX, 1, 3, str_1), dtostrf(PROBE_Y_MIN, 1, 3, str_2));
+                gcode.process_subcommands_now_P(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) - corner_pos, 1, 3, str_1), dtostrf(corner_pos, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_C:
+          if (draw)
+            Draw_Menu_Item(row, ICON_AxisC, "Center");
+          else {
+            Popup_Handler(MoveWait);
+            if (use_probe) {
+              #if HAS_BED_PROBE
+                sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s"), dtostrf(X_MAX_POS / 2.0f - probe.offset.x, 1, 3, str_1), dtostrf(Y_MAX_POS / 2.0f - probe.offset.y, 1, 3, str_2));
+                gcode.process_subcommands_now_P(cmd);
+                planner.synchronize();
+                Popup_Handler(ManualProbing);
+              #endif
+            }
+            else {
+              sprintf_P(cmd, PSTR("G0 F4000\nG0 Z10\nG0 X%s Y%s\nG0 F300 Z%s"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), dtostrf(mlev_z_pos, 1, 3, str_3));
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+          }
+          break;
+        case MLEVEL_ZPOS:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_SetZOffset, "Z Position");
+            Draw_Float(mlev_z_pos, row, false, 100);
+          }
+          else
+            Modify_Value(mlev_z_pos, 0, MAX_Z_OFFSET, 100);
+          break;
+      }
+      break;
+    #if HAS_ZOFFSET_ITEM
+      case ZOffset:
+
+        #define ZOFFSET_BACK 0
+        #define ZOFFSET_HOME (ZOFFSET_BACK + 1)
+        #define ZOFFSET_MODE (ZOFFSET_HOME + 1)
+        #define ZOFFSET_OFFSET (ZOFFSET_MODE + 1)
+        #define ZOFFSET_UP (ZOFFSET_OFFSET + 1)
+        #define ZOFFSET_DOWN (ZOFFSET_UP + 1)
+        #define ZOFFSET_SAVE (ZOFFSET_DOWN + ENABLED(EEPROM_SETTINGS))
+        #define ZOFFSET_TOTAL ZOFFSET_SAVE
+
+        switch (item) {
+          case ZOFFSET_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else {
+              liveadjust = false;
+              TERN_(HAS_LEVELING, set_bed_leveling_enabled(level_state));
+              Draw_Menu(Prepare, PREPARE_ZOFFSET);
+            }
+            break;
+          case ZOFFSET_HOME:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Homing, "Home Z Axis");
+            else {
+              Popup_Handler(Home);
+              gcode.process_subcommands_now_P(PSTR("G28 Z"));
+              Popup_Handler(MoveWait);
+              #if ENABLED(Z_SAFE_HOMING)
+                planner.synchronize();
+                sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
+                gcode.process_subcommands_now_P(cmd);
+              #else
+                gcode.process_subcommands_now_P(PSTR("G0 F4000 X117.5 Y117.5"));
+              #endif
+              gcode.process_subcommands_now_P(PSTR("G0 F300 Z0"));
+              planner.synchronize();
+              Redraw_Menu();
+            }
+            break;
+          case ZOFFSET_MODE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Zoffset, "Live Adjustment");
+              Draw_Checkbox(row, liveadjust);
+            }
+            else {
+              if (!liveadjust) {
+                if (axes_should_home()) {
+                  Popup_Handler(Home);
+                  gcode.home_all_axes(true);
+                }
+                Popup_Handler(MoveWait);
+                #if ENABLED(Z_SAFE_HOMING)
+                  planner.synchronize();
+                  sprintf_P(cmd, PSTR("G0 F4000 X%s Y%s"), dtostrf(Z_SAFE_HOMING_X_POINT, 1, 3, str_1), dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 3, str_2));
+                  gcode.process_subcommands_now_P(cmd);
+                #else
+                  gcode.process_subcommands_now_P(PSTR("G0 F4000 X117.5 Y117.5"));
+                #endif
+                gcode.process_subcommands_now_P(PSTR("G0 F300 Z0"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+              liveadjust = !liveadjust;
+              Draw_Checkbox(row, liveadjust);
+            }
+            break;
+          case ZOFFSET_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, "Z Offset");
+              Draw_Float(zoffsetvalue, row, false, 100);
+            }
+            else
+              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          case ZOFFSET_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+            else {
+              if (zoffsetvalue < MAX_Z_OFFSET) {
+                if (liveadjust) {
+                  gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+                  planner.synchronize();
+                }
+                zoffsetvalue += 0.01;
+                Draw_Float(zoffsetvalue, row - 1, false, 100);
+              }
+            }
+            break;
+          case ZOFFSET_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
+            else {
+              if (zoffsetvalue > MIN_Z_OFFSET) {
+                if (liveadjust) {
+                  gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+                  planner.synchronize();
+                }
+                zoffsetvalue -= 0.01;
+                Draw_Float(zoffsetvalue, row - 2, false, 100);
+              }
+            }
+            break;
+          #if ENABLED(EEPROM_SETTINGS)
+            case ZOFFSET_SAVE:
+              if (draw)
+                Draw_Menu_Item(row, ICON_WriteEEPROM, "Save");
+              else
+                AudioFeedback(settings.save());
+              break;
+          #endif
+        }
+        break;
+    #endif
+    #if HAS_PREHEAT
+      case Preheat:
+
+        #define PREHEAT_BACK 0
+        #define PREHEAT_MODE (PREHEAT_BACK + 1)
+        #define PREHEAT_1 (PREHEAT_MODE + (PREHEAT_COUNT >= 1))
+        #define PREHEAT_2 (PREHEAT_1 + (PREHEAT_COUNT >= 2))
+        #define PREHEAT_3 (PREHEAT_2 + (PREHEAT_COUNT >= 3))
+        #define PREHEAT_4 (PREHEAT_3 + (PREHEAT_COUNT >= 4))
+        #define PREHEAT_5 (PREHEAT_4 + (PREHEAT_COUNT >= 5))
+        #define PREHEAT_TOTAL PREHEAT_5
+
+        switch (item) {
+          case PREHEAT_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(Prepare, PREPARE_PREHEAT);
+            break;
+          case PREHEAT_MODE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Homing, "Preheat Mode");
+              Draw_Option(preheatmode, preheat_modes, row);
+            }
+            else
+              Modify_Option(preheatmode, preheat_modes, 2);
+            break;
+
+          #if PREHEAT_COUNT >= 1
+            case PREHEAT_1:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_1_LABEL);
+              else {
+                thermalManager.disable_all_heaters();
+                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+                if (preheatmode == 0 || preheatmode == 1) {
+                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[0].hotend_temp, 0));
+                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[0].fan_speed));
+                }
+                #if HAS_HEATED_BED
+                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[0].bed_temp);
+                #endif
+              }
+              break;
+          #endif
+
+          #if PREHEAT_COUNT >= 2
+            case PREHEAT_2:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_2_LABEL);
+              else {
+                thermalManager.disable_all_heaters();
+                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+                if (preheatmode == 0 || preheatmode == 1) {
+                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[1].hotend_temp, 0));
+                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[1].fan_speed));
+                }
+                #if HAS_HEATED_BED
+                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[1].bed_temp);
+                #endif
+              }
+              break;
+          #endif
+
+          #if PREHEAT_COUNT >= 3
+            case PREHEAT_3:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_3_LABEL);
+              else {
+                thermalManager.disable_all_heaters();
+                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+                if (preheatmode == 0 || preheatmode == 1) {
+                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[2].hotend_temp, 0));
+                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[2].fan_speed));
+                }
+                #if HAS_HEATED_BED
+                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[2].bed_temp);
+                #endif
+              }
+              break;
+          #endif
+
+          #if PREHEAT_COUNT >= 4
+            case PREHEAT_4:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_4_LABEL);
+              else {
+                thermalManager.disable_all_heaters();
+                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+                if (preheatmode == 0 || preheatmode == 1) {
+                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[3].hotend_temp, 0));
+                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[3].fan_speed));
+                }
+                #if HAS_HEATED_BED
+                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[3].bed_temp);
+                #endif
+              }
+              break;
+          #endif
+
+          #if PREHEAT_COUNT >= 5
+            case PREHEAT_5:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_5_LABEL);
+              else {
+                thermalManager.disable_all_heaters();
+                TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+                if (preheatmode == 0 || preheatmode == 1) {
+                  TERN_(HAS_HOTEND, thermalManager.setTargetHotend(ui.material_preset[4].hotend_temp, 0));
+                  TERN_(HAS_FAN, thermalManager.set_fan_speed(0, ui.material_preset[4].fan_speed));
+                }
+                #if HAS_HEATED_BED
+                  if (preheatmode == 0 || preheatmode == 2) thermalManager.setTargetBed(ui.material_preset[4].bed_temp);
+                #endif
+              }
+              break;
+          #endif
+        }
+        break;
+    #endif
+
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      case ChangeFilament:
+
+        #define CHANGEFIL_BACK 0
+        #define CHANGEFIL_LOAD (CHANGEFIL_BACK + 1)
+        #define CHANGEFIL_UNLOAD (CHANGEFIL_LOAD + 1)
+        #define CHANGEFIL_CHANGE (CHANGEFIL_UNLOAD + 1)
+        #define CHANGEFIL_TOTAL CHANGEFIL_CHANGE
+
+        switch (item) {
+          case CHANGEFIL_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(Prepare, PREPARE_CHANGEFIL);
+            break;
+          case CHANGEFIL_LOAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_WriteEEPROM, "Load Filament");
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                Popup_Handler(ETemp);
+              else {
+                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                }
+                Popup_Handler(FilLoad);
+                gcode.process_subcommands_now_P(PSTR("M701"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+            }
+            break;
+          case CHANGEFIL_UNLOAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ReadEEPROM, "Unload Filament");
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp) {
+                Popup_Handler(ETemp);
+              }
+              else {
+                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                }
+                Popup_Handler(FilLoad, true);
+                gcode.process_subcommands_now_P(PSTR("M702"));
+                planner.synchronize();
+                Redraw_Menu();
+              }
+            }
+            break;
+          case CHANGEFIL_CHANGE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament");
+            else {
+              if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+                Popup_Handler(ETemp);
+              else {
+                if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                  Popup_Handler(Heating);
+                  thermalManager.wait_for_hotend(0);
+                }
+                Popup_Handler(FilChange);
+                sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                gcode.process_subcommands_now_P(cmd);
+              }
+            }
+            break;
+        }
+        break;
+    #endif // FILAMENT_LOAD_UNLOAD_GCODES
+
+    case Control:
+
+      #define CONTROL_BACK 0
+      #define CONTROL_TEMP (CONTROL_BACK + 1)
+      #define CONTROL_MOTION (CONTROL_TEMP + 1)
+      #define CONTROL_VISUAL (CONTROL_MOTION + 1)
+      #define CONTROL_ADVANCED (CONTROL_VISUAL + 1)
+      #define CONTROL_SAVE (CONTROL_ADVANCED + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_RESTORE (CONTROL_SAVE + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_RESET (CONTROL_RESTORE + ENABLED(EEPROM_SETTINGS))
+      #define CONTROL_INFO (CONTROL_RESET + 1)
+      #define CONTROL_TOTAL CONTROL_INFO
+
+      switch (item) {
+        case CONTROL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Main_Menu(2);
+          break;
+        case CONTROL_TEMP:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Temperature, "Temperature", nullptr, true);
+          else
+            Draw_Menu(TempMenu);
+          break;
+        case CONTROL_MOTION:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Motion, "Motion", nullptr, true);
+          else
+            Draw_Menu(Motion);
+          break;
+        case CONTROL_VISUAL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_PrintSize, "Visual", nullptr, true);
+          else
+            Draw_Menu(Visual);
+          break;
+        case CONTROL_ADVANCED:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Version, "Advanced", nullptr, true);
+          else
+            Draw_Menu(Advanced);
+          break;
+        #if ENABLED(EEPROM_SETTINGS)
+          case CONTROL_SAVE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_WriteEEPROM, "Store Settings");
+            else
+              AudioFeedback(settings.save());
+            break;
+          case CONTROL_RESTORE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ReadEEPROM, "Restore Settings");
+            else
+              AudioFeedback(settings.load());
+            break;
+          case CONTROL_RESET:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Temperature, "Reset to Defaults");
+            else {
+              settings.reset();
+              AudioFeedback();
+            }
+            break;
+        #endif
+        case CONTROL_INFO:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Info, "Info");
+          else
+            Draw_Menu(Info);
+          break;
+      }
+      break;
+
+    case TempMenu:
+
+      #define TEMP_BACK 0
+      #define TEMP_HOTEND (TEMP_BACK + ENABLED(HAS_HOTEND))
+      #define TEMP_BED (TEMP_HOTEND + ENABLED(HAS_HEATED_BED))
+      #define TEMP_FAN (TEMP_BED + ENABLED(HAS_FAN))
+      #define TEMP_PID (TEMP_FAN + ANY(HAS_HOTEND, HAS_HEATED_BED))
+      #define TEMP_PREHEAT1 (TEMP_PID + (PREHEAT_COUNT >= 1))
+      #define TEMP_PREHEAT2 (TEMP_PREHEAT1 + (PREHEAT_COUNT >= 2))
+      #define TEMP_PREHEAT3 (TEMP_PREHEAT2 + (PREHEAT_COUNT >= 3))
+      #define TEMP_PREHEAT4 (TEMP_PREHEAT3 + (PREHEAT_COUNT >= 4))
+      #define TEMP_PREHEAT5 (TEMP_PREHEAT4 + (PREHEAT_COUNT >= 5))
+      #define TEMP_TOTAL TEMP_PREHEAT5
+
+      switch (item) {
+        case TEMP_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Control, CONTROL_TEMP);
+          break;
+        #if HAS_HOTEND
+          case TEMP_HOTEND:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+        #endif
+        #if HAS_HEATED_BED
+          case TEMP_BED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+        #endif
+        #if HAS_FAN
+          case TEMP_FAN:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+            break;
+        #endif
+        #if HAS_HOTEND || HAS_HEATED_BED
+          case TEMP_PID:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, "PID", nullptr, true);
+            else
+              Draw_Menu(PID);
+            break;
+        #endif
+        #if PREHEAT_COUNT >= 1
+          case TEMP_PREHEAT1:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, PREHEAT_1_LABEL, nullptr, true);
+            else
+              Draw_Menu(Preheat1);
+            break;
+        #endif
+        #if PREHEAT_COUNT >= 2
+          case TEMP_PREHEAT2:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, PREHEAT_2_LABEL, nullptr, true);
+            else
+              Draw_Menu(Preheat2);
+            break;
+        #endif
+        #if PREHEAT_COUNT >= 3
+          case TEMP_PREHEAT3:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, PREHEAT_3_LABEL, nullptr, true);
+            else
+              Draw_Menu(Preheat3);
+            break;
+        #endif
+        #if PREHEAT_COUNT >= 4
+          case TEMP_PREHEAT4:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, PREHEAT_4_LABEL, nullptr, true);
+            else
+              Draw_Menu(Preheat4);
+            break;
+        #endif
+        #if PREHEAT_COUNT >= 5
+          case TEMP_PREHEAT5:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, PREHEAT_5_LABEL, nullptr, true);
+            else
+              Draw_Menu(Preheat5);
+            break;
+        #endif
+      }
+      break;
+
+    #if HAS_HOTEND || HAS_HEATED_BED
+      case PID:
+
+        #define PID_BACK 0
+        #define PID_HOTEND (PID_BACK + ENABLED(HAS_HOTEND))
+        #define PID_BED (PID_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PID_CYCLES (PID_BED + 1)
+        #define PID_TOTAL PID_CYCLES
+
+        static uint8_t PID_cycles = 5;
+
+        switch (item) {
+          case PID_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(TempMenu, TEMP_PID);
+            break;
+          #if HAS_HOTEND
+            case PID_HOTEND:
+              if (draw)
+                Draw_Menu_Item(row, ICON_HotendTemp, "Hotend", nullptr, true);
+              else
+                Draw_Menu(HotendPID);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PID_BED:
+              if (draw)
+                Draw_Menu_Item(row, ICON_BedTemp, "Bed", nullptr, true);
+              else
+                Draw_Menu(BedPID);
+              break;
+          #endif
+          case PID_CYCLES:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, "Cycles");
+              Draw_Float(PID_cycles, row, false, 1);
+            }
+            else
+              Modify_Value(PID_cycles, 3, 50, 1);
+            break;
+        }
+        break;
+    #endif // HAS_HOTEND || HAS_HEATED_BED
+
+    #if HAS_HOTEND
+      case HotendPID:
+
+        #define HOTENDPID_BACK 0
+        #define HOTENDPID_TUNE (HOTENDPID_BACK + 1)
+        #define HOTENDPID_TEMP (HOTENDPID_TUNE + 1)
+        #define HOTENDPID_KP (HOTENDPID_TEMP + 1)
+        #define HOTENDPID_KI (HOTENDPID_KP + 1)
+        #define HOTENDPID_KD (HOTENDPID_KI + 1)
+        #define HOTENDPID_TOTAL HOTENDPID_KD
+
+        static uint16_t PID_e_temp = 180;
+
+        switch (item) {
+          case HOTENDPID_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(PID, PID_HOTEND);
+            break;
+          case HOTENDPID_TUNE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_HotendTemp, "Autotune");
+            else {
+              Popup_Handler(PIDWait);
+              sprintf_P(cmd, PSTR("M303 E0 C%i S%i U1"), PID_cycles, PID_e_temp);
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+            break;
+          case HOTENDPID_TEMP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Temperature, "Temperature");
+              Draw_Float(PID_e_temp, row, false, 1);
+            }
+            else
+              Modify_Value(PID_e_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+          case HOTENDPID_KP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "Kp Value");
+              Draw_Float(thermalManager.temp_hotend[0].pid.Kp, row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].pid.Kp, 0, 5000, 100, thermalManager.updatePID);
+            break;
+          case HOTENDPID_KI:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "Ki Value");
+              Draw_Float(unscalePID_i(thermalManager.temp_hotend[0].pid.Ki), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+            break;
+          case HOTENDPID_KD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "Kd Value");
+              Draw_Float(unscalePID_d(thermalManager.temp_hotend[0].pid.Kd), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+            break;
+        }
+        break;
+    #endif // HAS_HOTEND
+
+    #if HAS_HEATED_BED
+      case BedPID:
+
+        #define BEDPID_BACK 0
+        #define BEDPID_TUNE (BEDPID_BACK + 1)
+        #define BEDPID_TEMP (BEDPID_TUNE + 1)
+        #define BEDPID_KP (BEDPID_TEMP + 1)
+        #define BEDPID_KI (BEDPID_KP + 1)
+        #define BEDPID_KD (BEDPID_KI + 1)
+        #define BEDPID_TOTAL BEDPID_KD
+
+        static uint16_t PID_bed_temp = 60;
+
+        switch (item) {
+          case BEDPID_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(PID, PID_BED);
+            break;
+          case BEDPID_TUNE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_HotendTemp, "Autotune");
+            else {
+              Popup_Handler(PIDWait);
+              sprintf_P(cmd, PSTR("M303 E-1 C%i S%i U1"), PID_cycles, PID_bed_temp);
+              gcode.process_subcommands_now_P(cmd);
+              planner.synchronize();
+              Redraw_Menu();
+            }
+            break;
+          case BEDPID_TEMP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Temperature, "Temperature");
+              Draw_Float(PID_bed_temp, row, false, 1);
+            }
+            else
+              Modify_Value(PID_bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+          case BEDPID_KP:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "Kp Value");
+              Draw_Float(thermalManager.temp_bed.pid.Kp, row, false, 100);
+            }
+            else {
+              Modify_Value(thermalManager.temp_bed.pid.Kp, 0, 5000, 100, thermalManager.updatePID);
+            }
+            break;
+          case BEDPID_KI:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "Ki Value");
+              Draw_Float(unscalePID_i(thermalManager.temp_bed.pid.Ki), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.pid.Ki, 0, 5000, 100, thermalManager.updatePID);
+            break;
+          case BEDPID_KD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Version, "Kd Value");
+              Draw_Float(unscalePID_d(thermalManager.temp_bed.pid.Kd), row, false, 100);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.pid.Kd, 0, 5000, 100, thermalManager.updatePID);
+            break;
+        }
+        break;
+    #endif // HAS_HEATED_BED
+
+    #if PREHEAT_COUNT >= 1
+      case Preheat1:
+
+        #define PREHEAT1_BACK 0
+        #define PREHEAT1_HOTEND (PREHEAT1_BACK + ENABLED(HAS_HOTEND))
+        #define PREHEAT1_BED (PREHEAT1_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PREHEAT1_FAN (PREHEAT1_BED + ENABLED(HAS_FAN))
+        #define PREHEAT1_TOTAL PREHEAT1_FAN
+
+        switch (item) {
+          case PREHEAT1_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(TempMenu, TEMP_PREHEAT1);
+            break;
+          #if HAS_HOTEND
+            case PREHEAT1_HOTEND:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Float(ui.material_preset[0].hotend_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[0].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PREHEAT1_BED:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Float(ui.material_preset[0].bed_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[0].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              break;
+          #endif
+          #if HAS_FAN
+            case PREHEAT1_FAN:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Float(ui.material_preset[0].fan_speed, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[0].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              break;
+          #endif
+        }
+        break;
+    #endif // PREHEAT_COUNT >= 1
+
+    #if PREHEAT_COUNT >= 2
+      case Preheat2:
+
+        #define PREHEAT2_BACK 0
+        #define PREHEAT2_HOTEND (PREHEAT2_BACK + ENABLED(HAS_HOTEND))
+        #define PREHEAT2_BED (PREHEAT2_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PREHEAT2_FAN (PREHEAT2_BED + ENABLED(HAS_FAN))
+        #define PREHEAT2_TOTAL PREHEAT2_FAN
+
+        switch (item) {
+          case PREHEAT2_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(TempMenu, TEMP_PREHEAT2);
+            break;
+          #if HAS_HOTEND
+            case PREHEAT2_HOTEND:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Float(ui.material_preset[1].hotend_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[1].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PREHEAT2_BED:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Float(ui.material_preset[1].bed_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[1].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              break;
+          #endif
+          #if HAS_FAN
+            case PREHEAT2_FAN:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Float(ui.material_preset[1].fan_speed, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[1].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              break;
+          #endif
+        }
+        break;
+    #endif // PREHEAT_COUNT >= 2
+
+    #if PREHEAT_COUNT >= 3
+      case Preheat3:
+
+        #define PREHEAT3_BACK 0
+        #define PREHEAT3_HOTEND (PREHEAT3_BACK + ENABLED(HAS_HOTEND))
+        #define PREHEAT3_BED (PREHEAT3_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PREHEAT3_FAN (PREHEAT3_BED + ENABLED(HAS_FAN))
+        #define PREHEAT3_TOTAL PREHEAT3_FAN
+
+        switch (item) {
+          case PREHEAT3_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(TempMenu, TEMP_PREHEAT3);
+            break;
+          #if HAS_HOTEND
+            case PREHEAT3_HOTEND:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Float(ui.material_preset[2].hotend_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[2].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PREHEAT3_BED:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Float(ui.material_preset[2].bed_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[2].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              break;
+          #endif
+          #if HAS_FAN
+            case PREHEAT3_FAN:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Float(ui.material_preset[2].fan_speed, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[2].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              break;
+          #endif
+        }
+        break;
+    #endif // PREHEAT_COUNT >= 3
+
+    #if PREHEAT_COUNT >= 4
+      case Preheat4:
+
+        #define PREHEAT4_BACK 0
+        #define PREHEAT4_HOTEND (PREHEAT4_BACK + ENABLED(HAS_HOTEND))
+        #define PREHEAT4_BED (PREHEAT4_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PREHEAT4_FAN (PREHEAT4_BED + ENABLED(HAS_FAN))
+        #define PREHEAT4_TOTAL PREHEAT4_FAN
+
+        switch (item) {
+          case PREHEAT4_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(TempMenu, TEMP_PREHEAT4);
+            break;
+          #if HAS_HOTEND
+            case PREHEAT4_HOTEND:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Float(ui.material_preset[3].hotend_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[3].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PREHEAT4_BED:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Float(ui.material_preset[3].bed_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[3].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              break;
+          #endif
+          #if HAS_FAN
+            case PREHEAT4_FAN:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Float(ui.material_preset[3].fan_speed, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[3].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              break;
+          #endif
+        }
+        break;
+    #endif // PREHEAT_COUNT >= 4
+
+    #if PREHEAT_COUNT >= 5
+      case Preheat5:
+
+        #define PREHEAT5_BACK 0
+        #define PREHEAT5_HOTEND (PREHEAT5_BACK + ENABLED(HAS_HOTEND))
+        #define PREHEAT5_BED (PREHEAT5_HOTEND + ENABLED(HAS_HEATED_BED))
+        #define PREHEAT5_FAN (PREHEAT5_BED + ENABLED(HAS_FAN))
+        #define PREHEAT5_TOTAL PREHEAT5_FAN
+
+        switch (item) {
+          case PREHEAT5_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(TempMenu, TEMP_PREHEAT5);
+            break;
+          #if HAS_HOTEND
+            case PREHEAT5_HOTEND:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+                Draw_Float(ui.material_preset[4].hotend_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[4].hotend_temp, MIN_E_TEMP, MAX_E_TEMP, 1);
+              break;
+          #endif
+          #if HAS_HEATED_BED
+            case PREHEAT5_BED:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+                Draw_Float(ui.material_preset[4].bed_temp, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[4].bed_temp, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+              break;
+          #endif
+          #if HAS_FAN
+            case PREHEAT5_FAN:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+                Draw_Float(ui.material_preset[4].fan_speed, row, false, 1);
+              }
+              else
+                Modify_Value(ui.material_preset[4].fan_speed, MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+              break;
+          #endif
+        }
+        break;
+    #endif // PREHEAT_COUNT >= 5
+
+    case Motion:
+
+      #define MOTION_BACK 0
+      #define MOTION_HOMEOFFSETS (MOTION_BACK + 1)
+      #define MOTION_SPEED (MOTION_HOMEOFFSETS + 1)
+      #define MOTION_ACCEL (MOTION_SPEED + 1)
+      #define MOTION_JERK (MOTION_ACCEL + ENABLED(HAS_CLASSIC_JERK))
+      #define MOTION_STEPS (MOTION_JERK + 1)
+      #define MOTION_FLOW (MOTION_STEPS + ENABLED(HAS_HOTEND))
+      #define MOTION_TOTAL MOTION_FLOW
+
+      switch (item) {
+        case MOTION_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Control, CONTROL_MOTION);
+          break;
+        case MOTION_HOMEOFFSETS:
+          if (draw)
+            Draw_Menu_Item(row, ICON_SetHome, "Home Offsets", nullptr, true);
+          else
+            Draw_Menu(HomeOffsets);
+          break;
+        case MOTION_SPEED:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Max Speed", nullptr, true);
+          else
+            Draw_Menu(MaxSpeed);
+          break;
+        case MOTION_ACCEL:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MaxAccelerated, "Max Acceleration", nullptr, true);
+          else
+            Draw_Menu(MaxAcceleration);
+          break;
+        #if HAS_CLASSIC_JERK
+          case MOTION_JERK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_MaxJerk, "Max Jerk", nullptr, true);
+            else
+              Draw_Menu(MaxJerk);
+            break;
+        #endif
+        case MOTION_STEPS:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Step, "Steps/mm", nullptr, true);
+          else
+            Draw_Menu(Steps);
+          break;
+        #if HAS_HOTEND
+          case MOTION_FLOW:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Speed, "Flow Rate");
+              Draw_Float(planner.flow_percentage[0], row, false, 1);
+            }
+            else
+              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
+            break;
+        #endif
+      }
+      break;
+
+    case HomeOffsets:
+
+      #define HOMEOFFSETS_BACK 0
+      #define HOMEOFFSETS_XOFFSET (HOMEOFFSETS_BACK + 1)
+      #define HOMEOFFSETS_YOFFSET (HOMEOFFSETS_XOFFSET + 1)
+      #define HOMEOFFSETS_TOTAL HOMEOFFSETS_YOFFSET
+
+      switch (item) {
+        case HOMEOFFSETS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Motion, MOTION_HOMEOFFSETS);
+          break;
+        case HOMEOFFSETS_XOFFSET:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepX, "X Offset");
+            Draw_Float(home_offset.x, row, false, 100);
+          }
+          else
+            Modify_Value(home_offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+          break;
+        case HOMEOFFSETS_YOFFSET:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepY, "Y Offset");
+            Draw_Float(home_offset.y, row, false, 100);
+          }
+          else
+            Modify_Value(home_offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 100);
+          break;
+      }
+      break;
+    case MaxSpeed:
+
+      #define SPEED_BACK 0
+      #define SPEED_X (SPEED_BACK + 1)
+      #define SPEED_Y (SPEED_X + 1)
+      #define SPEED_Z (SPEED_Y + 1)
+      #define SPEED_E (SPEED_Z + ENABLED(HAS_HOTEND))
+      #define SPEED_TOTAL SPEED_E
+
+      switch (item) {
+        case SPEED_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Motion, MOTION_SPEED);
+          break;
+        case SPEED_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeedX, "X Axis");
+            Draw_Float(planner.settings.max_feedrate_mm_s[X_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_feedrate_mm_s[X_AXIS], 0, default_max_feedrate[X_AXIS] * 2, 1);
+          break;
+
+        #if HAS_Y_AXIS
+          case SPEED_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedY, "Y Axis");
+              Draw_Float(planner.settings.max_feedrate_mm_s[Y_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[Y_AXIS], 0, default_max_feedrate[Y_AXIS] * 2, 1);
+            break;
+        #endif
+
+        #if HAS_Z_AXIS
+          case SPEED_Z:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedZ, "Z Axis");
+              Draw_Float(planner.settings.max_feedrate_mm_s[Z_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[Z_AXIS], 0, default_max_feedrate[Z_AXIS] * 2, 1);
+            break;
+        #endif
+
+        #if HAS_HOTEND
+          case SPEED_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedE, "Extruder");
+              Draw_Float(planner.settings.max_feedrate_mm_s[E_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_feedrate_mm_s[E_AXIS], 0, default_max_feedrate[E_AXIS] * 2, 1);
+            break;
+        #endif
+      }
+      break;
+
+    case MaxAcceleration:
+
+      #define ACCEL_BACK 0
+      #define ACCEL_X (ACCEL_BACK + 1)
+      #define ACCEL_Y (ACCEL_X + 1)
+      #define ACCEL_Z (ACCEL_Y + 1)
+      #define ACCEL_E (ACCEL_Z + ENABLED(HAS_HOTEND))
+      #define ACCEL_TOTAL ACCEL_E
+
+      switch (item) {
+        case ACCEL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Motion, MOTION_ACCEL);
+          break;
+        case ACCEL_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccX, "X Axis");
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[X_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[X_AXIS], 0, default_max_acceleration[X_AXIS] * 2, 1);
+          break;
+        case ACCEL_Y:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccY, "Y Axis");
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Y_AXIS], 0, default_max_acceleration[Y_AXIS] * 2, 1);
+          break;
+        case ACCEL_Z:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccZ, "Z Axis");
+            Draw_Float(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], row, false, 1);
+          }
+          else
+            Modify_Value(planner.settings.max_acceleration_mm_per_s2[Z_AXIS], 0, default_max_acceleration[Z_AXIS] * 2, 1);
+          break;
+        #if HAS_HOTEND
+          case ACCEL_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxAccE, "Extruder");
+              Draw_Float(planner.settings.max_acceleration_mm_per_s2[E_AXIS], row, false, 1);
+            }
+            else
+              Modify_Value(planner.settings.max_acceleration_mm_per_s2[E_AXIS], 0, default_max_acceleration[E_AXIS] * 2, 1);
+            break;
+        #endif
+      }
+      break;
+    #if HAS_CLASSIC_JERK
+      case MaxJerk:
+
+        #define JERK_BACK 0
+        #define JERK_X (JERK_BACK + 1)
+        #define JERK_Y (JERK_X + 1)
+        #define JERK_Z (JERK_Y + 1)
+        #define JERK_E (JERK_Z + ENABLED(HAS_HOTEND))
+        #define JERK_TOTAL JERK_E
+
+        switch (item) {
+          case JERK_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(Motion, MOTION_JERK);
+            break;
+          case JERK_X:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkX, "X Axis");
+              Draw_Float(planner.max_jerk[X_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.max_jerk[X_AXIS], 0, default_max_jerk[X_AXIS] * 2, 10);
+            break;
+          case JERK_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkY, "Y Axis");
+              Draw_Float(planner.max_jerk[Y_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.max_jerk[Y_AXIS], 0, default_max_jerk[Y_AXIS] * 2, 10);
+            break;
+          case JERK_Z:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxSpeedJerkZ, "Z Axis");
+              Draw_Float(planner.max_jerk[Z_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.max_jerk[Z_AXIS], 0, default_max_jerk[Z_AXIS] * 2, 10);
+            break;
+          #if HAS_HOTEND
+            case JERK_E:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxSpeedJerkE, "Extruder");
+                Draw_Float(planner.max_jerk[E_AXIS], row, false, 10);
+              }
+              else
+                Modify_Value(planner.max_jerk[E_AXIS], 0, default_max_jerk[E_AXIS] * 2, 10);
+              break;
+          #endif
+        }
+        break;
+    #endif
+    case Steps:
+
+      #define STEPS_BACK 0
+      #define STEPS_X (STEPS_BACK + 1)
+      #define STEPS_Y (STEPS_X + 1)
+      #define STEPS_Z (STEPS_Y + 1)
+      #define STEPS_E (STEPS_Z + ENABLED(HAS_HOTEND))
+      #define STEPS_TOTAL STEPS_E
+
+      switch (item) {
+        case STEPS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Motion, MOTION_STEPS);
+          break;
+        case STEPS_X:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepX, "X Axis");
+            Draw_Float(planner.settings.axis_steps_per_mm[X_AXIS], row, false, 10);
+          }
+          else
+            Modify_Value(planner.settings.axis_steps_per_mm[X_AXIS], 0, default_steps[X_AXIS] * 2, 10);
+          break;
+        case STEPS_Y:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepY, "Y Axis");
+            Draw_Float(planner.settings.axis_steps_per_mm[Y_AXIS], row, false, 10);
+          }
+          else
+            Modify_Value(planner.settings.axis_steps_per_mm[Y_AXIS], 0, default_steps[Y_AXIS] * 2, 10);
+          break;
+        case STEPS_Z:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_StepZ, "Z Axis");
+            Draw_Float(planner.settings.axis_steps_per_mm[Z_AXIS], row, false, 10);
+          }
+          else
+            Modify_Value(planner.settings.axis_steps_per_mm[Z_AXIS], 0, default_steps[Z_AXIS] * 2, 10);
+          break;
+        #if HAS_HOTEND
+          case STEPS_E:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StepE, "Extruder");
+              Draw_Float(planner.settings.axis_steps_per_mm[E_AXIS], row, false, 10);
+            }
+            else
+              Modify_Value(planner.settings.axis_steps_per_mm[E_AXIS], 0, 1000, 10);
+            break;
+        #endif
+      }
+      break;
+
+    case Visual:
+
+      #define VISUAL_BACK 0
+      #define VISUAL_BACKLIGHT (VISUAL_BACK + 1)
+      #define VISUAL_BRIGHTNESS (VISUAL_BACKLIGHT + 1)
+      #define VISUAL_TIME_FORMAT (VISUAL_BRIGHTNESS + 1)
+      #define VISUAL_COLOR_THEMES (VISUAL_TIME_FORMAT + 1)
+      #define VISUAL_TOTAL VISUAL_COLOR_THEMES
+
+      switch (item) {
+        case VISUAL_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Control, CONTROL_VISUAL);
+          break;
+        case VISUAL_BACKLIGHT:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Brightness, "Display Off");
+          else
+            ui.set_brightness(0);
+          break;
+        case VISUAL_BRIGHTNESS:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Brightness, "LCD Brightness");
+            Draw_Float(ui.brightness, row, false, 1);
+          }
+          else
+            Modify_Value(ui.brightness, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS, 1, ui.refresh_brightness);
+          break;
+        case VISUAL_TIME_FORMAT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_PrintTime, "Progress as __h__m");
+            Draw_Checkbox(row, eeprom_settings.time_format_textual);
+          }
+          else {
+            eeprom_settings.time_format_textual = !eeprom_settings.time_format_textual;
+            Draw_Checkbox(row, eeprom_settings.time_format_textual);
+          }
+          break;
+        case VISUAL_COLOR_THEMES:
+          if (draw)
+            Draw_Menu_Item(row, ICON_MaxSpeed, "UI Color Settings", nullptr, true);
+          else
+            Draw_Menu(ColorSettings);
+        break;
+      }
+      break;
+
+    case ColorSettings:
+
+      #define COLORSETTINGS_BACK 0
+      #define COLORSETTINGS_CURSOR (COLORSETTINGS_BACK + 1)
+      #define COLORSETTINGS_SPLIT_LINE (COLORSETTINGS_CURSOR + 1)
+      #define COLORSETTINGS_MENU_TOP_TXT (COLORSETTINGS_SPLIT_LINE + 1)
+      #define COLORSETTINGS_MENU_TOP_BG (COLORSETTINGS_MENU_TOP_TXT + 1)
+      #define COLORSETTINGS_HIGHLIGHT_BORDER (COLORSETTINGS_MENU_TOP_BG + 1)
+      #define COLORSETTINGS_PROGRESS_PERCENT (COLORSETTINGS_HIGHLIGHT_BORDER + 1)
+      #define COLORSETTINGS_PROGRESS_TIME (COLORSETTINGS_PROGRESS_PERCENT + 1)
+      #define COLORSETTINGS_PROGRESS_STATUS_BAR (COLORSETTINGS_PROGRESS_TIME + 1)
+      #define COLORSETTINGS_PROGRESS_STATUS_AREA (COLORSETTINGS_PROGRESS_STATUS_BAR + 1)
+      #define COLORSETTINGS_PROGRESS_COORDINATES (COLORSETTINGS_PROGRESS_STATUS_AREA + 1)
+      #define COLORSETTINGS_PROGRESS_COORDINATES_LINE (COLORSETTINGS_PROGRESS_COORDINATES + 1)
+      #define COLORSETTINGS_TOTAL COLORSETTINGS_PROGRESS_COORDINATES_LINE
+
+      switch (item) {
+        case COLORSETTINGS_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Visual, VISUAL_COLOR_THEMES);
+          break;
+        case COLORSETTINGS_CURSOR:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Cursor");
+            Draw_Option(eeprom_settings.cursor_color, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.cursor_color, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_SPLIT_LINE:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Menu Split Line");
+            Draw_Option(eeprom_settings.menu_split_line, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.menu_split_line, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_MENU_TOP_TXT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Menu Header Text");
+            Draw_Option(eeprom_settings.menu_top_txt, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.menu_top_txt, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_MENU_TOP_BG:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Menu Header Bg");
+            Draw_Option(eeprom_settings.menu_top_bg, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.menu_top_bg, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_HIGHLIGHT_BORDER:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Highlight Box");
+            Draw_Option(eeprom_settings.highlight_box, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.highlight_box, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_PERCENT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Progress Percent");
+            Draw_Option(eeprom_settings.progress_percent, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.progress_percent, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_TIME:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Progress Time");
+            Draw_Option(eeprom_settings.progress_time, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.progress_time, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_STATUS_BAR:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Status Bar Text");
+            Draw_Option(eeprom_settings.status_bar_text, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.status_bar_text, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_STATUS_AREA:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Status Area Text");
+            Draw_Option(eeprom_settings.status_area_text, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.status_area_text, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_COORDINATES:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Coordinates Text");
+            Draw_Option(eeprom_settings.coordinates_text, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.coordinates_text, color_names, Custom_Colors);
+          break;
+        case COLORSETTINGS_PROGRESS_COORDINATES_LINE:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxSpeed, "Coordinates Line");
+            Draw_Option(eeprom_settings.coordinates_split_line, color_names, row, false, true);
+          }
+          else
+            Modify_Option(eeprom_settings.coordinates_split_line, color_names, Custom_Colors);
+          break;
+      } // switch (item)
+      break;
+
+    case Advanced:
+
+      #define ADVANCED_BACK 0
+      #define ADVANCED_BEEPER (ADVANCED_BACK + 1)
+      #define ADVANCED_PROBE (ADVANCED_BEEPER + ENABLED(HAS_BED_PROBE))
+      #define ADVANCED_CORNER (ADVANCED_PROBE + 1)
+      #define ADVANCED_LA (ADVANCED_CORNER + ENABLED(LIN_ADVANCE))
+      #define ADVANCED_LOAD (ADVANCED_LA + ENABLED(ADVANCED_PAUSE_FEATURE))
+      #define ADVANCED_UNLOAD (ADVANCED_LOAD + ENABLED(ADVANCED_PAUSE_FEATURE))
+      #define ADVANCED_COLD_EXTRUDE  (ADVANCED_UNLOAD + ENABLED(PREVENT_COLD_EXTRUSION))
+      #define ADVANCED_FILSENSORENABLED (ADVANCED_COLD_EXTRUDE + ENABLED(FILAMENT_RUNOUT_SENSOR))
+      #define ADVANCED_FILSENSORDISTANCE (ADVANCED_FILSENSORENABLED + ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE))
+      #define ADVANCED_POWER_LOSS (ADVANCED_FILSENSORDISTANCE + ENABLED(POWER_LOSS_RECOVERY))
+      #define ADVANCED_TOTAL ADVANCED_POWER_LOSS
+
+      switch (item) {
+        case ADVANCED_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Menu(Control, CONTROL_ADVANCED);
+          break;
+
+        case ADVANCED_BEEPER:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Version, "LCD Beeper");
+            Draw_Checkbox(row, eeprom_settings.beeperenable);
+          }
+          else {
+            eeprom_settings.beeperenable = !eeprom_settings.beeperenable;
+            Draw_Checkbox(row, eeprom_settings.beeperenable);
+          }
+          break;
+
+        #if HAS_BED_PROBE
+          case ADVANCED_PROBE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_StepX, "Probe", nullptr, true);
+            else
+              Draw_Menu(ProbeMenu);
+            break;
+        #endif
+
+        case ADVANCED_CORNER:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_MaxAccelerated, "Bed Screw Inset");
+            Draw_Float(corner_pos, row, false, 10);
+          }
+          else
+            Modify_Value(corner_pos, 1, 100, 10);
+          break;
+
+        #if ENABLED(LIN_ADVANCE)
+          case ADVANCED_LA:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MaxAccelerated, "Lin Advance Kp");
+              Draw_Float(planner.extruder_advance_K[0], row, false, 100);
+            }
+            else
+              Modify_Value(planner.extruder_advance_K[0], 0, 10, 100);
+            break;
+        #endif
+
+        #if ENABLED(ADVANCED_PAUSE_FEATURE)
+          case ADVANCED_LOAD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_WriteEEPROM, "Load Length");
+              Draw_Float(fc_settings[0].load_length, row, false, 1);
+            }
+            else
+              Modify_Value(fc_settings[0].load_length, 0, EXTRUDE_MAXLENGTH, 1);
+            break;
+          case ADVANCED_UNLOAD:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_ReadEEPROM, "Unload Length");
+              Draw_Float(fc_settings[0].unload_length, row, false, 1);
+            }
+            else
+              Modify_Value(fc_settings[0].unload_length, 0, EXTRUDE_MAXLENGTH, 1);
+            break;
+        #endif // ADVANCED_PAUSE_FEATURE
+
+        #if ENABLED(PREVENT_COLD_EXTRUSION)
+          case ADVANCED_COLD_EXTRUDE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Cool, "Min Extrusion T");
+              Draw_Float(thermalManager.extrude_min_temp, row, false, 1);
+            }
+            else {
+              Modify_Value(thermalManager.extrude_min_temp, 0, MAX_E_TEMP, 1);
+              thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
+            }
+            break;
+        #endif
+
+        #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+          case ADVANCED_FILSENSORENABLED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Extruder, "Filament Sensor");
+              Draw_Checkbox(row, runout.enabled);
+            }
+            else {
+              runout.enabled = !runout.enabled;
+              Draw_Checkbox(row, runout.enabled);
+            }
+            break;
+
+          #if ENABLED(HAS_FILAMENT_RUNOUT_DISTANCE)
+            case ADVANCED_FILSENSORDISTANCE:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_MaxAccE, "Runout Distance");
+                Draw_Float(runout.runout_distance(), row, false, 10);
+              }
+              else
+                Modify_Value(runout.runout_distance(), 0, 999, 10);
+              break;
+          #endif
+        #endif // FILAMENT_RUNOUT_SENSOR
+
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          case ADVANCED_POWER_LOSS:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Motion, "Power-loss recovery");
+              Draw_Checkbox(row, recovery.enabled);
+            }
+            else {
+              recovery.enable(!recovery.enabled);
+              Draw_Checkbox(row, recovery.enabled);
+            }
+            break;
+        #endif
+      }
+      break;
+
+    #if HAS_BED_PROBE
+      case ProbeMenu:
+
+        #define PROBE_BACK 0
+        #define PROBE_XOFFSET (PROBE_BACK + 1)
+        #define PROBE_YOFFSET (PROBE_XOFFSET + 1)
+        #define PROBE_TEST (PROBE_YOFFSET + 1)
+        #define PROBE_TEST_COUNT (PROBE_TEST + 1)
+        #define PROBE_TOTAL PROBE_TEST_COUNT
+
+        static uint8_t testcount = 4;
+
+        switch (item) {
+          case PROBE_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(Advanced, ADVANCED_PROBE);
+            break;
+
+            case PROBE_XOFFSET:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepX, "Probe X Offset");
+                Draw_Float(probe.offset.x, row, false, 10);
+              }
+              else
+                Modify_Value(probe.offset.x, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+              break;
+            case PROBE_YOFFSET:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepY, "Probe Y Offset");
+                Draw_Float(probe.offset.y, row, false, 10);
+              }
+              else
+                Modify_Value(probe.offset.y, -MAX_XY_OFFSET, MAX_XY_OFFSET, 10);
+              break;
+            case PROBE_TEST:
+              if (draw)
+                Draw_Menu_Item(row, ICON_StepY, "M48 Probe Test");
+              else {
+                sprintf_P(cmd, PSTR("G28O\nM48 X%s Y%s P%i"), dtostrf((X_BED_SIZE + X_MIN_POS) / 2.0f, 1, 3, str_1), dtostrf((Y_BED_SIZE + Y_MIN_POS) / 2.0f, 1, 3, str_2), testcount);
+                gcode.process_subcommands_now_P(cmd);
+              }
+              break;
+            case PROBE_TEST_COUNT:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_StepY, "Probe Test Count");
+                Draw_Float(testcount, row, false, 1);
+              }
+              else
+                Modify_Value(testcount, 4, 50, 1);
+              break;
+        }
+        break;
+    #endif
+
+    case InfoMain:
+    case Info:
+
+      #define INFO_BACK 0
+      #define INFO_PRINTCOUNT (INFO_BACK + ENABLED(PRINTCOUNTER))
+      #define INFO_PRINTTIME (INFO_PRINTCOUNT + ENABLED(PRINTCOUNTER))
+      #define INFO_SIZE (INFO_PRINTTIME + 1)
+      #define INFO_VERSION (INFO_SIZE + 1)
+      #define INFO_CONTACT (INFO_VERSION + 1)
+      #define INFO_TOTAL INFO_BACK
+
+      switch (item) {
+        case INFO_BACK:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Back, "Back");
+
+            #if ENABLED(PRINTCOUNTER)
+              char row1[50], row2[50], buf[32];
+              printStatistics ps = print_job_timer.getStats();
+
+              sprintf_P(row1, PSTR("%i prints, %i finished"), ps.totalPrints, ps.finishedPrints);
+              sprintf_P(row2, PSTR("%s m filament used"), dtostrf(ps.filamentUsed / 1000, 1, 2, str_1));
+              Draw_Menu_Item(INFO_PRINTCOUNT, ICON_HotendTemp, row1, row2, false, true);
+
+              duration_t(print_job_timer.getStats().printTime).toString(buf);
+              sprintf_P(row1, PSTR("Printed: %s"), buf);
+              duration_t(print_job_timer.getStats().longestPrint).toString(buf);
+              sprintf_P(row2, PSTR("Longest: %s"), buf);
+              Draw_Menu_Item(INFO_PRINTTIME, ICON_PrintTime, row1, row2, false, true);
+            #endif
+
+            Draw_Menu_Item(INFO_SIZE, ICON_PrintSize, MACHINE_SIZE, nullptr, false, true);
+            Draw_Menu_Item(INFO_VERSION, ICON_Version, SHORT_BUILD_VERSION, nullptr, false, true);
+            Draw_Menu_Item(INFO_CONTACT, ICON_Contact, CORP_WEBSITE, nullptr, false, true);
+          }
+          else {
+            if (menu == Info)
+              Draw_Menu(Control, CONTROL_INFO);
+            else
+              Draw_Main_Menu(3);
+          }
+          break;
+      }
+      break;
+
+    #if HAS_MESH
+      case Leveling:
+
+        #define LEVELING_BACK 0
+        #define LEVELING_ACTIVE (LEVELING_BACK + 1)
+        #define LEVELING_GET_TILT (LEVELING_ACTIVE + BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL))
+        #define LEVELING_GET_MESH (LEVELING_GET_TILT + 1)
+        #define LEVELING_MANUAL (LEVELING_GET_MESH + 1)
+        #define LEVELING_VIEW (LEVELING_MANUAL + 1)
+        #define LEVELING_SETTINGS (LEVELING_VIEW + 1)
+        #define LEVELING_SLOT (LEVELING_SETTINGS + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_LOAD (LEVELING_SLOT + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SAVE (LEVELING_LOAD + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_TOTAL LEVELING_SAVE
+
+        switch (item) {
+          case LEVELING_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Main_Menu(3);
+            break;
+          case LEVELING_ACTIVE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StockConfiguraton, "Leveling Active");
+              Draw_Checkbox(row, planner.leveling_active);
+            }
+            else {
+              if (!planner.leveling_active) {
+                set_bed_leveling_enabled(!planner.leveling_active);
+                if (!planner.leveling_active) {
+                  Confirm_Handler(LevelError);
+                  break;
+                }
+              }
+              else
+                set_bed_leveling_enabled(!planner.leveling_active);
+              Draw_Checkbox(row, planner.leveling_active);
+            }
+            break;
+          #if BOTH(HAS_BED_PROBE, AUTO_BED_LEVELING_UBL)
+            case LEVELING_GET_TILT:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Tilt, "Autotilt Current Mesh");
+              else {
+                if (ubl.storage_slot < 0) {
+                  Popup_Handler(MeshSlot);
+                  break;
+                }
+                Popup_Handler(Home);
+                gcode.home_all_axes(true);
+                Popup_Handler(Level);
+                if (mesh_conf.tilt_grid > 1)
+                  sprintf_P(cmd, PSTR("G29 J%i"), mesh_conf.tilt_grid);
+                else
+                  sprintf_P(cmd, PSTR("G29 J"));
+                gcode.process_subcommands_now_P(cmd);
+                planner.synchronize();
+                Redraw_Menu();
+              }
+              break;
+          #endif
+          case LEVELING_GET_MESH:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Mesh, "Create New Mesh");
+            else {
+              Popup_Handler(Home);
+              gcode.home_all_axes(true);
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                #if ENABLED(PREHEAT_BEFORE_LEVELING)
+                  Popup_Handler(Heating);
+                  #if HAS_HOTEND
+                    if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
+                      thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
+                  #endif
+                  #if HAS_HEATED_BED
+                    if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
+                      thermalManager.setTargetBed(LEVELING_BED_TEMP);
+                  #endif
+                  thermalManager.wait_for_hotend(0);
+                  TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
+                #endif
+                #if HAS_BED_PROBE
+                  Popup_Handler(Level);
+                  gcode.process_subcommands_now_P(PSTR("G29 P0\nG29 P1"));
+                  gcode.process_subcommands_now_P(PSTR("G29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nG29 P3\nM420 S1"));
+                  planner.synchronize();
+                  Update_Status("Probed all reachable points");
+                  Popup_Handler(SaveLevel);
+                #else
+                  level_state = planner.leveling_active;
+                  set_bed_leveling_enabled(false);
+                  mesh_conf.goto_mesh_value = true;
+                  mesh_conf.mesh_x = mesh_conf.mesh_y = 0;
+                  Popup_Handler(MoveWait);
+                  mesh_conf.manual_move();;
+                  Draw_Menu(UBLMesh);
+                #endif
+              #elif HAS_BED_PROBE
+                Popup_Handler(Level);
+                gcode.process_subcommands_now_P(PSTR("G29"));
+                planner.synchronize();
+                Popup_Handler(SaveLevel);
+              #else
+                level_state = planner.leveling_active;
+                set_bed_leveling_enabled(false);
+                gridpoint = 1;
+                Popup_Handler(MoveWait);
+                gcode.process_subcommands_now_P(PSTR("G29"));
+                planner.synchronize();
+                Draw_Menu(ManualMesh);
+              #endif
+            }
+            break;
+          case LEVELING_MANUAL:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Mesh, "Manual Tuning", nullptr, true);
+            else {
+              #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+                if (!leveling_is_valid()) {
+                  Confirm_Handler(InvalidMesh);
+                  break;
+                }
+              #endif
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                if (ubl.storage_slot < 0) {
+                  Popup_Handler(MeshSlot);
+                  break;
+                }
+              #endif
+              if (axes_should_home()) {
+                Popup_Handler(Home);
+                gcode.home_all_axes(true);
+              }
+              level_state = planner.leveling_active;
+              set_bed_leveling_enabled(false);
+              mesh_conf.goto_mesh_value = false;
+              #if ENABLED(PREHEAT_BEFORE_LEVELING)
+                Popup_Handler(Heating);
+                #if HAS_HOTEND
+                  if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
+                    thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
+                #endif
+                #if HAS_HEATED_BED
+                  if (thermalManager.degTargetBed() < LEVELING_BED_TEMP)
+                    thermalManager.setTargetBed(LEVELING_BED_TEMP);
+                #endif
+                TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
+                TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
+              #endif
+              Popup_Handler(MoveWait);
+              mesh_conf.manual_move();
+              Draw_Menu(LevelManual);
+            }
+            break;
+          case LEVELING_VIEW:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Mesh, "Mesh Viewer", nullptr, true);
+            else {
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                if (ubl.storage_slot < 0) {
+                  Popup_Handler(MeshSlot);
+                  break;
+                }
+              #endif
+              Draw_Menu(LevelView);
+            }
+            break;
+          case LEVELING_SETTINGS:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Step, "Leveling Settings", nullptr, true);
+            else
+              Draw_Menu(LevelSettings);
+            break;
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+          case LEVELING_SLOT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_PrintSize, "Mesh Slot");
+              Draw_Float(ubl.storage_slot, row, false, 1);
+            }
+            else
+              Modify_Value(ubl.storage_slot, 0, settings.calc_num_meshes() - 1, 1);
+            break;
+          case LEVELING_LOAD:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ReadEEPROM, "Load Mesh");
+            else {
+              if (ubl.storage_slot < 0) {
+                Popup_Handler(MeshSlot);
+                break;
+              }
+              gcode.process_subcommands_now_P(PSTR("G29 L"));
+              planner.synchronize();
+              AudioFeedback(true);
+            }
+            break;
+          case LEVELING_SAVE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_WriteEEPROM, "Save Mesh");
+            else {
+              if (ubl.storage_slot < 0) {
+                Popup_Handler(MeshSlot);
+                break;
+              }
+              gcode.process_subcommands_now_P(PSTR("G29 S"));
+              planner.synchronize();
+              AudioFeedback(true);
+            }
+            break;
+          #endif
+        }
+        break;
+
+      case LevelView:
+
+        #define LEVELING_VIEW_BACK 0
+        #define LEVELING_VIEW_MESH (LEVELING_VIEW_BACK + 1)
+        #define LEVELING_VIEW_TEXT (LEVELING_VIEW_MESH + 1)
+        #define LEVELING_VIEW_ASYMMETRIC (LEVELING_VIEW_TEXT + 1)
+        #define LEVELING_VIEW_TOTAL LEVELING_VIEW_ASYMMETRIC
+
+        switch (item) {
+          case LEVELING_VIEW_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(Leveling, LEVELING_VIEW);
+            break;
+          case LEVELING_VIEW_MESH:
+            if (draw)
+              Draw_Menu_Item(row, ICON_PrintSize, "Mesh Viewer", nullptr, true);
+            else
+              Draw_Menu(MeshViewer);
+            break;
+          case LEVELING_VIEW_TEXT:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Contact, "Viewer Show Values");
+              Draw_Checkbox(row, mesh_conf.viewer_print_value);
+            }
+            else {
+              mesh_conf.viewer_print_value = !mesh_conf.viewer_print_value;
+              Draw_Checkbox(row, mesh_conf.viewer_print_value);
+            }
+            break;
+          case LEVELING_VIEW_ASYMMETRIC:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Axis, "Viewer Asymmetric");
+              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
+            }
+            else {
+              mesh_conf.viewer_asymmetric_range = !mesh_conf.viewer_asymmetric_range;
+              Draw_Checkbox(row, mesh_conf.viewer_asymmetric_range);
+            }
+            break;
+        }
+        break;
+
+      case LevelSettings:
+
+        #define LEVELING_SETTINGS_BACK 0
+        #define LEVELING_SETTINGS_FADE (LEVELING_SETTINGS_BACK + 1)
+        #define LEVELING_SETTINGS_TILT (LEVELING_SETTINGS_FADE + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_PLANE (LEVELING_SETTINGS_TILT + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_ZERO (LEVELING_SETTINGS_PLANE + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_UNDEF (LEVELING_SETTINGS_ZERO + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_SETTINGS_TOTAL LEVELING_SETTINGS_UNDEF
+
+        switch (item) {
+          case LEVELING_SETTINGS_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else
+              Draw_Menu(Leveling, LEVELING_SETTINGS);
+            break;
+          case LEVELING_SETTINGS_FADE:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_Fade, "Fade Mesh within");
+                Draw_Float(planner.z_fade_height, row, false, 1);
+              }
+              else {
+                Modify_Value(planner.z_fade_height, 0, Z_MAX_POS, 1);
+                planner.z_fade_height = -1;
+                set_z_fade_height(planner.z_fade_height);
+              }
+              break;
+
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+            case LEVELING_SETTINGS_TILT:
+              if (draw) {
+                Draw_Menu_Item(row, ICON_Tilt, "Tilting Grid Size");
+                Draw_Float(mesh_conf.tilt_grid, row, false, 1);
+              }
+              else
+                Modify_Value(mesh_conf.tilt_grid, 1, 8, 1);
+              break;
+            case LEVELING_SETTINGS_PLANE:
+              if (draw)
+                Draw_Menu_Item(row, ICON_ResumeEEPROM, "Convert Mesh to Plane");
+              else {
+                if (mesh_conf.create_plane_from_mesh()) break;
+                gcode.process_subcommands_now_P(PSTR("M420 S1"));
+                planner.synchronize();
+                AudioFeedback(true);
+              }
+              break;
+            case LEVELING_SETTINGS_ZERO:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Mesh, "Zero Current Mesh");
+              else
+                ZERO(mesh_conf.mesh_z_values);
+              break;
+            case LEVELING_SETTINGS_UNDEF:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Mesh, "Clear Current Mesh");
+              else
+                ubl.invalidate();
+              break;
+          #endif // AUTO_BED_LEVELING_UBL
+        }
+        break;
+
+      case MeshViewer:
+        #define MESHVIEW_BACK 0
+        #define MESHVIEW_TOTAL MESHVIEW_BACK
+
+        if (item == MESHVIEW_BACK) {
+          if (draw) {
+            Draw_Menu_Item(0, ICON_Back, "Back");
+            mesh_conf.Draw_Bed_Mesh();
+            mesh_conf.Set_Mesh_Viewer_Status();
+          }
+          else if (!mesh_conf.drawing_mesh) {
+            Draw_Menu(LevelView, LEVELING_VIEW_MESH);
+            Update_Status("");
+          }
+        }
+        break;
+
+      case LevelManual:
+
+        #define LEVELING_M_BACK 0
+        #define LEVELING_M_X (LEVELING_M_BACK + 1)
+        #define LEVELING_M_Y (LEVELING_M_X + 1)
+        #define LEVELING_M_NEXT (LEVELING_M_Y + 1)
+        #define LEVELING_M_OFFSET (LEVELING_M_NEXT + 1)
+        #define LEVELING_M_UP (LEVELING_M_OFFSET + 1)
+        #define LEVELING_M_DOWN (LEVELING_M_UP + 1)
+        #define LEVELING_M_GOTO_VALUE (LEVELING_M_DOWN + 1)
+        #define LEVELING_M_UNDEF (LEVELING_M_GOTO_VALUE + ENABLED(AUTO_BED_LEVELING_UBL))
+        #define LEVELING_M_TOTAL LEVELING_M_UNDEF
+
+        switch (item) {
+          case LEVELING_M_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else {
+              set_bed_leveling_enabled(level_state);
+              TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
+              Draw_Menu(Leveling, LEVELING_MANUAL);
+            }
+            break;
+          case LEVELING_M_X:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MoveX, "Mesh Point X");
+              Draw_Float(mesh_conf.mesh_x, row, 0, 1);
+            }
+            else
+              Modify_Value(mesh_conf.mesh_x, 0, GRID_MAX_POINTS_X - 1, 1);
+            break;
+          case LEVELING_M_Y:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_MoveY, "Mesh Point Y");
+              Draw_Float(mesh_conf.mesh_y, row, 0, 1);
+            }
+            else
+              Modify_Value(mesh_conf.mesh_y, 0, GRID_MAX_POINTS_Y - 1, 1);
+            break;
+          case LEVELING_M_NEXT:
+            if (draw)
+              Draw_Menu_Item(row, ICON_More, "Next Point");
+            else {
+              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
+                  mesh_conf.mesh_y++;
+                else if (mesh_conf.mesh_y % 2 == 0)
+                  mesh_conf.mesh_x++;
+                else
+                  mesh_conf.mesh_x--;
+                mesh_conf.manual_move();
+              }
+            }
+            break;
+          case LEVELING_M_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, "Point Z Offset");
+              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+            }
+            else {
+              if (isnan(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            }
+            break;
+          case LEVELING_M_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              planner.synchronize();
+              current_position.z += 0.01f;
+              sync_plan_position();
+              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+            }
+            break;
+          case LEVELING_M_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
+            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              planner.synchronize();
+              current_position.z -= 0.01f;
+              sync_plan_position();
+              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+            }
+            break;
+          case LEVELING_M_GOTO_VALUE:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_StockConfiguraton, "Go to Mesh Z Value");
+              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
+            }
+            else {
+              mesh_conf.goto_mesh_value = !mesh_conf.goto_mesh_value;
+              current_position.z = 0;
+              mesh_conf.manual_move(true);
+              Draw_Checkbox(row, mesh_conf.goto_mesh_value);
+            }
+            break;
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+          case LEVELING_M_UNDEF:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Clear Point Value");
+            else {
+              mesh_conf.manual_value_update(true);
+              Redraw_Menu(false);
+            }
+            break;
+          #endif
+        }
+        break;
+    #endif // HAS_MESH
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+      case UBLMesh:
+
+        #define UBL_M_BACK 0
+        #define UBL_M_NEXT (UBL_M_BACK + 1)
+        #define UBL_M_PREV (UBL_M_NEXT + 1)
+        #define UBL_M_OFFSET (UBL_M_PREV + 1)
+        #define UBL_M_UP (UBL_M_OFFSET + 1)
+        #define UBL_M_DOWN (UBL_M_UP + 1)
+        #define UBL_M_TOTAL UBL_M_DOWN
+
+        switch (item) {
+          case UBL_M_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Back");
+            else {
+              set_bed_leveling_enabled(level_state);
+              Draw_Menu(Leveling, LEVELING_GET_MESH);
+            }
+            break;
+          case UBL_M_NEXT:
+            if (draw) {
+              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1))
+                Draw_Menu_Item(row, ICON_More, "Next Point");
+              else
+                Draw_Menu_Item(row, ICON_More, "Save Mesh");
+            }
+            else {
+              if (mesh_conf.mesh_x != (GRID_MAX_POINTS_X - 1) || mesh_conf.mesh_y != (GRID_MAX_POINTS_Y - 1)) {
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 0) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 1))
+                  mesh_conf.mesh_y++;
+                else if (mesh_conf.mesh_y % 2 == 0)
+                  mesh_conf.mesh_x++;
+                else
+                  mesh_conf.mesh_x--;
+                mesh_conf.manual_move();
+              }
+              else {
+                gcode.process_subcommands_now_P(PSTR("G29 S"));
+                planner.synchronize();
+                AudioFeedback(true);
+                Draw_Menu(Leveling, LEVELING_GET_MESH);
+              }
+            }
+            break;
+          case UBL_M_PREV:
+            if (draw)
+              Draw_Menu_Item(row, ICON_More, "Previous Point");
+            else {
+              if (mesh_conf.mesh_x != 0 || mesh_conf.mesh_y != 0) {
+                if ((mesh_conf.mesh_x == (GRID_MAX_POINTS_X - 1) && mesh_conf.mesh_y % 2 == 1) || (mesh_conf.mesh_x == 0 && mesh_conf.mesh_y % 2 == 0))
+                  mesh_conf.mesh_y--;
+                else if (mesh_conf.mesh_y % 2 == 0)
+                  mesh_conf.mesh_x--;
+                else
+                  mesh_conf.mesh_x++;
+                mesh_conf.manual_move();
+              }
+            }
+            break;
+          case UBL_M_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, "Point Z Offset");
+              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row, false, 100);
+            }
+            else {
+              if (isnan(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y]))
+                mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] = 0;
+              Modify_Value(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            }
+            break;
+          case UBL_M_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] < MAX_Z_OFFSET) {
+              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] += 0.01;
+              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              planner.synchronize();
+              current_position.z += 0.01f;
+              sync_plan_position();
+              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 1, false, 100);
+            }
+            break;
+          case UBL_M_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, "Microstep Down");
+            else if (mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] > MIN_Z_OFFSET) {
+              mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y] -= 0.01;
+              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              planner.synchronize();
+              current_position.z -= 0.01f;
+              sync_plan_position();
+              Draw_Float(mesh_conf.mesh_z_values[mesh_conf.mesh_x][mesh_conf.mesh_y], row - 2, false, 100);
+            }
+            break;
+        }
+        break;
+    #endif // AUTO_BED_LEVELING_UBL && !HAS_BED_PROBE
+
+    #if ENABLED(PROBE_MANUALLY)
+      case ManualMesh:
+
+        #define MMESH_BACK 0
+        #define MMESH_NEXT (MMESH_BACK + 1)
+        #define MMESH_OFFSET (MMESH_NEXT + 1)
+        #define MMESH_UP (MMESH_OFFSET + 1)
+        #define MMESH_DOWN (MMESH_UP + 1)
+        #define MMESH_OLD (MMESH_DOWN + 1)
+        #define MMESH_TOTAL MMESH_OLD
+
+        switch (item) {
+          case MMESH_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Cancel");
+            else {
+              gcode.process_subcommands_now_P(PSTR("G29 A"));
+              planner.synchronize();
+              set_bed_leveling_enabled(level_state);
+              Draw_Menu(Leveling, LEVELING_GET_MESH);
+            }
+            break;
+          case MMESH_NEXT:
+            if (draw) {
+              if (gridpoint < GRID_MAX_POINTS)
+                Draw_Menu_Item(row, ICON_More, "Next Point");
+              else
+                Draw_Menu_Item(row, ICON_More, "Save Mesh");
+            }
+            else if (gridpoint < GRID_MAX_POINTS) {
+              Popup_Handler(MoveWait);
+              gcode.process_subcommands_now_P(PSTR("G29"));
+              planner.synchronize();
+              gridpoint++;
+              Redraw_Menu();
+            }
+            else {
+              gcode.process_subcommands_now_P(PSTR("G29"));
+              planner.synchronize();
+              AudioFeedback(settings.save());
+              Draw_Menu(Leveling, LEVELING_GET_MESH);
+            }
+            break;
+          case MMESH_OFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetZOffset, "Z Position");
+              current_position.z = MANUAL_PROBE_START_Z;
+              Draw_Float(current_position.z, row, false, 100);
+            }
+            else
+              Modify_Value(current_position.z, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          case MMESH_UP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, "Microstep Up");
+            else if (current_position.z < MAX_Z_OFFSET) {
+              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              planner.synchronize();
+              current_position.z += 0.01f;
+              sync_plan_position();
+              Draw_Float(current_position.z, row - 1, false, 100);
+            }
+            break;
+          case MMESH_DOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, "Microstep Down");
+            else if (current_position.z > MIN_Z_OFFSET) {
+              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              planner.synchronize();
+              current_position.z -= 0.01f;
+              sync_plan_position();
+              Draw_Float(current_position.z, row - 2, false, 100);
+            }
+            break;
+          case MMESH_OLD:
+            uint8_t mesh_x, mesh_y;
+            // 0,0 -> 1,0 -> 2,0 -> 2,1 -> 1,1 -> 0,1 -> 0,2 -> 1,2 -> 2,2
+            mesh_y = (gridpoint - 1) / GRID_MAX_POINTS_Y;
+            mesh_x = (gridpoint - 1) % GRID_MAX_POINTS_X;
+
+            if (mesh_y % 2 == 1)
+              mesh_x = GRID_MAX_POINTS_X - mesh_x - 1;
+
+            const float currval = mesh_conf.mesh_z_values[mesh_x][mesh_y];
+
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Zoffset, "Goto Mesh Value");
+              Draw_Float(currval, row, false, 100);
+            }
+            else if (!isnan(currval)) {
+              current_position.z = currval;
+              planner.synchronize();
+              planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+              planner.synchronize();
+              Draw_Float(current_position.z, row - 3, false, 100);
+            }
+            break;
+        }
+        break;
+    #endif // PROBE_MANUALLY
+
+    case Tune:
+
+      #define TUNE_BACK 0
+      #define TUNE_SPEED (TUNE_BACK + 1)
+      #define TUNE_FLOW (TUNE_SPEED + ENABLED(HAS_HOTEND))
+      #define TUNE_HOTEND (TUNE_FLOW + ENABLED(HAS_HOTEND))
+      #define TUNE_BED (TUNE_HOTEND + ENABLED(HAS_HEATED_BED))
+      #define TUNE_FAN (TUNE_BED + ENABLED(HAS_FAN))
+      #define TUNE_ZOFFSET (TUNE_FAN + ENABLED(HAS_ZOFFSET_ITEM))
+      #define TUNE_ZUP (TUNE_ZOFFSET + ENABLED(HAS_ZOFFSET_ITEM))
+      #define TUNE_ZDOWN (TUNE_ZUP + ENABLED(HAS_ZOFFSET_ITEM))
+      #define TUNE_CHANGEFIL (TUNE_ZDOWN + ENABLED(FILAMENT_LOAD_UNLOAD_GCODES))
+      #define TUNE_FILSENSORENABLED (TUNE_CHANGEFIL + ENABLED(FILAMENT_RUNOUT_SENSOR))
+      #define TUNE_BACKLIGHT_OFF (TUNE_FILSENSORENABLED + 1)
+      #define TUNE_BACKLIGHT (TUNE_BACKLIGHT_OFF + 1)
+      #define TUNE_TOTAL TUNE_BACKLIGHT
+
+      switch (item) {
+        case TUNE_BACK:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Back, "Back");
+          else
+            Draw_Print_Screen();
+          break;
+        case TUNE_SPEED:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Speed, "Print Speed");
+            Draw_Float(feedrate_percentage, row, false, 1);
+          }
+          else
+            Modify_Value(feedrate_percentage, MIN_PRINT_SPEED, MAX_PRINT_SPEED, 1);
+          break;
+
+        #if HAS_HOTEND
+          case TUNE_FLOW:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Speed, "Flow Rate");
+              Draw_Float(planner.flow_percentage[0], row, false, 1);
+            }
+            else
+              Modify_Value(planner.flow_percentage[0], MIN_FLOW_RATE, MAX_FLOW_RATE, 1);
+            break;
+          case TUNE_HOTEND:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetEndTemp, "Hotend");
+              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].target, MIN_E_TEMP, MAX_E_TEMP, 1);
+            break;
+        #endif
+
+        #if HAS_HEATED_BED
+          case TUNE_BED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_SetBedTemp, "Bed");
+              Draw_Float(thermalManager.temp_bed.target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_bed.target, MIN_BED_TEMP, MAX_BED_TEMP, 1);
+            break;
+        #endif
+
+        #if HAS_FAN
+          case TUNE_FAN:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, "Fan");
+              Draw_Float(thermalManager.fan_speed[0], row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.fan_speed[0], MIN_FAN_SPEED, MAX_FAN_SPEED, 1);
+            break;
+        #endif
+
+        #if HAS_ZOFFSET_ITEM
+          case TUNE_ZOFFSET:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_FanSpeed, "Z-Offset");
+              Draw_Float(zoffsetvalue, row, false, 100);
+            }
+            else
+              Modify_Value(zoffsetvalue, MIN_Z_OFFSET, MAX_Z_OFFSET, 100);
+            break;
+          case TUNE_ZUP:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Axis, "Z-Offset Up");
+            else if (zoffsetvalue < MAX_Z_OFFSET) {
+              gcode.process_subcommands_now_P(PSTR("M290 Z0.01"));
+              zoffsetvalue += 0.01;
+              Draw_Float(zoffsetvalue, row - 1, false, 100);
+            }
+            break;
+          case TUNE_ZDOWN:
+            if (draw)
+              Draw_Menu_Item(row, ICON_AxisD, "Z-Offset Down");
+            else if (zoffsetvalue > MIN_Z_OFFSET) {
+              gcode.process_subcommands_now_P(PSTR("M290 Z-0.01"));
+              zoffsetvalue -= 0.01;
+              Draw_Float(zoffsetvalue, row - 2, false, 100);
+            }
+            break;
+        #endif
+
+        #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+          case TUNE_CHANGEFIL:
+            if (draw)
+              Draw_Menu_Item(row, ICON_ResumeEEPROM, "Change Filament");
+            else
+              Popup_Handler(ConfFilChange);
+            break;
+        #endif
+
+        #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+          case TUNE_FILSENSORENABLED:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Extruder, "Filament Sensor");
+              Draw_Checkbox(row, runout.enabled);
+            }
+            else {
+              runout.enabled = !runout.enabled;
+              Draw_Checkbox(row, runout.enabled);
+            }
+            break;
+        #endif
+
+        case TUNE_BACKLIGHT_OFF:
+          if (draw)
+            Draw_Menu_Item(row, ICON_Brightness, "Display Off");
+          else
+            ui.set_brightness(0);
+          break;
+        case TUNE_BACKLIGHT:
+          if (draw) {
+            Draw_Menu_Item(row, ICON_Brightness, "LCD Brightness");
+            Draw_Float(ui.brightness, row, false, 1);
+          }
+          else
+            Modify_Value(ui.brightness, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS, 1, ui.refresh_brightness);
+          break;
+      }
+      break;
+
+    case PreheatHotend:
+
+        #define PREHEATHOTEND_BACK 0
+        #define PREHEATHOTEND_CONTINUE (PREHEATHOTEND_BACK + 1)
+        #define PREHEATHOTEND_1 (PREHEATHOTEND_CONTINUE + (PREHEAT_COUNT >= 1))
+        #define PREHEATHOTEND_2 (PREHEATHOTEND_1 + (PREHEAT_COUNT >= 2))
+        #define PREHEATHOTEND_3 (PREHEATHOTEND_2 + (PREHEAT_COUNT >= 3))
+        #define PREHEATHOTEND_4 (PREHEATHOTEND_3 + (PREHEAT_COUNT >= 4))
+        #define PREHEATHOTEND_5 (PREHEATHOTEND_4 + (PREHEAT_COUNT >= 5))
+        #define PREHEATHOTEND_CUSTOM (PREHEATHOTEND_5 + 1)
+        #define PREHEATHOTEND_TOTAL PREHEATHOTEND_CUSTOM
+
+        switch (item) {
+          case PREHEATHOTEND_BACK:
+            if (draw)
+              Draw_Menu_Item(row, ICON_Back, "Cancel");
+            else {
+              thermalManager.setTargetHotend(0, 0);
+              thermalManager.set_fan_speed(0, 0);
+              Redraw_Menu(false, true, true);
+            }
+            break;
+          case PREHEATHOTEND_CONTINUE:
+            if (draw)
+              Draw_Menu_Item(row, ICON_SetEndTemp, "Continue");
+            else {
+              Popup_Handler(Heating);
+              thermalManager.wait_for_hotend(0);
+              switch (last_menu) {
+                case Prepare:
+                  Popup_Handler(FilChange);
+                  sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                  gcode.process_subcommands_now_P(cmd);
+                  break;
+                #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+                  case ChangeFilament:
+                    switch (last_selection) {
+                      case CHANGEFIL_LOAD:
+                        Popup_Handler(FilLoad);
+                        gcode.process_subcommands_now_P("M701");
+                        planner.synchronize();
+                        Redraw_Menu(true, true, true);
+                        break;
+                      case CHANGEFIL_UNLOAD:
+                        Popup_Handler(FilLoad, true);
+                        gcode.process_subcommands_now_P("M702");
+                        planner.synchronize();
+                        Redraw_Menu(true, true, true);
+                        break;
+                      case CHANGEFIL_CHANGE:
+                        Popup_Handler(FilChange);
+                        sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+                        gcode.process_subcommands_now_P(cmd);
+                        break;
+                    }
+                    break;
+                #endif
+                default:
+                  Redraw_Menu(true, true, true);
+                  break;
+              }
+            }
+            break;
+          #if PREHEAT_COUNT >= 1
+            case PREHEATHOTEND_1:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_1_LABEL);
+              else {
+                thermalManager.setTargetHotend(ui.material_preset[0].hotend_temp, 0);
+                thermalManager.set_fan_speed(0, ui.material_preset[0].fan_speed);
+              }
+              break;
+          #endif
+          #if PREHEAT_COUNT >= 2
+            case PREHEATHOTEND_2:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_2_LABEL);
+              else {
+                thermalManager.setTargetHotend(ui.material_preset[1].hotend_temp, 0);
+                thermalManager.set_fan_speed(0, ui.material_preset[1].fan_speed);
+              }
+              break;
+          #endif
+          #if PREHEAT_COUNT >= 3
+            case PREHEATHOTEND_3:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_3_LABEL);
+              else {
+                thermalManager.setTargetHotend(ui.material_preset[2].hotend_temp, 0);
+                thermalManager.set_fan_speed(0, ui.material_preset[2].fan_speed);
+              }
+              break;
+          #endif
+          #if PREHEAT_COUNT >= 4
+            case PREHEATHOTEND_4:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_4_LABEL);
+              else {
+                thermalManager.setTargetHotend(ui.material_preset[3].hotend_temp, 0);
+                thermalManager.set_fan_speed(0, ui.material_preset[3].fan_speed);
+              }
+              break;
+          #endif
+          #if PREHEAT_COUNT >= 5
+            case PREHEATHOTEND_5:
+              if (draw)
+                Draw_Menu_Item(row, ICON_Temperature, PREHEAT_5_LABEL);
+              else {
+                thermalManager.setTargetHotend(ui.material_preset[4].hotend_temp, 0);
+                thermalManager.set_fan_speed(0, ui.material_preset[4].fan_speed);
+              }
+              break;
+          #endif
+          case PREHEATHOTEND_CUSTOM:
+            if (draw) {
+              Draw_Menu_Item(row, ICON_Temperature, "Custom");
+              Draw_Float(thermalManager.temp_hotend[0].target, row, false, 1);
+            }
+            else
+              Modify_Value(thermalManager.temp_hotend[0].target, EXTRUDE_MINTEMP, MAX_E_TEMP, 1);
+            break;
+        }
+        break;
+  }
+}
+
+const char * CrealityDWINClass::Get_Menu_Title(uint8_t menu) {
+  switch (menu) {
+    case MainMenu:          return "Main Menu";
+    case Prepare:           return "Prepare";
+    case HomeMenu:          return "Homing Menu";
+    case Move:              return "Move";
+    case ManualLevel:       return "Manual Leveling";
+    #if HAS_ZOFFSET_ITEM
+      case ZOffset:         return "Z Offset";
+    #endif
+    #if HAS_PREHEAT
+      case Preheat:         return "Preheat";
+    #endif
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      case ChangeFilament:  return "Change Filament";
+    #endif
+    case Control:           return "Control";
+    case TempMenu:          return "Temperature";
+    #if HAS_HOTEND || HAS_HEATED_BED
+      case PID:             return "PID Menu";
+    #endif
+    #if HAS_HOTEND
+      case HotendPID:       return "Hotend PID Settings";
+    #endif
+    #if HAS_HEATED_BED
+      case BedPID:          return "Bed PID Settings";
+    #endif
+    #if PREHEAT_COUNT >= 1
+      case Preheat1:        return (PREHEAT_1_LABEL " Settings");
+    #endif
+    #if PREHEAT_COUNT >= 2
+      case Preheat2:        return (PREHEAT_2_LABEL " Settings");
+    #endif
+    #if PREHEAT_COUNT >= 3
+      case Preheat3:        return (PREHEAT_3_LABEL " Settings");
+    #endif
+    #if PREHEAT_COUNT >= 4
+      case Preheat4:        return (PREHEAT_4_LABEL " Settings");
+    #endif
+    #if PREHEAT_COUNT >= 5
+      case Preheat5:        return (PREHEAT_5_LABEL " Settings");
+    #endif
+    case Motion:            return "Motion Settings";
+    case HomeOffsets:       return "Home Offsets";
+    case MaxSpeed:          return "Max Speed";
+    case MaxAcceleration:   return "Max Acceleration";
+    #if HAS_CLASSIC_JERK
+      case MaxJerk:         return "Max Jerk";
+    #endif
+    case Steps:             return "Steps/mm";
+    case Visual:            return "Visual Settings";
+    case Advanced:          return "Advanced Settings";
+    #if HAS_BED_PROBE
+      case ProbeMenu:       return "Probe Menu";
+    #endif
+    case ColorSettings:     return "UI Color Settings";
+    case Info:              return "Info";
+    case InfoMain:          return "Info";
+    #if HAS_MESH
+      case Leveling:        return "Leveling";
+      case LevelView:       return "Mesh View";
+      case LevelSettings:   return "Leveling Settings";
+      case MeshViewer:      return "Mesh Viewer";
+      case LevelManual:     return "Manual Tuning";
+    #endif
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+      case UBLMesh:         return "UBL Bed Leveling";
+    #endif
+    #if ENABLED(PROBE_MANUALLY)
+      case ManualMesh:      return "Mesh Bed Leveling";
+    #endif
+    case Tune:              return "Tune";
+    case PreheatHotend:     return "Preheat Hotend";
+  }
+  return "";
+}
+
+uint8_t CrealityDWINClass::Get_Menu_Size(uint8_t menu) {
+  switch (menu) {
+    case Prepare:           return PREPARE_TOTAL;
+    case HomeMenu:          return HOME_TOTAL;
+    case Move:              return MOVE_TOTAL;
+    case ManualLevel:       return MLEVEL_TOTAL;
+    #if HAS_ZOFFSET_ITEM
+      case ZOffset:         return ZOFFSET_TOTAL;
+    #endif
+    #if HAS_PREHEAT
+      case Preheat:         return PREHEAT_TOTAL;
+    #endif
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      case ChangeFilament:  return CHANGEFIL_TOTAL;
+    #endif
+    case Control:           return CONTROL_TOTAL;
+    case TempMenu:          return TEMP_TOTAL;
+    #if HAS_HOTEND || HAS_HEATED_BED
+      case PID:             return PID_TOTAL;
+    #endif
+    #if HAS_HOTEND
+      case HotendPID:       return HOTENDPID_TOTAL;
+    #endif
+    #if HAS_HEATED_BED
+      case BedPID:          return BEDPID_TOTAL;
+    #endif
+    #if PREHEAT_COUNT >= 1
+      case Preheat1:        return PREHEAT1_TOTAL;
+    #endif
+    #if PREHEAT_COUNT >= 2
+      case Preheat2:        return PREHEAT2_TOTAL;
+    #endif
+    #if PREHEAT_COUNT >= 3
+      case Preheat3:        return PREHEAT3_TOTAL;
+    #endif
+    #if PREHEAT_COUNT >= 4
+      case Preheat4:        return PREHEAT4_TOTAL;
+    #endif
+    #if PREHEAT_COUNT >= 5
+      case Preheat5:        return PREHEAT5_TOTAL;
+    #endif
+    case Motion:            return MOTION_TOTAL;
+    case HomeOffsets:       return HOMEOFFSETS_TOTAL;
+    case MaxSpeed:          return SPEED_TOTAL;
+    case MaxAcceleration:   return ACCEL_TOTAL;
+    #if HAS_CLASSIC_JERK
+      case MaxJerk:         return JERK_TOTAL;
+    #endif
+    case Steps:             return STEPS_TOTAL;
+    case Visual:            return VISUAL_TOTAL;
+    case Advanced:          return ADVANCED_TOTAL;
+    #if HAS_BED_PROBE
+      case ProbeMenu:       return PROBE_TOTAL;
+    #endif
+    case Info:              return INFO_TOTAL;
+    case InfoMain:          return INFO_TOTAL;
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && !HAS_BED_PROBE
+      case UBLMesh:         return UBL_M_TOTAL;
+    #endif
+    #if ENABLED(PROBE_MANUALLY)
+      case ManualMesh:      return MMESH_TOTAL;
+    #endif
+    #if HAS_MESH
+      case Leveling:        return LEVELING_TOTAL;
+      case LevelView:       return LEVELING_VIEW_TOTAL;
+      case LevelSettings:   return LEVELING_SETTINGS_TOTAL;
+      case MeshViewer:      return MESHVIEW_TOTAL;
+      case LevelManual:     return LEVELING_M_TOTAL;
+    #endif
+    case Tune:              return TUNE_TOTAL;
+    case PreheatHotend:     return PREHEATHOTEND_TOTAL;
+    case ColorSettings:     return COLORSETTINGS_TOTAL;
+  }
+  return 0;
+}
+
+/* Popup Config */
+
+void CrealityDWINClass::Popup_Handler(PopupID popupid, bool option/*=false*/) {
+  popup = last_popup = popupid;
+  switch (popupid) {
+    case Pause:         Draw_Popup(PSTR("Pause Print"), PSTR(""), PSTR(""), Popup); break;
+    case Stop:          Draw_Popup(PSTR("Stop Print"), PSTR(""), PSTR(""), Popup); break;
+    case Resume:        Draw_Popup(PSTR("Resume Print?"), PSTR("Looks Like the last"), PSTR("print was interupted."), Popup); break;
+    case ConfFilChange: Draw_Popup(PSTR("Confirm Filament Change"), PSTR(""), PSTR(""), Popup); break;
+    case PurgeMore:     Draw_Popup(PSTR("Purge more filament?"), PSTR("(Cancel to finish process)"), PSTR(""), Popup); break;
+    case SaveLevel:     Draw_Popup(PSTR("Leveling Complete"), PSTR("Save to EEPROM?"), PSTR(""), Popup); break;
+    case MeshSlot:      Draw_Popup(PSTR("Mesh slot not selected"), PSTR("(Confirm to select slot 0)"), PSTR(""), Popup); break;
+    case ETemp:         Draw_Popup(PSTR("Nozzle is too cold"), PSTR("Open Preheat Menu?"), PSTR(""), Popup); break;
+    case ManualProbing: Draw_Popup(PSTR("Manual Probing"), PSTR("(Confirm to probe)"), PSTR("(cancel to exit)"), Popup); break;
+    case Level:         Draw_Popup(PSTR("Auto Bed Leveling"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_AutoLeveling); break;
+    case Home:          Draw_Popup(option ? PSTR("Parking") : PSTR("Homing"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
+    case MoveWait:      Draw_Popup(PSTR("Moving to Point"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
+    case Heating:       Draw_Popup(PSTR("Heating"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
+    case FilLoad:       Draw_Popup(option ? PSTR("Unloading Filament") : PSTR("Loading Filament"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
+    case FilChange:     Draw_Popup(PSTR("Filament Change"), PSTR("Please wait for prompt."), PSTR(""), Wait, ICON_BLTouch); break;
+    case TempWarn:      Draw_Popup(option ? PSTR("Nozzle temp too low!") : PSTR("Nozzle temp too high!"), PSTR(""), PSTR(""), Wait, option ? ICON_TempTooLow : ICON_TempTooHigh); break;
+    case Runout:        Draw_Popup(PSTR("Filament Runout"), PSTR(""), PSTR(""), Wait, ICON_BLTouch); break;
+    case PIDWait:       Draw_Popup(PSTR("PID Autotune"), PSTR("in process"), PSTR("Please wait until done."), Wait, ICON_BLTouch); break;
+    case Resuming:      Draw_Popup(PSTR("Resuming Print"), PSTR("Please wait until done."), PSTR(""), Wait, ICON_BLTouch); break;
+    default: break;
+  }
+}
+
+void CrealityDWINClass::Confirm_Handler(PopupID popupid) {
+  popup = popupid;
+  switch (popupid) {
+    case FilInsert:   Draw_Popup(PSTR("Insert Filament"), PSTR("Press to Continue"), PSTR(""), Confirm); break;
+    case HeaterTime:  Draw_Popup(PSTR("Heater Timed Out"), PSTR("Press to Reheat"), PSTR(""), Confirm); break;
+    case UserInput:   Draw_Popup(PSTR("Waiting for Input"), PSTR("Press to Continue"), PSTR(""), Confirm); break;
+    case LevelError:  Draw_Popup(PSTR("Couldn't enable Leveling"), PSTR("(Valid mesh must exist)"), PSTR(""), Confirm); break;
+    case InvalidMesh: Draw_Popup(PSTR("Valid mesh must exist"), PSTR("before tuning can be"), PSTR("performed"), Confirm); break;
+    default: break;
+  }
+}
+
+/* Navigation and Control */
+
+void CrealityDWINClass::Main_Menu_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < 3) {
+    selection++; // Select Down
+    Main_Menu_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    selection--; // Select Up
+    Main_Menu_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER)
+    switch (selection) {
+      case 0: card.mount(); Draw_SD_List(); break;
+      case 1: Draw_Menu(Prepare); break;
+      case 2: Draw_Menu(Control); break;
+      case 3: Draw_Menu(TERN(HAS_MESH, Leveling, InfoMain)); break;
+    }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Menu_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < Get_Menu_Size(active_menu)) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    selection++; // Select Down
+    if (selection > scrollpos+MROWS) {
+      scrollpos++;
+      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Menu_Item_Handler(active_menu, selection);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    selection--; // Select Up
+    if (selection < scrollpos) {
+      scrollpos--;
+      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Menu_Item_Handler(active_menu, selection);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER)
+    Menu_Item_Handler(active_menu, selection, false);
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Value_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    tempvalue += EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    tempvalue -= EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    process = Menu;
+    EncoderRate.enabled = false;
+    Draw_Float(tempvalue / valueunit, selection - scrollpos, false, valueunit);
+    DWIN_UpdateLCD();
+    if (active_menu == ZOffset && liveadjust) {
+      planner.synchronize();
+      current_position.z += (tempvalue / valueunit - zoffsetvalue);
+      planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+      current_position.z = 0;
+      sync_plan_position();
+    }
+    else if (active_menu == Tune && selection == TUNE_ZOFFSET) {
+      sprintf_P(cmd, PSTR("M290 Z%s"), dtostrf((tempvalue / valueunit - zoffsetvalue), 1, 3, str_1));
+      gcode.process_subcommands_now_P(cmd);
+    }
+    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
+      tempvalue = scalePID_i(tempvalue);
+    if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
+      tempvalue = scalePID_d(tempvalue);
+    switch (valuetype) {
+      case 0: *(float*)valuepointer = tempvalue / valueunit; break;
+      case 1: *(uint8_t*)valuepointer = tempvalue / valueunit; break;
+      case 2: *(uint16_t*)valuepointer = tempvalue / valueunit; break;
+      case 3: *(int16_t*)valuepointer = tempvalue / valueunit; break;
+      case 4: *(uint32_t*)valuepointer = tempvalue / valueunit; break;
+      case 5: *(int8_t*)valuepointer = tempvalue / valueunit; break;
+    }
+    switch (active_menu) {
+      case Move:
+        planner.synchronize();
+        planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
+        break;
+      #if HAS_MESH
+        case ManualMesh:
+          planner.synchronize();
+          planner.buffer_line(current_position, homing_feedrate(Z_AXIS), active_extruder);
+          planner.synchronize();
+          break;
+        case UBLMesh:     mesh_conf.manual_move(true); break;
+        case LevelManual: mesh_conf.manual_move(selection == LEVELING_M_OFFSET); break;
+      #endif
+    }
+    if (valuepointer == &planner.flow_percentage[0])
+      planner.refresh_e_factor(0);
+    if (funcpointer) funcpointer();
+    return;
+  }
+  NOLESS(tempvalue, (valuemin * valueunit));
+  NOMORE(tempvalue, (valuemax * valueunit));
+  Draw_Float(tempvalue / valueunit, selection - scrollpos, true, valueunit);
+  DWIN_UpdateLCD();
+  if (active_menu == Move && livemove) {
+    *(float*)valuepointer = tempvalue / valueunit;
+    planner.buffer_line(current_position, manual_feedrate_mm_s[selection - 1], active_extruder);
+  }
+}
+
+void CrealityDWINClass::Option_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    tempvalue += EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    tempvalue -= EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    process = Menu;
+    EncoderRate.enabled = false;
+    if (valuepointer == &color_names) {
+      switch (selection) {
+        case COLORSETTINGS_CURSOR: eeprom_settings.cursor_color = tempvalue; break;
+        case COLORSETTINGS_SPLIT_LINE: eeprom_settings.menu_split_line = tempvalue; break;
+        case COLORSETTINGS_MENU_TOP_BG: eeprom_settings.menu_top_bg = tempvalue; break;
+        case COLORSETTINGS_MENU_TOP_TXT: eeprom_settings.menu_top_txt = tempvalue; break;
+        case COLORSETTINGS_HIGHLIGHT_BORDER: eeprom_settings.highlight_box = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_PERCENT: eeprom_settings.progress_percent = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_TIME: eeprom_settings.progress_time = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_STATUS_BAR: eeprom_settings.status_bar_text = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_STATUS_AREA: eeprom_settings.status_area_text = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_COORDINATES: eeprom_settings.coordinates_text = tempvalue; break;
+        case COLORSETTINGS_PROGRESS_COORDINATES_LINE: eeprom_settings.coordinates_split_line = tempvalue; break;
+      }
+      Redraw_Screen();
+    }
+    else if (valuepointer == &preheat_modes)
+      preheatmode = tempvalue;
+
+    Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, false, (valuepointer == &color_names));
+    DWIN_UpdateLCD();
+    return;
+  }
+  NOLESS(tempvalue, valuemin);
+  NOMORE(tempvalue, valuemax);
+  Draw_Option(tempvalue, static_cast<const char * const *>(valuepointer), selection - scrollpos, true);
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::File_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  static uint8_t filescrl = 0;
+  if (encoder_diffState == ENCODER_DIFF_NO) {
+    if (selection > 0) {
+      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
+      char * const filename = card.longest_filename();
+      size_t len = strlen(filename);
+      int8_t pos = len;
+      if (!card.flag.filenameIsDir)
+        while (pos && filename[pos] != '.') pos--;
+      if (pos > MENU_CHAR_LIMIT) {
+        static millis_t time = 0;
+        if (PENDING(millis(), time)) return;
+        time = millis() + 200;
+        pos -= filescrl;
+        len = _MIN(pos, MENU_CHAR_LIMIT);
+        char name[len + 1];
+        if (pos >= 0) {
+          LOOP_L_N(i, len) name[i] = filename[i + filescrl];
+        }
+        else {
+          LOOP_L_N(i, MENU_CHAR_LIMIT + pos) name[i] = ' ';
+          LOOP_S_L_N(i, MENU_CHAR_LIMIT + pos, MENU_CHAR_LIMIT) name[i] = filename[i - (MENU_CHAR_LIMIT + pos)];
+        }
+        name[len] = '\0';
+        DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+        Draw_Menu_Item(selection - scrollpos, card.flag.filenameIsDir ? ICON_More : ICON_File, name);
+        if (-pos >= MENU_CHAR_LIMIT) filescrl = 0;
+        filescrl++;
+        DWIN_UpdateLCD();
+      }
+    }
+    return;
+  }
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < card.get_num_Files()) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    if (selection > 0) {
+      DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+      Draw_SD_Item(selection, selection - scrollpos);
+    }
+    filescrl = 0;
+    selection++; // Select Down
+    if (selection > scrollpos + MROWS) {
+      scrollpos++;
+      DWIN_Frame_AreaMove(1, 2, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Draw_SD_Item(selection, selection - scrollpos);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, LBLX, MBASE(selection - scrollpos) - 14, 271, MBASE(selection - scrollpos) + 28);
+    Draw_SD_Item(selection, selection - scrollpos);
+    filescrl = 0;
+    selection--; // Select Up
+    if (selection < scrollpos) {
+      scrollpos--;
+      DWIN_Frame_AreaMove(1, 3, MLINE, Color_Bg_Black, 0, 31, DWIN_WIDTH, 349);
+      Draw_SD_Item(selection, selection - scrollpos);
+    }
+    DWIN_Draw_Rectangle(1, GetColor(eeprom_settings.cursor_color, Rectangle_Color), 0, MBASE(selection - scrollpos) - 18, 14, MBASE(selection - scrollpos) + 33);
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    if (selection == 0) {
+      if (card.flag.workDirIsRoot) {
+        process = Main;
+        Draw_Main_Menu();
+      }
+      else {
+        card.cdup();
+        Draw_SD_List();
+      }
+    }
+    else {
+      card.getfilename_sorted(SD_ORDER(selection - 1, card.get_num_Files()));
+      if (card.flag.filenameIsDir) {
+        card.cd(card.filename);
+        Draw_SD_List();
+      }
+      else {
+        card.openAndPrintFile(card.filename);
+      }
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Print_Screen_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < 2) {
+    selection++; // Select Down
+    Print_Screen_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    selection--; // Select Up
+    Print_Screen_Icons();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (selection) {
+      case 0:
+        Draw_Menu(Tune);
+        Update_Status_Bar(true);
+        break;
+      case 1:
+        if (paused) {
+          if (sdprint) {
+            wait_for_user = false;
+            #if ENABLED(PARK_HEAD_ON_PAUSE)
+              card.startOrResumeFilePrinting();
+              TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
+            #else
+              char cmnd[20];
+              #if HAS_HEATED_BED
+                cmnd[sprintf_P(cmnd, PSTR("M140 S%i"), pausebed)] = '\0';
+                gcode.process_subcommands_now_P(PSTR(cmnd));
+              #endif
+              #if HAS_EXTRUDERS
+                cmnd[sprintf_P(cmnd, PSTR("M109 S%i"), pausetemp)] = '\0';
+                gcode.process_subcommands_now_P(PSTR(cmnd));
+              #endif
+              TERN_(HAS_FAN, thermalManager.fan_speed[0] = pausefan);
+              planner.synchronize();
+              TERN_(SDSUPPORT, queue.inject_P(PSTR("M24")));
+            #endif
+          }
+          else {
+            TERN_(HOST_ACTION_COMMANDS, host_action_resume());
+          }
+          Draw_Print_Screen();
+        }
+        else
+          Popup_Handler(Pause);
+        break;
+      case 2:
+        Popup_Handler(Stop);
+        break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Popup_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_CW && selection < 1) {
+    selection++;
+    Popup_Select();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && selection > 0) {
+    selection--;
+    Popup_Select();
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (popup) {
+      case Pause:
+        if (selection == 0) {
+          if (sdprint) {
+            #if ENABLED(POWER_LOSS_RECOVERY)
+              if (recovery.enabled) recovery.save(true);
+            #endif
+            #if ENABLED(PARK_HEAD_ON_PAUSE)
+              Popup_Handler(Home, true);
+              #if ENABLED(SDSUPPORT)
+                if (IS_SD_PRINTING()) card.pauseSDPrint();
+              #endif
+              planner.synchronize();
+              queue.inject_P(PSTR("M125"));
+              planner.synchronize();
+            #else
+              queue.inject_P(PSTR("M25"));
+              TERN_(HAS_HOTEND, pausetemp = thermalManager.temp_hotend[0].target);
+              TERN_(HAS_HEATED_BED, pausebed = thermalManager.temp_bed.target);
+              TERN_(HAS_FAN, pausefan = thermalManager.fan_speed[0]);
+              thermalManager.disable_all_heaters();
+              TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+            #endif
+          }
+          else {
+            TERN_(HOST_ACTION_COMMANDS, host_action_pause());
+          }
+        }
+        Draw_Print_Screen();
+        break;
+      case Stop:
+        if (selection == 0) {
+          if (sdprint) {
+            ui.abort_print();
+            TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+            thermalManager.disable_all_heaters();
+          }
+          else {
+            TERN_(HOST_ACTION_COMMANDS, host_action_cancel());
+          }
+        }
+        else
+          Draw_Print_Screen();
+        break;
+      case Resume:
+        if (selection == 0)
+          queue.inject_P(PSTR("M1000"));
+        else {
+          queue.inject_P(PSTR("M1000 C"));
+          Draw_Main_Menu();
+        }
+        break;
+
+      #if HAS_HOTEND
+        case ETemp:
+          if (selection == 0) {
+            thermalManager.setTargetHotend(EXTRUDE_MINTEMP, 0);
+            thermalManager.set_fan_speed(0, MAX_FAN_SPEED);
+            Draw_Menu(PreheatHotend);
+          }
+          else
+            Redraw_Menu(true, true, false);
+          break;
+      #endif
+
+      #if HAS_BED_PROBE
+        case ManualProbing:
+          if (selection == 0) {
+            char buf[80];
+            const float dif = probe.probe_at_point(current_position.x, current_position.y, PROBE_PT_STOW, 0, false) - corner_avg;
+            sprintf_P(buf, dif > 0 ? PSTR("Corner is %smm high") : PSTR("Corner is %smm low"), dtostrf(abs(dif), 1, 3, str_1));
+            Update_Status(buf);
+          }
+          else {
+            Redraw_Menu(true, true, false);
+            Update_Status("");
+          }
+          break;
+      #endif
+
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        case ConfFilChange:
+          if (selection == 0) {
+            if (thermalManager.temp_hotend[0].target < thermalManager.extrude_min_temp)
+              Popup_Handler(ETemp);
+            else {
+              if (thermalManager.temp_hotend[0].celsius < thermalManager.temp_hotend[0].target - 2) {
+                Popup_Handler(Heating);
+                thermalManager.wait_for_hotend(0);
+              }
+              Popup_Handler(FilChange);
+              sprintf_P(cmd, PSTR("M600 B1 R%i"), thermalManager.temp_hotend[0].target);
+              gcode.process_subcommands_now_P(cmd);
+            }
+          }
+          else
+            Redraw_Menu(true, true, false);
+          break;
+        case PurgeMore:
+          if (selection == 0) {
+            pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;
+            Popup_Handler(FilChange);
+          }
+          else {
+            pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;
+            if (printing) Popup_Handler(Resuming);
+            else Redraw_Menu(true, true, (active_menu==PreheatHotend));
+          }
+          break;
+      #endif // ADVANCED_PAUSE_FEATURE
+
+      #if HAS_MESH
+        case SaveLevel:
+          if (selection == 0) {
+            #if ENABLED(AUTO_BED_LEVELING_UBL)
+              gcode.process_subcommands_now_P(PSTR("G29 S"));
+              planner.synchronize();
+              AudioFeedback(true);
+            #else
+              AudioFeedback(settings.save());
+            #endif
+          }
+          Draw_Menu(Leveling, LEVELING_GET_MESH);
+          break;
+      #endif
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        case MeshSlot:
+          if (selection == 0) ubl.storage_slot = 0;
+          Redraw_Menu(true, true);
+          break;
+      #endif
+      default: break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+void CrealityDWINClass::Confirm_Control() {
+  ENCODER_DiffState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (popup) {
+      case Complete:
+        Draw_Main_Menu();
+        break;
+      case FilInsert:
+        Popup_Handler(FilChange);
+        wait_for_user = false;
+        break;
+      case HeaterTime:
+        Popup_Handler(Heating);
+        wait_for_user = false;
+        break;
+      default:
+        Redraw_Menu(true, true, false);
+        wait_for_user = false;
+        break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+/* In-Menu Value Modification */
+
+void CrealityDWINClass::Setup_Value(float value, float min, float max, float unit, uint8_t type) {
+  if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Ki) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Ki))
+    tempvalue = unscalePID_i(value) * unit;
+  else if (TERN0(HAS_HOTEND, valuepointer == &thermalManager.temp_hotend[0].pid.Kd) || TERN0(HAS_HEATED_BED, valuepointer == &thermalManager.temp_bed.pid.Kd))
+    tempvalue = unscalePID_d(value) * unit;
+  else
+    tempvalue = value * unit;
+  valuemin = min;
+  valuemax = max;
+  valueunit = unit;
+  valuetype = type;
+  process = Value;
+  EncoderRate.enabled = true;
+  Draw_Float(tempvalue / unit, selection - scrollpos, true, valueunit);
+}
+
+void CrealityDWINClass::Modify_Value(float &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 0);
+}
+void CrealityDWINClass::Modify_Value(uint8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 1);
+}
+void CrealityDWINClass::Modify_Value(uint16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 2);
+}
+void CrealityDWINClass::Modify_Value(int16_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 3);
+}
+void CrealityDWINClass::Modify_Value(uint32_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 4);
+}
+void CrealityDWINClass::Modify_Value(int8_t &value, float min, float max, float unit, void (*f)()/*=nullptr*/) {
+  valuepointer = &value;
+  funcpointer = f;
+  Setup_Value((float)value, min, max, unit, 5);
+}
+
+void CrealityDWINClass::Modify_Option(uint8_t value, const char * const * options, uint8_t max) {
+  tempvalue = value;
+  valuepointer = const_cast<const char * *>(options);
+  valuemin = 0;
+  valuemax = max;
+  process = Option;
+  EncoderRate.enabled = true;
+  Draw_Option(value, options, selection - scrollpos, true);
+}
+
+/* Main Functions */
+
+void CrealityDWINClass::Update_Status(const char * const text) {
+  char header[4];
+  LOOP_L_N(i, 3) header[i] = text[i];
+  header[3] = '\0';
+  if (strcmp_P(header,"<F>") == 0) {
+    LOOP_L_N(i, _MIN((size_t)LONG_FILENAME_LENGTH, strlen(text))) filename[i] = text[i + 3];
+    filename[_MIN((size_t)LONG_FILENAME_LENGTH - 1, strlen(text))] = '\0';
+    Draw_Print_Filename(true);
+  }
+  else {
+    LOOP_L_N(i, _MIN((size_t)64, strlen(text))) statusmsg[i] = text[i];
+    statusmsg[_MIN((size_t)64, strlen(text))] = '\0';
+  }
+}
+
+void CrealityDWINClass::Start_Print(bool sd) {
+  sdprint = sd;
+  if (!printing) {
+    printing = true;
+    statusmsg[0] = '\0';
+    if (sd) {
+      if (recovery.valid()) {
+        SdFile *diveDir = nullptr;
+        const char * const fname = card.diveToFile(true, diveDir, recovery.info.sd_filename);
+        card.selectFileByName(fname);
+      }
+      strcpy_P(filename, card.longest_filename());
+    }
+    else
+      strcpy_P(filename, "Host Print");
+    TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(0));
+    TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
+    Draw_Print_Screen();
+  }
+}
+
+void CrealityDWINClass::Stop_Print() {
+  printing = false;
+  sdprint = false;
+  TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
+  thermalManager.disable_all_heaters();
+  TERN_(LCD_SET_PROGRESS_MANUALLY, ui.set_progress(100 * (PROGRESS_SCALE)));
+  TERN_(USE_M73_REMAINING_TIME, ui.set_remaining_time(0));
+  Draw_Print_confirm();
+}
+
+void CrealityDWINClass::Update() {
+  State_Update();
+  Screen_Update();
+  switch (process) {
+    case Main:    Main_Menu_Control();    break;
+    case Menu:    Menu_Control();         break;
+    case Value:   Value_Control();        break;
+    case Option:  Option_Control();       break;
+    case File:    File_Control();         break;
+    case Print:   Print_Screen_Control(); break;
+    case Popup:   Popup_Control();        break;
+    case Confirm: Confirm_Control();      break;
+  }
+}
+
+void MarlinUI::update() { CrealityDWIN.Update(); }
+
+void CrealityDWINClass::State_Update() {
+  if ((print_job_timer.isRunning() || print_job_timer.isPaused()) != printing) {
+    if (!printing) Start_Print((card.isFileOpen() || recovery.valid()));
+    else Stop_Print();
+  }
+  if (print_job_timer.isPaused() != paused) {
+    paused = print_job_timer.isPaused();
+    if (process == Print) Print_Screen_Icons();
+    if (process == Wait && !paused) Redraw_Menu(true, true);
+  }
+  if (wait_for_user && !(process == Confirm) && !print_job_timer.isPaused())
+    Confirm_Handler(UserInput);
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    if (process == Popup && popup == PurgeMore) {
+      if (pause_menu_response == PAUSE_RESPONSE_EXTRUDE_MORE)
+        Popup_Handler(FilChange);
+      else if (pause_menu_response == PAUSE_RESPONSE_RESUME_PRINT) {
+        if (printing) Popup_Handler(Resuming);
+        else Redraw_Menu(true, true, (active_menu==PreheatHotend));
+      }
+    }
+  #endif
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    static bool ranout = false;
+    if (runout.filament_ran_out != ranout) {
+      ranout = runout.filament_ran_out;
+      if (ranout) Popup_Handler(Runout);
+    }
+  #endif
+}
+
+void CrealityDWINClass::Screen_Update() {
+  static millis_t scrltime = 0;
+  if (ELAPSED(millis(), scrltime)) {
+    scrltime = millis() + 200;
+    Update_Status_Bar();
+    if (process == Print) Draw_Print_Filename();
+  }
+
+  static millis_t statustime = 0;
+  if (ELAPSED(millis(), statustime)) {
+    statustime = millis() + 500;
+    Draw_Status_Area();
+  }
+
+  static millis_t printtime = 0;
+  if (ELAPSED(millis(), printtime)) {
+    printtime = millis() + 1000;
+    if (process == Print) {
+      Draw_Print_ProgressBar();
+      Draw_Print_ProgressElapsed();
+      TERN_(USE_M73_REMAINING_TIME, Draw_Print_ProgressRemain());
+    }
+  }
+
+  static bool mounted = card.isMounted();
+  if (mounted != card.isMounted()) {
+    mounted = card.isMounted();
+    if (process == File)
+      Draw_SD_List();
+  }
+
+  #if HAS_HOTEND
+    static int16_t hotendtarget = -1;
+  #endif
+  #if HAS_HEATED_BED
+    static int16_t bedtarget = -1;
+  #endif
+  #if HAS_FAN
+    static int16_t fanspeed = -1;
+  #endif
+
+  #if HAS_ZOFFSET_ITEM
+    static float lastzoffset = zoffsetvalue;
+    if (zoffsetvalue != lastzoffset) {
+      lastzoffset = zoffsetvalue;
+      #if HAS_BED_PROBE
+        probe.offset.z = zoffsetvalue;
+      #else
+        set_home_offset(Z_AXIS, -zoffsetvalue);
+      #endif
+    }
+
+    #if HAS_BED_PROBE
+      if (probe.offset.z != lastzoffset)
+        zoffsetvalue = lastzoffset = probe.offset.z;
+    #else
+      if (-home_offset.z != lastzoffset)
+        zoffsetvalue = lastzoffset = -home_offset.z;
+    #endif
+  #endif // HAS_ZOFFSET_ITEM
+
+  if (process == Menu || process == Value) {
+    switch (active_menu) {
+      case TempMenu:
+        #if HAS_HOTEND
+          if (thermalManager.temp_hotend[0].target != hotendtarget) {
+            hotendtarget = thermalManager.temp_hotend[0].target;
+            if (scrollpos <= TEMP_HOTEND && TEMP_HOTEND <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_hotend[0].target, TEMP_HOTEND - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_HEATED_BED
+          if (thermalManager.temp_bed.target != bedtarget) {
+            bedtarget = thermalManager.temp_bed.target;
+            if (scrollpos <= TEMP_BED && TEMP_BED <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_bed.target, TEMP_BED - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_FAN
+          if (thermalManager.fan_speed[0] != fanspeed) {
+            fanspeed = thermalManager.fan_speed[0];
+            if (scrollpos <= TEMP_FAN && TEMP_FAN <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.fan_speed[0], TEMP_FAN - scrollpos, false, 1);
+            }
+          }
+        #endif
+        break;
+      case Tune:
+        #if HAS_HOTEND
+          if (thermalManager.temp_hotend[0].target != hotendtarget) {
+            hotendtarget = thermalManager.temp_hotend[0].target;
+            if (scrollpos <= TUNE_HOTEND && TUNE_HOTEND <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_hotend[0].target, TUNE_HOTEND - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_HEATED_BED
+          if (thermalManager.temp_bed.target != bedtarget) {
+            bedtarget = thermalManager.temp_bed.target;
+            if (scrollpos <= TUNE_BED && TUNE_BED <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.temp_bed.target, TUNE_BED - scrollpos, false, 1);
+            }
+          }
+        #endif
+        #if HAS_FAN
+          if (thermalManager.fan_speed[0] != fanspeed) {
+            fanspeed = thermalManager.fan_speed[0];
+            if (scrollpos <= TUNE_FAN && TUNE_FAN <= scrollpos + MROWS) {
+              if (process != Value || selection != TEMP_HOTEND - scrollpos)
+                Draw_Float(thermalManager.fan_speed[0], TUNE_FAN - scrollpos, false, 1);
+            }
+          }
+        #endif
+        break;
+    }
+  }
+}
+
+void CrealityDWINClass::AudioFeedback(const bool success/*=true*/) {
+  if (success) {
+    if (eeprom_settings.beeperenable) {
+      BUZZ(100, 659);
+      BUZZ( 10,   0);
+      BUZZ(100, 698);
+    }
+    else Update_Status("Success");
+  }
+  else if (eeprom_settings.beeperenable)
+    BUZZ(40, 440);
+  else
+    Update_Status("Failed");
+}
+
+void CrealityDWINClass::Save_Settings(char *buff) {
+  TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = mesh_conf.tilt_grid - 1);
+  eeprom_settings.corner_pos = corner_pos * 10;
+  memcpy(buff, &eeprom_settings, min(sizeof(eeprom_settings), eeprom_data_size));
+}
+
+void CrealityDWINClass::Load_Settings(const char *buff) {
+  memcpy(&eeprom_settings, buff, min(sizeof(eeprom_settings), eeprom_data_size));
+  TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
+  if (eeprom_settings.corner_pos == 0) eeprom_settings.corner_pos = 325;
+  corner_pos = eeprom_settings.corner_pos / 10.0f;
+  Redraw_Screen();
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    static bool init = true;
+    if (init) {
+      init = false;
+      queue.inject_P(PSTR("M1000 S"));
+    }
+  #endif
+}
+
+void CrealityDWINClass::Reset_Settings() {
+  eeprom_settings.time_format_textual = false;
+  eeprom_settings.beeperenable = true;
+  TERN_(AUTO_BED_LEVELING_UBL, eeprom_settings.tilt_grid_size = 0);
+  eeprom_settings.corner_pos = 325;
+  eeprom_settings.cursor_color = 0;
+  eeprom_settings.menu_split_line = 0;
+  eeprom_settings.menu_top_bg = 0;
+  eeprom_settings.menu_top_txt = 0;
+  eeprom_settings.highlight_box = 0;
+  eeprom_settings.progress_percent = 0;
+  eeprom_settings.progress_time = 0;
+  eeprom_settings.status_bar_text = 0;
+  eeprom_settings.status_area_text = 0;
+  eeprom_settings.coordinates_text = 0;
+  eeprom_settings.coordinates_split_line = 0;
+  TERN_(AUTO_BED_LEVELING_UBL, mesh_conf.tilt_grid = eeprom_settings.tilt_grid_size + 1);
+  corner_pos = eeprom_settings.corner_pos / 10.0f;
+  Redraw_Screen();
+}
+
+void MarlinUI::init() {
+  delay(800);
+  SERIAL_ECHOPGM("\nDWIN handshake ");
+  if (DWIN_Handshake()) SERIAL_ECHOLNPGM("ok."); else SERIAL_ECHOLNPGM("error.");
+  DWIN_Frame_SetDir(1); // Orientation 90°
+  DWIN_UpdateLCD();     // Show bootscreen (first image)
+  Encoder_Configuration();
+  for (uint16_t t = 0; t <= 100; t += 2) {
+    DWIN_ICON_Show(ICON, ICON_Bar, 15, 260);
+    DWIN_Draw_Rectangle(1, Color_Bg_Black, 15 + t * 242 / 100, 260, 257, 280);
+    DWIN_UpdateLCD();
+    delay(20);
+  }
+  DWIN_JPG_CacheTo1(Language_English);
+  CrealityDWIN.Redraw_Screen();
+}
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
+    switch (message) {
+      case PAUSE_MESSAGE_INSERT:  CrealityDWIN.Confirm_Handler(FilInsert);  break;
+      case PAUSE_MESSAGE_OPTION:  CrealityDWIN.Popup_Handler(PurgeMore);    break;
+      case PAUSE_MESSAGE_HEAT:    CrealityDWIN.Confirm_Handler(HeaterTime); break;
+      case PAUSE_MESSAGE_WAITING: CrealityDWIN.Draw_Print_Screen();         break;
+      default: break;
+    }
+  }
+#endif
+
+#endif // DWIN_CREALITY_LCD_JYERSUI
